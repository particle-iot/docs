/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("ParticleUsb", [], factory);
	else if(typeof exports === 'object')
		exports["ParticleUsb"] = factory();
	else
		root["ParticleUsb"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@particle/device-os-protobuf/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const pbjsGeneratedProtobufCode = __webpack_require__(/*! ./pbjs-generated/definitions */ \"./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js\");\n\nclass DeviceOSProtobuf {\n\t/**\n\t * Create a valid Buffer of bytes that can be sent to DeviceOS, typically used with \"Request\" messages.\n\t *\n\t * @example <caption>Encoding a request to get serial number</caption>\n\t * // returns a zero length Buffer because there is no properties for this message, just the option type_id\n\t * const buffer = DeviceOSProtobuf.encode('GetSerialNumberRequest');\n\t *\n\t * @param {string|ProtobufMessage} protobufMessageNameOrMessage - Protobuf message name or actual message object. See getDefinitions() to valid options.\n\t * @param {Object} protobufMessageData - An object containing key data/code to encode & decode protobufjs messages from Device OS\n\t * @returns {Buffer} - A Buffer of bytes representing a valid protobuf message that Device OS can interpret\n\t */\n\tstatic encode(protobufMessageNameOrMessage, protobufMessageData = null) {\n\t\tconst message = this._resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage);\n\t\tconst msg = message.create(protobufMessageData);\n\t\tconst buffer = message.encode(msg).finish();\n\t\treturn buffer;\n\t}\n\n\tstatic _resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage) {\n\t\tlet message;\n\t\tif (typeof protobufMessageNameOrMessage === 'string') {\n\t\t\tconst protobufDefinition = this.getDefinition(protobufMessageNameOrMessage);\n\t\t\tmessage = protobufDefinition.message;\n\t\t} else {\n\t\t\tmessage = protobufMessageNameOrMessage;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Create a JavaScript object by decoding a Buffer representing a protobuf message from DeviceOS; typically used with \"Reply\" messages\"\n\t *\n\t * @example <caption>Decode a GetSerialNumberReply</caption>\n\t * // returns a Javascript object with .serial property\n\t * const object = DeviceOSProtobuf.decode('GetSerialNumberReply', buffer);\n\t * // shows the serial number as a string\n\t * console.log(object.serial);\n\t * @param {string|ProtobufMessage} protobufMessageNameOrMessage - Protobuf message name or actual message object. See getDefinitions() to valid options.\n\t * @param {Buffer} buffer - Buffer from DeviceOS representing valid non-decoded Protobuf message\n\t * @returns {Object} - A JavaScript object with properties for each data item declared in the *.proto file\n\t */\n\tstatic decode(protobufMessageNameOrMessage, buffer) {\n\t\tconst message = this._resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage);\n\t\treturn message.decode(buffer);\n\t}\n\n\t/**\n\t * @param {string} protobufMessageName - Protobuf definition from *.proto files like \"GetSerialNumberRequest\". To access definitions in a namespace, prefix with \"<namespace>.\"\n\t * @returns {ProtobufDefinition} protobufDefinition An object containing code to encode & decode protobufjs messages from Device OS\n\t */\n\tstatic getDefinition(protobufMessageName) {\n\t\tconst message = this._getProtobufMessage(protobufMessageName);\n\n\t\tlet id, replyMessage;\n\t\tif (protobufMessageName.match(/Request$/)) {\n\t\t\tid = this._getIDFromJSON(protobufMessageName);\n\t\t\treplyMessage = this._getProtobufReplyMessage(protobufMessageName);\n\t\t} else {\n\t\t\tid = null;\n\t\t\treplyMessage = null;\n\t\t}\n\n\t\treturn {\n\t\t\tmessage,\n\t\t\tid,\n\t\t\treplyMessage\n\t\t};\n\t}\n\n\t/**\n\t * @typedef {Object} ProtobufDefinition\n\t * @property {Function} message - protobufjs generated Javascript function that includes encode and decode methods.\n\t * @property {(number|null)} id - integer request ID of the message for \"Request\" protobuf definitions, null otherwise.\n\t * @property {(Function | null)} replyMessage The corresponding reply message to a given \"Request\" message, null otherwise.\n   */\n\n\n\t/**\n\t * This is typedef describing the auto-generated code that pbjs generates\n\t * @typedef {Object} ProtobufMessage\n\t * @property {Function} create\n\t * @property {Function} encode\n\t * @property {Function} decode\n   */\n\n\n\t/**\n\t * @returns {Array} valid strings that can be passed to getDefinition(). Includes all Request/Reply style messages as well as non request messages and enums.\n\t */\n\tstatic getDefinitions() {\n\t\tconst namespaces = this.getNamespaces();\n\t\tconst returnThis = [];\n\t\tfor (const key of Object.keys(this.definitions)) {\n\t\t\tif (namespaces.includes(key)) {\n\t\t\t\tconst namespace = namespaces[namespaces.indexOf(key)];\n\t\t\t\tfor (const namespacedKey of Object.keys(this.definitions[namespace])) {\n\t\t\t\t\treturnThis.push(`${namespace}.${namespacedKey}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturnThis.push(key);\n\t\t\t}\n\t\t}\n\t\treturn returnThis;\n\t}\n\n\t/**\n\t * @returns {Array} valid dot prefixes to getDefinition() arguments (i.e. the \"cellular\" from \"cellular\".GetIccidRequest, etc)\n\t */\n\tstatic getNamespaces() {\n\t\treturn [\n\t\t\t'wifi',\n\t\t\t'logging',\n\t\t\t'mesh',\n\t\t\t'cloud',\n\t\t\t'cellular'\n\t\t];\n\t}\n\n\tstatic _getIDFromJSON(protobufMessageName) {\n\t\tlet rootJSONObject;\n\t\tif (this._isNamespaced(protobufMessageName)) {\n\t\t\tconst [namespace, nonNamespacedName] = this._getNamespaceAndMessageName(protobufMessageName);\n\t\t\trootJSONObject = DeviceOSProtobuf._pbjsJSON.nested.particle.nested.ctrl\n\t\t\t\t.nested[namespace].nested[nonNamespacedName];\n\t\t} else {\n\t\t\trootJSONObject = DeviceOSProtobuf._pbjsJSON.nested.particle.nested.ctrl\n\t\t\t\t.nested[protobufMessageName];\n\t\t}\n\n\t\ttry {\n\t\t\treturn rootJSONObject.options['(type_id)'];\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Could not extract request type id from pbjs json where protobufMessageName=${protobufMessageName}`);\n\t\t}\n\t}\n\n\tstatic _isNamespaced(protobufMessageName) {\n\t\treturn protobufMessageName.includes('.');\n\t}\n\n\tstatic _getNamespaceAndMessageName(protobufMessageName) {\n\t\treturn protobufMessageName.split('.');\n\t}\n\n\t// Get's a pbjs generated Function by name or namespace.name\n\tstatic _getProtobufMessage(protobufMessageName) {\n\t\tlet rootObject;\n\t\tif (protobufMessageName.includes('.')) {\n\t\t\tconst [namespace, nonNamespacedName] = this._getNamespaceAndMessageName(protobufMessageName);\n\t\t\tprotobufMessageName = nonNamespacedName;\n\t\t\trootObject = this.definitions[namespace];\n\t\t} else {\n\t\t\trootObject = this.definitions;\n\t\t}\n\t\tif (!(protobufMessageName in rootObject)) {\n\t\t\tthrow new Error(`There is no pbjs generated protobuf Function for protobufMessageName=${protobufMessageName}`);\n\t\t}\n\t\treturn rootObject[protobufMessageName];\n\t}\n\n\tstatic _getProtobufReplyMessage(protobufMessageName) {\n\t\treturn this._getProtobufMessage(protobufMessageName.replace('Request', 'Reply'));\n\t}\n}\n\n/**\n * Parsed JSON object generated via `npm run build:json`; this is how we get the type id associated with\n * a given ctrl request\n */\nDeviceOSProtobuf._pbjsJSON = __webpack_require__(/*! ./pbjs-generated/definitions.json */ \"./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json\");\n\n/**\n * All of the interesting auto-generated Javascript objects from `*.proto` files live in this definitions object\n * (which is keyed by protobuf message name)\n */\nDeviceOSProtobuf.schema = pbjsGeneratedProtobufCode.particle;\n\n// These definitions are specific to control requests and are exposed for backward compatibility\nDeviceOSProtobuf.definitions = pbjsGeneratedProtobufCode.particle.ctrl;\nDeviceOSProtobuf.cloudDefinitions = pbjsGeneratedProtobufCode.particle.cloud;\n\nmodule.exports = DeviceOSProtobuf;\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/index.js?");

/***/ }),

/***/ "./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js ***!
  \*************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (true)\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /* CommonJS */ else {}\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.particle = (function() {\n    \n        /**\n         * Namespace particle.\n         * @exports particle\n         * @namespace\n         */\n        var particle = {};\n    \n        particle.ctrl = (function() {\n    \n            /**\n             * Namespace ctrl.\n             * @memberof particle\n             * @namespace\n             */\n            var ctrl = {};\n    \n            ctrl.cellular = (function() {\n    \n                /**\n                 * Namespace cellular.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var cellular = {};\n    \n                /**\n                 * SIM card types.\n                 * \n                 * The Boron 2G/3G and Boron LTE can use either the built-in MFF2 embedded Particle SIM card or an external nano SIM card in the SIM card connector.\n                 * \n                 * Note: The values of this enum should match the values defined by the `SimType` enum in the firmware.\n                 * @name particle.ctrl.cellular.SimType\n                 * @enum {number}\n                 * @property {number} INVALID_SIM_TYPE=0 INVALID_SIM_TYPE value\n                 * @property {number} INTERNAL=1 INTERNAL value\n                 * @property {number} EXTERNAL=2 EXTERNAL value\n                 */\n                cellular.SimType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_SIM_TYPE\"] = 0;\n                    values[valuesById[1] = \"INTERNAL\"] = 1;\n                    values[valuesById[2] = \"EXTERNAL\"] = 2;\n                    return values;\n                })();\n    \n                cellular.AccessPoint = (function() {\n    \n                    /**\n                     * Properties of an AccessPoint.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IAccessPoint\n                     * @property {string|null} [apn] AccessPoint apn\n                     * @property {string|null} [user] AccessPoint user\n                     * @property {string|null} [password] AccessPoint password\n                     * @property {boolean|null} [useDefaults] AccessPoint useDefaults\n                     */\n    \n                    /**\n                     * Constructs a new AccessPoint.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Access point settings for 3rd party SIM credentials for the Cellular network.\n                     * @implements IAccessPoint\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set\n                     */\n                    function AccessPoint(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AccessPoint apn.\n                     * @member {string} apn\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.apn = \"\";\n    \n                    /**\n                     * AccessPoint user.\n                     * @member {string} user\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.user = \"\";\n    \n                    /**\n                     * AccessPoint password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.password = \"\";\n    \n                    /**\n                     * AccessPoint useDefaults.\n                     * @member {boolean} useDefaults\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.useDefaults = false;\n    \n                    /**\n                     * Creates a new AccessPoint instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint instance\n                     */\n                    AccessPoint.create = function create(properties) {\n                        return new AccessPoint(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AccessPoint message. Does not implicitly {@link particle.ctrl.cellular.AccessPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {particle.ctrl.cellular.IAccessPoint} message AccessPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AccessPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.apn != null && Object.hasOwnProperty.call(message, \"apn\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.apn);\n                        if (message.user != null && Object.hasOwnProperty.call(message, \"user\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.user);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);\n                        if (message.useDefaults != null && Object.hasOwnProperty.call(message, \"useDefaults\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useDefaults);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AccessPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AccessPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.AccessPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.apn = reader.string();\n                                break;\n                            case 2:\n                                message.user = reader.string();\n                                break;\n                            case 3:\n                                message.password = reader.string();\n                                break;\n                            case 4:\n                                message.useDefaults = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AccessPoint;\n                })();\n    \n                cellular.SetAccessPointRequest = (function() {\n    \n                    /**\n                     * Properties of a SetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetAccessPointRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetAccessPointRequest simType\n                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] SetAccessPointRequest accessPoint\n                     */\n    \n                    /**\n                     * Constructs a new SetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Set access point settings.\n                     * @implements ISetAccessPointRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set\n                     */\n                    function SetAccessPointRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SetAccessPointRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @instance\n                     */\n                    SetAccessPointRequest.prototype.simType = 0;\n    \n                    /**\n                     * SetAccessPointRequest accessPoint.\n                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @instance\n                     */\n                    SetAccessPointRequest.prototype.accessPoint = null;\n    \n                    /**\n                     * Creates a new SetAccessPointRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest instance\n                     */\n                    SetAccessPointRequest.create = function create(properties) {\n                        return new SetAccessPointRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest} message SetAccessPointRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetAccessPointRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetAccessPointRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetAccessPointRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            case 2:\n                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetAccessPointRequest;\n                })();\n    \n                cellular.SetAccessPointReply = (function() {\n    \n                    /**\n                     * Properties of a SetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetAccessPointReply\n                     */\n    \n                    /**\n                     * Constructs a new SetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a SetAccessPointReply.\n                     * @implements ISetAccessPointReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set\n                     */\n                    function SetAccessPointReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetAccessPointReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply instance\n                     */\n                    SetAccessPointReply.create = function create(properties) {\n                        return new SetAccessPointReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply} message SetAccessPointReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetAccessPointReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetAccessPointReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetAccessPointReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetAccessPointReply;\n                })();\n    \n                cellular.GetAccessPointRequest = (function() {\n    \n                    /**\n                     * Properties of a GetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetAccessPointRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetAccessPointRequest simType\n                     */\n    \n                    /**\n                     * Constructs a new GetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get access point settings.\n                     * @implements IGetAccessPointRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set\n                     */\n                    function GetAccessPointRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetAccessPointRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @instance\n                     */\n                    GetAccessPointRequest.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new GetAccessPointRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest instance\n                     */\n                    GetAccessPointRequest.create = function create(properties) {\n                        return new GetAccessPointRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest} message GetAccessPointRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetAccessPointRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetAccessPointRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetAccessPointRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetAccessPointRequest;\n                })();\n    \n                cellular.GetAccessPointReply = (function() {\n    \n                    /**\n                     * Properties of a GetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetAccessPointReply\n                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] GetAccessPointReply accessPoint\n                     */\n    \n                    /**\n                     * Constructs a new GetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetAccessPointReply.\n                     * @implements IGetAccessPointReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set\n                     */\n                    function GetAccessPointReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetAccessPointReply accessPoint.\n                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @instance\n                     */\n                    GetAccessPointReply.prototype.accessPoint = null;\n    \n                    /**\n                     * Creates a new GetAccessPointReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply instance\n                     */\n                    GetAccessPointReply.create = function create(properties) {\n                        return new GetAccessPointReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply} message GetAccessPointReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetAccessPointReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetAccessPointReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetAccessPointReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetAccessPointReply;\n                })();\n    \n                cellular.SetActiveSimRequest = (function() {\n    \n                    /**\n                     * Properties of a SetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetActiveSimRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetActiveSimRequest simType\n                     */\n    \n                    /**\n                     * Constructs a new SetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Set active SIM card.\n                     * \n                     * Note: The device needs to be reset in order for the settings to take effect.\n                     * @implements ISetActiveSimRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set\n                     */\n                    function SetActiveSimRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SetActiveSimRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @instance\n                     */\n                    SetActiveSimRequest.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new SetActiveSimRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest instance\n                     */\n                    SetActiveSimRequest.create = function create(properties) {\n                        return new SetActiveSimRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest} message SetActiveSimRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetActiveSimRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetActiveSimRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetActiveSimRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetActiveSimRequest;\n                })();\n    \n                cellular.SetActiveSimReply = (function() {\n    \n                    /**\n                     * Properties of a SetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetActiveSimReply\n                     */\n    \n                    /**\n                     * Constructs a new SetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a SetActiveSimReply.\n                     * @implements ISetActiveSimReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set\n                     */\n                    function SetActiveSimReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetActiveSimReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply instance\n                     */\n                    SetActiveSimReply.create = function create(properties) {\n                        return new SetActiveSimReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply} message SetActiveSimReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetActiveSimReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetActiveSimReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetActiveSimReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetActiveSimReply;\n                })();\n    \n                cellular.GetActiveSimRequest = (function() {\n    \n                    /**\n                     * Properties of a GetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetActiveSimRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get active SIM card.\n                     * @implements IGetActiveSimRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set\n                     */\n                    function GetActiveSimRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetActiveSimRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest instance\n                     */\n                    GetActiveSimRequest.create = function create(properties) {\n                        return new GetActiveSimRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest} message GetActiveSimRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetActiveSimRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetActiveSimRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetActiveSimRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetActiveSimRequest;\n                })();\n    \n                cellular.GetActiveSimReply = (function() {\n    \n                    /**\n                     * Properties of a GetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetActiveSimReply\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetActiveSimReply simType\n                     */\n    \n                    /**\n                     * Constructs a new GetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetActiveSimReply.\n                     * @implements IGetActiveSimReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set\n                     */\n                    function GetActiveSimReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetActiveSimReply simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @instance\n                     */\n                    GetActiveSimReply.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new GetActiveSimReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply instance\n                     */\n                    GetActiveSimReply.create = function create(properties) {\n                        return new GetActiveSimReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply} message GetActiveSimReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetActiveSimReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetActiveSimReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetActiveSimReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetActiveSimReply;\n                })();\n    \n                cellular.GetIccidRequest = (function() {\n    \n                    /**\n                     * Properties of a GetIccidRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetIccidRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetIccidRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get ICCID.\n                     * @implements IGetIccidRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set\n                     */\n                    function GetIccidRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetIccidRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest instance\n                     */\n                    GetIccidRequest.create = function create(properties) {\n                        return new GetIccidRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetIccidRequest message. Does not implicitly {@link particle.ctrl.cellular.GetIccidRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidRequest} message GetIccidRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetIccidRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetIccidRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetIccidRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetIccidRequest;\n                })();\n    \n                cellular.GetIccidReply = (function() {\n    \n                    /**\n                     * Properties of a GetIccidReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetIccidReply\n                     * @property {string|null} [iccid] GetIccidReply iccid\n                     * @property {string|null} [imei] GetIccidReply imei\n                     */\n    \n                    /**\n                     * Constructs a new GetIccidReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetIccidReply.\n                     * @implements IGetIccidReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set\n                     */\n                    function GetIccidReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetIccidReply iccid.\n                     * @member {string} iccid\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @instance\n                     */\n                    GetIccidReply.prototype.iccid = \"\";\n    \n                    /**\n                     * GetIccidReply imei.\n                     * @member {string} imei\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @instance\n                     */\n                    GetIccidReply.prototype.imei = \"\";\n    \n                    /**\n                     * Creates a new GetIccidReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply instance\n                     */\n                    GetIccidReply.create = function create(properties) {\n                        return new GetIccidReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetIccidReply message. Does not implicitly {@link particle.ctrl.cellular.GetIccidReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidReply} message GetIccidReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetIccidReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.iccid != null && Object.hasOwnProperty.call(message, \"iccid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.iccid);\n                        if (message.imei != null && Object.hasOwnProperty.call(message, \"imei\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.imei);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetIccidReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetIccidReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.iccid = reader.string();\n                                break;\n                            case 2:\n                                message.imei = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetIccidReply;\n                })();\n    \n                return cellular;\n            })();\n    \n            ctrl.cloud = (function() {\n    \n                /**\n                 * Namespace cloud.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var cloud = {};\n    \n                /**\n                 * ConnectionStatus enum.\n                 * @name particle.ctrl.cloud.ConnectionStatus\n                 * @enum {number}\n                 * @property {number} DISCONNECTED=0 DISCONNECTED value\n                 * @property {number} CONNECTING=1 CONNECTING value\n                 * @property {number} CONNECTED=2 CONNECTED value\n                 * @property {number} DISCONNECTING=3 DISCONNECTING value\n                 */\n                cloud.ConnectionStatus = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DISCONNECTED\"] = 0;\n                    values[valuesById[1] = \"CONNECTING\"] = 1;\n                    values[valuesById[2] = \"CONNECTED\"] = 2;\n                    values[valuesById[3] = \"DISCONNECTING\"] = 3;\n                    return values;\n                })();\n    \n                cloud.GetConnectionStatusRequest = (function() {\n    \n                    /**\n                     * Properties of a GetConnectionStatusRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IGetConnectionStatusRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetConnectionStatusRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a GetConnectionStatusRequest.\n                     * @implements IGetConnectionStatusRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set\n                     */\n                    function GetConnectionStatusRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetConnectionStatusRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest instance\n                     */\n                    GetConnectionStatusRequest.create = function create(properties) {\n                        return new GetConnectionStatusRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetConnectionStatusRequest message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest} message GetConnectionStatusRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetConnectionStatusRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetConnectionStatusRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetConnectionStatusRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetConnectionStatusRequest;\n                })();\n    \n                cloud.GetConnectionStatusReply = (function() {\n    \n                    /**\n                     * Properties of a GetConnectionStatusReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IGetConnectionStatusReply\n                     * @property {particle.ctrl.cloud.ConnectionStatus|null} [status] GetConnectionStatusReply status\n                     */\n    \n                    /**\n                     * Constructs a new GetConnectionStatusReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a GetConnectionStatusReply.\n                     * @implements IGetConnectionStatusReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set\n                     */\n                    function GetConnectionStatusReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetConnectionStatusReply status.\n                     * @member {particle.ctrl.cloud.ConnectionStatus} status\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @instance\n                     */\n                    GetConnectionStatusReply.prototype.status = 0;\n    \n                    /**\n                     * Creates a new GetConnectionStatusReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply instance\n                     */\n                    GetConnectionStatusReply.create = function create(properties) {\n                        return new GetConnectionStatusReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetConnectionStatusReply message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply} message GetConnectionStatusReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetConnectionStatusReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetConnectionStatusReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetConnectionStatusReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.status = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetConnectionStatusReply;\n                })();\n    \n                cloud.ConnectRequest = (function() {\n    \n                    /**\n                     * Properties of a ConnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IConnectRequest\n                     */\n    \n                    /**\n                     * Constructs a new ConnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a ConnectRequest.\n                     * @implements IConnectRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set\n                     */\n                    function ConnectRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ConnectRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest instance\n                     */\n                    ConnectRequest.create = function create(properties) {\n                        return new ConnectRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ConnectRequest message. Does not implicitly {@link particle.ctrl.cloud.ConnectRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectRequest} message ConnectRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ConnectRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ConnectRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ConnectRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ConnectRequest;\n                })();\n    \n                cloud.ConnectReply = (function() {\n    \n                    /**\n                     * Properties of a ConnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IConnectReply\n                     */\n    \n                    /**\n                     * Constructs a new ConnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a ConnectReply.\n                     * @implements IConnectReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set\n                     */\n                    function ConnectReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ConnectReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply instance\n                     */\n                    ConnectReply.create = function create(properties) {\n                        return new ConnectReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ConnectReply message. Does not implicitly {@link particle.ctrl.cloud.ConnectReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectReply} message ConnectReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ConnectReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ConnectReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ConnectReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ConnectReply;\n                })();\n    \n                cloud.DisconnectRequest = (function() {\n    \n                    /**\n                     * Properties of a DisconnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IDisconnectRequest\n                     */\n    \n                    /**\n                     * Constructs a new DisconnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a DisconnectRequest.\n                     * @implements IDisconnectRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set\n                     */\n                    function DisconnectRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new DisconnectRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest instance\n                     */\n                    DisconnectRequest.create = function create(properties) {\n                        return new DisconnectRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DisconnectRequest message. Does not implicitly {@link particle.ctrl.cloud.DisconnectRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectRequest} message DisconnectRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DisconnectRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DisconnectRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DisconnectRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return DisconnectRequest;\n                })();\n    \n                cloud.DisconnectReply = (function() {\n    \n                    /**\n                     * Properties of a DisconnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IDisconnectReply\n                     */\n    \n                    /**\n                     * Constructs a new DisconnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a DisconnectReply.\n                     * @implements IDisconnectReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set\n                     */\n                    function DisconnectReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new DisconnectReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply instance\n                     */\n                    DisconnectReply.create = function create(properties) {\n                        return new DisconnectReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DisconnectReply message. Does not implicitly {@link particle.ctrl.cloud.DisconnectReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectReply} message DisconnectReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DisconnectReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DisconnectReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DisconnectReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return DisconnectReply;\n                })();\n    \n                return cloud;\n            })();\n    \n            /**\n             * ResultCode enum.\n             * @name particle.ctrl.ResultCode\n             * @enum {number}\n             * @property {number} OK=0 OK value\n             * @property {number} NOT_ALLOWED=1 NOT_ALLOWED value\n             * @property {number} TIMEOUT=2 TIMEOUT value\n             * @property {number} NOT_FOUND=3 NOT_FOUND value\n             * @property {number} ALREADY_EXIST=4 ALREADY_EXIST value\n             * @property {number} INVALID_STATE=5 INVALID_STATE value\n             * @property {number} NO_MEMORY=6 NO_MEMORY value\n             * @property {number} INVALID_PARAM=7 INVALID_PARAM value\n             */\n            ctrl.ResultCode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"OK\"] = 0;\n                values[valuesById[1] = \"NOT_ALLOWED\"] = 1;\n                values[valuesById[2] = \"TIMEOUT\"] = 2;\n                values[valuesById[3] = \"NOT_FOUND\"] = 3;\n                values[valuesById[4] = \"ALREADY_EXIST\"] = 4;\n                values[valuesById[5] = \"INVALID_STATE\"] = 5;\n                values[valuesById[6] = \"NO_MEMORY\"] = 6;\n                values[valuesById[7] = \"INVALID_PARAM\"] = 7;\n                return values;\n            })();\n    \n            ctrl.Ipv4Address = (function() {\n    \n                /**\n                 * Properties of an Ipv4Address.\n                 * @memberof particle.ctrl\n                 * @interface IIpv4Address\n                 * @property {number|null} [address] Ipv4Address address\n                 */\n    \n                /**\n                 * Constructs a new Ipv4Address.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv4Address.\n                 * @implements IIpv4Address\n                 * @constructor\n                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set\n                 */\n                function Ipv4Address(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv4Address address.\n                 * @member {number} address\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @instance\n                 */\n                Ipv4Address.prototype.address = 0;\n    \n                /**\n                 * Creates a new Ipv4Address instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address instance\n                 */\n                Ipv4Address.create = function create(properties) {\n                    return new Ipv4Address(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv4Address message. Does not implicitly {@link particle.ctrl.Ipv4Address.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {particle.ctrl.IIpv4Address} message Ipv4Address message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv4Address.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv4Address message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv4Address.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Address();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv4Address;\n            })();\n    \n            ctrl.Ipv6Address = (function() {\n    \n                /**\n                 * Properties of an Ipv6Address.\n                 * @memberof particle.ctrl\n                 * @interface IIpv6Address\n                 * @property {Uint8Array|null} [address] Ipv6Address address\n                 */\n    \n                /**\n                 * Constructs a new Ipv6Address.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv6Address.\n                 * @implements IIpv6Address\n                 * @constructor\n                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set\n                 */\n                function Ipv6Address(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv6Address address.\n                 * @member {Uint8Array} address\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @instance\n                 */\n                Ipv6Address.prototype.address = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new Ipv6Address instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address instance\n                 */\n                Ipv6Address.create = function create(properties) {\n                    return new Ipv6Address(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv6Address message. Does not implicitly {@link particle.ctrl.Ipv6Address.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {particle.ctrl.IIpv6Address} message Ipv6Address message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv6Address.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv6Address message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv6Address.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Address();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv6Address;\n            })();\n    \n            ctrl.IpAddress = (function() {\n    \n                /**\n                 * Properties of an IpAddress.\n                 * @memberof particle.ctrl\n                 * @interface IIpAddress\n                 * @property {particle.ctrl.IIpv4Address|null} [v4] IpAddress v4\n                 * @property {particle.ctrl.IIpv6Address|null} [v6] IpAddress v6\n                 */\n    \n                /**\n                 * Constructs a new IpAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IpAddress.\n                 * @implements IIpAddress\n                 * @constructor\n                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set\n                 */\n                function IpAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IpAddress v4.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} v4\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                IpAddress.prototype.v4 = null;\n    \n                /**\n                 * IpAddress v6.\n                 * @member {particle.ctrl.IIpv6Address|null|undefined} v6\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                IpAddress.prototype.v6 = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * IpAddress address.\n                 * @member {\"v4\"|\"v6\"|undefined} address\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                Object.defineProperty(IpAddress.prototype, \"address\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"v4\", \"v6\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new IpAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.IpAddress} IpAddress instance\n                 */\n                IpAddress.create = function create(properties) {\n                    return new IpAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified IpAddress message. Does not implicitly {@link particle.ctrl.IpAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {particle.ctrl.IIpAddress} message IpAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IpAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.v4 != null && Object.hasOwnProperty.call(message, \"v4\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.v4, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.v6 != null && Object.hasOwnProperty.call(message, \"v6\"))\n                        $root.particle.ctrl.Ipv6Address.encode(message.v6, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IpAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IpAddress} IpAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IpAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IpAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.v4 = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            message.v6 = $root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IpAddress;\n            })();\n    \n            ctrl.IPAddress = (function() {\n    \n                /**\n                 * Properties of a IPAddress.\n                 * @memberof particle.ctrl\n                 * @interface IIPAddress\n                 * @property {particle.ctrl.IPAddress.Protocol|null} [protocol] IPAddress protocol\n                 * @property {Uint8Array|null} [address] IPAddress address\n                 */\n    \n                /**\n                 * Constructs a new IPAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a IPAddress.\n                 * @implements IIPAddress\n                 * @constructor\n                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set\n                 */\n                function IPAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IPAddress protocol.\n                 * @member {particle.ctrl.IPAddress.Protocol} protocol\n                 * @memberof particle.ctrl.IPAddress\n                 * @instance\n                 */\n                IPAddress.prototype.protocol = 0;\n    \n                /**\n                 * IPAddress address.\n                 * @member {Uint8Array} address\n                 * @memberof particle.ctrl.IPAddress\n                 * @instance\n                 */\n                IPAddress.prototype.address = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new IPAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.IPAddress} IPAddress instance\n                 */\n                IPAddress.create = function create(properties) {\n                    return new IPAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified IPAddress message. Does not implicitly {@link particle.ctrl.IPAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {particle.ctrl.IIPAddress} message IPAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IPAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a IPAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IPAddress} IPAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IPAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        case 2:\n                            message.address = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Protocol enum.\n                 * @name particle.ctrl.IPAddress.Protocol\n                 * @enum {number}\n                 * @property {number} NONE=0 NONE value\n                 * @property {number} IPv4=1 IPv4 value\n                 * @property {number} IPv6=2 IPv6 value\n                 */\n                IPAddress.Protocol = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"IPv4\"] = 1;\n                    values[valuesById[2] = \"IPv6\"] = 2;\n                    return values;\n                })();\n    \n                return IPAddress;\n            })();\n    \n            /**\n             * SecurityKeyType enum.\n             * @name particle.ctrl.SecurityKeyType\n             * @enum {number}\n             * @property {number} INVALID_SECURITY_KEY=0 INVALID_SECURITY_KEY value\n             * @property {number} TCP_DEVICE_PRIVATE_KEY=1 TCP_DEVICE_PRIVATE_KEY value\n             * @property {number} TCP_DEVICE_PUBLIC_KEY=2 TCP_DEVICE_PUBLIC_KEY value\n             * @property {number} TCP_SERVER_PUBLIC_KEY=3 TCP_SERVER_PUBLIC_KEY value\n             * @property {number} UDP_DEVICE_PRIVATE_KEY=4 UDP_DEVICE_PRIVATE_KEY value\n             * @property {number} UDP_DEVICE_PUBLIC_KEY=5 UDP_DEVICE_PUBLIC_KEY value\n             * @property {number} UDP_SERVER_PUBLIC_KEY=6 UDP_SERVER_PUBLIC_KEY value\n             */\n            ctrl.SecurityKeyType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECURITY_KEY\"] = 0;\n                values[valuesById[1] = \"TCP_DEVICE_PRIVATE_KEY\"] = 1;\n                values[valuesById[2] = \"TCP_DEVICE_PUBLIC_KEY\"] = 2;\n                values[valuesById[3] = \"TCP_SERVER_PUBLIC_KEY\"] = 3;\n                values[valuesById[4] = \"UDP_DEVICE_PRIVATE_KEY\"] = 4;\n                values[valuesById[5] = \"UDP_DEVICE_PUBLIC_KEY\"] = 5;\n                values[valuesById[6] = \"UDP_SERVER_PUBLIC_KEY\"] = 6;\n                return values;\n            })();\n    \n            /**\n             * ServerProtocolType enum.\n             * @name particle.ctrl.ServerProtocolType\n             * @enum {number}\n             * @property {number} INVALID_PROTOCOL=0 INVALID_PROTOCOL value\n             * @property {number} TCP_PROTOCOL=1 TCP_PROTOCOL value\n             * @property {number} UDP_PROTOCOL=2 UDP_PROTOCOL value\n             */\n            ctrl.ServerProtocolType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_PROTOCOL\"] = 0;\n                values[valuesById[1] = \"TCP_PROTOCOL\"] = 1;\n                values[valuesById[2] = \"UDP_PROTOCOL\"] = 2;\n                return values;\n            })();\n    \n            /**\n             * DeviceMode enum.\n             * @name particle.ctrl.DeviceMode\n             * @enum {number}\n             * @property {number} NORMAL_MODE=0 NORMAL_MODE value\n             * @property {number} LISTENING_MODE=1 LISTENING_MODE value\n             */\n            ctrl.DeviceMode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NORMAL_MODE\"] = 0;\n                values[valuesById[1] = \"LISTENING_MODE\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * SystemCapabilityFlag enum.\n             * @name particle.ctrl.SystemCapabilityFlag\n             * @enum {number}\n             * @property {number} NO_SYSTEM_CAPABILITY_FLAGS=0 NO_SYSTEM_CAPABILITY_FLAGS value\n             * @property {number} COMPRESSED_OTA=1 COMPRESSED_OTA value\n             */\n            ctrl.SystemCapabilityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SYSTEM_CAPABILITY_FLAGS\"] = 0;\n                values[valuesById[1] = \"COMPRESSED_OTA\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * Feature enum.\n             * @name particle.ctrl.Feature\n             * @enum {number}\n             * @property {number} INVALID_FEATURE=0 INVALID_FEATURE value\n             * @property {number} ETHERNET_DETECTION=1 ETHERNET_DETECTION value\n             */\n            ctrl.Feature = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FEATURE\"] = 0;\n                values[valuesById[1] = \"ETHERNET_DETECTION\"] = 1;\n                return values;\n            })();\n    \n            ctrl.GetDeviceIdRequest = (function() {\n    \n                /**\n                 * Properties of a GetDeviceIdRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceIdRequest\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceIdRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceIdRequest.\n                 * @implements IGetDeviceIdRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set\n                 */\n                function GetDeviceIdRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetDeviceIdRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest instance\n                 */\n                GetDeviceIdRequest.create = function create(properties) {\n                    return new GetDeviceIdRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceIdRequest message. Does not implicitly {@link particle.ctrl.GetDeviceIdRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdRequest} message GetDeviceIdRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceIdRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceIdRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceIdRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceIdRequest;\n            })();\n    \n            ctrl.GetDeviceIdReply = (function() {\n    \n                /**\n                 * Properties of a GetDeviceIdReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceIdReply\n                 * @property {string|null} [id] GetDeviceIdReply id\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceIdReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceIdReply.\n                 * @implements IGetDeviceIdReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set\n                 */\n                function GetDeviceIdReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetDeviceIdReply id.\n                 * @member {string} id\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @instance\n                 */\n                GetDeviceIdReply.prototype.id = \"\";\n    \n                /**\n                 * Creates a new GetDeviceIdReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply instance\n                 */\n                GetDeviceIdReply.create = function create(properties) {\n                    return new GetDeviceIdReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceIdReply message. Does not implicitly {@link particle.ctrl.GetDeviceIdReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdReply} message GetDeviceIdReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceIdReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceIdReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceIdReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.id = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceIdReply;\n            })();\n    \n            ctrl.GetSerialNumberRequest = (function() {\n    \n                /**\n                 * Properties of a GetSerialNumberRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSerialNumberRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSerialNumberRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSerialNumberRequest.\n                 * @implements IGetSerialNumberRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set\n                 */\n                function GetSerialNumberRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSerialNumberRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest instance\n                 */\n                GetSerialNumberRequest.create = function create(properties) {\n                    return new GetSerialNumberRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSerialNumberRequest message. Does not implicitly {@link particle.ctrl.GetSerialNumberRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberRequest} message GetSerialNumberRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSerialNumberRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSerialNumberRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSerialNumberRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSerialNumberRequest;\n            })();\n    \n            ctrl.GetSerialNumberReply = (function() {\n    \n                /**\n                 * Properties of a GetSerialNumberReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSerialNumberReply\n                 * @property {string|null} [serial] GetSerialNumberReply serial\n                 */\n    \n                /**\n                 * Constructs a new GetSerialNumberReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSerialNumberReply.\n                 * @implements IGetSerialNumberReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set\n                 */\n                function GetSerialNumberReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSerialNumberReply serial.\n                 * @member {string} serial\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @instance\n                 */\n                GetSerialNumberReply.prototype.serial = \"\";\n    \n                /**\n                 * Creates a new GetSerialNumberReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply instance\n                 */\n                GetSerialNumberReply.create = function create(properties) {\n                    return new GetSerialNumberReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSerialNumberReply message. Does not implicitly {@link particle.ctrl.GetSerialNumberReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberReply} message GetSerialNumberReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSerialNumberReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.serial != null && Object.hasOwnProperty.call(message, \"serial\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serial);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSerialNumberReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSerialNumberReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.serial = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSerialNumberReply;\n            })();\n    \n            ctrl.GetSystemVersionRequest = (function() {\n    \n                /**\n                 * Properties of a GetSystemVersionRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemVersionRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSystemVersionRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemVersionRequest.\n                 * @implements IGetSystemVersionRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set\n                 */\n                function GetSystemVersionRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSystemVersionRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest instance\n                 */\n                GetSystemVersionRequest.create = function create(properties) {\n                    return new GetSystemVersionRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemVersionRequest message. Does not implicitly {@link particle.ctrl.GetSystemVersionRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionRequest} message GetSystemVersionRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemVersionRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemVersionRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemVersionRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemVersionRequest;\n            })();\n    \n            ctrl.GetSystemVersionReply = (function() {\n    \n                /**\n                 * Properties of a GetSystemVersionReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemVersionReply\n                 * @property {string|null} [version] GetSystemVersionReply version\n                 */\n    \n                /**\n                 * Constructs a new GetSystemVersionReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemVersionReply.\n                 * @implements IGetSystemVersionReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set\n                 */\n                function GetSystemVersionReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSystemVersionReply version.\n                 * @member {string} version\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @instance\n                 */\n                GetSystemVersionReply.prototype.version = \"\";\n    \n                /**\n                 * Creates a new GetSystemVersionReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply instance\n                 */\n                GetSystemVersionReply.create = function create(properties) {\n                    return new GetSystemVersionReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemVersionReply message. Does not implicitly {@link particle.ctrl.GetSystemVersionReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionReply} message GetSystemVersionReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemVersionReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemVersionReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemVersionReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.version = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemVersionReply;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionRequest = (function() {\n    \n                /**\n                 * Properties of a GetNcpFirmwareVersionRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetNcpFirmwareVersionRequest\n                 */\n    \n                /**\n                 * Constructs a new GetNcpFirmwareVersionRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetNcpFirmwareVersionRequest.\n                 * @implements IGetNcpFirmwareVersionRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set\n                 */\n                function GetNcpFirmwareVersionRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetNcpFirmwareVersionRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest instance\n                 */\n                GetNcpFirmwareVersionRequest.create = function create(properties) {\n                    return new GetNcpFirmwareVersionRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetNcpFirmwareVersionRequest message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest} message GetNcpFirmwareVersionRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetNcpFirmwareVersionRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetNcpFirmwareVersionRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetNcpFirmwareVersionRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetNcpFirmwareVersionRequest;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionReply = (function() {\n    \n                /**\n                 * Properties of a GetNcpFirmwareVersionReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetNcpFirmwareVersionReply\n                 * @property {string|null} [version] GetNcpFirmwareVersionReply version\n                 * @property {number|null} [moduleVersion] GetNcpFirmwareVersionReply moduleVersion\n                 */\n    \n                /**\n                 * Constructs a new GetNcpFirmwareVersionReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetNcpFirmwareVersionReply.\n                 * @implements IGetNcpFirmwareVersionReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set\n                 */\n                function GetNcpFirmwareVersionReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetNcpFirmwareVersionReply version.\n                 * @member {string} version\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @instance\n                 */\n                GetNcpFirmwareVersionReply.prototype.version = \"\";\n    \n                /**\n                 * GetNcpFirmwareVersionReply moduleVersion.\n                 * @member {number} moduleVersion\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @instance\n                 */\n                GetNcpFirmwareVersionReply.prototype.moduleVersion = 0;\n    \n                /**\n                 * Creates a new GetNcpFirmwareVersionReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply instance\n                 */\n                GetNcpFirmwareVersionReply.create = function create(properties) {\n                    return new GetNcpFirmwareVersionReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetNcpFirmwareVersionReply message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply} message GetNcpFirmwareVersionReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetNcpFirmwareVersionReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);\n                    if (message.moduleVersion != null && Object.hasOwnProperty.call(message, \"moduleVersion\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.moduleVersion);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetNcpFirmwareVersionReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetNcpFirmwareVersionReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.version = reader.string();\n                            break;\n                        case 2:\n                            message.moduleVersion = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetNcpFirmwareVersionReply;\n            })();\n    \n            ctrl.GetSystemCapabilitiesRequest = (function() {\n    \n                /**\n                 * Properties of a GetSystemCapabilitiesRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemCapabilitiesRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSystemCapabilitiesRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemCapabilitiesRequest.\n                 * @implements IGetSystemCapabilitiesRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set\n                 */\n                function GetSystemCapabilitiesRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSystemCapabilitiesRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest instance\n                 */\n                GetSystemCapabilitiesRequest.create = function create(properties) {\n                    return new GetSystemCapabilitiesRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemCapabilitiesRequest message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest} message GetSystemCapabilitiesRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemCapabilitiesRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemCapabilitiesRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemCapabilitiesRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemCapabilitiesRequest;\n            })();\n    \n            ctrl.GetSystemCapabilitiesReply = (function() {\n    \n                /**\n                 * Properties of a GetSystemCapabilitiesReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemCapabilitiesReply\n                 * @property {number|null} [flags] GetSystemCapabilitiesReply flags\n                 */\n    \n                /**\n                 * Constructs a new GetSystemCapabilitiesReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemCapabilitiesReply.\n                 * @implements IGetSystemCapabilitiesReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set\n                 */\n                function GetSystemCapabilitiesReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSystemCapabilitiesReply flags.\n                 * @member {number} flags\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @instance\n                 */\n                GetSystemCapabilitiesReply.prototype.flags = 0;\n    \n                /**\n                 * Creates a new GetSystemCapabilitiesReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply instance\n                 */\n                GetSystemCapabilitiesReply.create = function create(properties) {\n                    return new GetSystemCapabilitiesReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemCapabilitiesReply message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply} message GetSystemCapabilitiesReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemCapabilitiesReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.flags);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemCapabilitiesReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemCapabilitiesReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.flags = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemCapabilitiesReply;\n            })();\n    \n            ctrl.SetClaimCodeRequest = (function() {\n    \n                /**\n                 * Properties of a SetClaimCodeRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetClaimCodeRequest\n                 * @property {string|null} [code] SetClaimCodeRequest code\n                 */\n    \n                /**\n                 * Constructs a new SetClaimCodeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetClaimCodeRequest.\n                 * @implements ISetClaimCodeRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set\n                 */\n                function SetClaimCodeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetClaimCodeRequest code.\n                 * @member {string} code\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @instance\n                 */\n                SetClaimCodeRequest.prototype.code = \"\";\n    \n                /**\n                 * Creates a new SetClaimCodeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest instance\n                 */\n                SetClaimCodeRequest.create = function create(properties) {\n                    return new SetClaimCodeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetClaimCodeRequest message. Does not implicitly {@link particle.ctrl.SetClaimCodeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeRequest} message SetClaimCodeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetClaimCodeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetClaimCodeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetClaimCodeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.code = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetClaimCodeRequest;\n            })();\n    \n            ctrl.SetClaimCodeReply = (function() {\n    \n                /**\n                 * Properties of a SetClaimCodeReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetClaimCodeReply\n                 */\n    \n                /**\n                 * Constructs a new SetClaimCodeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetClaimCodeReply.\n                 * @implements ISetClaimCodeReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set\n                 */\n                function SetClaimCodeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetClaimCodeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply instance\n                 */\n                SetClaimCodeReply.create = function create(properties) {\n                    return new SetClaimCodeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetClaimCodeReply message. Does not implicitly {@link particle.ctrl.SetClaimCodeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeReply} message SetClaimCodeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetClaimCodeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetClaimCodeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetClaimCodeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetClaimCodeReply;\n            })();\n    \n            ctrl.IsClaimedRequest = (function() {\n    \n                /**\n                 * Properties of an IsClaimedRequest.\n                 * @memberof particle.ctrl\n                 * @interface IIsClaimedRequest\n                 */\n    \n                /**\n                 * Constructs a new IsClaimedRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsClaimedRequest.\n                 * @implements IIsClaimedRequest\n                 * @constructor\n                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set\n                 */\n                function IsClaimedRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new IsClaimedRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest instance\n                 */\n                IsClaimedRequest.create = function create(properties) {\n                    return new IsClaimedRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsClaimedRequest message. Does not implicitly {@link particle.ctrl.IsClaimedRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedRequest} message IsClaimedRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsClaimedRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsClaimedRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsClaimedRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsClaimedRequest;\n            })();\n    \n            ctrl.IsClaimedReply = (function() {\n    \n                /**\n                 * Properties of an IsClaimedReply.\n                 * @memberof particle.ctrl\n                 * @interface IIsClaimedReply\n                 * @property {boolean|null} [claimed] IsClaimedReply claimed\n                 */\n    \n                /**\n                 * Constructs a new IsClaimedReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsClaimedReply.\n                 * @implements IIsClaimedReply\n                 * @constructor\n                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set\n                 */\n                function IsClaimedReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IsClaimedReply claimed.\n                 * @member {boolean} claimed\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @instance\n                 */\n                IsClaimedReply.prototype.claimed = false;\n    \n                /**\n                 * Creates a new IsClaimedReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply instance\n                 */\n                IsClaimedReply.create = function create(properties) {\n                    return new IsClaimedReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsClaimedReply message. Does not implicitly {@link particle.ctrl.IsClaimedReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedReply} message IsClaimedReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsClaimedReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.claimed != null && Object.hasOwnProperty.call(message, \"claimed\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.claimed);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsClaimedReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsClaimedReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.claimed = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsClaimedReply;\n            })();\n    \n            ctrl.SetSecurityKeyRequest = (function() {\n    \n                /**\n                 * Properties of a SetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetSecurityKeyRequest\n                 * @property {particle.ctrl.SecurityKeyType|null} [type] SetSecurityKeyRequest type\n                 * @property {Uint8Array|null} [data] SetSecurityKeyRequest data\n                 */\n    \n                /**\n                 * Constructs a new SetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSecurityKeyRequest.\n                 * @implements ISetSecurityKeyRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set\n                 */\n                function SetSecurityKeyRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetSecurityKeyRequest type.\n                 * @member {particle.ctrl.SecurityKeyType} type\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @instance\n                 */\n                SetSecurityKeyRequest.prototype.type = 0;\n    \n                /**\n                 * SetSecurityKeyRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @instance\n                 */\n                SetSecurityKeyRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new SetSecurityKeyRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest instance\n                 */\n                SetSecurityKeyRequest.create = function create(properties) {\n                    return new SetSecurityKeyRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.SetSecurityKeyRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyRequest} message SetSecurityKeyRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSecurityKeyRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSecurityKeyRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSecurityKeyRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSecurityKeyRequest;\n            })();\n    \n            ctrl.SetSecurityKeyReply = (function() {\n    \n                /**\n                 * Properties of a SetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetSecurityKeyReply\n                 */\n    \n                /**\n                 * Constructs a new SetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSecurityKeyReply.\n                 * @implements ISetSecurityKeyReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set\n                 */\n                function SetSecurityKeyReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetSecurityKeyReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply instance\n                 */\n                SetSecurityKeyReply.create = function create(properties) {\n                    return new SetSecurityKeyReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.SetSecurityKeyReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyReply} message SetSecurityKeyReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSecurityKeyReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSecurityKeyReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSecurityKeyReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSecurityKeyReply;\n            })();\n    \n            ctrl.GetSecurityKeyRequest = (function() {\n    \n                /**\n                 * Properties of a GetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSecurityKeyRequest\n                 * @property {particle.ctrl.SecurityKeyType|null} [type] GetSecurityKeyRequest type\n                 */\n    \n                /**\n                 * Constructs a new GetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSecurityKeyRequest.\n                 * @implements IGetSecurityKeyRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set\n                 */\n                function GetSecurityKeyRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSecurityKeyRequest type.\n                 * @member {particle.ctrl.SecurityKeyType} type\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @instance\n                 */\n                GetSecurityKeyRequest.prototype.type = 0;\n    \n                /**\n                 * Creates a new GetSecurityKeyRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest instance\n                 */\n                GetSecurityKeyRequest.create = function create(properties) {\n                    return new GetSecurityKeyRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.GetSecurityKeyRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyRequest} message GetSecurityKeyRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSecurityKeyRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSecurityKeyRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSecurityKeyRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSecurityKeyRequest;\n            })();\n    \n            ctrl.GetSecurityKeyReply = (function() {\n    \n                /**\n                 * Properties of a GetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSecurityKeyReply\n                 * @property {Uint8Array|null} [data] GetSecurityKeyReply data\n                 */\n    \n                /**\n                 * Constructs a new GetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSecurityKeyReply.\n                 * @implements IGetSecurityKeyReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set\n                 */\n                function GetSecurityKeyReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSecurityKeyReply data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @instance\n                 */\n                GetSecurityKeyReply.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new GetSecurityKeyReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply instance\n                 */\n                GetSecurityKeyReply.create = function create(properties) {\n                    return new GetSecurityKeyReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.GetSecurityKeyReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyReply} message GetSecurityKeyReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSecurityKeyReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSecurityKeyReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSecurityKeyReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSecurityKeyReply;\n            })();\n    \n            ctrl.SetServerAddressRequest = (function() {\n    \n                /**\n                 * Properties of a SetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerAddressRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerAddressRequest protocol\n                 * @property {string|null} [address] SetServerAddressRequest address\n                 * @property {number|null} [port] SetServerAddressRequest port\n                 */\n    \n                /**\n                 * Constructs a new SetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerAddressRequest.\n                 * @implements ISetServerAddressRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set\n                 */\n                function SetServerAddressRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetServerAddressRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.protocol = 0;\n    \n                /**\n                 * SetServerAddressRequest address.\n                 * @member {string} address\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.address = \"\";\n    \n                /**\n                 * SetServerAddressRequest port.\n                 * @member {number} port\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.port = 0;\n    \n                /**\n                 * Creates a new SetServerAddressRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest instance\n                 */\n                SetServerAddressRequest.create = function create(properties) {\n                    return new SetServerAddressRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerAddressRequest message. Does not implicitly {@link particle.ctrl.SetServerAddressRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressRequest} message SetServerAddressRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerAddressRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);\n                    if (message.port != null && Object.hasOwnProperty.call(message, \"port\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerAddressRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerAddressRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        case 2:\n                            message.address = reader.string();\n                            break;\n                        case 3:\n                            message.port = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerAddressRequest;\n            })();\n    \n            ctrl.SetServerAddressReply = (function() {\n    \n                /**\n                 * Properties of a SetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerAddressReply\n                 */\n    \n                /**\n                 * Constructs a new SetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerAddressReply.\n                 * @implements ISetServerAddressReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set\n                 */\n                function SetServerAddressReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetServerAddressReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply instance\n                 */\n                SetServerAddressReply.create = function create(properties) {\n                    return new SetServerAddressReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerAddressReply message. Does not implicitly {@link particle.ctrl.SetServerAddressReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressReply} message SetServerAddressReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerAddressReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerAddressReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerAddressReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerAddressReply;\n            })();\n    \n            ctrl.GetServerAddressRequest = (function() {\n    \n                /**\n                 * Properties of a GetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerAddressRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerAddressRequest protocol\n                 */\n    \n                /**\n                 * Constructs a new GetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerAddressRequest.\n                 * @implements IGetServerAddressRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set\n                 */\n                function GetServerAddressRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerAddressRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @instance\n                 */\n                GetServerAddressRequest.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new GetServerAddressRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest instance\n                 */\n                GetServerAddressRequest.create = function create(properties) {\n                    return new GetServerAddressRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerAddressRequest message. Does not implicitly {@link particle.ctrl.GetServerAddressRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressRequest} message GetServerAddressRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerAddressRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerAddressRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerAddressRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerAddressRequest;\n            })();\n    \n            ctrl.GetServerAddressReply = (function() {\n    \n                /**\n                 * Properties of a GetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerAddressReply\n                 * @property {string|null} [address] GetServerAddressReply address\n                 * @property {number|null} [port] GetServerAddressReply port\n                 */\n    \n                /**\n                 * Constructs a new GetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerAddressReply.\n                 * @implements IGetServerAddressReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set\n                 */\n                function GetServerAddressReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerAddressReply address.\n                 * @member {string} address\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @instance\n                 */\n                GetServerAddressReply.prototype.address = \"\";\n    \n                /**\n                 * GetServerAddressReply port.\n                 * @member {number} port\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @instance\n                 */\n                GetServerAddressReply.prototype.port = 0;\n    \n                /**\n                 * Creates a new GetServerAddressReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply instance\n                 */\n                GetServerAddressReply.create = function create(properties) {\n                    return new GetServerAddressReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerAddressReply message. Does not implicitly {@link particle.ctrl.GetServerAddressReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressReply} message GetServerAddressReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerAddressReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);\n                    if (message.port != null && Object.hasOwnProperty.call(message, \"port\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerAddressReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerAddressReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.string();\n                            break;\n                        case 2:\n                            message.port = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerAddressReply;\n            })();\n    \n            ctrl.SetServerProtocolRequest = (function() {\n    \n                /**\n                 * Properties of a SetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerProtocolRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerProtocolRequest protocol\n                 */\n    \n                /**\n                 * Constructs a new SetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerProtocolRequest.\n                 * @implements ISetServerProtocolRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set\n                 */\n                function SetServerProtocolRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetServerProtocolRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @instance\n                 */\n                SetServerProtocolRequest.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new SetServerProtocolRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest instance\n                 */\n                SetServerProtocolRequest.create = function create(properties) {\n                    return new SetServerProtocolRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.SetServerProtocolRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolRequest} message SetServerProtocolRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerProtocolRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerProtocolRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerProtocolRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerProtocolRequest;\n            })();\n    \n            ctrl.SetServerProtocolReply = (function() {\n    \n                /**\n                 * Properties of a SetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerProtocolReply\n                 */\n    \n                /**\n                 * Constructs a new SetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerProtocolReply.\n                 * @implements ISetServerProtocolReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set\n                 */\n                function SetServerProtocolReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetServerProtocolReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply instance\n                 */\n                SetServerProtocolReply.create = function create(properties) {\n                    return new SetServerProtocolReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerProtocolReply message. Does not implicitly {@link particle.ctrl.SetServerProtocolReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolReply} message SetServerProtocolReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerProtocolReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerProtocolReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerProtocolReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerProtocolReply;\n            })();\n    \n            ctrl.GetServerProtocolRequest = (function() {\n    \n                /**\n                 * Properties of a GetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerProtocolRequest\n                 */\n    \n                /**\n                 * Constructs a new GetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerProtocolRequest.\n                 * @implements IGetServerProtocolRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set\n                 */\n                function GetServerProtocolRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetServerProtocolRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest instance\n                 */\n                GetServerProtocolRequest.create = function create(properties) {\n                    return new GetServerProtocolRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.GetServerProtocolRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolRequest} message GetServerProtocolRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerProtocolRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerProtocolRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerProtocolRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerProtocolRequest;\n            })();\n    \n            ctrl.GetServerProtocolReply = (function() {\n    \n                /**\n                 * Properties of a GetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerProtocolReply\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerProtocolReply protocol\n                 */\n    \n                /**\n                 * Constructs a new GetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerProtocolReply.\n                 * @implements IGetServerProtocolReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set\n                 */\n                function GetServerProtocolReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerProtocolReply protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @instance\n                 */\n                GetServerProtocolReply.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new GetServerProtocolReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply instance\n                 */\n                GetServerProtocolReply.create = function create(properties) {\n                    return new GetServerProtocolReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerProtocolReply message. Does not implicitly {@link particle.ctrl.GetServerProtocolReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolReply} message GetServerProtocolReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerProtocolReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerProtocolReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerProtocolReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerProtocolReply;\n            })();\n    \n            ctrl.SetSoftApSsidRequest = (function() {\n    \n                /**\n                 * Properties of a SetSoftApSsidRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetSoftApSsidRequest\n                 * @property {string|null} [prefix] SetSoftApSsidRequest prefix\n                 * @property {string|null} [suffix] SetSoftApSsidRequest suffix\n                 */\n    \n                /**\n                 * Constructs a new SetSoftApSsidRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSoftApSsidRequest.\n                 * @implements ISetSoftApSsidRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set\n                 */\n                function SetSoftApSsidRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetSoftApSsidRequest prefix.\n                 * @member {string} prefix\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @instance\n                 */\n                SetSoftApSsidRequest.prototype.prefix = \"\";\n    \n                /**\n                 * SetSoftApSsidRequest suffix.\n                 * @member {string} suffix\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @instance\n                 */\n                SetSoftApSsidRequest.prototype.suffix = \"\";\n    \n                /**\n                 * Creates a new SetSoftApSsidRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest instance\n                 */\n                SetSoftApSsidRequest.create = function create(properties) {\n                    return new SetSoftApSsidRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSoftApSsidRequest message. Does not implicitly {@link particle.ctrl.SetSoftApSsidRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidRequest} message SetSoftApSsidRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSoftApSsidRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.prefix != null && Object.hasOwnProperty.call(message, \"prefix\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefix);\n                    if (message.suffix != null && Object.hasOwnProperty.call(message, \"suffix\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.suffix);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSoftApSsidRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSoftApSsidRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.prefix = reader.string();\n                            break;\n                        case 2:\n                            message.suffix = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSoftApSsidRequest;\n            })();\n    \n            ctrl.SetSoftApSsidReply = (function() {\n    \n                /**\n                 * Properties of a SetSoftApSsidReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetSoftApSsidReply\n                 */\n    \n                /**\n                 * Constructs a new SetSoftApSsidReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSoftApSsidReply.\n                 * @implements ISetSoftApSsidReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set\n                 */\n                function SetSoftApSsidReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetSoftApSsidReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply instance\n                 */\n                SetSoftApSsidReply.create = function create(properties) {\n                    return new SetSoftApSsidReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSoftApSsidReply message. Does not implicitly {@link particle.ctrl.SetSoftApSsidReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidReply} message SetSoftApSsidReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSoftApSsidReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSoftApSsidReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSoftApSsidReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSoftApSsidReply;\n            })();\n    \n            ctrl.StartListeningModeRequest = (function() {\n    \n                /**\n                 * Properties of a StartListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartListeningModeRequest\n                 */\n    \n                /**\n                 * Constructs a new StartListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartListeningModeRequest.\n                 * @implements IStartListeningModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set\n                 */\n                function StartListeningModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartListeningModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest instance\n                 */\n                StartListeningModeRequest.create = function create(properties) {\n                    return new StartListeningModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartListeningModeRequest message. Does not implicitly {@link particle.ctrl.StartListeningModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeRequest} message StartListeningModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartListeningModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartListeningModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartListeningModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartListeningModeRequest;\n            })();\n    \n            ctrl.StartListeningModeReply = (function() {\n    \n                /**\n                 * Properties of a StartListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartListeningModeReply\n                 */\n    \n                /**\n                 * Constructs a new StartListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartListeningModeReply.\n                 * @implements IStartListeningModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set\n                 */\n                function StartListeningModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartListeningModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply instance\n                 */\n                StartListeningModeReply.create = function create(properties) {\n                    return new StartListeningModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartListeningModeReply message. Does not implicitly {@link particle.ctrl.StartListeningModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeReply} message StartListeningModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartListeningModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartListeningModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartListeningModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartListeningModeReply;\n            })();\n    \n            ctrl.StopListeningModeRequest = (function() {\n    \n                /**\n                 * Properties of a StopListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStopListeningModeRequest\n                 */\n    \n                /**\n                 * Constructs a new StopListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopListeningModeRequest.\n                 * @implements IStopListeningModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set\n                 */\n                function StopListeningModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopListeningModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest instance\n                 */\n                StopListeningModeRequest.create = function create(properties) {\n                    return new StopListeningModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopListeningModeRequest message. Does not implicitly {@link particle.ctrl.StopListeningModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeRequest} message StopListeningModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopListeningModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopListeningModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopListeningModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopListeningModeRequest;\n            })();\n    \n            ctrl.StopListeningModeReply = (function() {\n    \n                /**\n                 * Properties of a StopListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IStopListeningModeReply\n                 */\n    \n                /**\n                 * Constructs a new StopListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopListeningModeReply.\n                 * @implements IStopListeningModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set\n                 */\n                function StopListeningModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopListeningModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply instance\n                 */\n                StopListeningModeReply.create = function create(properties) {\n                    return new StopListeningModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopListeningModeReply message. Does not implicitly {@link particle.ctrl.StopListeningModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeReply} message StopListeningModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopListeningModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopListeningModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopListeningModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopListeningModeReply;\n            })();\n    \n            ctrl.GetDeviceModeRequest = (function() {\n    \n                /**\n                 * Properties of a GetDeviceModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceModeRequest\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceModeRequest.\n                 * @implements IGetDeviceModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set\n                 */\n                function GetDeviceModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetDeviceModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest instance\n                 */\n                GetDeviceModeRequest.create = function create(properties) {\n                    return new GetDeviceModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceModeRequest message. Does not implicitly {@link particle.ctrl.GetDeviceModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeRequest} message GetDeviceModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceModeRequest;\n            })();\n    \n            ctrl.GetDeviceModeReply = (function() {\n    \n                /**\n                 * Properties of a GetDeviceModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceModeReply\n                 * @property {particle.ctrl.DeviceMode|null} [mode] GetDeviceModeReply mode\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceModeReply.\n                 * @implements IGetDeviceModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set\n                 */\n                function GetDeviceModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetDeviceModeReply mode.\n                 * @member {particle.ctrl.DeviceMode} mode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @instance\n                 */\n                GetDeviceModeReply.prototype.mode = 0;\n    \n                /**\n                 * Creates a new GetDeviceModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply instance\n                 */\n                GetDeviceModeReply.create = function create(properties) {\n                    return new GetDeviceModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceModeReply message. Does not implicitly {@link particle.ctrl.GetDeviceModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeReply} message GetDeviceModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.mode = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceModeReply;\n            })();\n    \n            ctrl.SetDeviceSetupDoneRequest = (function() {\n    \n                /**\n                 * Properties of a SetDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetDeviceSetupDoneRequest\n                 * @property {boolean|null} [done] SetDeviceSetupDoneRequest done\n                 */\n    \n                /**\n                 * Constructs a new SetDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetDeviceSetupDoneRequest.\n                 * @implements ISetDeviceSetupDoneRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set\n                 */\n                function SetDeviceSetupDoneRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetDeviceSetupDoneRequest done.\n                 * @member {boolean} done\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @instance\n                 */\n                SetDeviceSetupDoneRequest.prototype.done = false;\n    \n                /**\n                 * Creates a new SetDeviceSetupDoneRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest instance\n                 */\n                SetDeviceSetupDoneRequest.create = function create(properties) {\n                    return new SetDeviceSetupDoneRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest} message SetDeviceSetupDoneRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetDeviceSetupDoneRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.done != null && Object.hasOwnProperty.call(message, \"done\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetDeviceSetupDoneRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetDeviceSetupDoneRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.done = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.SetDeviceSetupDoneReply = (function() {\n    \n                /**\n                 * Properties of a SetDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetDeviceSetupDoneReply\n                 */\n    \n                /**\n                 * Constructs a new SetDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetDeviceSetupDoneReply.\n                 * @implements ISetDeviceSetupDoneReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set\n                 */\n                function SetDeviceSetupDoneReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetDeviceSetupDoneReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply instance\n                 */\n                SetDeviceSetupDoneReply.create = function create(properties) {\n                    return new SetDeviceSetupDoneReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply} message SetDeviceSetupDoneReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetDeviceSetupDoneReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetDeviceSetupDoneReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetDeviceSetupDoneReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetDeviceSetupDoneReply;\n            })();\n    \n            ctrl.IsDeviceSetupDoneRequest = (function() {\n    \n                /**\n                 * Properties of an IsDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @interface IIsDeviceSetupDoneRequest\n                 */\n    \n                /**\n                 * Constructs a new IsDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsDeviceSetupDoneRequest.\n                 * @implements IIsDeviceSetupDoneRequest\n                 * @constructor\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set\n                 */\n                function IsDeviceSetupDoneRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new IsDeviceSetupDoneRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest instance\n                 */\n                IsDeviceSetupDoneRequest.create = function create(properties) {\n                    return new IsDeviceSetupDoneRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest} message IsDeviceSetupDoneRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsDeviceSetupDoneRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsDeviceSetupDoneRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsDeviceSetupDoneRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.IsDeviceSetupDoneReply = (function() {\n    \n                /**\n                 * Properties of an IsDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @interface IIsDeviceSetupDoneReply\n                 * @property {boolean|null} [done] IsDeviceSetupDoneReply done\n                 */\n    \n                /**\n                 * Constructs a new IsDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsDeviceSetupDoneReply.\n                 * @implements IIsDeviceSetupDoneReply\n                 * @constructor\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set\n                 */\n                function IsDeviceSetupDoneReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IsDeviceSetupDoneReply done.\n                 * @member {boolean} done\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @instance\n                 */\n                IsDeviceSetupDoneReply.prototype.done = false;\n    \n                /**\n                 * Creates a new IsDeviceSetupDoneReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply instance\n                 */\n                IsDeviceSetupDoneReply.create = function create(properties) {\n                    return new IsDeviceSetupDoneReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply} message IsDeviceSetupDoneReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsDeviceSetupDoneReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.done != null && Object.hasOwnProperty.call(message, \"done\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsDeviceSetupDoneReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsDeviceSetupDoneReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.done = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsDeviceSetupDoneReply;\n            })();\n    \n            ctrl.SetStartupModeRequest = (function() {\n    \n                /**\n                 * Properties of a SetStartupModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetStartupModeRequest\n                 * @property {particle.ctrl.DeviceMode|null} [mode] SetStartupModeRequest mode\n                 */\n    \n                /**\n                 * Constructs a new SetStartupModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetStartupModeRequest.\n                 * @implements ISetStartupModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set\n                 */\n                function SetStartupModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetStartupModeRequest mode.\n                 * @member {particle.ctrl.DeviceMode} mode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @instance\n                 */\n                SetStartupModeRequest.prototype.mode = 0;\n    \n                /**\n                 * Creates a new SetStartupModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest instance\n                 */\n                SetStartupModeRequest.create = function create(properties) {\n                    return new SetStartupModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetStartupModeRequest message. Does not implicitly {@link particle.ctrl.SetStartupModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeRequest} message SetStartupModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetStartupModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetStartupModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetStartupModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.mode = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetStartupModeRequest;\n            })();\n    \n            ctrl.SetStartupModeReply = (function() {\n    \n                /**\n                 * Properties of a SetStartupModeReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetStartupModeReply\n                 */\n    \n                /**\n                 * Constructs a new SetStartupModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetStartupModeReply.\n                 * @implements ISetStartupModeReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set\n                 */\n                function SetStartupModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetStartupModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply instance\n                 */\n                SetStartupModeReply.create = function create(properties) {\n                    return new SetStartupModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetStartupModeReply message. Does not implicitly {@link particle.ctrl.SetStartupModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeReply} message SetStartupModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetStartupModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetStartupModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetStartupModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetStartupModeReply;\n            })();\n    \n            ctrl.GetProtectedStateRequest = (function() {\n    \n                /**\n                 * Properties of a GetProtectedStateRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetProtectedStateRequest\n                 */\n    \n                /**\n                 * Constructs a new GetProtectedStateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetProtectedStateRequest.\n                 * @implements IGetProtectedStateRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetProtectedStateRequest=} [properties] Properties to set\n                 */\n                function GetProtectedStateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetProtectedStateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetProtectedStateRequest\n                 * @static\n                 * @param {particle.ctrl.IGetProtectedStateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetProtectedStateRequest} GetProtectedStateRequest instance\n                 */\n                GetProtectedStateRequest.create = function create(properties) {\n                    return new GetProtectedStateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetProtectedStateRequest message. Does not implicitly {@link particle.ctrl.GetProtectedStateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetProtectedStateRequest\n                 * @static\n                 * @param {particle.ctrl.IGetProtectedStateRequest} message GetProtectedStateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetProtectedStateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetProtectedStateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetProtectedStateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetProtectedStateRequest} GetProtectedStateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetProtectedStateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetProtectedStateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetProtectedStateRequest;\n            })();\n    \n            ctrl.GetProtectedStateReply = (function() {\n    \n                /**\n                 * Properties of a GetProtectedStateReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetProtectedStateReply\n                 * @property {boolean|null} [state] GetProtectedStateReply state\n                 * @property {boolean|null} [overridden] GetProtectedStateReply overridden\n                 */\n    \n                /**\n                 * Constructs a new GetProtectedStateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetProtectedStateReply.\n                 * @implements IGetProtectedStateReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetProtectedStateReply=} [properties] Properties to set\n                 */\n                function GetProtectedStateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetProtectedStateReply state.\n                 * @member {boolean} state\n                 * @memberof particle.ctrl.GetProtectedStateReply\n                 * @instance\n                 */\n                GetProtectedStateReply.prototype.state = false;\n    \n                /**\n                 * GetProtectedStateReply overridden.\n                 * @member {boolean} overridden\n                 * @memberof particle.ctrl.GetProtectedStateReply\n                 * @instance\n                 */\n                GetProtectedStateReply.prototype.overridden = false;\n    \n                /**\n                 * Creates a new GetProtectedStateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetProtectedStateReply\n                 * @static\n                 * @param {particle.ctrl.IGetProtectedStateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetProtectedStateReply} GetProtectedStateReply instance\n                 */\n                GetProtectedStateReply.create = function create(properties) {\n                    return new GetProtectedStateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetProtectedStateReply message. Does not implicitly {@link particle.ctrl.GetProtectedStateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetProtectedStateReply\n                 * @static\n                 * @param {particle.ctrl.IGetProtectedStateReply} message GetProtectedStateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetProtectedStateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.state);\n                    if (message.overridden != null && Object.hasOwnProperty.call(message, \"overridden\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.overridden);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetProtectedStateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetProtectedStateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetProtectedStateReply} GetProtectedStateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetProtectedStateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetProtectedStateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.state = reader.bool();\n                            break;\n                        case 2:\n                            message.overridden = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetProtectedStateReply;\n            })();\n    \n            ctrl.SetProtectedStateRequest = (function() {\n    \n                /**\n                 * Properties of a SetProtectedStateRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetProtectedStateRequest\n                 * @property {particle.ctrl.SetProtectedStateRequest.Action|null} [action] SetProtectedStateRequest action\n                 * @property {particle.ctrl.SetProtectedStateRequest.IPrepare|null} [prepare] SetProtectedStateRequest prepare\n                 * @property {particle.ctrl.SetProtectedStateRequest.IConfirm|null} [confirm] SetProtectedStateRequest confirm\n                 */\n    \n                /**\n                 * Constructs a new SetProtectedStateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetProtectedStateRequest.\n                 * @implements ISetProtectedStateRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetProtectedStateRequest=} [properties] Properties to set\n                 */\n                function SetProtectedStateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetProtectedStateRequest action.\n                 * @member {particle.ctrl.SetProtectedStateRequest.Action} action\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @instance\n                 */\n                SetProtectedStateRequest.prototype.action = 0;\n    \n                /**\n                 * SetProtectedStateRequest prepare.\n                 * @member {particle.ctrl.SetProtectedStateRequest.IPrepare|null|undefined} prepare\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @instance\n                 */\n                SetProtectedStateRequest.prototype.prepare = null;\n    \n                /**\n                 * SetProtectedStateRequest confirm.\n                 * @member {particle.ctrl.SetProtectedStateRequest.IConfirm|null|undefined} confirm\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @instance\n                 */\n                SetProtectedStateRequest.prototype.confirm = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * SetProtectedStateRequest data.\n                 * @member {\"prepare\"|\"confirm\"|undefined} data\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @instance\n                 */\n                Object.defineProperty(SetProtectedStateRequest.prototype, \"data\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"prepare\", \"confirm\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new SetProtectedStateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @static\n                 * @param {particle.ctrl.ISetProtectedStateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetProtectedStateRequest} SetProtectedStateRequest instance\n                 */\n                SetProtectedStateRequest.create = function create(properties) {\n                    return new SetProtectedStateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetProtectedStateRequest message. Does not implicitly {@link particle.ctrl.SetProtectedStateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @static\n                 * @param {particle.ctrl.ISetProtectedStateRequest} message SetProtectedStateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetProtectedStateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.action != null && Object.hasOwnProperty.call(message, \"action\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.action);\n                    if (message.prepare != null && Object.hasOwnProperty.call(message, \"prepare\"))\n                        $root.particle.ctrl.SetProtectedStateRequest.Prepare.encode(message.prepare, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.confirm != null && Object.hasOwnProperty.call(message, \"confirm\"))\n                        $root.particle.ctrl.SetProtectedStateRequest.Confirm.encode(message.confirm, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetProtectedStateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetProtectedStateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetProtectedStateRequest} SetProtectedStateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetProtectedStateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetProtectedStateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.action = reader.int32();\n                            break;\n                        case 2:\n                            message.prepare = $root.particle.ctrl.SetProtectedStateRequest.Prepare.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.confirm = $root.particle.ctrl.SetProtectedStateRequest.Confirm.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Action enum.\n                 * @name particle.ctrl.SetProtectedStateRequest.Action\n                 * @enum {number}\n                 * @property {number} RESET=0 RESET value\n                 * @property {number} PREPARE=1 PREPARE value\n                 * @property {number} CONFIRM=2 CONFIRM value\n                 */\n                SetProtectedStateRequest.Action = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"RESET\"] = 0;\n                    values[valuesById[1] = \"PREPARE\"] = 1;\n                    values[valuesById[2] = \"CONFIRM\"] = 2;\n                    return values;\n                })();\n    \n                SetProtectedStateRequest.Prepare = (function() {\n    \n                    /**\n                     * Properties of a Prepare.\n                     * @memberof particle.ctrl.SetProtectedStateRequest\n                     * @interface IPrepare\n                     * @property {Uint8Array|null} [serverNonce] Prepare serverNonce\n                     */\n    \n                    /**\n                     * Constructs a new Prepare.\n                     * @memberof particle.ctrl.SetProtectedStateRequest\n                     * @classdesc Represents a Prepare.\n                     * @implements IPrepare\n                     * @constructor\n                     * @param {particle.ctrl.SetProtectedStateRequest.IPrepare=} [properties] Properties to set\n                     */\n                    function Prepare(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Prepare serverNonce.\n                     * @member {Uint8Array} serverNonce\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Prepare\n                     * @instance\n                     */\n                    Prepare.prototype.serverNonce = $util.newBuffer([]);\n    \n                    /**\n                     * Creates a new Prepare instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Prepare\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateRequest.IPrepare=} [properties] Properties to set\n                     * @returns {particle.ctrl.SetProtectedStateRequest.Prepare} Prepare instance\n                     */\n                    Prepare.create = function create(properties) {\n                        return new Prepare(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Prepare message. Does not implicitly {@link particle.ctrl.SetProtectedStateRequest.Prepare.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Prepare\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateRequest.IPrepare} message Prepare message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Prepare.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.serverNonce != null && Object.hasOwnProperty.call(message, \"serverNonce\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.serverNonce);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Prepare message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Prepare\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.SetProtectedStateRequest.Prepare} Prepare\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Prepare.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetProtectedStateRequest.Prepare();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.serverNonce = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Prepare;\n                })();\n    \n                SetProtectedStateRequest.Confirm = (function() {\n    \n                    /**\n                     * Properties of a Confirm.\n                     * @memberof particle.ctrl.SetProtectedStateRequest\n                     * @interface IConfirm\n                     * @property {Uint8Array|null} [serverSignature] Confirm serverSignature\n                     * @property {Uint8Array|null} [serverPublicKeyFingerprint] Confirm serverPublicKeyFingerprint\n                     */\n    \n                    /**\n                     * Constructs a new Confirm.\n                     * @memberof particle.ctrl.SetProtectedStateRequest\n                     * @classdesc Represents a Confirm.\n                     * @implements IConfirm\n                     * @constructor\n                     * @param {particle.ctrl.SetProtectedStateRequest.IConfirm=} [properties] Properties to set\n                     */\n                    function Confirm(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Confirm serverSignature.\n                     * @member {Uint8Array} serverSignature\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Confirm\n                     * @instance\n                     */\n                    Confirm.prototype.serverSignature = $util.newBuffer([]);\n    \n                    /**\n                     * Confirm serverPublicKeyFingerprint.\n                     * @member {Uint8Array} serverPublicKeyFingerprint\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Confirm\n                     * @instance\n                     */\n                    Confirm.prototype.serverPublicKeyFingerprint = $util.newBuffer([]);\n    \n                    /**\n                     * Creates a new Confirm instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Confirm\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateRequest.IConfirm=} [properties] Properties to set\n                     * @returns {particle.ctrl.SetProtectedStateRequest.Confirm} Confirm instance\n                     */\n                    Confirm.create = function create(properties) {\n                        return new Confirm(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Confirm message. Does not implicitly {@link particle.ctrl.SetProtectedStateRequest.Confirm.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Confirm\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateRequest.IConfirm} message Confirm message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Confirm.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.serverSignature != null && Object.hasOwnProperty.call(message, \"serverSignature\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.serverSignature);\n                        if (message.serverPublicKeyFingerprint != null && Object.hasOwnProperty.call(message, \"serverPublicKeyFingerprint\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.serverPublicKeyFingerprint);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Confirm message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.SetProtectedStateRequest.Confirm\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.SetProtectedStateRequest.Confirm} Confirm\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Confirm.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetProtectedStateRequest.Confirm();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.serverSignature = reader.bytes();\n                                break;\n                            case 2:\n                                message.serverPublicKeyFingerprint = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Confirm;\n                })();\n    \n                return SetProtectedStateRequest;\n            })();\n    \n            ctrl.SetProtectedStateReply = (function() {\n    \n                /**\n                 * Properties of a SetProtectedStateReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetProtectedStateReply\n                 * @property {particle.ctrl.SetProtectedStateReply.IPrepare|null} [prepare] SetProtectedStateReply prepare\n                 */\n    \n                /**\n                 * Constructs a new SetProtectedStateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetProtectedStateReply.\n                 * @implements ISetProtectedStateReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetProtectedStateReply=} [properties] Properties to set\n                 */\n                function SetProtectedStateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetProtectedStateReply prepare.\n                 * @member {particle.ctrl.SetProtectedStateReply.IPrepare|null|undefined} prepare\n                 * @memberof particle.ctrl.SetProtectedStateReply\n                 * @instance\n                 */\n                SetProtectedStateReply.prototype.prepare = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * SetProtectedStateReply _prepare.\n                 * @member {\"prepare\"|undefined} _prepare\n                 * @memberof particle.ctrl.SetProtectedStateReply\n                 * @instance\n                 */\n                Object.defineProperty(SetProtectedStateReply.prototype, \"_prepare\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"prepare\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new SetProtectedStateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetProtectedStateReply\n                 * @static\n                 * @param {particle.ctrl.ISetProtectedStateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetProtectedStateReply} SetProtectedStateReply instance\n                 */\n                SetProtectedStateReply.create = function create(properties) {\n                    return new SetProtectedStateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetProtectedStateReply message. Does not implicitly {@link particle.ctrl.SetProtectedStateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetProtectedStateReply\n                 * @static\n                 * @param {particle.ctrl.ISetProtectedStateReply} message SetProtectedStateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetProtectedStateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.prepare != null && Object.hasOwnProperty.call(message, \"prepare\"))\n                        $root.particle.ctrl.SetProtectedStateReply.Prepare.encode(message.prepare, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetProtectedStateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetProtectedStateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetProtectedStateReply} SetProtectedStateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetProtectedStateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetProtectedStateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.prepare = $root.particle.ctrl.SetProtectedStateReply.Prepare.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                SetProtectedStateReply.Prepare = (function() {\n    \n                    /**\n                     * Properties of a Prepare.\n                     * @memberof particle.ctrl.SetProtectedStateReply\n                     * @interface IPrepare\n                     * @property {Uint8Array|null} [deviceNonce] Prepare deviceNonce\n                     * @property {Uint8Array|null} [deviceSignature] Prepare deviceSignature\n                     * @property {Uint8Array|null} [devicePublicKeyFingerprint] Prepare devicePublicKeyFingerprint\n                     */\n    \n                    /**\n                     * Constructs a new Prepare.\n                     * @memberof particle.ctrl.SetProtectedStateReply\n                     * @classdesc Represents a Prepare.\n                     * @implements IPrepare\n                     * @constructor\n                     * @param {particle.ctrl.SetProtectedStateReply.IPrepare=} [properties] Properties to set\n                     */\n                    function Prepare(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Prepare deviceNonce.\n                     * @member {Uint8Array} deviceNonce\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @instance\n                     */\n                    Prepare.prototype.deviceNonce = $util.newBuffer([]);\n    \n                    /**\n                     * Prepare deviceSignature.\n                     * @member {Uint8Array} deviceSignature\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @instance\n                     */\n                    Prepare.prototype.deviceSignature = $util.newBuffer([]);\n    \n                    /**\n                     * Prepare devicePublicKeyFingerprint.\n                     * @member {Uint8Array} devicePublicKeyFingerprint\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @instance\n                     */\n                    Prepare.prototype.devicePublicKeyFingerprint = $util.newBuffer([]);\n    \n                    /**\n                     * Creates a new Prepare instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateReply.IPrepare=} [properties] Properties to set\n                     * @returns {particle.ctrl.SetProtectedStateReply.Prepare} Prepare instance\n                     */\n                    Prepare.create = function create(properties) {\n                        return new Prepare(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Prepare message. Does not implicitly {@link particle.ctrl.SetProtectedStateReply.Prepare.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @static\n                     * @param {particle.ctrl.SetProtectedStateReply.IPrepare} message Prepare message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Prepare.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.deviceNonce != null && Object.hasOwnProperty.call(message, \"deviceNonce\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.deviceNonce);\n                        if (message.deviceSignature != null && Object.hasOwnProperty.call(message, \"deviceSignature\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.deviceSignature);\n                        if (message.devicePublicKeyFingerprint != null && Object.hasOwnProperty.call(message, \"devicePublicKeyFingerprint\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.devicePublicKeyFingerprint);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Prepare message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.SetProtectedStateReply.Prepare\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.SetProtectedStateReply.Prepare} Prepare\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Prepare.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetProtectedStateReply.Prepare();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.deviceNonce = reader.bytes();\n                                break;\n                            case 2:\n                                message.deviceSignature = reader.bytes();\n                                break;\n                            case 3:\n                                message.devicePublicKeyFingerprint = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Prepare;\n                })();\n    \n                return SetProtectedStateReply;\n            })();\n    \n            ctrl.SystemResetRequest = (function() {\n    \n                /**\n                 * Properties of a SystemResetRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISystemResetRequest\n                 */\n    \n                /**\n                 * Constructs a new SystemResetRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SystemResetRequest.\n                 * @implements ISystemResetRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set\n                 */\n                function SystemResetRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SystemResetRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest instance\n                 */\n                SystemResetRequest.create = function create(properties) {\n                    return new SystemResetRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SystemResetRequest message. Does not implicitly {@link particle.ctrl.SystemResetRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {particle.ctrl.ISystemResetRequest} message SystemResetRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SystemResetRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SystemResetRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SystemResetRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SystemResetRequest;\n            })();\n    \n            ctrl.SystemResetReply = (function() {\n    \n                /**\n                 * Properties of a SystemResetReply.\n                 * @memberof particle.ctrl\n                 * @interface ISystemResetReply\n                 */\n    \n                /**\n                 * Constructs a new SystemResetReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SystemResetReply.\n                 * @implements ISystemResetReply\n                 * @constructor\n                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set\n                 */\n                function SystemResetReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SystemResetReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply instance\n                 */\n                SystemResetReply.create = function create(properties) {\n                    return new SystemResetReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SystemResetReply message. Does not implicitly {@link particle.ctrl.SystemResetReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {particle.ctrl.ISystemResetReply} message SystemResetReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SystemResetReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SystemResetReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SystemResetReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SystemResetReply;\n            })();\n    \n            ctrl.SetFeatureRequest = (function() {\n    \n                /**\n                 * Properties of a SetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetFeatureRequest\n                 * @property {particle.ctrl.Feature|null} [feature] SetFeatureRequest feature\n                 * @property {boolean|null} [enabled] SetFeatureRequest enabled\n                 */\n    \n                /**\n                 * Constructs a new SetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetFeatureRequest.\n                 * @implements ISetFeatureRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set\n                 */\n                function SetFeatureRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetFeatureRequest feature.\n                 * @member {particle.ctrl.Feature} feature\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @instance\n                 */\n                SetFeatureRequest.prototype.feature = 0;\n    \n                /**\n                 * SetFeatureRequest enabled.\n                 * @member {boolean} enabled\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @instance\n                 */\n                SetFeatureRequest.prototype.enabled = false;\n    \n                /**\n                 * Creates a new SetFeatureRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest instance\n                 */\n                SetFeatureRequest.create = function create(properties) {\n                    return new SetFeatureRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetFeatureRequest message. Does not implicitly {@link particle.ctrl.SetFeatureRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureRequest} message SetFeatureRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetFeatureRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.feature != null && Object.hasOwnProperty.call(message, \"feature\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);\n                    if (message.enabled != null && Object.hasOwnProperty.call(message, \"enabled\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetFeatureRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetFeatureRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.feature = reader.int32();\n                            break;\n                        case 2:\n                            message.enabled = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetFeatureRequest;\n            })();\n    \n            ctrl.SetFeatureReply = (function() {\n    \n                /**\n                 * Properties of a SetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetFeatureReply\n                 */\n    \n                /**\n                 * Constructs a new SetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetFeatureReply.\n                 * @implements ISetFeatureReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set\n                 */\n                function SetFeatureReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetFeatureReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply instance\n                 */\n                SetFeatureReply.create = function create(properties) {\n                    return new SetFeatureReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetFeatureReply message. Does not implicitly {@link particle.ctrl.SetFeatureReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureReply} message SetFeatureReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetFeatureReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetFeatureReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetFeatureReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetFeatureReply;\n            })();\n    \n            ctrl.GetFeatureRequest = (function() {\n    \n                /**\n                 * Properties of a GetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetFeatureRequest\n                 * @property {particle.ctrl.Feature|null} [feature] GetFeatureRequest feature\n                 */\n    \n                /**\n                 * Constructs a new GetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetFeatureRequest.\n                 * @implements IGetFeatureRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set\n                 */\n                function GetFeatureRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetFeatureRequest feature.\n                 * @member {particle.ctrl.Feature} feature\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @instance\n                 */\n                GetFeatureRequest.prototype.feature = 0;\n    \n                /**\n                 * Creates a new GetFeatureRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest instance\n                 */\n                GetFeatureRequest.create = function create(properties) {\n                    return new GetFeatureRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetFeatureRequest message. Does not implicitly {@link particle.ctrl.GetFeatureRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureRequest} message GetFeatureRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetFeatureRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.feature != null && Object.hasOwnProperty.call(message, \"feature\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetFeatureRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetFeatureRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.feature = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetFeatureRequest;\n            })();\n    \n            ctrl.GetFeatureReply = (function() {\n    \n                /**\n                 * Properties of a GetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetFeatureReply\n                 * @property {boolean|null} [enabled] GetFeatureReply enabled\n                 */\n    \n                /**\n                 * Constructs a new GetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetFeatureReply.\n                 * @implements IGetFeatureReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set\n                 */\n                function GetFeatureReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetFeatureReply enabled.\n                 * @member {boolean} enabled\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @instance\n                 */\n                GetFeatureReply.prototype.enabled = false;\n    \n                /**\n                 * Creates a new GetFeatureReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply instance\n                 */\n                GetFeatureReply.create = function create(properties) {\n                    return new GetFeatureReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetFeatureReply message. Does not implicitly {@link particle.ctrl.GetFeatureReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureReply} message GetFeatureReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetFeatureReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.enabled != null && Object.hasOwnProperty.call(message, \"enabled\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetFeatureReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetFeatureReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.enabled = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetFeatureReply;\n            })();\n    \n            ctrl.StartNyanSignalRequest = (function() {\n    \n                /**\n                 * Properties of a StartNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartNyanSignalRequest\n                 */\n    \n                /**\n                 * Constructs a new StartNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartNyanSignalRequest.\n                 * @implements IStartNyanSignalRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set\n                 */\n                function StartNyanSignalRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartNyanSignalRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest instance\n                 */\n                StartNyanSignalRequest.create = function create(properties) {\n                    return new StartNyanSignalRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StartNyanSignalRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalRequest} message StartNyanSignalRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartNyanSignalRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartNyanSignalRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartNyanSignalRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartNyanSignalRequest;\n            })();\n    \n            ctrl.StartNyanSignalReply = (function() {\n    \n                /**\n                 * Properties of a StartNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartNyanSignalReply\n                 */\n    \n                /**\n                 * Constructs a new StartNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartNyanSignalReply.\n                 * @implements IStartNyanSignalReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set\n                 */\n                function StartNyanSignalReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartNyanSignalReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply instance\n                 */\n                StartNyanSignalReply.create = function create(properties) {\n                    return new StartNyanSignalReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartNyanSignalReply message. Does not implicitly {@link particle.ctrl.StartNyanSignalReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalReply} message StartNyanSignalReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartNyanSignalReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartNyanSignalReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartNyanSignalReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartNyanSignalReply;\n            })();\n    \n            ctrl.StopNyanSignalRequest = (function() {\n    \n                /**\n                 * Properties of a StopNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStopNyanSignalRequest\n                 */\n    \n                /**\n                 * Constructs a new StopNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopNyanSignalRequest.\n                 * @implements IStopNyanSignalRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set\n                 */\n                function StopNyanSignalRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopNyanSignalRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest instance\n                 */\n                StopNyanSignalRequest.create = function create(properties) {\n                    return new StopNyanSignalRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StopNyanSignalRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalRequest} message StopNyanSignalRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopNyanSignalRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopNyanSignalRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopNyanSignalRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopNyanSignalRequest;\n            })();\n    \n            ctrl.StopNyanSignalReply = (function() {\n    \n                /**\n                 * Properties of a StopNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @interface IStopNyanSignalReply\n                 */\n    \n                /**\n                 * Constructs a new StopNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopNyanSignalReply.\n                 * @implements IStopNyanSignalReply\n                 * @constructor\n                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set\n                 */\n                function StopNyanSignalReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopNyanSignalReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply instance\n                 */\n                StopNyanSignalReply.create = function create(properties) {\n                    return new StopNyanSignalReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopNyanSignalReply message. Does not implicitly {@link particle.ctrl.StopNyanSignalReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalReply} message StopNyanSignalReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopNyanSignalReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopNyanSignalReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopNyanSignalReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopNyanSignalReply;\n            })();\n    \n            ctrl.logging = (function() {\n    \n                /**\n                 * Namespace logging.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var logging = {};\n    \n                /**\n                 * Logging levels.\n                 * @name particle.ctrl.logging.LogLevel\n                 * @enum {number}\n                 * @property {number} INVALID_LOG_LEVEL=0 INVALID_LOG_LEVEL value\n                 * @property {number} ALL=1 ALL value\n                 * @property {number} TRACE=1 TRACE value\n                 * @property {number} INFO=30 INFO value\n                 * @property {number} WARN=40 WARN value\n                 * @property {number} ERROR=50 ERROR value\n                 * @property {number} NONE=70 NONE value\n                 */\n                logging.LogLevel = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_LEVEL\"] = 0;\n                    values[valuesById[1] = \"ALL\"] = 1;\n                    values[\"TRACE\"] = 1;\n                    values[valuesById[30] = \"INFO\"] = 30;\n                    values[valuesById[40] = \"WARN\"] = 40;\n                    values[valuesById[50] = \"ERROR\"] = 50;\n                    values[valuesById[70] = \"NONE\"] = 70;\n                    return values;\n                })();\n    \n                /**\n                 * Log handler types.\n                 * @name particle.ctrl.logging.LogHandlerType\n                 * @enum {number}\n                 * @property {number} INVALID_LOG_HANDLER_TYPE=0 INVALID_LOG_HANDLER_TYPE value\n                 * @property {number} DEFAULT_STREAM_HANDLER=1 DEFAULT_STREAM_HANDLER value\n                 * @property {number} JSON_STREAM_HANDLER=2 JSON_STREAM_HANDLER value\n                 */\n                logging.LogHandlerType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_HANDLER_TYPE\"] = 0;\n                    values[valuesById[1] = \"DEFAULT_STREAM_HANDLER\"] = 1;\n                    values[valuesById[2] = \"JSON_STREAM_HANDLER\"] = 2;\n                    return values;\n                })();\n    \n                /**\n                 * Stream types.\n                 * @name particle.ctrl.logging.StreamType\n                 * @enum {number}\n                 * @property {number} INVALID_STREAM_TYPE=0 INVALID_STREAM_TYPE value\n                 * @property {number} USB_SERIAL_STREAM=1 USB_SERIAL_STREAM value\n                 * @property {number} HW_SERIAL_STREAM=2 HW_SERIAL_STREAM value\n                 */\n                logging.StreamType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_STREAM_TYPE\"] = 0;\n                    values[valuesById[1] = \"USB_SERIAL_STREAM\"] = 1;\n                    values[valuesById[2] = \"HW_SERIAL_STREAM\"] = 2;\n                    return values;\n                })();\n    \n                logging.LogFilter = (function() {\n    \n                    /**\n                     * Properties of a LogFilter.\n                     * @memberof particle.ctrl.logging\n                     * @interface ILogFilter\n                     * @property {string|null} [category] LogFilter category\n                     * @property {particle.ctrl.logging.LogLevel|null} [level] LogFilter level\n                     */\n    \n                    /**\n                     * Constructs a new LogFilter.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Category filter.\n                     * @implements ILogFilter\n                     * @constructor\n                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set\n                     */\n                    function LogFilter(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * LogFilter category.\n                     * @member {string} category\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @instance\n                     */\n                    LogFilter.prototype.category = \"\";\n    \n                    /**\n                     * LogFilter level.\n                     * @member {particle.ctrl.logging.LogLevel} level\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @instance\n                     */\n                    LogFilter.prototype.level = 0;\n    \n                    /**\n                     * Creates a new LogFilter instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.LogFilter} LogFilter instance\n                     */\n                    LogFilter.create = function create(properties) {\n                        return new LogFilter(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LogFilter message. Does not implicitly {@link particle.ctrl.logging.LogFilter.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {particle.ctrl.logging.ILogFilter} message LogFilter message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogFilter.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);\n                        if (message.level != null && Object.hasOwnProperty.call(message, \"level\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LogFilter message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.LogFilter} LogFilter\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogFilter.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.LogFilter();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.category = reader.string();\n                                break;\n                            case 2:\n                                message.level = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LogFilter;\n                })();\n    \n                logging.SerialStreamParams = (function() {\n    \n                    /**\n                     * Properties of a SerialStreamParams.\n                     * @memberof particle.ctrl.logging\n                     * @interface ISerialStreamParams\n                     * @property {number|null} [index] SerialStreamParams index\n                     * @property {number|null} [baudRate] SerialStreamParams baudRate\n                     */\n    \n                    /**\n                     * Constructs a new SerialStreamParams.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Serial stream parameters.\n                     * @implements ISerialStreamParams\n                     * @constructor\n                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set\n                     */\n                    function SerialStreamParams(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SerialStreamParams index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @instance\n                     */\n                    SerialStreamParams.prototype.index = 0;\n    \n                    /**\n                     * SerialStreamParams baudRate.\n                     * @member {number} baudRate\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @instance\n                     */\n                    SerialStreamParams.prototype.baudRate = 0;\n    \n                    /**\n                     * Creates a new SerialStreamParams instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams instance\n                     */\n                    SerialStreamParams.create = function create(properties) {\n                        return new SerialStreamParams(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SerialStreamParams message. Does not implicitly {@link particle.ctrl.logging.SerialStreamParams.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {particle.ctrl.logging.ISerialStreamParams} message SerialStreamParams message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SerialStreamParams.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                        if (message.baudRate != null && Object.hasOwnProperty.call(message, \"baudRate\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.baudRate);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SerialStreamParams message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SerialStreamParams.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.SerialStreamParams();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.index = reader.uint32();\n                                break;\n                            case 2:\n                                message.baudRate = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SerialStreamParams;\n                })();\n    \n                logging.AddLogHandlerRequest = (function() {\n    \n                    /**\n                     * Properties of an AddLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IAddLogHandlerRequest\n                     * @property {string|null} [id] AddLogHandlerRequest id\n                     * @property {particle.ctrl.logging.LogHandlerType|null} [handlerType] AddLogHandlerRequest handlerType\n                     * @property {particle.ctrl.logging.LogLevel|null} [level] AddLogHandlerRequest level\n                     * @property {Array.<particle.ctrl.logging.ILogFilter>|null} [filters] AddLogHandlerRequest filters\n                     * @property {particle.ctrl.logging.StreamType|null} [streamType] AddLogHandlerRequest streamType\n                     * @property {particle.ctrl.logging.ISerialStreamParams|null} [serial] AddLogHandlerRequest serial\n                     */\n    \n                    /**\n                     * Constructs a new AddLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Add a log handler.\n                     * @implements IAddLogHandlerRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set\n                     */\n                    function AddLogHandlerRequest(properties) {\n                        this.filters = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AddLogHandlerRequest id.\n                     * @member {string} id\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.id = \"\";\n    \n                    /**\n                     * AddLogHandlerRequest handlerType.\n                     * @member {particle.ctrl.logging.LogHandlerType} handlerType\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.handlerType = 0;\n    \n                    /**\n                     * AddLogHandlerRequest level.\n                     * @member {particle.ctrl.logging.LogLevel} level\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.level = 0;\n    \n                    /**\n                     * AddLogHandlerRequest filters.\n                     * @member {Array.<particle.ctrl.logging.ILogFilter>} filters\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.filters = $util.emptyArray;\n    \n                    /**\n                     * AddLogHandlerRequest streamType.\n                     * @member {particle.ctrl.logging.StreamType} streamType\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.streamType = 0;\n    \n                    /**\n                     * AddLogHandlerRequest serial.\n                     * @member {particle.ctrl.logging.ISerialStreamParams|null|undefined} serial\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.serial = null;\n    \n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n    \n                    /**\n                     * AddLogHandlerRequest streamParams.\n                     * @member {\"serial\"|undefined} streamParams\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    Object.defineProperty(AddLogHandlerRequest.prototype, \"streamParams\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"serial\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * Creates a new AddLogHandlerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest instance\n                     */\n                    AddLogHandlerRequest.create = function create(properties) {\n                        return new AddLogHandlerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest} message AddLogHandlerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddLogHandlerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                        if (message.handlerType != null && Object.hasOwnProperty.call(message, \"handlerType\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.handlerType);\n                        if (message.level != null && Object.hasOwnProperty.call(message, \"level\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);\n                        if (message.filters != null && message.filters.length)\n                            for (var i = 0; i < message.filters.length; ++i)\n                                $root.particle.ctrl.logging.LogFilter.encode(message.filters[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        if (message.streamType != null && Object.hasOwnProperty.call(message, \"streamType\"))\n                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.streamType);\n                        if (message.serial != null && Object.hasOwnProperty.call(message, \"serial\"))\n                            $root.particle.ctrl.logging.SerialStreamParams.encode(message.serial, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddLogHandlerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddLogHandlerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            case 2:\n                                message.handlerType = reader.int32();\n                                break;\n                            case 3:\n                                message.level = reader.int32();\n                                break;\n                            case 4:\n                                if (!(message.filters && message.filters.length))\n                                    message.filters = [];\n                                message.filters.push($root.particle.ctrl.logging.LogFilter.decode(reader, reader.uint32()));\n                                break;\n                            case 5:\n                                message.streamType = reader.int32();\n                                break;\n                            case 6:\n                                message.serial = $root.particle.ctrl.logging.SerialStreamParams.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddLogHandlerRequest;\n                })();\n    \n                logging.AddLogHandlerReply = (function() {\n    \n                    /**\n                     * Properties of an AddLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IAddLogHandlerReply\n                     */\n    \n                    /**\n                     * Constructs a new AddLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents an AddLogHandlerReply.\n                     * @implements IAddLogHandlerReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set\n                     */\n                    function AddLogHandlerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AddLogHandlerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply instance\n                     */\n                    AddLogHandlerReply.create = function create(properties) {\n                        return new AddLogHandlerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply} message AddLogHandlerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddLogHandlerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddLogHandlerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddLogHandlerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddLogHandlerReply;\n                })();\n    \n                logging.RemoveLogHandlerRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IRemoveLogHandlerRequest\n                     * @property {string|null} [id] RemoveLogHandlerRequest id\n                     */\n    \n                    /**\n                     * Constructs a new RemoveLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Remove a log handler.\n                     * @implements IRemoveLogHandlerRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set\n                     */\n                    function RemoveLogHandlerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveLogHandlerRequest id.\n                     * @member {string} id\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @instance\n                     */\n                    RemoveLogHandlerRequest.prototype.id = \"\";\n    \n                    /**\n                     * Creates a new RemoveLogHandlerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest instance\n                     */\n                    RemoveLogHandlerRequest.create = function create(properties) {\n                        return new RemoveLogHandlerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest} message RemoveLogHandlerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveLogHandlerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveLogHandlerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveLogHandlerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveLogHandlerRequest;\n                })();\n    \n                logging.RemoveLogHandlerReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IRemoveLogHandlerReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents a RemoveLogHandlerReply.\n                     * @implements IRemoveLogHandlerReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set\n                     */\n                    function RemoveLogHandlerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveLogHandlerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply instance\n                     */\n                    RemoveLogHandlerReply.create = function create(properties) {\n                        return new RemoveLogHandlerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply} message RemoveLogHandlerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveLogHandlerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveLogHandlerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveLogHandlerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveLogHandlerReply;\n                })();\n    \n                logging.GetLogHandlersRequest = (function() {\n    \n                    /**\n                     * Properties of a GetLogHandlersRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IGetLogHandlersRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetLogHandlersRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Get the list of active log handlers.\n                     * @implements IGetLogHandlersRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set\n                     */\n                    function GetLogHandlersRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetLogHandlersRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest instance\n                     */\n                    GetLogHandlersRequest.create = function create(properties) {\n                        return new GetLogHandlersRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetLogHandlersRequest message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest} message GetLogHandlersRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetLogHandlersRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetLogHandlersRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetLogHandlersRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetLogHandlersRequest;\n                })();\n    \n                logging.GetLogHandlersReply = (function() {\n    \n                    /**\n                     * Properties of a GetLogHandlersReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IGetLogHandlersReply\n                     * @property {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>|null} [handlers] GetLogHandlersReply handlers\n                     */\n    \n                    /**\n                     * Constructs a new GetLogHandlersReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents a GetLogHandlersReply.\n                     * @implements IGetLogHandlersReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set\n                     */\n                    function GetLogHandlersReply(properties) {\n                        this.handlers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetLogHandlersReply handlers.\n                     * @member {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>} handlers\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @instance\n                     */\n                    GetLogHandlersReply.prototype.handlers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetLogHandlersReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply instance\n                     */\n                    GetLogHandlersReply.create = function create(properties) {\n                        return new GetLogHandlersReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetLogHandlersReply message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply} message GetLogHandlersReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetLogHandlersReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.handlers != null && message.handlers.length)\n                            for (var i = 0; i < message.handlers.length; ++i)\n                                $root.particle.ctrl.logging.GetLogHandlersReply.Handler.encode(message.handlers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetLogHandlersReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetLogHandlersReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.handlers && message.handlers.length))\n                                    message.handlers = [];\n                                message.handlers.push($root.particle.ctrl.logging.GetLogHandlersReply.Handler.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    GetLogHandlersReply.Handler = (function() {\n    \n                        /**\n                         * Properties of a Handler.\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply\n                         * @interface IHandler\n                         * @property {string|null} [id] Handler id\n                         */\n    \n                        /**\n                         * Constructs a new Handler.\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply\n                         * @classdesc Represents a Handler.\n                         * @implements IHandler\n                         * @constructor\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set\n                         */\n                        function Handler(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Handler id.\n                         * @member {string} id\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @instance\n                         */\n                        Handler.prototype.id = \"\";\n    \n                        /**\n                         * Creates a new Handler instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set\n                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler instance\n                         */\n                        Handler.create = function create(properties) {\n                            return new Handler(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Handler message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.Handler.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler} message Handler message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Handler.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Handler message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Handler.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply.Handler();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.id = reader.string();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Handler;\n                    })();\n    \n                    return GetLogHandlersReply;\n                })();\n    \n                return logging;\n            })();\n    \n            ctrl.mesh = (function() {\n    \n                /**\n                 * Namespace mesh.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var mesh = {};\n    \n                mesh.NetworkInfo = (function() {\n    \n                    /**\n                     * Properties of a NetworkInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @interface INetworkInfo\n                     * @property {string|null} [name] NetworkInfo name\n                     * @property {string|null} [extPanId] NetworkInfo extPanId\n                     * @property {number|null} [panId] NetworkInfo panId\n                     * @property {number|null} [channel] NetworkInfo channel\n                     * @property {string|null} [networkId] NetworkInfo networkId\n                     */\n    \n                    /**\n                     * Constructs a new NetworkInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a NetworkInfo.\n                     * @implements INetworkInfo\n                     * @constructor\n                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set\n                     */\n                    function NetworkInfo(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * NetworkInfo name.\n                     * @member {string} name\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.name = \"\";\n    \n                    /**\n                     * NetworkInfo extPanId.\n                     * @member {string} extPanId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.extPanId = \"\";\n    \n                    /**\n                     * NetworkInfo panId.\n                     * @member {number} panId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.panId = 0;\n    \n                    /**\n                     * NetworkInfo channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.channel = 0;\n    \n                    /**\n                     * NetworkInfo networkId.\n                     * @member {string} networkId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.networkId = \"\";\n    \n                    /**\n                     * Creates a new NetworkInfo instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo instance\n                     */\n                    NetworkInfo.create = function create(properties) {\n                        return new NetworkInfo(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NetworkInfo message. Does not implicitly {@link particle.ctrl.mesh.NetworkInfo.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.INetworkInfo} message NetworkInfo message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NetworkInfo.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.extPanId != null && Object.hasOwnProperty.call(message, \"extPanId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.extPanId);\n                        if (message.panId != null && Object.hasOwnProperty.call(message, \"panId\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.panId);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.channel);\n                        if (message.networkId != null && Object.hasOwnProperty.call(message, \"networkId\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.networkId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NetworkInfo message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NetworkInfo.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.NetworkInfo();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.extPanId = reader.string();\n                                break;\n                            case 3:\n                                message.panId = reader.uint32();\n                                break;\n                            case 4:\n                                message.channel = reader.uint32();\n                                break;\n                            case 5:\n                                message.networkId = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return NetworkInfo;\n                })();\n    \n                mesh.AuthRequest = (function() {\n    \n                    /**\n                     * Properties of an AuthRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAuthRequest\n                     * @property {string|null} [password] AuthRequest password\n                     */\n    \n                    /**\n                     * Constructs a new AuthRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AuthRequest.\n                     * @implements IAuthRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set\n                     */\n                    function AuthRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AuthRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @instance\n                     */\n                    AuthRequest.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new AuthRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest instance\n                     */\n                    AuthRequest.create = function create(properties) {\n                        return new AuthRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AuthRequest message. Does not implicitly {@link particle.ctrl.mesh.AuthRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthRequest} message AuthRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AuthRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AuthRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AuthRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AuthRequest;\n                })();\n    \n                mesh.AuthReply = (function() {\n    \n                    /**\n                     * Properties of an AuthReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAuthReply\n                     */\n    \n                    /**\n                     * Constructs a new AuthReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AuthReply.\n                     * @implements IAuthReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set\n                     */\n                    function AuthReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AuthReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply instance\n                     */\n                    AuthReply.create = function create(properties) {\n                        return new AuthReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AuthReply message. Does not implicitly {@link particle.ctrl.mesh.AuthReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthReply} message AuthReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AuthReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AuthReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AuthReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AuthReply;\n                })();\n    \n                mesh.CreateNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a CreateNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ICreateNetworkRequest\n                     * @property {string|null} [name] CreateNetworkRequest name\n                     * @property {string|null} [password] CreateNetworkRequest password\n                     * @property {number|null} [channel] CreateNetworkRequest channel\n                     * @property {string|null} [networkId] CreateNetworkRequest networkId\n                     */\n    \n                    /**\n                     * Constructs a new CreateNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a CreateNetworkRequest.\n                     * @implements ICreateNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set\n                     */\n                    function CreateNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * CreateNetworkRequest name.\n                     * @member {string} name\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.name = \"\";\n    \n                    /**\n                     * CreateNetworkRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.password = \"\";\n    \n                    /**\n                     * CreateNetworkRequest channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.channel = 0;\n    \n                    /**\n                     * CreateNetworkRequest networkId.\n                     * @member {string} networkId\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.networkId = \"\";\n    \n                    /**\n                     * Creates a new CreateNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest instance\n                     */\n                    CreateNetworkRequest.create = function create(properties) {\n                        return new CreateNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified CreateNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    CreateNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.channel);\n                        if (message.networkId != null && Object.hasOwnProperty.call(message, \"networkId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a CreateNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    CreateNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            case 3:\n                                message.channel = reader.uint32();\n                                break;\n                            case 4:\n                                message.networkId = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return CreateNetworkRequest;\n                })();\n    \n                mesh.CreateNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a CreateNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ICreateNetworkReply\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] CreateNetworkReply network\n                     */\n    \n                    /**\n                     * Constructs a new CreateNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a CreateNetworkReply.\n                     * @implements ICreateNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set\n                     */\n                    function CreateNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * CreateNetworkReply network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @instance\n                     */\n                    CreateNetworkReply.prototype.network = null;\n    \n                    /**\n                     * Creates a new CreateNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply instance\n                     */\n                    CreateNetworkReply.create = function create(properties) {\n                        return new CreateNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified CreateNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply} message CreateNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    CreateNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a CreateNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    CreateNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return CreateNetworkReply;\n                })();\n    \n                mesh.StartCommissionerRequest = (function() {\n    \n                    /**\n                     * Properties of a StartCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStartCommissionerRequest\n                     * @property {number|null} [timeout] StartCommissionerRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new StartCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StartCommissionerRequest.\n                     * @implements IStartCommissionerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set\n                     */\n                    function StartCommissionerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * StartCommissionerRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @instance\n                     */\n                    StartCommissionerRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new StartCommissionerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest instance\n                     */\n                    StartCommissionerRequest.create = function create(properties) {\n                        return new StartCommissionerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StartCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest} message StartCommissionerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StartCommissionerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StartCommissionerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StartCommissionerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StartCommissionerRequest;\n                })();\n    \n                mesh.StartCommissionerReply = (function() {\n    \n                    /**\n                     * Properties of a StartCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStartCommissionerReply\n                     */\n    \n                    /**\n                     * Constructs a new StartCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StartCommissionerReply.\n                     * @implements IStartCommissionerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set\n                     */\n                    function StartCommissionerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StartCommissionerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply instance\n                     */\n                    StartCommissionerReply.create = function create(properties) {\n                        return new StartCommissionerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StartCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply} message StartCommissionerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StartCommissionerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StartCommissionerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StartCommissionerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StartCommissionerReply;\n                })();\n    \n                mesh.StopCommissionerRequest = (function() {\n    \n                    /**\n                     * Properties of a StopCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStopCommissionerRequest\n                     */\n    \n                    /**\n                     * Constructs a new StopCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StopCommissionerRequest.\n                     * @implements IStopCommissionerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set\n                     */\n                    function StopCommissionerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StopCommissionerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest instance\n                     */\n                    StopCommissionerRequest.create = function create(properties) {\n                        return new StopCommissionerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StopCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest} message StopCommissionerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StopCommissionerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StopCommissionerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StopCommissionerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StopCommissionerRequest;\n                })();\n    \n                mesh.StopCommissionerReply = (function() {\n    \n                    /**\n                     * Properties of a StopCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStopCommissionerReply\n                     */\n    \n                    /**\n                     * Constructs a new StopCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StopCommissionerReply.\n                     * @implements IStopCommissionerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set\n                     */\n                    function StopCommissionerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StopCommissionerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply instance\n                     */\n                    StopCommissionerReply.create = function create(properties) {\n                        return new StopCommissionerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StopCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply} message StopCommissionerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StopCommissionerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StopCommissionerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StopCommissionerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StopCommissionerReply;\n                })();\n    \n                mesh.PrepareJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of a PrepareJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IPrepareJoinerRequest\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] PrepareJoinerRequest network\n                     */\n    \n                    /**\n                     * Constructs a new PrepareJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a PrepareJoinerRequest.\n                     * @implements IPrepareJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set\n                     */\n                    function PrepareJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * PrepareJoinerRequest network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @instance\n                     */\n                    PrepareJoinerRequest.prototype.network = null;\n    \n                    /**\n                     * Creates a new PrepareJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest instance\n                     */\n                    PrepareJoinerRequest.create = function create(properties) {\n                        return new PrepareJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified PrepareJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest} message PrepareJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    PrepareJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a PrepareJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    PrepareJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return PrepareJoinerRequest;\n                })();\n    \n                mesh.PrepareJoinerReply = (function() {\n    \n                    /**\n                     * Properties of a PrepareJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IPrepareJoinerReply\n                     * @property {string|null} [eui64] PrepareJoinerReply eui64\n                     * @property {string|null} [password] PrepareJoinerReply password\n                     */\n    \n                    /**\n                     * Constructs a new PrepareJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a PrepareJoinerReply.\n                     * @implements IPrepareJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set\n                     */\n                    function PrepareJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * PrepareJoinerReply eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @instance\n                     */\n                    PrepareJoinerReply.prototype.eui64 = \"\";\n    \n                    /**\n                     * PrepareJoinerReply password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @instance\n                     */\n                    PrepareJoinerReply.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new PrepareJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply instance\n                     */\n                    PrepareJoinerReply.create = function create(properties) {\n                        return new PrepareJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified PrepareJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply} message PrepareJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    PrepareJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a PrepareJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    PrepareJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return PrepareJoinerReply;\n                })();\n    \n                mesh.AddJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of an AddJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAddJoinerRequest\n                     * @property {string|null} [eui64] AddJoinerRequest eui64\n                     * @property {string|null} [password] AddJoinerRequest password\n                     * @property {number|null} [timeout] AddJoinerRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new AddJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AddJoinerRequest.\n                     * @implements IAddJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set\n                     */\n                    function AddJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AddJoinerRequest eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.eui64 = \"\";\n    \n                    /**\n                     * AddJoinerRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.password = \"\";\n    \n                    /**\n                     * AddJoinerRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new AddJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest instance\n                     */\n                    AddJoinerRequest.create = function create(properties) {\n                        return new AddJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest} message AddJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            case 3:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddJoinerRequest;\n                })();\n    \n                mesh.AddJoinerReply = (function() {\n    \n                    /**\n                     * Properties of an AddJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAddJoinerReply\n                     */\n    \n                    /**\n                     * Constructs a new AddJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AddJoinerReply.\n                     * @implements IAddJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set\n                     */\n                    function AddJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AddJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply instance\n                     */\n                    AddJoinerReply.create = function create(properties) {\n                        return new AddJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerReply} message AddJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddJoinerReply;\n                })();\n    \n                mesh.RemoveJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IRemoveJoinerRequest\n                     * @property {string|null} [eui64] RemoveJoinerRequest eui64\n                     */\n    \n                    /**\n                     * Constructs a new RemoveJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a RemoveJoinerRequest.\n                     * @implements IRemoveJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set\n                     */\n                    function RemoveJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveJoinerRequest eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @instance\n                     */\n                    RemoveJoinerRequest.prototype.eui64 = \"\";\n    \n                    /**\n                     * Creates a new RemoveJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest instance\n                     */\n                    RemoveJoinerRequest.create = function create(properties) {\n                        return new RemoveJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest} message RemoveJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveJoinerRequest;\n                })();\n    \n                mesh.RemoveJoinerReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IRemoveJoinerReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a RemoveJoinerReply.\n                     * @implements IRemoveJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set\n                     */\n                    function RemoveJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply instance\n                     */\n                    RemoveJoinerReply.create = function create(properties) {\n                        return new RemoveJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply} message RemoveJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveJoinerReply;\n                })();\n    \n                mesh.JoinNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IJoinNetworkRequest\n                     * @property {number|null} [timeout] JoinNetworkRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new JoinNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a JoinNetworkRequest.\n                     * @implements IJoinNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinNetworkRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @instance\n                     */\n                    JoinNetworkRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new JoinNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest instance\n                     */\n                    JoinNetworkRequest.create = function create(properties) {\n                        return new JoinNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest} message JoinNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNetworkRequest;\n                })();\n    \n                mesh.JoinNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IJoinNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a JoinNetworkReply.\n                     * @implements IJoinNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply instance\n                     */\n                    JoinNetworkReply.create = function create(properties) {\n                        return new JoinNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply} message JoinNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNetworkReply;\n                })();\n    \n                mesh.LeaveNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a LeaveNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ILeaveNetworkRequest\n                     */\n    \n                    /**\n                     * Constructs a new LeaveNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a LeaveNetworkRequest.\n                     * @implements ILeaveNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set\n                     */\n                    function LeaveNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new LeaveNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest instance\n                     */\n                    LeaveNetworkRequest.create = function create(properties) {\n                        return new LeaveNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LeaveNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest} message LeaveNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LeaveNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LeaveNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LeaveNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LeaveNetworkRequest;\n                })();\n    \n                mesh.LeaveNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a LeaveNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ILeaveNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new LeaveNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a LeaveNetworkReply.\n                     * @implements ILeaveNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set\n                     */\n                    function LeaveNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new LeaveNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply instance\n                     */\n                    LeaveNetworkReply.create = function create(properties) {\n                        return new LeaveNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LeaveNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply} message LeaveNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LeaveNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LeaveNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LeaveNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LeaveNetworkReply;\n                })();\n    \n                mesh.GetNetworkInfoRequest = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkInfoRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkInfoRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkInfoRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkInfoRequest.\n                     * @implements IGetNetworkInfoRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set\n                     */\n                    function GetNetworkInfoRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetNetworkInfoRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest instance\n                     */\n                    GetNetworkInfoRequest.create = function create(properties) {\n                        return new GetNetworkInfoRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkInfoRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest} message GetNetworkInfoRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkInfoRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkInfoRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkInfoRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkInfoRequest;\n                })();\n    \n                mesh.GetNetworkInfoReply = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkInfoReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkInfoReply\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] GetNetworkInfoReply network\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkInfoReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkInfoReply.\n                     * @implements IGetNetworkInfoReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set\n                     */\n                    function GetNetworkInfoReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkInfoReply network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @instance\n                     */\n                    GetNetworkInfoReply.prototype.network = null;\n    \n                    /**\n                     * Creates a new GetNetworkInfoReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply instance\n                     */\n                    GetNetworkInfoReply.create = function create(properties) {\n                        return new GetNetworkInfoReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkInfoReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply} message GetNetworkInfoReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkInfoReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkInfoReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkInfoReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkInfoReply;\n                })();\n    \n                mesh.ScanNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IScanNetworksRequest\n                     * @property {number|null} [duration] ScanNetworksRequest duration\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a ScanNetworksRequest.\n                     * @implements IScanNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set\n                     */\n                    function ScanNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksRequest duration.\n                     * @member {number} duration\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @instance\n                     */\n                    ScanNetworksRequest.prototype.duration = 0;\n    \n                    /**\n                     * Creates a new ScanNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest instance\n                     */\n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.duration != null && Object.hasOwnProperty.call(message, \"duration\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.duration = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                mesh.ScanNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IScanNetworksReply\n                     * @property {Array.<particle.ctrl.mesh.INetworkInfo>|null} [networks] ScanNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a ScanNetworksReply.\n                     * @implements IScanNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set\n                     */\n                    function ScanNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksReply networks.\n                     * @member {Array.<particle.ctrl.mesh.INetworkInfo>} networks\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @instance\n                     */\n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new ScanNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply instance\n                     */\n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksReply} message ScanNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.mesh.NetworkInfo.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksReply;\n                })();\n    \n                /**\n                 * DiagnosticType enum.\n                 * @name particle.ctrl.mesh.DiagnosticType\n                 * @enum {number}\n                 * @property {number} MAC_EXTENDED_ADDRESS=0 MAC_EXTENDED_ADDRESS value\n                 * @property {number} RLOC=1 RLOC value\n                 * @property {number} MAC_ADDRESS=1 MAC_ADDRESS value\n                 * @property {number} MODE=2 MODE value\n                 * @property {number} TIMEOUT=3 TIMEOUT value\n                 * @property {number} CONNECTIVITY=4 CONNECTIVITY value\n                 * @property {number} ROUTE64=5 ROUTE64 value\n                 * @property {number} LEADER_DATA=6 LEADER_DATA value\n                 * @property {number} NETWORK_DATA=7 NETWORK_DATA value\n                 * @property {number} IPV6_ADDRESS_LIST=8 IPV6_ADDRESS_LIST value\n                 * @property {number} MAC_COUNTERS=9 MAC_COUNTERS value\n                 * @property {number} BATTERY_LEVEL=14 BATTERY_LEVEL value\n                 * @property {number} SUPPLY_VOLTAGE=15 SUPPLY_VOLTAGE value\n                 * @property {number} CHILD_TABLE=16 CHILD_TABLE value\n                 * @property {number} CHANNEL_PAGES=17 CHANNEL_PAGES value\n                 * @property {number} TYPE_LIST=18 TYPE_LIST value\n                 * @property {number} MAX_CHILD_TIMEOUT=19 MAX_CHILD_TIMEOUT value\n                 */\n                mesh.DiagnosticType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"MAC_EXTENDED_ADDRESS\"] = 0;\n                    values[valuesById[1] = \"RLOC\"] = 1;\n                    values[\"MAC_ADDRESS\"] = 1;\n                    values[valuesById[2] = \"MODE\"] = 2;\n                    values[valuesById[3] = \"TIMEOUT\"] = 3;\n                    values[valuesById[4] = \"CONNECTIVITY\"] = 4;\n                    values[valuesById[5] = \"ROUTE64\"] = 5;\n                    values[valuesById[6] = \"LEADER_DATA\"] = 6;\n                    values[valuesById[7] = \"NETWORK_DATA\"] = 7;\n                    values[valuesById[8] = \"IPV6_ADDRESS_LIST\"] = 8;\n                    values[valuesById[9] = \"MAC_COUNTERS\"] = 9;\n                    values[valuesById[14] = \"BATTERY_LEVEL\"] = 14;\n                    values[valuesById[15] = \"SUPPLY_VOLTAGE\"] = 15;\n                    values[valuesById[16] = \"CHILD_TABLE\"] = 16;\n                    values[valuesById[17] = \"CHANNEL_PAGES\"] = 17;\n                    values[valuesById[18] = \"TYPE_LIST\"] = 18;\n                    values[valuesById[19] = \"MAX_CHILD_TIMEOUT\"] = 19;\n                    return values;\n                })();\n    \n                mesh.DiagnosticInfo = (function() {\n    \n                    /**\n                     * Properties of a DiagnosticInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IDiagnosticInfo\n                     * @property {Uint8Array|null} [extMacAddress] DiagnosticInfo extMacAddress\n                     * @property {number|null} [rloc] DiagnosticInfo rloc\n                     * @property {number|null} [mode] DiagnosticInfo mode\n                     * @property {number|null} [timeout] DiagnosticInfo timeout\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null} [connectivity] DiagnosticInfo connectivity\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null} [route64] DiagnosticInfo route64\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null} [leaderData] DiagnosticInfo leaderData\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null} [networkData] DiagnosticInfo networkData\n                     * @property {Array.<particle.ctrl.IIpv6Address>|null} [ipv6AddressList] DiagnosticInfo ipv6AddressList\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null} [macCounters] DiagnosticInfo macCounters\n                     * @property {number|null} [batteryLevel] DiagnosticInfo batteryLevel\n                     * @property {number|null} [supplyVoltage] DiagnosticInfo supplyVoltage\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null} [childTable] DiagnosticInfo childTable\n                     * @property {Uint8Array|null} [channelPages] DiagnosticInfo channelPages\n                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [typeList] DiagnosticInfo typeList\n                     * @property {number|null} [maxChildTimeout] DiagnosticInfo maxChildTimeout\n                     * @property {Uint8Array|null} [deviceId] DiagnosticInfo deviceId\n                     */\n    \n                    /**\n                     * Constructs a new DiagnosticInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a DiagnosticInfo.\n                     * @implements IDiagnosticInfo\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set\n                     */\n                    function DiagnosticInfo(properties) {\n                        this.ipv6AddressList = [];\n                        this.typeList = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * DiagnosticInfo extMacAddress.\n                     * @member {Uint8Array} extMacAddress\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.extMacAddress = $util.newBuffer([]);\n    \n                    /**\n                     * DiagnosticInfo rloc.\n                     * @member {number} rloc\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.rloc = 0;\n    \n                    /**\n                     * DiagnosticInfo mode.\n                     * @member {number} mode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.mode = 0;\n    \n                    /**\n                     * DiagnosticInfo timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.timeout = 0;\n    \n                    /**\n                     * DiagnosticInfo connectivity.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null|undefined} connectivity\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.connectivity = null;\n    \n                    /**\n                     * DiagnosticInfo route64.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null|undefined} route64\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.route64 = null;\n    \n                    /**\n                     * DiagnosticInfo leaderData.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null|undefined} leaderData\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.leaderData = null;\n    \n                    /**\n                     * DiagnosticInfo networkData.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null|undefined} networkData\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.networkData = null;\n    \n                    /**\n                     * DiagnosticInfo ipv6AddressList.\n                     * @member {Array.<particle.ctrl.IIpv6Address>} ipv6AddressList\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.ipv6AddressList = $util.emptyArray;\n    \n                    /**\n                     * DiagnosticInfo macCounters.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null|undefined} macCounters\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.macCounters = null;\n    \n                    /**\n                     * DiagnosticInfo batteryLevel.\n                     * @member {number} batteryLevel\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.batteryLevel = 0;\n    \n                    /**\n                     * DiagnosticInfo supplyVoltage.\n                     * @member {number} supplyVoltage\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.supplyVoltage = 0;\n    \n                    /**\n                     * DiagnosticInfo childTable.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null|undefined} childTable\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.childTable = null;\n    \n                    /**\n                     * DiagnosticInfo channelPages.\n                     * @member {Uint8Array} channelPages\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.channelPages = $util.newBuffer([]);\n    \n                    /**\n                     * DiagnosticInfo typeList.\n                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} typeList\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.typeList = $util.emptyArray;\n    \n                    /**\n                     * DiagnosticInfo maxChildTimeout.\n                     * @member {number} maxChildTimeout\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.maxChildTimeout = 0;\n    \n                    /**\n                     * DiagnosticInfo deviceId.\n                     * @member {Uint8Array} deviceId\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.deviceId = $util.newBuffer([]);\n    \n                    /**\n                     * Creates a new DiagnosticInfo instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo instance\n                     */\n                    DiagnosticInfo.create = function create(properties) {\n                        return new DiagnosticInfo(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DiagnosticInfo message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo} message DiagnosticInfo message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DiagnosticInfo.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.extMacAddress != null && Object.hasOwnProperty.call(message, \"extMacAddress\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.extMacAddress);\n                        if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.rloc);\n                        if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timeout);\n                        if (message.connectivity != null && Object.hasOwnProperty.call(message, \"connectivity\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.encode(message.connectivity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.route64 != null && Object.hasOwnProperty.call(message, \"route64\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Route64.encode(message.route64, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.leaderData != null && Object.hasOwnProperty.call(message, \"leaderData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.encode(message.leaderData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.networkData != null && Object.hasOwnProperty.call(message, \"networkData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.encode(message.networkData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.ipv6AddressList != null && message.ipv6AddressList.length)\n                            for (var i = 0; i < message.ipv6AddressList.length; ++i)\n                                $root.particle.ctrl.Ipv6Address.encode(message.ipv6AddressList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.macCounters != null && Object.hasOwnProperty.call(message, \"macCounters\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.encode(message.macCounters, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                        if (message.batteryLevel != null && Object.hasOwnProperty.call(message, \"batteryLevel\"))\n                            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.batteryLevel);\n                        if (message.supplyVoltage != null && Object.hasOwnProperty.call(message, \"supplyVoltage\"))\n                            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.supplyVoltage);\n                        if (message.childTable != null && Object.hasOwnProperty.call(message, \"childTable\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.encode(message.childTable, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();\n                        if (message.channelPages != null && Object.hasOwnProperty.call(message, \"channelPages\"))\n                            writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.channelPages);\n                        if (message.typeList != null && message.typeList.length) {\n                            writer.uint32(/* id 19, wireType 2 =*/154).fork();\n                            for (var i = 0; i < message.typeList.length; ++i)\n                                writer.int32(message.typeList[i]);\n                            writer.ldelim();\n                        }\n                        if (message.maxChildTimeout != null && Object.hasOwnProperty.call(message, \"maxChildTimeout\"))\n                            writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.maxChildTimeout);\n                        if (message.deviceId != null && Object.hasOwnProperty.call(message, \"deviceId\"))\n                            writer.uint32(/* id 100, wireType 2 =*/802).bytes(message.deviceId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DiagnosticInfo message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DiagnosticInfo.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.extMacAddress = reader.bytes();\n                                break;\n                            case 2:\n                                message.rloc = reader.uint32();\n                                break;\n                            case 3:\n                                message.mode = reader.uint32();\n                                break;\n                            case 4:\n                                message.timeout = reader.uint32();\n                                break;\n                            case 5:\n                                message.connectivity = $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.decode(reader, reader.uint32());\n                                break;\n                            case 6:\n                                message.route64 = $root.particle.ctrl.mesh.DiagnosticInfo.Route64.decode(reader, reader.uint32());\n                                break;\n                            case 7:\n                                message.leaderData = $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.decode(reader, reader.uint32());\n                                break;\n                            case 8:\n                                message.networkData = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.decode(reader, reader.uint32());\n                                break;\n                            case 9:\n                                if (!(message.ipv6AddressList && message.ipv6AddressList.length))\n                                    message.ipv6AddressList = [];\n                                message.ipv6AddressList.push($root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32()));\n                                break;\n                            case 10:\n                                message.macCounters = $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.decode(reader, reader.uint32());\n                                break;\n                            case 15:\n                                message.batteryLevel = reader.uint32();\n                                break;\n                            case 16:\n                                message.supplyVoltage = reader.uint32();\n                                break;\n                            case 17:\n                                message.childTable = $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.decode(reader, reader.uint32());\n                                break;\n                            case 18:\n                                message.channelPages = reader.bytes();\n                                break;\n                            case 19:\n                                if (!(message.typeList && message.typeList.length))\n                                    message.typeList = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.typeList.push(reader.int32());\n                                } else\n                                    message.typeList.push(reader.int32());\n                                break;\n                            case 20:\n                                message.maxChildTimeout = reader.uint32();\n                                break;\n                            case 100:\n                                message.deviceId = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    /**\n                     * Mode enum.\n                     * @name particle.ctrl.mesh.DiagnosticInfo.Mode\n                     * @enum {number}\n                     * @property {number} INVALID=0 INVALID value\n                     * @property {number} RECEIVER_ON_WHEN_IDLE=16 RECEIVER_ON_WHEN_IDLE value\n                     * @property {number} SECURE_DATA_REQUESTS=32 SECURE_DATA_REQUESTS value\n                     * @property {number} DEVICE_TYPE=48 DEVICE_TYPE value\n                     * @property {number} DEVICE_TYPE_FTD=48 DEVICE_TYPE_FTD value\n                     * @property {number} NETWORK_DATA=64 NETWORK_DATA value\n                     * @property {number} NETWORK_DATA_FULL=64 NETWORK_DATA_FULL value\n                     */\n                    DiagnosticInfo.Mode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[16] = \"RECEIVER_ON_WHEN_IDLE\"] = 16;\n                        values[valuesById[32] = \"SECURE_DATA_REQUESTS\"] = 32;\n                        values[valuesById[48] = \"DEVICE_TYPE\"] = 48;\n                        values[\"DEVICE_TYPE_FTD\"] = 48;\n                        values[valuesById[64] = \"NETWORK_DATA\"] = 64;\n                        values[\"NETWORK_DATA_FULL\"] = 64;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.Connectivity = (function() {\n    \n                        /**\n                         * Properties of a Connectivity.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IConnectivity\n                         * @property {number|null} [parentPriority] Connectivity parentPriority\n                         * @property {number|null} [linkQuality_1] Connectivity linkQuality_1\n                         * @property {number|null} [linkQuality_2] Connectivity linkQuality_2\n                         * @property {number|null} [linkQuality_3] Connectivity linkQuality_3\n                         * @property {number|null} [leaderCost] Connectivity leaderCost\n                         * @property {number|null} [idSequence] Connectivity idSequence\n                         * @property {number|null} [activeRouters] Connectivity activeRouters\n                         * @property {number|null} [sedBufferSize] Connectivity sedBufferSize\n                         * @property {number|null} [sedDatagramCount] Connectivity sedDatagramCount\n                         */\n    \n                        /**\n                         * Constructs a new Connectivity.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a Connectivity.\n                         * @implements IConnectivity\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set\n                         */\n                        function Connectivity(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Connectivity parentPriority.\n                         * @member {number} parentPriority\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.parentPriority = 0;\n    \n                        /**\n                         * Connectivity linkQuality_1.\n                         * @member {number} linkQuality_1\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_1 = 0;\n    \n                        /**\n                         * Connectivity linkQuality_2.\n                         * @member {number} linkQuality_2\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_2 = 0;\n    \n                        /**\n                         * Connectivity linkQuality_3.\n                         * @member {number} linkQuality_3\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_3 = 0;\n    \n                        /**\n                         * Connectivity leaderCost.\n                         * @member {number} leaderCost\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.leaderCost = 0;\n    \n                        /**\n                         * Connectivity idSequence.\n                         * @member {number} idSequence\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.idSequence = 0;\n    \n                        /**\n                         * Connectivity activeRouters.\n                         * @member {number} activeRouters\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.activeRouters = 0;\n    \n                        /**\n                         * Connectivity sedBufferSize.\n                         * @member {number} sedBufferSize\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.sedBufferSize = 0;\n    \n                        /**\n                         * Connectivity sedDatagramCount.\n                         * @member {number} sedDatagramCount\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.sedDatagramCount = 0;\n    \n                        /**\n                         * Creates a new Connectivity instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity instance\n                         */\n                        Connectivity.create = function create(properties) {\n                            return new Connectivity(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Connectivity message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Connectivity.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity} message Connectivity message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Connectivity.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.parentPriority != null && Object.hasOwnProperty.call(message, \"parentPriority\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.parentPriority);\n                            if (message.linkQuality_1 != null && Object.hasOwnProperty.call(message, \"linkQuality_1\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQuality_1);\n                            if (message.linkQuality_2 != null && Object.hasOwnProperty.call(message, \"linkQuality_2\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQuality_2);\n                            if (message.linkQuality_3 != null && Object.hasOwnProperty.call(message, \"linkQuality_3\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.linkQuality_3);\n                            if (message.leaderCost != null && Object.hasOwnProperty.call(message, \"leaderCost\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderCost);\n                            if (message.idSequence != null && Object.hasOwnProperty.call(message, \"idSequence\"))\n                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.idSequence);\n                            if (message.activeRouters != null && Object.hasOwnProperty.call(message, \"activeRouters\"))\n                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.activeRouters);\n                            if (message.sedBufferSize != null && Object.hasOwnProperty.call(message, \"sedBufferSize\"))\n                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.sedBufferSize);\n                            if (message.sedDatagramCount != null && Object.hasOwnProperty.call(message, \"sedDatagramCount\"))\n                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.sedDatagramCount);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Connectivity message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Connectivity.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.parentPriority = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.linkQuality_1 = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.linkQuality_2 = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.linkQuality_3 = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.leaderCost = reader.uint32();\n                                    break;\n                                case 6:\n                                    message.idSequence = reader.uint32();\n                                    break;\n                                case 7:\n                                    message.activeRouters = reader.uint32();\n                                    break;\n                                case 8:\n                                    message.sedBufferSize = reader.uint32();\n                                    break;\n                                case 9:\n                                    message.sedDatagramCount = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Connectivity;\n                    })();\n    \n                    DiagnosticInfo.Route64 = (function() {\n    \n                        /**\n                         * Properties of a Route64.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IRoute64\n                         * @property {number|null} [idSequence] Route64 idSequence\n                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>|null} [routes] Route64 routes\n                         */\n    \n                        /**\n                         * Constructs a new Route64.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a Route64.\n                         * @implements IRoute64\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set\n                         */\n                        function Route64(properties) {\n                            this.routes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Route64 idSequence.\n                         * @member {number} idSequence\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @instance\n                         */\n                        Route64.prototype.idSequence = 0;\n    \n                        /**\n                         * Route64 routes.\n                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>} routes\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @instance\n                         */\n                        Route64.prototype.routes = $util.emptyArray;\n    \n                        /**\n                         * Creates a new Route64 instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64 instance\n                         */\n                        Route64.create = function create(properties) {\n                            return new Route64(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Route64 message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64} message Route64 message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Route64.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.idSequence != null && Object.hasOwnProperty.call(message, \"idSequence\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idSequence);\n                            if (message.routes != null && message.routes.length)\n                                for (var i = 0; i < message.routes.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.encode(message.routes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Route64 message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Route64.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.idSequence = reader.uint32();\n                                    break;\n                                case 2:\n                                    if (!(message.routes && message.routes.length))\n                                        message.routes = [];\n                                    message.routes.push($root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.decode(reader, reader.uint32()));\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        Route64.RouteData = (function() {\n    \n                            /**\n                             * Properties of a RouteData.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                             * @interface IRouteData\n                             * @property {number|null} [routerRloc] RouteData routerRloc\n                             * @property {number|null} [linkQualityOut] RouteData linkQualityOut\n                             * @property {number|null} [linkQualityIn] RouteData linkQualityIn\n                             * @property {number|null} [routeCost] RouteData routeCost\n                             */\n    \n                            /**\n                             * Constructs a new RouteData.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                             * @classdesc Represents a RouteData.\n                             * @implements IRouteData\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set\n                             */\n                            function RouteData(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * RouteData routerRloc.\n                             * @member {number} routerRloc\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.routerRloc = 0;\n    \n                            /**\n                             * RouteData linkQualityOut.\n                             * @member {number} linkQualityOut\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.linkQualityOut = 0;\n    \n                            /**\n                             * RouteData linkQualityIn.\n                             * @member {number} linkQualityIn\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.linkQualityIn = 0;\n    \n                            /**\n                             * RouteData routeCost.\n                             * @member {number} routeCost\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.routeCost = 0;\n    \n                            /**\n                             * Creates a new RouteData instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData instance\n                             */\n                            RouteData.create = function create(properties) {\n                                return new RouteData(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified RouteData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData} message RouteData message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            RouteData.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.routerRloc != null && Object.hasOwnProperty.call(message, \"routerRloc\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.routerRloc);\n                                if (message.linkQualityOut != null && Object.hasOwnProperty.call(message, \"linkQualityOut\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQualityOut);\n                                if (message.linkQualityIn != null && Object.hasOwnProperty.call(message, \"linkQualityIn\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQualityIn);\n                                if (message.routeCost != null && Object.hasOwnProperty.call(message, \"routeCost\"))\n                                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.routeCost);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a RouteData message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            RouteData.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.routerRloc = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.linkQualityOut = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.linkQualityIn = reader.uint32();\n                                        break;\n                                    case 4:\n                                        message.routeCost = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return RouteData;\n                        })();\n    \n                        return Route64;\n                    })();\n    \n                    DiagnosticInfo.LeaderData = (function() {\n    \n                        /**\n                         * Properties of a LeaderData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface ILeaderData\n                         * @property {number|null} [partitionId] LeaderData partitionId\n                         * @property {number|null} [weighting] LeaderData weighting\n                         * @property {number|null} [dataVersion] LeaderData dataVersion\n                         * @property {number|null} [stableDataVersion] LeaderData stableDataVersion\n                         * @property {number|null} [leaderRloc] LeaderData leaderRloc\n                         */\n    \n                        /**\n                         * Constructs a new LeaderData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a LeaderData.\n                         * @implements ILeaderData\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set\n                         */\n                        function LeaderData(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * LeaderData partitionId.\n                         * @member {number} partitionId\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.partitionId = 0;\n    \n                        /**\n                         * LeaderData weighting.\n                         * @member {number} weighting\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.weighting = 0;\n    \n                        /**\n                         * LeaderData dataVersion.\n                         * @member {number} dataVersion\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.dataVersion = 0;\n    \n                        /**\n                         * LeaderData stableDataVersion.\n                         * @member {number} stableDataVersion\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.stableDataVersion = 0;\n    \n                        /**\n                         * LeaderData leaderRloc.\n                         * @member {number} leaderRloc\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.leaderRloc = 0;\n    \n                        /**\n                         * Creates a new LeaderData instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData instance\n                         */\n                        LeaderData.create = function create(properties) {\n                            return new LeaderData(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified LeaderData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.LeaderData.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData} message LeaderData message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        LeaderData.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partitionId != null && Object.hasOwnProperty.call(message, \"partitionId\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.partitionId);\n                            if (message.weighting != null && Object.hasOwnProperty.call(message, \"weighting\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weighting);\n                            if (message.dataVersion != null && Object.hasOwnProperty.call(message, \"dataVersion\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dataVersion);\n                            if (message.stableDataVersion != null && Object.hasOwnProperty.call(message, \"stableDataVersion\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stableDataVersion);\n                            if (message.leaderRloc != null && Object.hasOwnProperty.call(message, \"leaderRloc\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderRloc);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a LeaderData message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        LeaderData.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.partitionId = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.weighting = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.dataVersion = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.stableDataVersion = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.leaderRloc = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return LeaderData;\n                    })();\n    \n                    /**\n                     * RoutePreference enum.\n                     * @name particle.ctrl.mesh.DiagnosticInfo.RoutePreference\n                     * @enum {number}\n                     * @property {number} MEDIUM=0 MEDIUM value\n                     * @property {number} HIGH=1 HIGH value\n                     * @property {number} LOW=-1 LOW value\n                     */\n                    DiagnosticInfo.RoutePreference = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"MEDIUM\"] = 0;\n                        values[valuesById[1] = \"HIGH\"] = 1;\n                        values[valuesById[-1] = \"LOW\"] = -1;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.NetworkData = (function() {\n    \n                        /**\n                         * Properties of a NetworkData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface INetworkData\n                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [stable] NetworkData stable\n                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [temporary] NetworkData temporary\n                         */\n    \n                        /**\n                         * Constructs a new NetworkData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a NetworkData.\n                         * @implements INetworkData\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set\n                         */\n                        function NetworkData(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * NetworkData stable.\n                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} stable\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @instance\n                         */\n                        NetworkData.prototype.stable = null;\n    \n                        /**\n                         * NetworkData temporary.\n                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} temporary\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @instance\n                         */\n                        NetworkData.prototype.temporary = null;\n    \n                        /**\n                         * Creates a new NetworkData instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData instance\n                         */\n                        NetworkData.create = function create(properties) {\n                            return new NetworkData(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified NetworkData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData} message NetworkData message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        NetworkData.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.stable != null && Object.hasOwnProperty.call(message, \"stable\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.stable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            if (message.temporary != null && Object.hasOwnProperty.call(message, \"temporary\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.temporary, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a NetworkData message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        NetworkData.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.stable = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());\n                                    break;\n                                case 2:\n                                    message.temporary = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        NetworkData.HasRoute = (function() {\n    \n                            /**\n                             * Properties of a HasRoute.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IHasRoute\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>|null} [entries] HasRoute entries\n                             */\n    \n                            /**\n                             * Constructs a new HasRoute.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a HasRoute.\n                             * @implements IHasRoute\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set\n                             */\n                            function HasRoute(properties) {\n                                this.entries = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * HasRoute entries.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>} entries\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @instance\n                             */\n                            HasRoute.prototype.entries = $util.emptyArray;\n    \n                            /**\n                             * Creates a new HasRoute instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute instance\n                             */\n                            HasRoute.create = function create(properties) {\n                                return new HasRoute(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified HasRoute message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute} message HasRoute message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            HasRoute.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.entries != null && message.entries.length)\n                                    for (var i = 0; i < message.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a HasRoute message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            HasRoute.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.entries && message.entries.length))\n                                            message.entries = [];\n                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            HasRoute.HasRouteEntry = (function() {\n    \n                                /**\n                                 * Properties of a HasRouteEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                                 * @interface IHasRouteEntry\n                                 * @property {number|null} [rloc] HasRouteEntry rloc\n                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] HasRouteEntry preference\n                                 */\n    \n                                /**\n                                 * Constructs a new HasRouteEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                                 * @classdesc Represents a HasRouteEntry.\n                                 * @implements IHasRouteEntry\n                                 * @constructor\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set\n                                 */\n                                function HasRouteEntry(properties) {\n                                    if (properties)\n                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                            if (properties[keys[i]] != null)\n                                                this[keys[i]] = properties[keys[i]];\n                                }\n    \n                                /**\n                                 * HasRouteEntry rloc.\n                                 * @member {number} rloc\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @instance\n                                 */\n                                HasRouteEntry.prototype.rloc = 0;\n    \n                                /**\n                                 * HasRouteEntry preference.\n                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @instance\n                                 */\n                                HasRouteEntry.prototype.preference = 0;\n    \n                                /**\n                                 * Creates a new HasRouteEntry instance using the specified properties.\n                                 * @function create\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry instance\n                                 */\n                                HasRouteEntry.create = function create(properties) {\n                                    return new HasRouteEntry(properties);\n                                };\n    \n                                /**\n                                 * Encodes the specified HasRouteEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.verify|verify} messages.\n                                 * @function encode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry} message HasRouteEntry message or plain object to encode\n                                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                                 * @returns {$protobuf.Writer} Writer\n                                 */\n                                HasRouteEntry.encode = function encode(message, writer) {\n                                    if (!writer)\n                                        writer = $Writer.create();\n                                    if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                    if (message.preference != null && Object.hasOwnProperty.call(message, \"preference\"))\n                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);\n                                    return writer;\n                                };\n    \n                                /**\n                                 * Decodes a HasRouteEntry message from the specified reader or buffer.\n                                 * @function decode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                                 * @param {number} [length] Message length if known beforehand\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry\n                                 * @throws {Error} If the payload is not a reader or valid buffer\n                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                                 */\n                                HasRouteEntry.decode = function decode(reader, length) {\n                                    if (!(reader instanceof $Reader))\n                                        reader = $Reader.create(reader);\n                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry();\n                                    while (reader.pos < end) {\n                                        var tag = reader.uint32();\n                                        switch (tag >>> 3) {\n                                        case 1:\n                                            message.rloc = reader.uint32();\n                                            break;\n                                        case 2:\n                                            message.preference = reader.int32();\n                                            break;\n                                        default:\n                                            reader.skipType(tag & 7);\n                                            break;\n                                        }\n                                    }\n                                    return message;\n                                };\n    \n                                return HasRouteEntry;\n                            })();\n    \n                            return HasRoute;\n                        })();\n    \n                        NetworkData.BorderRouter = (function() {\n    \n                            /**\n                             * Properties of a BorderRouter.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IBorderRouter\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>|null} [entries] BorderRouter entries\n                             */\n    \n                            /**\n                             * Constructs a new BorderRouter.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a BorderRouter.\n                             * @implements IBorderRouter\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set\n                             */\n                            function BorderRouter(properties) {\n                                this.entries = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * BorderRouter entries.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>} entries\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @instance\n                             */\n                            BorderRouter.prototype.entries = $util.emptyArray;\n    \n                            /**\n                             * Creates a new BorderRouter instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter instance\n                             */\n                            BorderRouter.create = function create(properties) {\n                                return new BorderRouter(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified BorderRouter message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter} message BorderRouter message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            BorderRouter.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.entries != null && message.entries.length)\n                                    for (var i = 0; i < message.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a BorderRouter message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            BorderRouter.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.entries && message.entries.length))\n                                            message.entries = [];\n                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            BorderRouter.BorderRouterEntry = (function() {\n    \n                                /**\n                                 * Properties of a BorderRouterEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                                 * @interface IBorderRouterEntry\n                                 * @property {number|null} [rloc] BorderRouterEntry rloc\n                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] BorderRouterEntry preference\n                                 * @property {number|null} [flags] BorderRouterEntry flags\n                                 */\n    \n                                /**\n                                 * Constructs a new BorderRouterEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                                 * @classdesc Represents a BorderRouterEntry.\n                                 * @implements IBorderRouterEntry\n                                 * @constructor\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set\n                                 */\n                                function BorderRouterEntry(properties) {\n                                    if (properties)\n                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                            if (properties[keys[i]] != null)\n                                                this[keys[i]] = properties[keys[i]];\n                                }\n    \n                                /**\n                                 * BorderRouterEntry rloc.\n                                 * @member {number} rloc\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.rloc = 0;\n    \n                                /**\n                                 * BorderRouterEntry preference.\n                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.preference = 0;\n    \n                                /**\n                                 * BorderRouterEntry flags.\n                                 * @member {number} flags\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.flags = 0;\n    \n                                /**\n                                 * Creates a new BorderRouterEntry instance using the specified properties.\n                                 * @function create\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry instance\n                                 */\n                                BorderRouterEntry.create = function create(properties) {\n                                    return new BorderRouterEntry(properties);\n                                };\n    \n                                /**\n                                 * Encodes the specified BorderRouterEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.verify|verify} messages.\n                                 * @function encode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry} message BorderRouterEntry message or plain object to encode\n                                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                                 * @returns {$protobuf.Writer} Writer\n                                 */\n                                BorderRouterEntry.encode = function encode(message, writer) {\n                                    if (!writer)\n                                        writer = $Writer.create();\n                                    if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                    if (message.preference != null && Object.hasOwnProperty.call(message, \"preference\"))\n                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);\n                                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);\n                                    return writer;\n                                };\n    \n                                /**\n                                 * Decodes a BorderRouterEntry message from the specified reader or buffer.\n                                 * @function decode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                                 * @param {number} [length] Message length if known beforehand\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry\n                                 * @throws {Error} If the payload is not a reader or valid buffer\n                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                                 */\n                                BorderRouterEntry.decode = function decode(reader, length) {\n                                    if (!(reader instanceof $Reader))\n                                        reader = $Reader.create(reader);\n                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry();\n                                    while (reader.pos < end) {\n                                        var tag = reader.uint32();\n                                        switch (tag >>> 3) {\n                                        case 1:\n                                            message.rloc = reader.uint32();\n                                            break;\n                                        case 2:\n                                            message.preference = reader.int32();\n                                            break;\n                                        case 3:\n                                            message.flags = reader.uint32();\n                                            break;\n                                        default:\n                                            reader.skipType(tag & 7);\n                                            break;\n                                        }\n                                    }\n                                    return message;\n                                };\n    \n                                /**\n                                 * Flags enum.\n                                 * @name particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.Flags\n                                 * @enum {number}\n                                 * @property {number} NONE=0 NONE value\n                                 * @property {number} PREFERRED=1 PREFERRED value\n                                 * @property {number} SLAAC=2 SLAAC value\n                                 * @property {number} DHCP=4 DHCP value\n                                 * @property {number} CONFIGURE=8 CONFIGURE value\n                                 * @property {number} DEFAULT_ROUTE=16 DEFAULT_ROUTE value\n                                 * @property {number} ON_MESH=32 ON_MESH value\n                                 * @property {number} ND_DNS=64 ND_DNS value\n                                 */\n                                BorderRouterEntry.Flags = (function() {\n                                    var valuesById = {}, values = Object.create(valuesById);\n                                    values[valuesById[0] = \"NONE\"] = 0;\n                                    values[valuesById[1] = \"PREFERRED\"] = 1;\n                                    values[valuesById[2] = \"SLAAC\"] = 2;\n                                    values[valuesById[4] = \"DHCP\"] = 4;\n                                    values[valuesById[8] = \"CONFIGURE\"] = 8;\n                                    values[valuesById[16] = \"DEFAULT_ROUTE\"] = 16;\n                                    values[valuesById[32] = \"ON_MESH\"] = 32;\n                                    values[valuesById[64] = \"ND_DNS\"] = 64;\n                                    return values;\n                                })();\n    \n                                return BorderRouterEntry;\n                            })();\n    \n                            return BorderRouter;\n                        })();\n    \n                        NetworkData.Context = (function() {\n    \n                            /**\n                             * Properties of a Context.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IContext\n                             * @property {number|null} [cid] Context cid\n                             * @property {boolean|null} [compress] Context compress\n                             * @property {number|null} [contextLength] Context contextLength\n                             */\n    \n                            /**\n                             * Constructs a new Context.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Context.\n                             * @implements IContext\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set\n                             */\n                            function Context(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Context cid.\n                             * @member {number} cid\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.cid = 0;\n    \n                            /**\n                             * Context compress.\n                             * @member {boolean} compress\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.compress = false;\n    \n                            /**\n                             * Context contextLength.\n                             * @member {number} contextLength\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.contextLength = 0;\n    \n                            /**\n                             * Creates a new Context instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context instance\n                             */\n                            Context.create = function create(properties) {\n                                return new Context(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Context message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext} message Context message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Context.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.cid != null && Object.hasOwnProperty.call(message, \"cid\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cid);\n                                if (message.compress != null && Object.hasOwnProperty.call(message, \"compress\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.compress);\n                                if (message.contextLength != null && Object.hasOwnProperty.call(message, \"contextLength\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.contextLength);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Context message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Context.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.cid = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.compress = reader.bool();\n                                        break;\n                                    case 3:\n                                        message.contextLength = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Context;\n                        })();\n    \n                        NetworkData.Prefix = (function() {\n    \n                            /**\n                             * Properties of a Prefix.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IPrefix\n                             * @property {number|null} [domainId] Prefix domainId\n                             * @property {number|null} [prefixLength] Prefix prefixLength\n                             * @property {Uint8Array|null} [prefix] Prefix prefix\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>|null} [context] Prefix context\n                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null} [hasRoute] Prefix hasRoute\n                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null} [borderRouter] Prefix borderRouter\n                             */\n    \n                            /**\n                             * Constructs a new Prefix.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Prefix.\n                             * @implements IPrefix\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set\n                             */\n                            function Prefix(properties) {\n                                this.context = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Prefix domainId.\n                             * @member {number} domainId\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.domainId = 0;\n    \n                            /**\n                             * Prefix prefixLength.\n                             * @member {number} prefixLength\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.prefixLength = 0;\n    \n                            /**\n                             * Prefix prefix.\n                             * @member {Uint8Array} prefix\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.prefix = $util.newBuffer([]);\n    \n                            /**\n                             * Prefix context.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>} context\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.context = $util.emptyArray;\n    \n                            /**\n                             * Prefix hasRoute.\n                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null|undefined} hasRoute\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.hasRoute = null;\n    \n                            /**\n                             * Prefix borderRouter.\n                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null|undefined} borderRouter\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.borderRouter = null;\n    \n                            /**\n                             * Creates a new Prefix instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix instance\n                             */\n                            Prefix.create = function create(properties) {\n                                return new Prefix(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Prefix message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix} message Prefix message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Prefix.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.domainId != null && Object.hasOwnProperty.call(message, \"domainId\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.domainId);\n                                if (message.prefixLength != null && Object.hasOwnProperty.call(message, \"prefixLength\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);\n                                if (message.prefix != null && Object.hasOwnProperty.call(message, \"prefix\"))\n                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.prefix);\n                                if (message.context != null && message.context.length)\n                                    for (var i = 0; i < message.context.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.encode(message.context[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                                if (message.hasRoute != null && Object.hasOwnProperty.call(message, \"hasRoute\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.encode(message.hasRoute, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                                if (message.borderRouter != null && Object.hasOwnProperty.call(message, \"borderRouter\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.encode(message.borderRouter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Prefix message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Prefix.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.domainId = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.prefixLength = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.prefix = reader.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(message.context && message.context.length))\n                                            message.context = [];\n                                        message.context.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.decode(reader, reader.uint32()));\n                                        break;\n                                    case 5:\n                                        message.hasRoute = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.decode(reader, reader.uint32());\n                                        break;\n                                    case 6:\n                                        message.borderRouter = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Prefix;\n                        })();\n    \n                        NetworkData.Server = (function() {\n    \n                            /**\n                             * Properties of a Server.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IServer\n                             * @property {number|null} [rloc] Server rloc\n                             * @property {Uint8Array|null} [data] Server data\n                             */\n    \n                            /**\n                             * Constructs a new Server.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Server.\n                             * @implements IServer\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set\n                             */\n                            function Server(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Server rloc.\n                             * @member {number} rloc\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @instance\n                             */\n                            Server.prototype.rloc = 0;\n    \n                            /**\n                             * Server data.\n                             * @member {Uint8Array} data\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @instance\n                             */\n                            Server.prototype.data = $util.newBuffer([]);\n    \n                            /**\n                             * Creates a new Server instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server instance\n                             */\n                            Server.create = function create(properties) {\n                                return new Server(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Server message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer} message Server message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Server.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Server message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Server.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.rloc = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.data = reader.bytes();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Server;\n                        })();\n    \n                        NetworkData.Service = (function() {\n    \n                            /**\n                             * Properties of a Service.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IService\n                             * @property {number|null} [sid] Service sid\n                             * @property {number|null} [enterpriseNumber] Service enterpriseNumber\n                             * @property {Uint8Array|null} [data] Service data\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>|null} [servers] Service servers\n                             */\n    \n                            /**\n                             * Constructs a new Service.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Service.\n                             * @implements IService\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set\n                             */\n                            function Service(properties) {\n                                this.servers = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Service sid.\n                             * @member {number} sid\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.sid = 0;\n    \n                            /**\n                             * Service enterpriseNumber.\n                             * @member {number} enterpriseNumber\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.enterpriseNumber = 0;\n    \n                            /**\n                             * Service data.\n                             * @member {Uint8Array} data\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.data = $util.newBuffer([]);\n    \n                            /**\n                             * Service servers.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>} servers\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.servers = $util.emptyArray;\n    \n                            /**\n                             * Creates a new Service instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service instance\n                             */\n                            Service.create = function create(properties) {\n                                return new Service(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Service message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService} message Service message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Service.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.sid != null && Object.hasOwnProperty.call(message, \"sid\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sid);\n                                if (message.enterpriseNumber != null && Object.hasOwnProperty.call(message, \"enterpriseNumber\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.enterpriseNumber);\n                                if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);\n                                if (message.servers != null && message.servers.length)\n                                    for (var i = 0; i < message.servers.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.encode(message.servers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Service message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Service.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.sid = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.enterpriseNumber = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.data = reader.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(message.servers && message.servers.length))\n                                            message.servers = [];\n                                        message.servers.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Service;\n                        })();\n    \n                        NetworkData.Data = (function() {\n    \n                            /**\n                             * Properties of a Data.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IData\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>|null} [prefixes] Data prefixes\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>|null} [services] Data services\n                             */\n    \n                            /**\n                             * Constructs a new Data.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Data.\n                             * @implements IData\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set\n                             */\n                            function Data(properties) {\n                                this.prefixes = [];\n                                this.services = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Data prefixes.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>} prefixes\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @instance\n                             */\n                            Data.prototype.prefixes = $util.emptyArray;\n    \n                            /**\n                             * Data services.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>} services\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @instance\n                             */\n                            Data.prototype.services = $util.emptyArray;\n    \n                            /**\n                             * Creates a new Data instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data instance\n                             */\n                            Data.create = function create(properties) {\n                                return new Data(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Data message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData} message Data message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Data.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.prefixes != null && message.prefixes.length)\n                                    for (var i = 0; i < message.prefixes.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.encode(message.prefixes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                if (message.services != null && message.services.length)\n                                    for (var i = 0; i < message.services.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.encode(message.services[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Data message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Data.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.prefixes && message.prefixes.length))\n                                            message.prefixes = [];\n                                        message.prefixes.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.decode(reader, reader.uint32()));\n                                        break;\n                                    case 2:\n                                        if (!(message.services && message.services.length))\n                                            message.services = [];\n                                        message.services.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Data;\n                        })();\n    \n                        return NetworkData;\n                    })();\n    \n                    DiagnosticInfo.MacCounters = (function() {\n    \n                        /**\n                         * Properties of a MacCounters.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IMacCounters\n                         * @property {number|null} [ifInUnknownProtos] MacCounters ifInUnknownProtos\n                         * @property {number|null} [ifInErrors] MacCounters ifInErrors\n                         * @property {number|null} [ifOutErrors] MacCounters ifOutErrors\n                         * @property {number|null} [ifInUcastPkts] MacCounters ifInUcastPkts\n                         * @property {number|null} [ifInBroadcastPkts] MacCounters ifInBroadcastPkts\n                         * @property {number|null} [ifInDiscards] MacCounters ifInDiscards\n                         * @property {number|null} [ifOutUcastPkts] MacCounters ifOutUcastPkts\n                         * @property {number|null} [ifOutBroadcastPkts] MacCounters ifOutBroadcastPkts\n                         * @property {number|null} [ifOutDiscards] MacCounters ifOutDiscards\n                         */\n    \n                        /**\n                         * Constructs a new MacCounters.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a MacCounters.\n                         * @implements IMacCounters\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set\n                         */\n                        function MacCounters(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * MacCounters ifInUnknownProtos.\n                         * @member {number} ifInUnknownProtos\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInUnknownProtos = 0;\n    \n                        /**\n                         * MacCounters ifInErrors.\n                         * @member {number} ifInErrors\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInErrors = 0;\n    \n                        /**\n                         * MacCounters ifOutErrors.\n                         * @member {number} ifOutErrors\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutErrors = 0;\n    \n                        /**\n                         * MacCounters ifInUcastPkts.\n                         * @member {number} ifInUcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInUcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifInBroadcastPkts.\n                         * @member {number} ifInBroadcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInBroadcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifInDiscards.\n                         * @member {number} ifInDiscards\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInDiscards = 0;\n    \n                        /**\n                         * MacCounters ifOutUcastPkts.\n                         * @member {number} ifOutUcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutUcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifOutBroadcastPkts.\n                         * @member {number} ifOutBroadcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutBroadcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifOutDiscards.\n                         * @member {number} ifOutDiscards\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutDiscards = 0;\n    \n                        /**\n                         * Creates a new MacCounters instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters instance\n                         */\n                        MacCounters.create = function create(properties) {\n                            return new MacCounters(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified MacCounters message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.MacCounters.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters} message MacCounters message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        MacCounters.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ifInUnknownProtos != null && Object.hasOwnProperty.call(message, \"ifInUnknownProtos\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ifInUnknownProtos);\n                            if (message.ifInErrors != null && Object.hasOwnProperty.call(message, \"ifInErrors\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ifInErrors);\n                            if (message.ifOutErrors != null && Object.hasOwnProperty.call(message, \"ifOutErrors\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.ifOutErrors);\n                            if (message.ifInUcastPkts != null && Object.hasOwnProperty.call(message, \"ifInUcastPkts\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ifInUcastPkts);\n                            if (message.ifInBroadcastPkts != null && Object.hasOwnProperty.call(message, \"ifInBroadcastPkts\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ifInBroadcastPkts);\n                            if (message.ifInDiscards != null && Object.hasOwnProperty.call(message, \"ifInDiscards\"))\n                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.ifInDiscards);\n                            if (message.ifOutUcastPkts != null && Object.hasOwnProperty.call(message, \"ifOutUcastPkts\"))\n                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ifOutUcastPkts);\n                            if (message.ifOutBroadcastPkts != null && Object.hasOwnProperty.call(message, \"ifOutBroadcastPkts\"))\n                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.ifOutBroadcastPkts);\n                            if (message.ifOutDiscards != null && Object.hasOwnProperty.call(message, \"ifOutDiscards\"))\n                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ifOutDiscards);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a MacCounters message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        MacCounters.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ifInUnknownProtos = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.ifInErrors = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.ifOutErrors = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.ifInUcastPkts = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.ifInBroadcastPkts = reader.uint32();\n                                    break;\n                                case 6:\n                                    message.ifInDiscards = reader.uint32();\n                                    break;\n                                case 7:\n                                    message.ifOutUcastPkts = reader.uint32();\n                                    break;\n                                case 8:\n                                    message.ifOutBroadcastPkts = reader.uint32();\n                                    break;\n                                case 9:\n                                    message.ifOutDiscards = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return MacCounters;\n                    })();\n    \n                    DiagnosticInfo.ChildTable = (function() {\n    \n                        /**\n                         * Properties of a ChildTable.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IChildTable\n                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>|null} [children] ChildTable children\n                         */\n    \n                        /**\n                         * Constructs a new ChildTable.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a ChildTable.\n                         * @implements IChildTable\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set\n                         */\n                        function ChildTable(properties) {\n                            this.children = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * ChildTable children.\n                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>} children\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @instance\n                         */\n                        ChildTable.prototype.children = $util.emptyArray;\n    \n                        /**\n                         * Creates a new ChildTable instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable instance\n                         */\n                        ChildTable.create = function create(properties) {\n                            return new ChildTable(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified ChildTable message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable} message ChildTable message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ChildTable.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.children != null && message.children.length)\n                                for (var i = 0; i < message.children.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.encode(message.children[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a ChildTable message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ChildTable.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    if (!(message.children && message.children.length))\n                                        message.children = [];\n                                    message.children.push($root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.decode(reader, reader.uint32()));\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        ChildTable.ChildEntry = (function() {\n    \n                            /**\n                             * Properties of a ChildEntry.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                             * @interface IChildEntry\n                             * @property {number|null} [timeout] ChildEntry timeout\n                             * @property {number|null} [childId] ChildEntry childId\n                             * @property {number|null} [mode] ChildEntry mode\n                             */\n    \n                            /**\n                             * Constructs a new ChildEntry.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                             * @classdesc Represents a ChildEntry.\n                             * @implements IChildEntry\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set\n                             */\n                            function ChildEntry(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * ChildEntry timeout.\n                             * @member {number} timeout\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.timeout = 0;\n    \n                            /**\n                             * ChildEntry childId.\n                             * @member {number} childId\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.childId = 0;\n    \n                            /**\n                             * ChildEntry mode.\n                             * @member {number} mode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.mode = 0;\n    \n                            /**\n                             * Creates a new ChildEntry instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry instance\n                             */\n                            ChildEntry.create = function create(properties) {\n                                return new ChildEntry(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified ChildEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry} message ChildEntry message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            ChildEntry.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                                if (message.childId != null && Object.hasOwnProperty.call(message, \"childId\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.childId);\n                                if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a ChildEntry message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            ChildEntry.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.timeout = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.childId = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.mode = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return ChildEntry;\n                        })();\n    \n                        return ChildTable;\n                    })();\n    \n                    return DiagnosticInfo;\n                })();\n    \n                mesh.GetNetworkDiagnosticsRequest = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkDiagnosticsRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkDiagnosticsRequest\n                     * @property {number|null} [flags] GetNetworkDiagnosticsRequest flags\n                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [diagnosticTypes] GetNetworkDiagnosticsRequest diagnosticTypes\n                     * @property {number|null} [timeout] GetNetworkDiagnosticsRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkDiagnosticsRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkDiagnosticsRequest.\n                     * @implements IGetNetworkDiagnosticsRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set\n                     */\n                    function GetNetworkDiagnosticsRequest(properties) {\n                        this.diagnosticTypes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.flags = 0;\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest diagnosticTypes.\n                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} diagnosticTypes\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.diagnosticTypes = $util.emptyArray;\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new GetNetworkDiagnosticsRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest instance\n                     */\n                    GetNetworkDiagnosticsRequest.create = function create(properties) {\n                        return new GetNetworkDiagnosticsRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkDiagnosticsRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest} message GetNetworkDiagnosticsRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkDiagnosticsRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flags);\n                        if (message.diagnosticTypes != null && message.diagnosticTypes.length) {\n                            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                            for (var i = 0; i < message.diagnosticTypes.length; ++i)\n                                writer.int32(message.diagnosticTypes[i]);\n                            writer.ldelim();\n                        }\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkDiagnosticsRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkDiagnosticsRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.flags = reader.uint32();\n                                break;\n                            case 2:\n                                if (!(message.diagnosticTypes && message.diagnosticTypes.length))\n                                    message.diagnosticTypes = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.diagnosticTypes.push(reader.int32());\n                                } else\n                                    message.diagnosticTypes.push(reader.int32());\n                                break;\n                            case 3:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    /**\n                     * Flags enum.\n                     * @name particle.ctrl.mesh.GetNetworkDiagnosticsRequest.Flags\n                     * @enum {number}\n                     * @property {number} INVALID=0 INVALID value\n                     * @property {number} QUERY_CHILDREN=1 QUERY_CHILDREN value\n                     * @property {number} RESOLVE_DEVICE_ID=2 RESOLVE_DEVICE_ID value\n                     */\n                    GetNetworkDiagnosticsRequest.Flags = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[1] = \"QUERY_CHILDREN\"] = 1;\n                        values[valuesById[2] = \"RESOLVE_DEVICE_ID\"] = 2;\n                        return values;\n                    })();\n    \n                    return GetNetworkDiagnosticsRequest;\n                })();\n    \n                mesh.GetNetworkDiagnosticsReply = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkDiagnosticsReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkDiagnosticsReply\n                     * @property {Array.<particle.ctrl.mesh.IDiagnosticInfo>|null} [nodes] GetNetworkDiagnosticsReply nodes\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkDiagnosticsReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkDiagnosticsReply.\n                     * @implements IGetNetworkDiagnosticsReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set\n                     */\n                    function GetNetworkDiagnosticsReply(properties) {\n                        this.nodes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkDiagnosticsReply nodes.\n                     * @member {Array.<particle.ctrl.mesh.IDiagnosticInfo>} nodes\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsReply.prototype.nodes = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetNetworkDiagnosticsReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply instance\n                     */\n                    GetNetworkDiagnosticsReply.create = function create(properties) {\n                        return new GetNetworkDiagnosticsReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkDiagnosticsReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply} message GetNetworkDiagnosticsReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkDiagnosticsReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.nodes != null && message.nodes.length)\n                            for (var i = 0; i < message.nodes.length; ++i)\n                                $root.particle.ctrl.mesh.DiagnosticInfo.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkDiagnosticsReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkDiagnosticsReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.nodes && message.nodes.length))\n                                    message.nodes = [];\n                                message.nodes.push($root.particle.ctrl.mesh.DiagnosticInfo.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkDiagnosticsReply;\n                })();\n    \n                return mesh;\n            })();\n    \n            /**\n             * InterfaceConfigurationSource enum.\n             * @name particle.ctrl.InterfaceConfigurationSource\n             * @enum {number}\n             * @property {number} NONE=0 NONE value\n             * @property {number} DHCP=1 DHCP value\n             * @property {number} STATIC=2 STATIC value\n             * @property {number} SLAAC=3 SLAAC value\n             * @property {number} DHCPV6=4 DHCPV6 value\n             */\n            ctrl.InterfaceConfigurationSource = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NONE\"] = 0;\n                values[valuesById[1] = \"DHCP\"] = 1;\n                values[valuesById[2] = \"STATIC\"] = 2;\n                values[valuesById[3] = \"SLAAC\"] = 3;\n                values[valuesById[4] = \"DHCPV6\"] = 4;\n                return values;\n            })();\n    \n            ctrl.InterfaceAddress = (function() {\n    \n                /**\n                 * Properties of an InterfaceAddress.\n                 * @memberof particle.ctrl\n                 * @interface IInterfaceAddress\n                 * @property {particle.ctrl.IIpAddress|null} [address] InterfaceAddress address\n                 * @property {number|null} [prefixLength] InterfaceAddress prefixLength\n                 */\n    \n                /**\n                 * Constructs a new InterfaceAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an InterfaceAddress.\n                 * @implements IInterfaceAddress\n                 * @constructor\n                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set\n                 */\n                function InterfaceAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * InterfaceAddress address.\n                 * @member {particle.ctrl.IIpAddress|null|undefined} address\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @instance\n                 */\n                InterfaceAddress.prototype.address = null;\n    \n                /**\n                 * InterfaceAddress prefixLength.\n                 * @member {number} prefixLength\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @instance\n                 */\n                InterfaceAddress.prototype.prefixLength = 0;\n    \n                /**\n                 * Creates a new InterfaceAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress instance\n                 */\n                InterfaceAddress.create = function create(properties) {\n                    return new InterfaceAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified InterfaceAddress message. Does not implicitly {@link particle.ctrl.InterfaceAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {particle.ctrl.IInterfaceAddress} message InterfaceAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                InterfaceAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        $root.particle.ctrl.IpAddress.encode(message.address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.prefixLength != null && Object.hasOwnProperty.call(message, \"prefixLength\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an InterfaceAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                InterfaceAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = $root.particle.ctrl.IpAddress.decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            message.prefixLength = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return InterfaceAddress;\n            })();\n    \n            ctrl.Ipv4Config = (function() {\n    \n                /**\n                 * Properties of an Ipv4Config.\n                 * @memberof particle.ctrl\n                 * @interface IIpv4Config\n                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv4Config addresses\n                 * @property {particle.ctrl.IIpv4Address|null} [peer] Ipv4Config peer\n                 * @property {particle.ctrl.IIpv4Address|null} [gateway] Ipv4Config gateway\n                 * @property {Array.<particle.ctrl.IIpv4Address>|null} [dns] Ipv4Config dns\n                 * @property {particle.ctrl.InterfaceConfigurationSource|null} [source] Ipv4Config source\n                 */\n    \n                /**\n                 * Constructs a new Ipv4Config.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv4Config.\n                 * @implements IIpv4Config\n                 * @constructor\n                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set\n                 */\n                function Ipv4Config(properties) {\n                    this.addresses = [];\n                    this.dns = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv4Config addresses.\n                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.addresses = $util.emptyArray;\n    \n                /**\n                 * Ipv4Config peer.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} peer\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.peer = null;\n    \n                /**\n                 * Ipv4Config gateway.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} gateway\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.gateway = null;\n    \n                /**\n                 * Ipv4Config dns.\n                 * @member {Array.<particle.ctrl.IIpv4Address>} dns\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.dns = $util.emptyArray;\n    \n                /**\n                 * Ipv4Config source.\n                 * @member {particle.ctrl.InterfaceConfigurationSource} source\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.source = 0;\n    \n                /**\n                 * Creates a new Ipv4Config instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config instance\n                 */\n                Ipv4Config.create = function create(properties) {\n                    return new Ipv4Config(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv4Config message. Does not implicitly {@link particle.ctrl.Ipv4Config.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {particle.ctrl.IIpv4Config} message Ipv4Config message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv4Config.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.addresses != null && message.addresses.length)\n                        for (var i = 0; i < message.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.peer != null && Object.hasOwnProperty.call(message, \"peer\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.peer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.gateway != null && Object.hasOwnProperty.call(message, \"gateway\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.gateway, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.dns != null && message.dns.length)\n                        for (var i = 0; i < message.dns.length; ++i)\n                            $root.particle.ctrl.Ipv4Address.encode(message.dns[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.source != null && Object.hasOwnProperty.call(message, \"source\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.source);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv4Config message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv4Config.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Config();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.addresses && message.addresses.length))\n                                message.addresses = [];\n                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            message.peer = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.gateway = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            if (!(message.dns && message.dns.length))\n                                message.dns = [];\n                            message.dns.push($root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            message.source = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv4Config;\n            })();\n    \n            ctrl.Ipv6Config = (function() {\n    \n                /**\n                 * Properties of an Ipv6Config.\n                 * @memberof particle.ctrl\n                 * @interface IIpv6Config\n                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv6Config addresses\n                 * @property {Array.<particle.ctrl.IIpv6Address>|null} [dns] Ipv6Config dns\n                 * @property {particle.ctrl.InterfaceConfigurationSource|null} [source] Ipv6Config source\n                 * @property {particle.ctrl.IIpv6Address|null} [gateway] Ipv6Config gateway\n                 */\n    \n                /**\n                 * Constructs a new Ipv6Config.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv6Config.\n                 * @implements IIpv6Config\n                 * @constructor\n                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set\n                 */\n                function Ipv6Config(properties) {\n                    this.addresses = [];\n                    this.dns = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv6Config addresses.\n                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @instance\n                 */\n                Ipv6Config.prototype.addresses = $util.emptyArray;\n    \n                /**\n                 * Ipv6Config dns.\n                 * @member {Array.<particle.ctrl.IIpv6Address>} dns\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @instance\n                 */\n                Ipv6Config.prototype.dns = $util.emptyArray;\n    \n                /**\n                 * Ipv6Config source.\n                 * @member {particle.ctrl.InterfaceConfigurationSource} source\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @instance\n                 */\n                Ipv6Config.prototype.source = 0;\n    \n                /**\n                 * Ipv6Config gateway.\n                 * @member {particle.ctrl.IIpv6Address|null|undefined} gateway\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @instance\n                 */\n                Ipv6Config.prototype.gateway = null;\n    \n                /**\n                 * Creates a new Ipv6Config instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config instance\n                 */\n                Ipv6Config.create = function create(properties) {\n                    return new Ipv6Config(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv6Config message. Does not implicitly {@link particle.ctrl.Ipv6Config.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {particle.ctrl.IIpv6Config} message Ipv6Config message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv6Config.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.addresses != null && message.addresses.length)\n                        for (var i = 0; i < message.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.dns != null && message.dns.length)\n                        for (var i = 0; i < message.dns.length; ++i)\n                            $root.particle.ctrl.Ipv6Address.encode(message.dns[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.source != null && Object.hasOwnProperty.call(message, \"source\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.source);\n                    if (message.gateway != null && Object.hasOwnProperty.call(message, \"gateway\"))\n                        $root.particle.ctrl.Ipv6Address.encode(message.gateway, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv6Config message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv6Config.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Config();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.addresses && message.addresses.length))\n                                message.addresses = [];\n                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            if (!(message.dns && message.dns.length))\n                                message.dns = [];\n                            message.dns.push($root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.source = reader.int32();\n                            break;\n                        case 4:\n                            message.gateway = $root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv6Config;\n            })();\n    \n            /**\n             * InterfaceFlag enum.\n             * @name particle.ctrl.InterfaceFlag\n             * @enum {number}\n             * @property {number} IFF_NONE=0 IFF_NONE value\n             * @property {number} IFF_UP=1 IFF_UP value\n             * @property {number} IFF_BROADCAST=2 IFF_BROADCAST value\n             * @property {number} IFF_DEBUG=4 IFF_DEBUG value\n             * @property {number} IFF_LOOPBACK=8 IFF_LOOPBACK value\n             * @property {number} IFF_POINTTOPOINT=16 IFF_POINTTOPOINT value\n             * @property {number} IFF_RUNNING=64 IFF_RUNNING value\n             * @property {number} IFF_LOWER_UP=64 IFF_LOWER_UP value\n             * @property {number} IFF_NOARP=128 IFF_NOARP value\n             * @property {number} IFF_PROMISC=256 IFF_PROMISC value\n             * @property {number} IFF_ALLMULTI=512 IFF_ALLMULTI value\n             * @property {number} IFF_MULTICAST=32768 IFF_MULTICAST value\n             * @property {number} IFF_NOND6=65536 IFF_NOND6 value\n             */\n            ctrl.InterfaceFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFF_NONE\"] = 0;\n                values[valuesById[1] = \"IFF_UP\"] = 1;\n                values[valuesById[2] = \"IFF_BROADCAST\"] = 2;\n                values[valuesById[4] = \"IFF_DEBUG\"] = 4;\n                values[valuesById[8] = \"IFF_LOOPBACK\"] = 8;\n                values[valuesById[16] = \"IFF_POINTTOPOINT\"] = 16;\n                values[valuesById[64] = \"IFF_RUNNING\"] = 64;\n                values[\"IFF_LOWER_UP\"] = 64;\n                values[valuesById[128] = \"IFF_NOARP\"] = 128;\n                values[valuesById[256] = \"IFF_PROMISC\"] = 256;\n                values[valuesById[512] = \"IFF_ALLMULTI\"] = 512;\n                values[valuesById[32768] = \"IFF_MULTICAST\"] = 32768;\n                values[valuesById[65536] = \"IFF_NOND6\"] = 65536;\n                return values;\n            })();\n    \n            /**\n             * InterfaceExtFlag enum.\n             * @name particle.ctrl.InterfaceExtFlag\n             * @enum {number}\n             * @property {number} IFXF_NONE=0 IFXF_NONE value\n             * @property {number} IFXF_WOL=16 IFXF_WOL value\n             * @property {number} IFXF_AUTOCONF6=32 IFXF_AUTOCONF6 value\n             * @property {number} IFXF_DHCP=65536 IFXF_DHCP value\n             * @property {number} IFXF_DHCP6=131072 IFXF_DHCP6 value\n             * @property {number} IFXF_AUTOIP=262144 IFXF_AUTOIP value\n             */\n            ctrl.InterfaceExtFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFXF_NONE\"] = 0;\n                values[valuesById[16] = \"IFXF_WOL\"] = 16;\n                values[valuesById[32] = \"IFXF_AUTOCONF6\"] = 32;\n                values[valuesById[65536] = \"IFXF_DHCP\"] = 65536;\n                values[valuesById[131072] = \"IFXF_DHCP6\"] = 131072;\n                values[valuesById[262144] = \"IFXF_AUTOIP\"] = 262144;\n                return values;\n            })();\n    \n            /**\n             * InterfaceType enum.\n             * @name particle.ctrl.InterfaceType\n             * @enum {number}\n             * @property {number} INVALID_INTERFACE_TYPE=0 INVALID_INTERFACE_TYPE value\n             * @property {number} LOOPBACK=1 LOOPBACK value\n             * @property {number} THREAD=2 THREAD value\n             * @property {number} ETHERNET=4 ETHERNET value\n             * @property {number} WIFI=8 WIFI value\n             * @property {number} PPP=16 PPP value\n             */\n            ctrl.InterfaceType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_INTERFACE_TYPE\"] = 0;\n                values[valuesById[1] = \"LOOPBACK\"] = 1;\n                values[valuesById[2] = \"THREAD\"] = 2;\n                values[valuesById[4] = \"ETHERNET\"] = 4;\n                values[valuesById[8] = \"WIFI\"] = 8;\n                values[valuesById[16] = \"PPP\"] = 16;\n                return values;\n            })();\n    \n            ctrl.Interface = (function() {\n    \n                /**\n                 * Properties of an Interface.\n                 * @memberof particle.ctrl\n                 * @interface IInterface\n                 * @property {number|null} [index] Interface index\n                 * @property {string|null} [name] Interface name\n                 * @property {particle.ctrl.InterfaceType|null} [type] Interface type\n                 * @property {number|null} [flags] Interface flags\n                 * @property {number|null} [extFlags] Interface extFlags\n                 * @property {particle.ctrl.IIpv4Config|null} [ipv4Config] Interface ipv4Config\n                 * @property {particle.ctrl.IIpv6Config|null} [ipv6Config] Interface ipv6Config\n                 * @property {Uint8Array|null} [hwAddress] Interface hwAddress\n                 * @property {number|null} [mtu] Interface mtu\n                 * @property {number|null} [metric] Interface metric\n                 * @property {Uint8Array|null} [profile] Interface profile\n                 */\n    \n                /**\n                 * Constructs a new Interface.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Interface.\n                 * @implements IInterface\n                 * @constructor\n                 * @param {particle.ctrl.IInterface=} [properties] Properties to set\n                 */\n                function Interface(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Interface index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.index = 0;\n    \n                /**\n                 * Interface name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.name = \"\";\n    \n                /**\n                 * Interface type.\n                 * @member {particle.ctrl.InterfaceType} type\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.type = 0;\n    \n                /**\n                 * Interface flags.\n                 * @member {number} flags\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.flags = 0;\n    \n                /**\n                 * Interface extFlags.\n                 * @member {number} extFlags\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.extFlags = 0;\n    \n                /**\n                 * Interface ipv4Config.\n                 * @member {particle.ctrl.IIpv4Config|null|undefined} ipv4Config\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.ipv4Config = null;\n    \n                /**\n                 * Interface ipv6Config.\n                 * @member {particle.ctrl.IIpv6Config|null|undefined} ipv6Config\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.ipv6Config = null;\n    \n                /**\n                 * Interface hwAddress.\n                 * @member {Uint8Array} hwAddress\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.hwAddress = $util.newBuffer([]);\n    \n                /**\n                 * Interface mtu.\n                 * @member {number} mtu\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.mtu = 0;\n    \n                /**\n                 * Interface metric.\n                 * @member {number} metric\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.metric = 0;\n    \n                /**\n                 * Interface profile.\n                 * @member {Uint8Array} profile\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.profile = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new Interface instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {particle.ctrl.IInterface=} [properties] Properties to set\n                 * @returns {particle.ctrl.Interface} Interface instance\n                 */\n                Interface.create = function create(properties) {\n                    return new Interface(properties);\n                };\n    \n                /**\n                 * Encodes the specified Interface message. Does not implicitly {@link particle.ctrl.Interface.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {particle.ctrl.IInterface} message Interface message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Interface.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags);\n                    if (message.extFlags != null && Object.hasOwnProperty.call(message, \"extFlags\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.extFlags);\n                    if (message.ipv4Config != null && Object.hasOwnProperty.call(message, \"ipv4Config\"))\n                        $root.particle.ctrl.Ipv4Config.encode(message.ipv4Config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.ipv6Config != null && Object.hasOwnProperty.call(message, \"ipv6Config\"))\n                        $root.particle.ctrl.Ipv6Config.encode(message.ipv6Config, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.hwAddress != null && Object.hasOwnProperty.call(message, \"hwAddress\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.hwAddress);\n                    if (message.mtu != null && Object.hasOwnProperty.call(message, \"mtu\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.mtu);\n                    if (message.metric != null && Object.hasOwnProperty.call(message, \"metric\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.metric);\n                    if (message.profile != null && Object.hasOwnProperty.call(message, \"profile\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).bytes(message.profile);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Interface message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Interface} Interface\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Interface.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Interface();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        case 2:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.type = reader.int32();\n                            break;\n                        case 4:\n                            message.flags = reader.uint32();\n                            break;\n                        case 5:\n                            message.extFlags = reader.uint32();\n                            break;\n                        case 6:\n                            message.ipv4Config = $root.particle.ctrl.Ipv4Config.decode(reader, reader.uint32());\n                            break;\n                        case 7:\n                            message.ipv6Config = $root.particle.ctrl.Ipv6Config.decode(reader, reader.uint32());\n                            break;\n                        case 8:\n                            message.hwAddress = reader.bytes();\n                            break;\n                        case 9:\n                            message.mtu = reader.uint32();\n                            break;\n                        case 10:\n                            message.metric = reader.uint32();\n                            break;\n                        case 11:\n                            message.profile = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Interface;\n            })();\n    \n            ctrl.InterfaceEntry = (function() {\n    \n                /**\n                 * Properties of an InterfaceEntry.\n                 * @memberof particle.ctrl\n                 * @interface IInterfaceEntry\n                 * @property {number|null} [index] InterfaceEntry index\n                 * @property {string|null} [name] InterfaceEntry name\n                 * @property {particle.ctrl.InterfaceType|null} [type] InterfaceEntry type\n                 */\n    \n                /**\n                 * Constructs a new InterfaceEntry.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an InterfaceEntry.\n                 * @implements IInterfaceEntry\n                 * @constructor\n                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set\n                 */\n                function InterfaceEntry(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * InterfaceEntry index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.index = 0;\n    \n                /**\n                 * InterfaceEntry name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.name = \"\";\n    \n                /**\n                 * InterfaceEntry type.\n                 * @member {particle.ctrl.InterfaceType} type\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.type = 0;\n    \n                /**\n                 * Creates a new InterfaceEntry instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set\n                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry instance\n                 */\n                InterfaceEntry.create = function create(properties) {\n                    return new InterfaceEntry(properties);\n                };\n    \n                /**\n                 * Encodes the specified InterfaceEntry message. Does not implicitly {@link particle.ctrl.InterfaceEntry.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {particle.ctrl.IInterfaceEntry} message InterfaceEntry message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                InterfaceEntry.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an InterfaceEntry message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                InterfaceEntry.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceEntry();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        case 2:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.type = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return InterfaceEntry;\n            })();\n    \n            ctrl.GetInterfaceListRequest = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceListRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceListRequest\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceListRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceListRequest.\n                 * @implements IGetInterfaceListRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set\n                 */\n                function GetInterfaceListRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetInterfaceListRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest instance\n                 */\n                GetInterfaceListRequest.create = function create(properties) {\n                    return new GetInterfaceListRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceListRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceListRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListRequest} message GetInterfaceListRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceListRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceListRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceListRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceListRequest;\n            })();\n    \n            ctrl.GetInterfaceListReply = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceListReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceListReply\n                 * @property {Array.<particle.ctrl.IInterfaceEntry>|null} [interfaces] GetInterfaceListReply interfaces\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceListReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceListReply.\n                 * @implements IGetInterfaceListReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set\n                 */\n                function GetInterfaceListReply(properties) {\n                    this.interfaces = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceListReply interfaces.\n                 * @member {Array.<particle.ctrl.IInterfaceEntry>} interfaces\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @instance\n                 */\n                GetInterfaceListReply.prototype.interfaces = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetInterfaceListReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply instance\n                 */\n                GetInterfaceListReply.create = function create(properties) {\n                    return new GetInterfaceListReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceListReply message. Does not implicitly {@link particle.ctrl.GetInterfaceListReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListReply} message GetInterfaceListReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceListReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.interfaces != null && message.interfaces.length)\n                        for (var i = 0; i < message.interfaces.length; ++i)\n                            $root.particle.ctrl.InterfaceEntry.encode(message.interfaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceListReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceListReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.interfaces && message.interfaces.length))\n                                message.interfaces = [];\n                            message.interfaces.push($root.particle.ctrl.InterfaceEntry.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceListReply;\n            })();\n    \n            ctrl.GetInterfaceRequest = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceRequest\n                 * @property {number|null} [index] GetInterfaceRequest index\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceRequest.\n                 * @implements IGetInterfaceRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set\n                 */\n                function GetInterfaceRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceRequest index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @instance\n                 */\n                GetInterfaceRequest.prototype.index = 0;\n    \n                /**\n                 * Creates a new GetInterfaceRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest instance\n                 */\n                GetInterfaceRequest.create = function create(properties) {\n                    return new GetInterfaceRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceRequest} message GetInterfaceRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceRequest;\n            })();\n    \n            ctrl.GetInterfaceReply = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceReply\n                 * @property {particle.ctrl.IInterface|null} [\"interface\"] GetInterfaceReply interface\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceReply.\n                 * @implements IGetInterfaceReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set\n                 */\n                function GetInterfaceReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceReply interface.\n                 * @member {particle.ctrl.IInterface|null|undefined} interface\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @instance\n                 */\n                GetInterfaceReply.prototype[\"interface\"] = null;\n    \n                /**\n                 * Creates a new GetInterfaceReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply instance\n                 */\n                GetInterfaceReply.create = function create(properties) {\n                    return new GetInterfaceReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceReply message. Does not implicitly {@link particle.ctrl.GetInterfaceReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceReply} message GetInterfaceReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        $root.particle.ctrl.Interface.encode(message[\"interface\"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = $root.particle.ctrl.Interface.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceReply;\n            })();\n    \n            ctrl.GetInterfaceStoredConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceStoredConfigurationRequest\n                 * @property {number|null} [index] GetInterfaceStoredConfigurationRequest index\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceStoredConfigurationRequest.\n                 * @implements IGetInterfaceStoredConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 */\n                function GetInterfaceStoredConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceStoredConfigurationRequest index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest\n                 * @instance\n                 */\n                GetInterfaceStoredConfigurationRequest.prototype.index = 0;\n    \n                /**\n                 * Creates a new GetInterfaceStoredConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationRequest} GetInterfaceStoredConfigurationRequest instance\n                 */\n                GetInterfaceStoredConfigurationRequest.create = function create(properties) {\n                    return new GetInterfaceStoredConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceStoredConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationRequest} message GetInterfaceStoredConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceStoredConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationRequest} GetInterfaceStoredConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceStoredConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceStoredConfigurationRequest;\n            })();\n    \n            ctrl.GetInterfaceStoredConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceStoredConfigurationReply\n                 * @property {Array.<particle.ctrl.IInterface>|null} [config] GetInterfaceStoredConfigurationReply config\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceStoredConfigurationReply.\n                 * @implements IGetInterfaceStoredConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 */\n                function GetInterfaceStoredConfigurationReply(properties) {\n                    this.config = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceStoredConfigurationReply config.\n                 * @member {Array.<particle.ctrl.IInterface>} config\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply\n                 * @instance\n                 */\n                GetInterfaceStoredConfigurationReply.prototype.config = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetInterfaceStoredConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationReply} GetInterfaceStoredConfigurationReply instance\n                 */\n                GetInterfaceStoredConfigurationReply.create = function create(properties) {\n                    return new GetInterfaceStoredConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.GetInterfaceStoredConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceStoredConfigurationReply} message GetInterfaceStoredConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceStoredConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && message.config.length)\n                        for (var i = 0; i < message.config.length; ++i)\n                            $root.particle.ctrl.Interface.encode(message.config[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceStoredConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceStoredConfigurationReply} GetInterfaceStoredConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceStoredConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceStoredConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.config && message.config.length))\n                                message.config = [];\n                            message.config.push($root.particle.ctrl.Interface.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceStoredConfigurationReply;\n            })();\n    \n            ctrl.SetInterfaceStoredConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a SetInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetInterfaceStoredConfigurationRequest\n                 * @property {particle.ctrl.IInterface|null} [config] SetInterfaceStoredConfigurationRequest config\n                 */\n    \n                /**\n                 * Constructs a new SetInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetInterfaceStoredConfigurationRequest.\n                 * @implements ISetInterfaceStoredConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 */\n                function SetInterfaceStoredConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetInterfaceStoredConfigurationRequest config.\n                 * @member {particle.ctrl.IInterface|null|undefined} config\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest\n                 * @instance\n                 */\n                SetInterfaceStoredConfigurationRequest.prototype.config = null;\n    \n                /**\n                 * Creates a new SetInterfaceStoredConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationRequest} SetInterfaceStoredConfigurationRequest instance\n                 */\n                SetInterfaceStoredConfigurationRequest.create = function create(properties) {\n                    return new SetInterfaceStoredConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.SetInterfaceStoredConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationRequest} message SetInterfaceStoredConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.Interface.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetInterfaceStoredConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationRequest} SetInterfaceStoredConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetInterfaceStoredConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.Interface.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetInterfaceStoredConfigurationRequest;\n            })();\n    \n            ctrl.SetInterfaceStoredConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a SetInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetInterfaceStoredConfigurationReply\n                 */\n    \n                /**\n                 * Constructs a new SetInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetInterfaceStoredConfigurationReply.\n                 * @implements ISetInterfaceStoredConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 */\n                function SetInterfaceStoredConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetInterfaceStoredConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationReply} SetInterfaceStoredConfigurationReply instance\n                 */\n                SetInterfaceStoredConfigurationReply.create = function create(properties) {\n                    return new SetInterfaceStoredConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.SetInterfaceStoredConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.ISetInterfaceStoredConfigurationReply} message SetInterfaceStoredConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetInterfaceStoredConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetInterfaceStoredConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetInterfaceStoredConfigurationReply} SetInterfaceStoredConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetInterfaceStoredConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetInterfaceStoredConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetInterfaceStoredConfigurationReply;\n            })();\n    \n            ctrl.DeleteInterfaceStoredConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a DeleteInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface IDeleteInterfaceStoredConfigurationRequest\n                 * @property {number|null} [index] DeleteInterfaceStoredConfigurationRequest index\n                 * @property {Uint8Array|null} [profile] DeleteInterfaceStoredConfigurationRequest profile\n                 */\n    \n                /**\n                 * Constructs a new DeleteInterfaceStoredConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DeleteInterfaceStoredConfigurationRequest.\n                 * @implements IDeleteInterfaceStoredConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 */\n                function DeleteInterfaceStoredConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DeleteInterfaceStoredConfigurationRequest index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest\n                 * @instance\n                 */\n                DeleteInterfaceStoredConfigurationRequest.prototype.index = 0;\n    \n                /**\n                 * DeleteInterfaceStoredConfigurationRequest profile.\n                 * @member {Uint8Array} profile\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest\n                 * @instance\n                 */\n                DeleteInterfaceStoredConfigurationRequest.prototype.profile = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new DeleteInterfaceStoredConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationRequest} DeleteInterfaceStoredConfigurationRequest instance\n                 */\n                DeleteInterfaceStoredConfigurationRequest.create = function create(properties) {\n                    return new DeleteInterfaceStoredConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified DeleteInterfaceStoredConfigurationRequest message. Does not implicitly {@link particle.ctrl.DeleteInterfaceStoredConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationRequest} message DeleteInterfaceStoredConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DeleteInterfaceStoredConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    if (message.profile != null && Object.hasOwnProperty.call(message, \"profile\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.profile);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DeleteInterfaceStoredConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationRequest} DeleteInterfaceStoredConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DeleteInterfaceStoredConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DeleteInterfaceStoredConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        case 2:\n                            message.profile = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DeleteInterfaceStoredConfigurationRequest;\n            })();\n    \n            ctrl.DeleteInterfaceStoredConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a DeleteInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface IDeleteInterfaceStoredConfigurationReply\n                 */\n    \n                /**\n                 * Constructs a new DeleteInterfaceStoredConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DeleteInterfaceStoredConfigurationReply.\n                 * @implements IDeleteInterfaceStoredConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 */\n                function DeleteInterfaceStoredConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new DeleteInterfaceStoredConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationReply} DeleteInterfaceStoredConfigurationReply instance\n                 */\n                DeleteInterfaceStoredConfigurationReply.create = function create(properties) {\n                    return new DeleteInterfaceStoredConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified DeleteInterfaceStoredConfigurationReply message. Does not implicitly {@link particle.ctrl.DeleteInterfaceStoredConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.IDeleteInterfaceStoredConfigurationReply} message DeleteInterfaceStoredConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DeleteInterfaceStoredConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DeleteInterfaceStoredConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DeleteInterfaceStoredConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DeleteInterfaceStoredConfigurationReply} DeleteInterfaceStoredConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DeleteInterfaceStoredConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DeleteInterfaceStoredConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DeleteInterfaceStoredConfigurationReply;\n            })();\n    \n            ctrl.NetworkGetStatusRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkGetStatusRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetStatusRequest\n                 * @property {number|null} [\"interface\"] NetworkGetStatusRequest interface\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetStatusRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetStatusRequest.\n                 * @implements INetworkGetStatusRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set\n                 */\n                function NetworkGetStatusRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetStatusRequest interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @instance\n                 */\n                NetworkGetStatusRequest.prototype[\"interface\"] = 0;\n    \n                /**\n                 * Creates a new NetworkGetStatusRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest instance\n                 */\n                NetworkGetStatusRequest.create = function create(properties) {\n                    return new NetworkGetStatusRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetStatusRequest message. Does not implicitly {@link particle.ctrl.NetworkGetStatusRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusRequest} message NetworkGetStatusRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetStatusRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetStatusRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetStatusRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetStatusRequest;\n            })();\n    \n            ctrl.NetworkGetStatusReply = (function() {\n    \n                /**\n                 * Properties of a NetworkGetStatusReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetStatusReply\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetStatusReply config\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetStatusReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetStatusReply.\n                 * @implements INetworkGetStatusReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set\n                 */\n                function NetworkGetStatusReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetStatusReply config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @instance\n                 */\n                NetworkGetStatusReply.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkGetStatusReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply instance\n                 */\n                NetworkGetStatusReply.create = function create(properties) {\n                    return new NetworkGetStatusReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetStatusReply message. Does not implicitly {@link particle.ctrl.NetworkGetStatusReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusReply} message NetworkGetStatusReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetStatusReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetStatusReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetStatusReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetStatusReply;\n            })();\n    \n            ctrl.NetworkGetConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkGetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetConfigurationRequest\n                 * @property {number|null} [\"interface\"] NetworkGetConfigurationRequest interface\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetConfigurationRequest.\n                 * @implements INetworkGetConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set\n                 */\n                function NetworkGetConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetConfigurationRequest interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @instance\n                 */\n                NetworkGetConfigurationRequest.prototype[\"interface\"] = 0;\n    \n                /**\n                 * Creates a new NetworkGetConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest instance\n                 */\n                NetworkGetConfigurationRequest.create = function create(properties) {\n                    return new NetworkGetConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest} message NetworkGetConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkGetConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a NetworkGetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetConfigurationReply\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetConfigurationReply config\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetConfigurationReply.\n                 * @implements INetworkGetConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set\n                 */\n                function NetworkGetConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetConfigurationReply config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @instance\n                 */\n                NetworkGetConfigurationReply.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkGetConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply instance\n                 */\n                NetworkGetConfigurationReply.create = function create(properties) {\n                    return new NetworkGetConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationReply} message NetworkGetConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetConfigurationReply;\n            })();\n    \n            ctrl.NetworkSetConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkSetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkSetConfigurationRequest\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkSetConfigurationRequest config\n                 */\n    \n                /**\n                 * Constructs a new NetworkSetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkSetConfigurationRequest.\n                 * @implements INetworkSetConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set\n                 */\n                function NetworkSetConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkSetConfigurationRequest config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @instance\n                 */\n                NetworkSetConfigurationRequest.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkSetConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest instance\n                 */\n                NetworkSetConfigurationRequest.create = function create(properties) {\n                    return new NetworkSetConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkSetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest} message NetworkSetConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkSetConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkSetConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkSetConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkSetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkSetConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a NetworkSetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkSetConfigurationReply\n                 */\n    \n                /**\n                 * Constructs a new NetworkSetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkSetConfigurationReply.\n                 * @implements INetworkSetConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set\n                 */\n                function NetworkSetConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new NetworkSetConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply instance\n                 */\n                NetworkSetConfigurationReply.create = function create(properties) {\n                    return new NetworkSetConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkSetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationReply} message NetworkSetConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkSetConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkSetConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkSetConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkSetConfigurationReply;\n            })();\n    \n            /**\n             * NetworkState enum.\n             * @name particle.ctrl.NetworkState\n             * @enum {number}\n             * @property {number} NETWORK_STATUS_NONE=0 NETWORK_STATUS_NONE value\n             * @property {number} DOWN=1 DOWN value\n             * @property {number} UP=2 UP value\n             */\n            ctrl.NetworkState = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NETWORK_STATUS_NONE\"] = 0;\n                values[valuesById[1] = \"DOWN\"] = 1;\n                values[valuesById[2] = \"UP\"] = 2;\n                return values;\n            })();\n    \n            ctrl.IPConfiguration = (function() {\n    \n                /**\n                 * Properties of a IPConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface IIPConfiguration\n                 * @property {particle.ctrl.IPConfiguration.Type|null} [type] IPConfiguration type\n                 * @property {particle.ctrl.IIPAddress|null} [address] IPConfiguration address\n                 * @property {particle.ctrl.IIPAddress|null} [netmask] IPConfiguration netmask\n                 * @property {particle.ctrl.IIPAddress|null} [gateway] IPConfiguration gateway\n                 * @property {particle.ctrl.IIPAddress|null} [dhcpServer] IPConfiguration dhcpServer\n                 * @property {string|null} [hostname] IPConfiguration hostname\n                 */\n    \n                /**\n                 * Constructs a new IPConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a IPConfiguration.\n                 * @implements IIPConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set\n                 */\n                function IPConfiguration(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IPConfiguration type.\n                 * @member {particle.ctrl.IPConfiguration.Type} type\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.type = 0;\n    \n                /**\n                 * IPConfiguration address.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} address\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.address = null;\n    \n                /**\n                 * IPConfiguration netmask.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} netmask\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.netmask = null;\n    \n                /**\n                 * IPConfiguration gateway.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} gateway\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.gateway = null;\n    \n                /**\n                 * IPConfiguration dhcpServer.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} dhcpServer\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.dhcpServer = null;\n    \n                /**\n                 * IPConfiguration hostname.\n                 * @member {string} hostname\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.hostname = \"\";\n    \n                /**\n                 * Creates a new IPConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration instance\n                 */\n                IPConfiguration.create = function create(properties) {\n                    return new IPConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified IPConfiguration message. Does not implicitly {@link particle.ctrl.IPConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {particle.ctrl.IIPConfiguration} message IPConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IPConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        $root.particle.ctrl.IPAddress.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.netmask != null && Object.hasOwnProperty.call(message, \"netmask\"))\n                        $root.particle.ctrl.IPAddress.encode(message.netmask, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.gateway != null && Object.hasOwnProperty.call(message, \"gateway\"))\n                        $root.particle.ctrl.IPAddress.encode(message.gateway, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.dhcpServer != null && Object.hasOwnProperty.call(message, \"dhcpServer\"))\n                        $root.particle.ctrl.IPAddress.encode(message.dhcpServer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.hostname != null && Object.hasOwnProperty.call(message, \"hostname\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.hostname);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a IPConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IPConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.address = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.netmask = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            message.gateway = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.dhcpServer = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.hostname = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Type enum.\n                 * @name particle.ctrl.IPConfiguration.Type\n                 * @enum {number}\n                 * @property {number} NONE=0 NONE value\n                 * @property {number} DHCP=1 DHCP value\n                 * @property {number} STATIC=2 STATIC value\n                 */\n                IPConfiguration.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"DHCP\"] = 1;\n                    values[valuesById[2] = \"STATIC\"] = 2;\n                    return values;\n                })();\n    \n                return IPConfiguration;\n            })();\n    \n            ctrl.DNSConfiguration = (function() {\n    \n                /**\n                 * Properties of a DNSConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface IDNSConfiguration\n                 * @property {Array.<particle.ctrl.IIPAddress>|null} [servers] DNSConfiguration servers\n                 */\n    \n                /**\n                 * Constructs a new DNSConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DNSConfiguration.\n                 * @implements IDNSConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set\n                 */\n                function DNSConfiguration(properties) {\n                    this.servers = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DNSConfiguration servers.\n                 * @member {Array.<particle.ctrl.IIPAddress>} servers\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @instance\n                 */\n                DNSConfiguration.prototype.servers = $util.emptyArray;\n    \n                /**\n                 * Creates a new DNSConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration instance\n                 */\n                DNSConfiguration.create = function create(properties) {\n                    return new DNSConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified DNSConfiguration message. Does not implicitly {@link particle.ctrl.DNSConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {particle.ctrl.IDNSConfiguration} message DNSConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DNSConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.servers != null && message.servers.length)\n                        for (var i = 0; i < message.servers.length; ++i)\n                            $root.particle.ctrl.IPAddress.encode(message.servers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DNSConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DNSConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DNSConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.servers && message.servers.length))\n                                message.servers = [];\n                            message.servers.push($root.particle.ctrl.IPAddress.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DNSConfiguration;\n            })();\n    \n            ctrl.NetworkConfiguration = (function() {\n    \n                /**\n                 * Properties of a NetworkConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface INetworkConfiguration\n                 * @property {number|null} [\"interface\"] NetworkConfiguration interface\n                 * @property {particle.ctrl.NetworkState|null} [state] NetworkConfiguration state\n                 * @property {string|null} [name] NetworkConfiguration name\n                 * @property {Uint8Array|null} [mac] NetworkConfiguration mac\n                 * @property {particle.ctrl.IIPConfiguration|null} [ipconfig] NetworkConfiguration ipconfig\n                 * @property {particle.ctrl.IDNSConfiguration|null} [dnsconfig] NetworkConfiguration dnsconfig\n                 */\n    \n                /**\n                 * Constructs a new NetworkConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkConfiguration.\n                 * @implements INetworkConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set\n                 */\n                function NetworkConfiguration(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkConfiguration interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype[\"interface\"] = 0;\n    \n                /**\n                 * NetworkConfiguration state.\n                 * @member {particle.ctrl.NetworkState} state\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.state = 0;\n    \n                /**\n                 * NetworkConfiguration name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.name = \"\";\n    \n                /**\n                 * NetworkConfiguration mac.\n                 * @member {Uint8Array} mac\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.mac = $util.newBuffer([]);\n    \n                /**\n                 * NetworkConfiguration ipconfig.\n                 * @member {particle.ctrl.IIPConfiguration|null|undefined} ipconfig\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.ipconfig = null;\n    \n                /**\n                 * NetworkConfiguration dnsconfig.\n                 * @member {particle.ctrl.IDNSConfiguration|null|undefined} dnsconfig\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.dnsconfig = null;\n    \n                /**\n                 * Creates a new NetworkConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration instance\n                 */\n                NetworkConfiguration.create = function create(properties) {\n                    return new NetworkConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkConfiguration message. Does not implicitly {@link particle.ctrl.NetworkConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {particle.ctrl.INetworkConfiguration} message NetworkConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);\n                    if (message.mac != null && Object.hasOwnProperty.call(message, \"mac\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mac);\n                    if (message.ipconfig != null && Object.hasOwnProperty.call(message, \"ipconfig\"))\n                        $root.particle.ctrl.IPConfiguration.encode(message.ipconfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.dnsconfig != null && Object.hasOwnProperty.call(message, \"dnsconfig\"))\n                        $root.particle.ctrl.DNSConfiguration.encode(message.dnsconfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        case 2:\n                            message.state = reader.int32();\n                            break;\n                        case 3:\n                            message.name = reader.string();\n                            break;\n                        case 4:\n                            message.mac = reader.bytes();\n                            break;\n                        case 5:\n                            message.ipconfig = $root.particle.ctrl.IPConfiguration.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.dnsconfig = $root.particle.ctrl.DNSConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkConfiguration;\n            })();\n    \n            /**\n             * StorageType enum.\n             * @name particle.ctrl.StorageType\n             * @enum {number}\n             * @property {number} INVALID_STORAGE=0 INVALID_STORAGE value\n             * @property {number} INTERNAL=1 INTERNAL value\n             */\n            ctrl.StorageType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_STORAGE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * SectionType enum.\n             * @name particle.ctrl.SectionType\n             * @enum {number}\n             * @property {number} INVALID_SECTION=0 INVALID_SECTION value\n             * @property {number} FIRMWARE=1 FIRMWARE value\n             * @property {number} OTA_BACKUP=2 OTA_BACKUP value\n             * @property {number} FACTORY_BACKUP=3 FACTORY_BACKUP value\n             * @property {number} CONFIG=4 CONFIG value\n             * @property {number} EEPROM=5 EEPROM value\n             */\n            ctrl.SectionType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECTION\"] = 0;\n                values[valuesById[1] = \"FIRMWARE\"] = 1;\n                values[valuesById[2] = \"OTA_BACKUP\"] = 2;\n                values[valuesById[3] = \"FACTORY_BACKUP\"] = 3;\n                values[valuesById[4] = \"CONFIG\"] = 4;\n                values[valuesById[5] = \"EEPROM\"] = 5;\n                return values;\n            })();\n    \n            /**\n             * FirmwareModuleType enum.\n             * @name particle.ctrl.FirmwareModuleType\n             * @enum {number}\n             * @property {number} INVALID_FIRMWARE_MODULE=0 INVALID_FIRMWARE_MODULE value\n             * @property {number} BOOTLOADER=1 BOOTLOADER value\n             * @property {number} SYSTEM_PART=2 SYSTEM_PART value\n             * @property {number} USER_PART=3 USER_PART value\n             * @property {number} MONO_FIRMWARE=4 MONO_FIRMWARE value\n             * @property {number} NCP_FIRMWARE=5 NCP_FIRMWARE value\n             * @property {number} RADIO_STACK=6 RADIO_STACK value\n             */\n            ctrl.FirmwareModuleType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FIRMWARE_MODULE\"] = 0;\n                values[valuesById[1] = \"BOOTLOADER\"] = 1;\n                values[valuesById[2] = \"SYSTEM_PART\"] = 2;\n                values[valuesById[3] = \"USER_PART\"] = 3;\n                values[valuesById[4] = \"MONO_FIRMWARE\"] = 4;\n                values[valuesById[5] = \"NCP_FIRMWARE\"] = 5;\n                values[valuesById[6] = \"RADIO_STACK\"] = 6;\n                return values;\n            })();\n    \n            /**\n             * FirmwareModuleValidityFlag enum.\n             * @name particle.ctrl.FirmwareModuleValidityFlag\n             * @enum {number}\n             * @property {number} NO_VALIDATION_ERRORS=0 NO_VALIDATION_ERRORS value\n             * @property {number} INTEGRITY_CHECK_FAILED=1 INTEGRITY_CHECK_FAILED value\n             * @property {number} DEPENDENCY_CHECK_FAILED=2 DEPENDENCY_CHECK_FAILED value\n             */\n            ctrl.FirmwareModuleValidityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_VALIDATION_ERRORS\"] = 0;\n                values[valuesById[1] = \"INTEGRITY_CHECK_FAILED\"] = 1;\n                values[valuesById[2] = \"DEPENDENCY_CHECK_FAILED\"] = 2;\n                return values;\n            })();\n    \n            /**\n             * SectionFlag enum.\n             * @name particle.ctrl.SectionFlag\n             * @enum {number}\n             * @property {number} NO_SECTION_FLAGS=0 NO_SECTION_FLAGS value\n             * @property {number} CAN_READ=1 CAN_READ value\n             * @property {number} CAN_WRITE=2 CAN_WRITE value\n             * @property {number} CAN_CLEAR=4 CAN_CLEAR value\n             * @property {number} CAN_GET_SIZE=8 CAN_GET_SIZE value\n             * @property {number} NEED_CLEAR=16 NEED_CLEAR value\n             */\n            ctrl.SectionFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SECTION_FLAGS\"] = 0;\n                values[valuesById[1] = \"CAN_READ\"] = 1;\n                values[valuesById[2] = \"CAN_WRITE\"] = 2;\n                values[valuesById[4] = \"CAN_CLEAR\"] = 4;\n                values[valuesById[8] = \"CAN_GET_SIZE\"] = 8;\n                values[valuesById[16] = \"NEED_CLEAR\"] = 16;\n                return values;\n            })();\n    \n            /**\n             * FileFormat enum.\n             * @name particle.ctrl.FileFormat\n             * @enum {number}\n             * @property {number} BIN=0 BIN value\n             * @property {number} MINIZ=1 MINIZ value\n             */\n            ctrl.FileFormat = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"BIN\"] = 0;\n                values[valuesById[1] = \"MINIZ\"] = 1;\n                return values;\n            })();\n    \n            ctrl.StartFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a StartFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartFirmwareUpdateRequest\n                 * @property {number|null} [size] StartFirmwareUpdateRequest size\n                 * @property {particle.ctrl.FileFormat|null} [format] StartFirmwareUpdateRequest format\n                 */\n    \n                /**\n                 * Constructs a new StartFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartFirmwareUpdateRequest.\n                 * @implements IStartFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function StartFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * StartFirmwareUpdateRequest size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @instance\n                 */\n                StartFirmwareUpdateRequest.prototype.size = 0;\n    \n                /**\n                 * StartFirmwareUpdateRequest format.\n                 * @member {particle.ctrl.FileFormat} format\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @instance\n                 */\n                StartFirmwareUpdateRequest.prototype.format = 0;\n    \n                /**\n                 * Creates a new StartFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest instance\n                 */\n                StartFirmwareUpdateRequest.create = function create(properties) {\n                    return new StartFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest} message StartFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);\n                    if (message.format != null && Object.hasOwnProperty.call(message, \"format\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.format);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.size = reader.uint32();\n                            break;\n                        case 2:\n                            message.format = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartFirmwareUpdateRequest;\n            })();\n    \n            ctrl.StartFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a StartFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartFirmwareUpdateReply\n                 * @property {number|null} [chunkSize] StartFirmwareUpdateReply chunkSize\n                 */\n    \n                /**\n                 * Constructs a new StartFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartFirmwareUpdateReply.\n                 * @implements IStartFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function StartFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * StartFirmwareUpdateReply chunkSize.\n                 * @member {number} chunkSize\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @instance\n                 */\n                StartFirmwareUpdateReply.prototype.chunkSize = 0;\n    \n                /**\n                 * Creates a new StartFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply instance\n                 */\n                StartFirmwareUpdateReply.create = function create(properties) {\n                    return new StartFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply} message StartFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.chunkSize != null && Object.hasOwnProperty.call(message, \"chunkSize\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chunkSize);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.chunkSize = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartFirmwareUpdateReply;\n            })();\n    \n            ctrl.FinishFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a FinishFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface IFinishFirmwareUpdateRequest\n                 * @property {boolean|null} [validateOnly] FinishFirmwareUpdateRequest validateOnly\n                 */\n    \n                /**\n                 * Constructs a new FinishFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FinishFirmwareUpdateRequest.\n                 * @implements IFinishFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function FinishFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FinishFirmwareUpdateRequest validateOnly.\n                 * @member {boolean} validateOnly\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @instance\n                 */\n                FinishFirmwareUpdateRequest.prototype.validateOnly = false;\n    \n                /**\n                 * Creates a new FinishFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest instance\n                 */\n                FinishFirmwareUpdateRequest.create = function create(properties) {\n                    return new FinishFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified FinishFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest} message FinishFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FinishFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.validateOnly != null && Object.hasOwnProperty.call(message, \"validateOnly\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.validateOnly);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FinishFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FinishFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.validateOnly = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FinishFirmwareUpdateRequest;\n            })();\n    \n            ctrl.FinishFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a FinishFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface IFinishFirmwareUpdateReply\n                 */\n    \n                /**\n                 * Constructs a new FinishFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FinishFirmwareUpdateReply.\n                 * @implements IFinishFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function FinishFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new FinishFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply instance\n                 */\n                FinishFirmwareUpdateReply.create = function create(properties) {\n                    return new FinishFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified FinishFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply} message FinishFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FinishFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FinishFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FinishFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FinishFirmwareUpdateReply;\n            })();\n    \n            ctrl.CancelFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a CancelFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface ICancelFirmwareUpdateRequest\n                 */\n    \n                /**\n                 * Constructs a new CancelFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a CancelFirmwareUpdateRequest.\n                 * @implements ICancelFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function CancelFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new CancelFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest instance\n                 */\n                CancelFirmwareUpdateRequest.create = function create(properties) {\n                    return new CancelFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified CancelFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest} message CancelFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                CancelFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a CancelFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                CancelFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return CancelFirmwareUpdateRequest;\n            })();\n    \n            ctrl.CancelFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a CancelFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface ICancelFirmwareUpdateReply\n                 */\n    \n                /**\n                 * Constructs a new CancelFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a CancelFirmwareUpdateReply.\n                 * @implements ICancelFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function CancelFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new CancelFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply instance\n                 */\n                CancelFirmwareUpdateReply.create = function create(properties) {\n                    return new CancelFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified CancelFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply} message CancelFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                CancelFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a CancelFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                CancelFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return CancelFirmwareUpdateReply;\n            })();\n    \n            ctrl.FirmwareUpdateDataRequest = (function() {\n    \n                /**\n                 * Properties of a FirmwareUpdateDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IFirmwareUpdateDataRequest\n                 * @property {Uint8Array|null} [data] FirmwareUpdateDataRequest data\n                 */\n    \n                /**\n                 * Constructs a new FirmwareUpdateDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FirmwareUpdateDataRequest.\n                 * @implements IFirmwareUpdateDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set\n                 */\n                function FirmwareUpdateDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FirmwareUpdateDataRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @instance\n                 */\n                FirmwareUpdateDataRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new FirmwareUpdateDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest instance\n                 */\n                FirmwareUpdateDataRequest.create = function create(properties) {\n                    return new FirmwareUpdateDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareUpdateDataRequest message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest} message FirmwareUpdateDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareUpdateDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareUpdateDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareUpdateDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareUpdateDataRequest;\n            })();\n    \n            ctrl.FirmwareUpdateDataReply = (function() {\n    \n                /**\n                 * Properties of a FirmwareUpdateDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IFirmwareUpdateDataReply\n                 */\n    \n                /**\n                 * Constructs a new FirmwareUpdateDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FirmwareUpdateDataReply.\n                 * @implements IFirmwareUpdateDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set\n                 */\n                function FirmwareUpdateDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new FirmwareUpdateDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply instance\n                 */\n                FirmwareUpdateDataReply.create = function create(properties) {\n                    return new FirmwareUpdateDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareUpdateDataReply message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply} message FirmwareUpdateDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareUpdateDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareUpdateDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareUpdateDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareUpdateDataReply;\n            })();\n    \n            ctrl.DescribeStorageRequest = (function() {\n    \n                /**\n                 * Properties of a DescribeStorageRequest.\n                 * @memberof particle.ctrl\n                 * @interface IDescribeStorageRequest\n                 */\n    \n                /**\n                 * Constructs a new DescribeStorageRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DescribeStorageRequest.\n                 * @implements IDescribeStorageRequest\n                 * @constructor\n                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set\n                 */\n                function DescribeStorageRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new DescribeStorageRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest instance\n                 */\n                DescribeStorageRequest.create = function create(properties) {\n                    return new DescribeStorageRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescribeStorageRequest message. Does not implicitly {@link particle.ctrl.DescribeStorageRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageRequest} message DescribeStorageRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescribeStorageRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescribeStorageRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescribeStorageRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DescribeStorageRequest;\n            })();\n    \n            ctrl.DescribeStorageReply = (function() {\n    \n                /**\n                 * Properties of a DescribeStorageReply.\n                 * @memberof particle.ctrl\n                 * @interface IDescribeStorageReply\n                 * @property {Array.<particle.ctrl.DescribeStorageReply.IStorage>|null} [storage] DescribeStorageReply storage\n                 */\n    \n                /**\n                 * Constructs a new DescribeStorageReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DescribeStorageReply.\n                 * @implements IDescribeStorageReply\n                 * @constructor\n                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set\n                 */\n                function DescribeStorageReply(properties) {\n                    this.storage = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DescribeStorageReply storage.\n                 * @member {Array.<particle.ctrl.DescribeStorageReply.IStorage>} storage\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @instance\n                 */\n                DescribeStorageReply.prototype.storage = $util.emptyArray;\n    \n                /**\n                 * Creates a new DescribeStorageReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply instance\n                 */\n                DescribeStorageReply.create = function create(properties) {\n                    return new DescribeStorageReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescribeStorageReply message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageReply} message DescribeStorageReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescribeStorageReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && message.storage.length)\n                        for (var i = 0; i < message.storage.length; ++i)\n                            $root.particle.ctrl.DescribeStorageReply.Storage.encode(message.storage[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescribeStorageReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescribeStorageReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.storage && message.storage.length))\n                                message.storage = [];\n                            message.storage.push($root.particle.ctrl.DescribeStorageReply.Storage.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                DescribeStorageReply.Section = (function() {\n    \n                    /**\n                     * Properties of a Section.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @interface ISection\n                     * @property {particle.ctrl.SectionType|null} [type] Section type\n                     * @property {number|null} [size] Section size\n                     * @property {number|null} [flags] Section flags\n                     * @property {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null} [firmwareModule] Section firmwareModule\n                     */\n    \n                    /**\n                     * Constructs a new Section.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @classdesc Represents a Section.\n                     * @implements ISection\n                     * @constructor\n                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set\n                     */\n                    function Section(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Section type.\n                     * @member {particle.ctrl.SectionType} type\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.type = 0;\n    \n                    /**\n                     * Section size.\n                     * @member {number} size\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.size = 0;\n    \n                    /**\n                     * Section flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.flags = 0;\n    \n                    /**\n                     * Section firmwareModule.\n                     * @member {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null|undefined} firmwareModule\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.firmwareModule = null;\n    \n                    /**\n                     * Creates a new Section instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set\n                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section instance\n                     */\n                    Section.create = function create(properties) {\n                        return new Section(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Section message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.ISection} message Section message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Section.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.size);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);\n                        if (message.firmwareModule != null && Object.hasOwnProperty.call(message, \"firmwareModule\"))\n                            $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.encode(message.firmwareModule, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Section message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Section.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.size = reader.uint32();\n                                break;\n                            case 3:\n                                message.flags = reader.uint32();\n                                break;\n                            case 4:\n                                message.firmwareModule = $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    Section.FirmwareModule = (function() {\n    \n                        /**\n                         * Properties of a FirmwareModule.\n                         * @memberof particle.ctrl.DescribeStorageReply.Section\n                         * @interface IFirmwareModule\n                         * @property {particle.ctrl.FirmwareModuleType|null} [type] FirmwareModule type\n                         * @property {number|null} [index] FirmwareModule index\n                         */\n    \n                        /**\n                         * Constructs a new FirmwareModule.\n                         * @memberof particle.ctrl.DescribeStorageReply.Section\n                         * @classdesc Represents a FirmwareModule.\n                         * @implements IFirmwareModule\n                         * @constructor\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set\n                         */\n                        function FirmwareModule(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * FirmwareModule type.\n                         * @member {particle.ctrl.FirmwareModuleType} type\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @instance\n                         */\n                        FirmwareModule.prototype.type = 0;\n    \n                        /**\n                         * FirmwareModule index.\n                         * @member {number} index\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @instance\n                         */\n                        FirmwareModule.prototype.index = 0;\n    \n                        /**\n                         * Creates a new FirmwareModule instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set\n                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule instance\n                         */\n                        FirmwareModule.create = function create(properties) {\n                            return new FirmwareModule(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified FirmwareModule message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.FirmwareModule.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule} message FirmwareModule message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        FirmwareModule.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                            if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a FirmwareModule message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        FirmwareModule.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.type = reader.int32();\n                                    break;\n                                case 2:\n                                    message.index = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return FirmwareModule;\n                    })();\n    \n                    return Section;\n                })();\n    \n                DescribeStorageReply.Storage = (function() {\n    \n                    /**\n                     * Properties of a Storage.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @interface IStorage\n                     * @property {particle.ctrl.StorageType|null} [type] Storage type\n                     * @property {number|null} [flags] Storage flags\n                     * @property {Array.<particle.ctrl.DescribeStorageReply.ISection>|null} [sections] Storage sections\n                     */\n    \n                    /**\n                     * Constructs a new Storage.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @classdesc Represents a Storage.\n                     * @implements IStorage\n                     * @constructor\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set\n                     */\n                    function Storage(properties) {\n                        this.sections = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Storage type.\n                     * @member {particle.ctrl.StorageType} type\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.type = 0;\n    \n                    /**\n                     * Storage flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.flags = 0;\n    \n                    /**\n                     * Storage sections.\n                     * @member {Array.<particle.ctrl.DescribeStorageReply.ISection>} sections\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.sections = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Storage instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set\n                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage instance\n                     */\n                    Storage.create = function create(properties) {\n                        return new Storage(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Storage message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Storage.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage} message Storage message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Storage.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);\n                        if (message.sections != null && message.sections.length)\n                            for (var i = 0; i < message.sections.length; ++i)\n                                $root.particle.ctrl.DescribeStorageReply.Section.encode(message.sections[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Storage message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Storage.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Storage();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.flags = reader.uint32();\n                                break;\n                            case 3:\n                                if (!(message.sections && message.sections.length))\n                                    message.sections = [];\n                                message.sections.push($root.particle.ctrl.DescribeStorageReply.Section.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Storage;\n                })();\n    \n                return DescribeStorageReply;\n            })();\n    \n            ctrl.ReadSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a ReadSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IReadSectionDataRequest\n                 * @property {number|null} [storage] ReadSectionDataRequest storage\n                 * @property {number|null} [section] ReadSectionDataRequest section\n                 * @property {number|null} [offset] ReadSectionDataRequest offset\n                 * @property {number|null} [size] ReadSectionDataRequest size\n                 */\n    \n                /**\n                 * Constructs a new ReadSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ReadSectionDataRequest.\n                 * @implements IReadSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set\n                 */\n                function ReadSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ReadSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * ReadSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * ReadSectionDataRequest offset.\n                 * @member {number} offset\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.offset = 0;\n    \n                /**\n                 * ReadSectionDataRequest size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.size = 0;\n    \n                /**\n                 * Creates a new ReadSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest instance\n                 */\n                ReadSectionDataRequest.create = function create(properties) {\n                    return new ReadSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified ReadSectionDataRequest message. Does not implicitly {@link particle.ctrl.ReadSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataRequest} message ReadSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ReadSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ReadSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ReadSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        case 3:\n                            message.offset = reader.uint32();\n                            break;\n                        case 4:\n                            message.size = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ReadSectionDataRequest;\n            })();\n    \n            ctrl.ReadSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a ReadSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IReadSectionDataReply\n                 * @property {Uint8Array|null} [data] ReadSectionDataReply data\n                 */\n    \n                /**\n                 * Constructs a new ReadSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ReadSectionDataReply.\n                 * @implements IReadSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set\n                 */\n                function ReadSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ReadSectionDataReply data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @instance\n                 */\n                ReadSectionDataReply.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new ReadSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply instance\n                 */\n                ReadSectionDataReply.create = function create(properties) {\n                    return new ReadSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified ReadSectionDataReply message. Does not implicitly {@link particle.ctrl.ReadSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataReply} message ReadSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ReadSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ReadSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ReadSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ReadSectionDataReply;\n            })();\n    \n            ctrl.WriteSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a WriteSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWriteSectionDataRequest\n                 * @property {number|null} [storage] WriteSectionDataRequest storage\n                 * @property {number|null} [section] WriteSectionDataRequest section\n                 * @property {number|null} [offset] WriteSectionDataRequest offset\n                 * @property {Uint8Array|null} [data] WriteSectionDataRequest data\n                 */\n    \n                /**\n                 * Constructs a new WriteSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WriteSectionDataRequest.\n                 * @implements IWriteSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set\n                 */\n                function WriteSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WriteSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * WriteSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * WriteSectionDataRequest offset.\n                 * @member {number} offset\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.offset = 0;\n    \n                /**\n                 * WriteSectionDataRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new WriteSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest instance\n                 */\n                WriteSectionDataRequest.create = function create(properties) {\n                    return new WriteSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WriteSectionDataRequest message. Does not implicitly {@link particle.ctrl.WriteSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataRequest} message WriteSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WriteSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WriteSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WriteSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        case 3:\n                            message.offset = reader.uint32();\n                            break;\n                        case 4:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WriteSectionDataRequest;\n            })();\n    \n            ctrl.WriteSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a WriteSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IWriteSectionDataReply\n                 */\n    \n                /**\n                 * Constructs a new WriteSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WriteSectionDataReply.\n                 * @implements IWriteSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set\n                 */\n                function WriteSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WriteSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply instance\n                 */\n                WriteSectionDataReply.create = function create(properties) {\n                    return new WriteSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WriteSectionDataReply message. Does not implicitly {@link particle.ctrl.WriteSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataReply} message WriteSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WriteSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WriteSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WriteSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WriteSectionDataReply;\n            })();\n    \n            ctrl.ClearSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a ClearSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IClearSectionDataRequest\n                 * @property {number|null} [storage] ClearSectionDataRequest storage\n                 * @property {number|null} [section] ClearSectionDataRequest section\n                 */\n    \n                /**\n                 * Constructs a new ClearSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ClearSectionDataRequest.\n                 * @implements IClearSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set\n                 */\n                function ClearSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ClearSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @instance\n                 */\n                ClearSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * ClearSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @instance\n                 */\n                ClearSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * Creates a new ClearSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest instance\n                 */\n                ClearSectionDataRequest.create = function create(properties) {\n                    return new ClearSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified ClearSectionDataRequest message. Does not implicitly {@link particle.ctrl.ClearSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataRequest} message ClearSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClearSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ClearSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClearSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ClearSectionDataRequest;\n            })();\n    \n            ctrl.ClearSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a ClearSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IClearSectionDataReply\n                 */\n    \n                /**\n                 * Constructs a new ClearSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ClearSectionDataReply.\n                 * @implements IClearSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set\n                 */\n                function ClearSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new ClearSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply instance\n                 */\n                ClearSectionDataReply.create = function create(properties) {\n                    return new ClearSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified ClearSectionDataReply message. Does not implicitly {@link particle.ctrl.ClearSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataReply} message ClearSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClearSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ClearSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClearSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ClearSectionDataReply;\n            })();\n    \n            ctrl.GetSectionDataSizeRequest = (function() {\n    \n                /**\n                 * Properties of a GetSectionDataSizeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSectionDataSizeRequest\n                 * @property {number|null} [storage] GetSectionDataSizeRequest storage\n                 * @property {number|null} [section] GetSectionDataSizeRequest section\n                 */\n    \n                /**\n                 * Constructs a new GetSectionDataSizeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSectionDataSizeRequest.\n                 * @implements IGetSectionDataSizeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set\n                 */\n                function GetSectionDataSizeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSectionDataSizeRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @instance\n                 */\n                GetSectionDataSizeRequest.prototype.storage = 0;\n    \n                /**\n                 * GetSectionDataSizeRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @instance\n                 */\n                GetSectionDataSizeRequest.prototype.section = 0;\n    \n                /**\n                 * Creates a new GetSectionDataSizeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest instance\n                 */\n                GetSectionDataSizeRequest.create = function create(properties) {\n                    return new GetSectionDataSizeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSectionDataSizeRequest message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest} message GetSectionDataSizeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSectionDataSizeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSectionDataSizeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSectionDataSizeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSectionDataSizeRequest;\n            })();\n    \n            ctrl.GetSectionDataSizeReply = (function() {\n    \n                /**\n                 * Properties of a GetSectionDataSizeReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSectionDataSizeReply\n                 * @property {number|null} [size] GetSectionDataSizeReply size\n                 */\n    \n                /**\n                 * Constructs a new GetSectionDataSizeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSectionDataSizeReply.\n                 * @implements IGetSectionDataSizeReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set\n                 */\n                function GetSectionDataSizeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSectionDataSizeReply size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @instance\n                 */\n                GetSectionDataSizeReply.prototype.size = 0;\n    \n                /**\n                 * Creates a new GetSectionDataSizeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply instance\n                 */\n                GetSectionDataSizeReply.create = function create(properties) {\n                    return new GetSectionDataSizeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSectionDataSizeReply message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeReply} message GetSectionDataSizeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSectionDataSizeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSectionDataSizeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSectionDataSizeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.size = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSectionDataSizeReply;\n            })();\n    \n            ctrl.GetModuleInfoRequest = (function() {\n    \n                /**\n                 * Properties of a GetModuleInfoRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetModuleInfoRequest\n                 */\n    \n                /**\n                 * Constructs a new GetModuleInfoRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Get firmware module info.\n                 * @implements IGetModuleInfoRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set\n                 */\n                function GetModuleInfoRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetModuleInfoRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest instance\n                 */\n                GetModuleInfoRequest.create = function create(properties) {\n                    return new GetModuleInfoRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetModuleInfoRequest message. Does not implicitly {@link particle.ctrl.GetModuleInfoRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoRequest} message GetModuleInfoRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetModuleInfoRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetModuleInfoRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetModuleInfoRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetModuleInfoRequest;\n            })();\n    \n            ctrl.GetModuleInfoReply = (function() {\n    \n                /**\n                 * Properties of a GetModuleInfoReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetModuleInfoReply\n                 * @property {Array.<particle.ctrl.GetModuleInfoReply.IModule>|null} [modulesDeprecated] GetModuleInfoReply modulesDeprecated\n                 * @property {Array.<particle.cloud.IFirmwareModule>|null} [modules] < Firmware modules\n                 */\n    \n                /**\n                 * Constructs a new GetModuleInfoReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetModuleInfoReply.\n                 * @implements IGetModuleInfoReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set\n                 */\n                function GetModuleInfoReply(properties) {\n                    this.modulesDeprecated = [];\n                    this.modules = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetModuleInfoReply modulesDeprecated.\n                 * @member {Array.<particle.ctrl.GetModuleInfoReply.IModule>} modulesDeprecated\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @instance\n                 */\n                GetModuleInfoReply.prototype.modulesDeprecated = $util.emptyArray;\n    \n                /**\n                 * < Firmware modules\n                 * @member {Array.<particle.cloud.IFirmwareModule>} modules\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @instance\n                 */\n                GetModuleInfoReply.prototype.modules = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetModuleInfoReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply instance\n                 */\n                GetModuleInfoReply.create = function create(properties) {\n                    return new GetModuleInfoReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetModuleInfoReply message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoReply} message GetModuleInfoReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetModuleInfoReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.modulesDeprecated != null && message.modulesDeprecated.length)\n                        for (var i = 0; i < message.modulesDeprecated.length; ++i)\n                            $root.particle.ctrl.GetModuleInfoReply.Module.encode(message.modulesDeprecated[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.modules != null && message.modules.length)\n                        for (var i = 0; i < message.modules.length; ++i)\n                            $root.particle.cloud.FirmwareModule.encode(message.modules[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetModuleInfoReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetModuleInfoReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.modulesDeprecated && message.modulesDeprecated.length))\n                                message.modulesDeprecated = [];\n                            message.modulesDeprecated.push($root.particle.ctrl.GetModuleInfoReply.Module.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            if (!(message.modules && message.modules.length))\n                                message.modules = [];\n                            message.modules.push($root.particle.cloud.FirmwareModule.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                GetModuleInfoReply.Dependency = (function() {\n    \n                    /**\n                     * Properties of a Dependency.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @interface IDependency\n                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Dependency type\n                     * @property {number|null} [index] Dependency index\n                     * @property {number|null} [version] Dependency version\n                     */\n    \n                    /**\n                     * Constructs a new Dependency.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @classdesc Represents a Dependency.\n                     * @implements IDependency\n                     * @constructor\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set\n                     */\n                    function Dependency(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Dependency type.\n                     * @member {particle.ctrl.FirmwareModuleType} type\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.type = 0;\n    \n                    /**\n                     * Dependency index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.index = 0;\n    \n                    /**\n                     * Dependency version.\n                     * @member {number} version\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.version = 0;\n    \n                    /**\n                     * Creates a new Dependency instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set\n                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency instance\n                     */\n                    Dependency.create = function create(properties) {\n                        return new Dependency(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Dependency message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Dependency.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency} message Dependency message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Dependency.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Dependency message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Dependency.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Dependency();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.index = reader.uint32();\n                                break;\n                            case 3:\n                                message.version = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Dependency;\n                })();\n    \n                GetModuleInfoReply.Module = (function() {\n    \n                    /**\n                     * Properties of a Module.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @interface IModule\n                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Module type\n                     * @property {number|null} [index] Module index\n                     * @property {number|null} [version] Module version\n                     * @property {number|null} [size] Module size\n                     * @property {number|null} [validity] Module validity\n                     * @property {Array.<particle.ctrl.GetModuleInfoReply.IDependency>|null} [dependencies] Module dependencies\n                     */\n    \n                    /**\n                     * Constructs a new Module.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @classdesc Represents a Module.\n                     * @implements IModule\n                     * @constructor\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set\n                     */\n                    function Module(properties) {\n                        this.dependencies = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Module type.\n                     * @member {particle.ctrl.FirmwareModuleType} type\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.type = 0;\n    \n                    /**\n                     * Module index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.index = 0;\n    \n                    /**\n                     * Module version.\n                     * @member {number} version\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.version = 0;\n    \n                    /**\n                     * Module size.\n                     * @member {number} size\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.size = 0;\n    \n                    /**\n                     * Module validity.\n                     * @member {number} validity\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.validity = 0;\n    \n                    /**\n                     * Module dependencies.\n                     * @member {Array.<particle.ctrl.GetModuleInfoReply.IDependency>} dependencies\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.dependencies = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Module instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set\n                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module instance\n                     */\n                    Module.create = function create(properties) {\n                        return new Module(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Module message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Module.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule} message Module message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Module.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                        if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);\n                        if (message.validity != null && Object.hasOwnProperty.call(message, \"validity\"))\n                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.validity);\n                        if (message.dependencies != null && message.dependencies.length)\n                            for (var i = 0; i < message.dependencies.length; ++i)\n                                $root.particle.ctrl.GetModuleInfoReply.Dependency.encode(message.dependencies[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Module message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Module.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Module();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.index = reader.uint32();\n                                break;\n                            case 3:\n                                message.version = reader.uint32();\n                                break;\n                            case 4:\n                                message.size = reader.uint32();\n                                break;\n                            case 5:\n                                message.validity = reader.uint32();\n                                break;\n                            case 6:\n                                if (!(message.dependencies && message.dependencies.length))\n                                    message.dependencies = [];\n                                message.dependencies.push($root.particle.ctrl.GetModuleInfoReply.Dependency.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Module;\n                })();\n    \n                return GetModuleInfoReply;\n            })();\n    \n            ctrl.GetAssetInfoRequest = (function() {\n    \n                /**\n                 * Properties of a GetAssetInfoRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetAssetInfoRequest\n                 */\n    \n                /**\n                 * Constructs a new GetAssetInfoRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Get asset info.\n                 * @implements IGetAssetInfoRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetAssetInfoRequest=} [properties] Properties to set\n                 */\n                function GetAssetInfoRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetAssetInfoRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetAssetInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetAssetInfoRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetAssetInfoRequest} GetAssetInfoRequest instance\n                 */\n                GetAssetInfoRequest.create = function create(properties) {\n                    return new GetAssetInfoRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetAssetInfoRequest message. Does not implicitly {@link particle.ctrl.GetAssetInfoRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetAssetInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetAssetInfoRequest} message GetAssetInfoRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetAssetInfoRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetAssetInfoRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetAssetInfoRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetAssetInfoRequest} GetAssetInfoRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetAssetInfoRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetAssetInfoRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetAssetInfoRequest;\n            })();\n    \n            ctrl.GetAssetInfoReply = (function() {\n    \n                /**\n                 * Properties of a GetAssetInfoReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetAssetInfoReply\n                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [available] < List of valid assets currently present in device storage\n                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [required] < List of valid assets currently present in device storage\n                 */\n    \n                /**\n                 * Constructs a new GetAssetInfoReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetAssetInfoReply.\n                 * @implements IGetAssetInfoReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetAssetInfoReply=} [properties] Properties to set\n                 */\n                function GetAssetInfoReply(properties) {\n                    this.available = [];\n                    this.required = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < List of valid assets currently present in device storage\n                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} available\n                 * @memberof particle.ctrl.GetAssetInfoReply\n                 * @instance\n                 */\n                GetAssetInfoReply.prototype.available = $util.emptyArray;\n    \n                /**\n                 * < List of valid assets currently present in device storage\n                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} required\n                 * @memberof particle.ctrl.GetAssetInfoReply\n                 * @instance\n                 */\n                GetAssetInfoReply.prototype.required = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetAssetInfoReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetAssetInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetAssetInfoReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetAssetInfoReply} GetAssetInfoReply instance\n                 */\n                GetAssetInfoReply.create = function create(properties) {\n                    return new GetAssetInfoReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetAssetInfoReply message. Does not implicitly {@link particle.ctrl.GetAssetInfoReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetAssetInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetAssetInfoReply} message GetAssetInfoReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetAssetInfoReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.available != null && message.available.length)\n                        for (var i = 0; i < message.available.length; ++i)\n                            $root.particle.cloud.FirmwareModuleAsset.encode(message.available[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.required != null && message.required.length)\n                        for (var i = 0; i < message.required.length; ++i)\n                            $root.particle.cloud.FirmwareModuleAsset.encode(message.required[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetAssetInfoReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetAssetInfoReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetAssetInfoReply} GetAssetInfoReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetAssetInfoReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetAssetInfoReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.available && message.available.length))\n                                message.available = [];\n                            message.available.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            if (!(message.required && message.required.length))\n                                message.required = [];\n                            message.required.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetAssetInfoReply;\n            })();\n    \n            ctrl.WiFiGetAntennaRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiGetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetAntennaRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetAntennaRequest.\n                 * @implements IWiFiGetAntennaRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set\n                 */\n                function WiFiGetAntennaRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiGetAntennaRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest instance\n                 */\n                WiFiGetAntennaRequest.create = function create(properties) {\n                    return new WiFiGetAntennaRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest} message WiFiGetAntennaRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetAntennaRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetAntennaRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetAntennaRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetAntennaRequest;\n            })();\n    \n            ctrl.WiFiGetAntennaReply = (function() {\n    \n                /**\n                 * Properties of a WiFiGetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetAntennaReply\n                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiGetAntennaReply antenna\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetAntennaReply.\n                 * @implements IWiFiGetAntennaReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set\n                 */\n                function WiFiGetAntennaReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiGetAntennaReply antenna.\n                 * @member {particle.ctrl.WiFiAntenna} antenna\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @instance\n                 */\n                WiFiGetAntennaReply.prototype.antenna = 0;\n    \n                /**\n                 * Creates a new WiFiGetAntennaReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply instance\n                 */\n                WiFiGetAntennaReply.create = function create(properties) {\n                    return new WiFiGetAntennaReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaReply} message WiFiGetAntennaReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetAntennaReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.antenna != null && Object.hasOwnProperty.call(message, \"antenna\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetAntennaReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetAntennaReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.antenna = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetAntennaReply;\n            })();\n    \n            ctrl.WiFiSetAntennaRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiSetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetAntennaRequest\n                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiSetAntennaRequest antenna\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetAntennaRequest.\n                 * @implements IWiFiSetAntennaRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set\n                 */\n                function WiFiSetAntennaRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiSetAntennaRequest antenna.\n                 * @member {particle.ctrl.WiFiAntenna} antenna\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @instance\n                 */\n                WiFiSetAntennaRequest.prototype.antenna = 0;\n    \n                /**\n                 * Creates a new WiFiSetAntennaRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest instance\n                 */\n                WiFiSetAntennaRequest.create = function create(properties) {\n                    return new WiFiSetAntennaRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest} message WiFiSetAntennaRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetAntennaRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.antenna != null && Object.hasOwnProperty.call(message, \"antenna\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetAntennaRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetAntennaRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.antenna = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetAntennaRequest;\n            })();\n    \n            ctrl.WiFiSetAntennaReply = (function() {\n    \n                /**\n                 * Properties of a WiFiSetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetAntennaReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetAntennaReply.\n                 * @implements IWiFiSetAntennaReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set\n                 */\n                function WiFiSetAntennaReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiSetAntennaReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply instance\n                 */\n                WiFiSetAntennaReply.create = function create(properties) {\n                    return new WiFiSetAntennaReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaReply} message WiFiSetAntennaReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetAntennaReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetAntennaReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetAntennaReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetAntennaReply;\n            })();\n    \n            ctrl.WiFiScanRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiScanRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiScanRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiScanRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiScanRequest.\n                 * @implements IWiFiScanRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set\n                 */\n                function WiFiScanRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiScanRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest instance\n                 */\n                WiFiScanRequest.create = function create(properties) {\n                    return new WiFiScanRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiScanRequest message. Does not implicitly {@link particle.ctrl.WiFiScanRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanRequest} message WiFiScanRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiScanRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiScanRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiScanRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiScanRequest;\n            })();\n    \n            ctrl.WiFiScanReply = (function() {\n    \n                /**\n                 * Properties of a WiFiScanReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiScanReply\n                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiScanReply list\n                 */\n    \n                /**\n                 * Constructs a new WiFiScanReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiScanReply.\n                 * @implements IWiFiScanReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set\n                 */\n                function WiFiScanReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiScanReply list.\n                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @instance\n                 */\n                WiFiScanReply.prototype.list = null;\n    \n                /**\n                 * Creates a new WiFiScanReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply instance\n                 */\n                WiFiScanReply.create = function create(properties) {\n                    return new WiFiScanReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiScanReply message. Does not implicitly {@link particle.ctrl.WiFiScanReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanReply} message WiFiScanReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiScanReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.list != null && Object.hasOwnProperty.call(message, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiScanReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiScanReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiScanReply;\n            })();\n    \n            ctrl.WiFiGetCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiGetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetCredentialsRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetCredentialsRequest.\n                 * @implements IWiFiGetCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiGetCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiGetCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest instance\n                 */\n                WiFiGetCredentialsRequest.create = function create(properties) {\n                    return new WiFiGetCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest} message WiFiGetCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiGetCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiGetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetCredentialsReply\n                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiGetCredentialsReply list\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetCredentialsReply.\n                 * @implements IWiFiGetCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiGetCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiGetCredentialsReply list.\n                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @instance\n                 */\n                WiFiGetCredentialsReply.prototype.list = null;\n    \n                /**\n                 * Creates a new WiFiGetCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply instance\n                 */\n                WiFiGetCredentialsReply.create = function create(properties) {\n                    return new WiFiGetCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply} message WiFiGetCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.list != null && Object.hasOwnProperty.call(message, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetCredentialsReply;\n            })();\n    \n            ctrl.WiFiSetCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiSetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetCredentialsRequest\n                 * @property {particle.ctrl.IWiFiAccessPoint|null} [ap] WiFiSetCredentialsRequest ap\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetCredentialsRequest.\n                 * @implements IWiFiSetCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiSetCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiSetCredentialsRequest ap.\n                 * @member {particle.ctrl.IWiFiAccessPoint|null|undefined} ap\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @instance\n                 */\n                WiFiSetCredentialsRequest.prototype.ap = null;\n    \n                /**\n                 * Creates a new WiFiSetCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest instance\n                 */\n                WiFiSetCredentialsRequest.create = function create(properties) {\n                    return new WiFiSetCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest} message WiFiSetCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ap != null && Object.hasOwnProperty.call(message, \"ap\"))\n                        $root.particle.ctrl.WiFiAccessPoint.encode(message.ap, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ap = $root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiSetCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiSetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetCredentialsReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetCredentialsReply.\n                 * @implements IWiFiSetCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiSetCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiSetCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply instance\n                 */\n                WiFiSetCredentialsReply.create = function create(properties) {\n                    return new WiFiSetCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply} message WiFiSetCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetCredentialsReply;\n            })();\n    \n            ctrl.WiFiClearCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiClearCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiClearCredentialsRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiClearCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiClearCredentialsRequest.\n                 * @implements IWiFiClearCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiClearCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiClearCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest instance\n                 */\n                WiFiClearCredentialsRequest.create = function create(properties) {\n                    return new WiFiClearCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiClearCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest} message WiFiClearCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiClearCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiClearCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiClearCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiClearCredentialsRequest;\n            })();\n    \n            ctrl.WiFiClearCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiClearCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiClearCredentialsReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiClearCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiClearCredentialsReply.\n                 * @implements IWiFiClearCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiClearCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiClearCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply instance\n                 */\n                WiFiClearCredentialsReply.create = function create(properties) {\n                    return new WiFiClearCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiClearCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply} message WiFiClearCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiClearCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiClearCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiClearCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiClearCredentialsReply;\n            })();\n    \n            /**\n             * WiFiAntenna enum.\n             * @name particle.ctrl.WiFiAntenna\n             * @enum {number}\n             * @property {number} ANTENNA_NONE=0 ANTENNA_NONE value\n             * @property {number} INTERNAL=1 INTERNAL value\n             * @property {number} EXTERNAL=2 EXTERNAL value\n             * @property {number} AUTO=3 AUTO value\n             */\n            ctrl.WiFiAntenna = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"ANTENNA_NONE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                values[valuesById[2] = \"EXTERNAL\"] = 2;\n                values[valuesById[3] = \"AUTO\"] = 3;\n                return values;\n            })();\n    \n            /**\n             * WiFiSecurityType enum.\n             * @name particle.ctrl.WiFiSecurityType\n             * @enum {number}\n             * @property {number} UNSEC=0 UNSEC value\n             * @property {number} WEP=1 WEP value\n             * @property {number} WPA=2 WPA value\n             * @property {number} WPA2=3 WPA2 value\n             * @property {number} WPA_ENTERPRISE=4 WPA_ENTERPRISE value\n             * @property {number} WPA2_ENTERPRISE=5 WPA2_ENTERPRISE value\n             * @property {number} UNKNOWN=255 UNKNOWN value\n             */\n            ctrl.WiFiSecurityType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"UNSEC\"] = 0;\n                values[valuesById[1] = \"WEP\"] = 1;\n                values[valuesById[2] = \"WPA\"] = 2;\n                values[valuesById[3] = \"WPA2\"] = 3;\n                values[valuesById[4] = \"WPA_ENTERPRISE\"] = 4;\n                values[valuesById[5] = \"WPA2_ENTERPRISE\"] = 5;\n                values[valuesById[255] = \"UNKNOWN\"] = 255;\n                return values;\n            })();\n    \n            /**\n             * WiFiSecurityCipher enum.\n             * @name particle.ctrl.WiFiSecurityCipher\n             * @enum {number}\n             * @property {number} CIPHER_NONE=0 CIPHER_NONE value\n             * @property {number} AES=1 AES value\n             * @property {number} TKIP=2 TKIP value\n             * @property {number} AES_TKIP=3 AES_TKIP value\n             */\n            ctrl.WiFiSecurityCipher = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"CIPHER_NONE\"] = 0;\n                values[valuesById[1] = \"AES\"] = 1;\n                values[valuesById[2] = \"TKIP\"] = 2;\n                values[valuesById[3] = \"AES_TKIP\"] = 3;\n                return values;\n            })();\n    \n            /**\n             * EapType enum.\n             * @name particle.ctrl.EapType\n             * @enum {number}\n             * @property {number} EAP_TYPE_NONE=0 EAP_TYPE_NONE value\n             * @property {number} TLS=13 TLS value\n             * @property {number} PEAP=25 PEAP value\n             */\n            ctrl.EapType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"EAP_TYPE_NONE\"] = 0;\n                values[valuesById[13] = \"TLS\"] = 13;\n                values[valuesById[25] = \"PEAP\"] = 25;\n                return values;\n            })();\n    \n            ctrl.WiFiAccessPoint = (function() {\n    \n                /**\n                 * Properties of a WiFiAccessPoint.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiAccessPoint\n                 * @property {string|null} [ssid] WiFiAccessPoint ssid\n                 * @property {Uint8Array|null} [bssid] WiFiAccessPoint bssid\n                 * @property {particle.ctrl.WiFiSecurityType|null} [security] WiFiAccessPoint security\n                 * @property {particle.ctrl.WiFiSecurityCipher|null} [cipher] WiFiAccessPoint cipher\n                 * @property {number|null} [channel] WiFiAccessPoint channel\n                 * @property {number|null} [maxDataRate] WiFiAccessPoint maxDataRate\n                 * @property {number|null} [rssi] WiFiAccessPoint rssi\n                 * @property {string|null} [password] WiFiAccessPoint password\n                 * @property {particle.ctrl.EapType|null} [eapType] WiFiAccessPoint eapType\n                 * @property {string|null} [innerIdentity] WiFiAccessPoint innerIdentity\n                 * @property {string|null} [outerIdentity] WiFiAccessPoint outerIdentity\n                 * @property {Uint8Array|null} [privateKey] WiFiAccessPoint privateKey\n                 * @property {Uint8Array|null} [clientCertificate] WiFiAccessPoint clientCertificate\n                 * @property {Uint8Array|null} [caCertificate] WiFiAccessPoint caCertificate\n                 */\n    \n                /**\n                 * Constructs a new WiFiAccessPoint.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiAccessPoint.\n                 * @implements IWiFiAccessPoint\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set\n                 */\n                function WiFiAccessPoint(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiAccessPoint ssid.\n                 * @member {string} ssid\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.ssid = \"\";\n    \n                /**\n                 * WiFiAccessPoint bssid.\n                 * @member {Uint8Array} bssid\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.bssid = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint security.\n                 * @member {particle.ctrl.WiFiSecurityType} security\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.security = 0;\n    \n                /**\n                 * WiFiAccessPoint cipher.\n                 * @member {particle.ctrl.WiFiSecurityCipher} cipher\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.cipher = 0;\n    \n                /**\n                 * WiFiAccessPoint channel.\n                 * @member {number} channel\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.channel = 0;\n    \n                /**\n                 * WiFiAccessPoint maxDataRate.\n                 * @member {number} maxDataRate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.maxDataRate = 0;\n    \n                /**\n                 * WiFiAccessPoint rssi.\n                 * @member {number} rssi\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.rssi = 0;\n    \n                /**\n                 * WiFiAccessPoint password.\n                 * @member {string} password\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.password = \"\";\n    \n                /**\n                 * WiFiAccessPoint eapType.\n                 * @member {particle.ctrl.EapType} eapType\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.eapType = 0;\n    \n                /**\n                 * WiFiAccessPoint innerIdentity.\n                 * @member {string} innerIdentity\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.innerIdentity = \"\";\n    \n                /**\n                 * WiFiAccessPoint outerIdentity.\n                 * @member {string} outerIdentity\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.outerIdentity = \"\";\n    \n                /**\n                 * WiFiAccessPoint privateKey.\n                 * @member {Uint8Array} privateKey\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.privateKey = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint clientCertificate.\n                 * @member {Uint8Array} clientCertificate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.clientCertificate = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint caCertificate.\n                 * @member {Uint8Array} caCertificate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.caCertificate = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new WiFiAccessPoint instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint instance\n                 */\n                WiFiAccessPoint.create = function create(properties) {\n                    return new WiFiAccessPoint(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiAccessPoint message. Does not implicitly {@link particle.ctrl.WiFiAccessPoint.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPoint} message WiFiAccessPoint message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiAccessPoint.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                    if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                    if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                    if (message.cipher != null && Object.hasOwnProperty.call(message, \"cipher\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cipher);\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.channel);\n                    if (message.maxDataRate != null && Object.hasOwnProperty.call(message, \"maxDataRate\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxDataRate);\n                    if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rssi);\n                    if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.password);\n                    if (message.eapType != null && Object.hasOwnProperty.call(message, \"eapType\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.eapType);\n                    if (message.innerIdentity != null && Object.hasOwnProperty.call(message, \"innerIdentity\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.innerIdentity);\n                    if (message.outerIdentity != null && Object.hasOwnProperty.call(message, \"outerIdentity\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.outerIdentity);\n                    if (message.privateKey != null && Object.hasOwnProperty.call(message, \"privateKey\"))\n                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.privateKey);\n                    if (message.clientCertificate != null && Object.hasOwnProperty.call(message, \"clientCertificate\"))\n                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.clientCertificate);\n                    if (message.caCertificate != null && Object.hasOwnProperty.call(message, \"caCertificate\"))\n                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.caCertificate);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiAccessPoint message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiAccessPoint.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPoint();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ssid = reader.string();\n                            break;\n                        case 2:\n                            message.bssid = reader.bytes();\n                            break;\n                        case 3:\n                            message.security = reader.int32();\n                            break;\n                        case 4:\n                            message.cipher = reader.int32();\n                            break;\n                        case 5:\n                            message.channel = reader.uint32();\n                            break;\n                        case 6:\n                            message.maxDataRate = reader.int32();\n                            break;\n                        case 7:\n                            message.rssi = reader.int32();\n                            break;\n                        case 8:\n                            message.password = reader.string();\n                            break;\n                        case 9:\n                            message.eapType = reader.int32();\n                            break;\n                        case 10:\n                            message.innerIdentity = reader.string();\n                            break;\n                        case 11:\n                            message.outerIdentity = reader.string();\n                            break;\n                        case 12:\n                            message.privateKey = reader.bytes();\n                            break;\n                        case 13:\n                            message.clientCertificate = reader.bytes();\n                            break;\n                        case 14:\n                            message.caCertificate = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiAccessPoint;\n            })();\n    \n            ctrl.WiFiAccessPointList = (function() {\n    \n                /**\n                 * Properties of a WiFiAccessPointList.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiAccessPointList\n                 * @property {Array.<particle.ctrl.IWiFiAccessPoint>|null} [aps] WiFiAccessPointList aps\n                 */\n    \n                /**\n                 * Constructs a new WiFiAccessPointList.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiAccessPointList.\n                 * @implements IWiFiAccessPointList\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set\n                 */\n                function WiFiAccessPointList(properties) {\n                    this.aps = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiAccessPointList aps.\n                 * @member {Array.<particle.ctrl.IWiFiAccessPoint>} aps\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @instance\n                 */\n                WiFiAccessPointList.prototype.aps = $util.emptyArray;\n    \n                /**\n                 * Creates a new WiFiAccessPointList instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList instance\n                 */\n                WiFiAccessPointList.create = function create(properties) {\n                    return new WiFiAccessPointList(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiAccessPointList message. Does not implicitly {@link particle.ctrl.WiFiAccessPointList.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPointList} message WiFiAccessPointList message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiAccessPointList.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.aps != null && message.aps.length)\n                        for (var i = 0; i < message.aps.length; ++i)\n                            $root.particle.ctrl.WiFiAccessPoint.encode(message.aps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiAccessPointList message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiAccessPointList.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPointList();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.aps && message.aps.length))\n                                message.aps = [];\n                            message.aps.push($root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiAccessPointList;\n            })();\n    \n            ctrl.wifi = (function() {\n    \n                /**\n                 * Namespace wifi.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var wifi = {};\n    \n                /**\n                 * WiFi security types.\n                 * \n                 * Note: The values of this enum should match the values defined by the `WifiSecurity` enum in\n                 * the firmware.\n                 * @name particle.ctrl.wifi.Security\n                 * @enum {number}\n                 * @property {number} NO_SECURITY=0 NO_SECURITY value\n                 * @property {number} WEP=1 WEP value\n                 * @property {number} WPA_PSK=2 WPA_PSK value\n                 * @property {number} WPA2_PSK=3 WPA2_PSK value\n                 * @property {number} WPA_WPA2_PSK=4 WPA_WPA2_PSK value\n                 * @property {number} WPA3_PSK=5 WPA3_PSK value\n                 * @property {number} WPA2_WPA3_PSK=6 WPA2_WPA3_PSK value\n                 */\n                wifi.Security = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_SECURITY\"] = 0;\n                    values[valuesById[1] = \"WEP\"] = 1;\n                    values[valuesById[2] = \"WPA_PSK\"] = 2;\n                    values[valuesById[3] = \"WPA2_PSK\"] = 3;\n                    values[valuesById[4] = \"WPA_WPA2_PSK\"] = 4;\n                    values[valuesById[5] = \"WPA3_PSK\"] = 5;\n                    values[valuesById[6] = \"WPA2_WPA3_PSK\"] = 6;\n                    return values;\n                })();\n    \n                /**\n                 * Network credential types.\n                 * \n                 * Note: The values of this enum should match the values defined by the `WiFiCredentials::Type` enum\n                 * in the firmware.\n                 * @name particle.ctrl.wifi.CredentialsType\n                 * @enum {number}\n                 * @property {number} NO_CREDENTIALS=0 NO_CREDENTIALS value\n                 * @property {number} PASSWORD=1 PASSWORD value\n                 */\n                wifi.CredentialsType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_CREDENTIALS\"] = 0;\n                    values[valuesById[1] = \"PASSWORD\"] = 1;\n                    return values;\n                })();\n    \n                wifi.Credentials = (function() {\n    \n                    /**\n                     * Properties of a Credentials.\n                     * @memberof particle.ctrl.wifi\n                     * @interface ICredentials\n                     * @property {particle.ctrl.wifi.CredentialsType|null} [type] Credentials type\n                     * @property {string|null} [password] Credentials password\n                     */\n    \n                    /**\n                     * Constructs a new Credentials.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Network credentials.\n                     * @implements ICredentials\n                     * @constructor\n                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set\n                     */\n                    function Credentials(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Credentials type.\n                     * @member {particle.ctrl.wifi.CredentialsType} type\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @instance\n                     */\n                    Credentials.prototype.type = 0;\n    \n                    /**\n                     * Credentials password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @instance\n                     */\n                    Credentials.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new Credentials instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.Credentials} Credentials instance\n                     */\n                    Credentials.create = function create(properties) {\n                        return new Credentials(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Credentials message. Does not implicitly {@link particle.ctrl.wifi.Credentials.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {particle.ctrl.wifi.ICredentials} message Credentials message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Credentials.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Credentials message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.Credentials} Credentials\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Credentials.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.Credentials();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Credentials;\n                })();\n    \n                wifi.JoinNewNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinNewNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinNewNetworkRequest\n                     * @property {string|null} [ssid] JoinNewNetworkRequest ssid\n                     * @property {Uint8Array|null} [bssid] JoinNewNetworkRequest bssid\n                     * @property {particle.ctrl.wifi.Security|null} [security] JoinNewNetworkRequest security\n                     * @property {particle.ctrl.wifi.ICredentials|null} [credentials] JoinNewNetworkRequest credentials\n                     * @property {particle.ctrl.IInterface|null} [interfaceConfig] JoinNewNetworkRequest interfaceConfig\n                     * @property {boolean|null} [hidden] JoinNewNetworkRequest hidden\n                     */\n    \n                    /**\n                     * Constructs a new JoinNewNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Join a new network.\n                     * \n                     * On success, the network credentials get saved to a persistent storage.\n                     * @implements IJoinNewNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinNewNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinNewNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * JoinNewNetworkRequest bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * JoinNewNetworkRequest security.\n                     * @member {particle.ctrl.wifi.Security} security\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.security = 0;\n    \n                    /**\n                     * JoinNewNetworkRequest credentials.\n                     * @member {particle.ctrl.wifi.ICredentials|null|undefined} credentials\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.credentials = null;\n    \n                    /**\n                     * JoinNewNetworkRequest interfaceConfig.\n                     * @member {particle.ctrl.IInterface|null|undefined} interfaceConfig\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.interfaceConfig = null;\n    \n                    /**\n                     * JoinNewNetworkRequest hidden.\n                     * @member {boolean} hidden\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.hidden = false;\n    \n                    /**\n                     * Creates a new JoinNewNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest instance\n                     */\n                    JoinNewNetworkRequest.create = function create(properties) {\n                        return new JoinNewNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNewNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest} message JoinNewNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNewNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                        if (message.credentials != null && Object.hasOwnProperty.call(message, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(message.credentials, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        if (message.interfaceConfig != null && Object.hasOwnProperty.call(message, \"interfaceConfig\"))\n                            $root.particle.ctrl.Interface.encode(message.interfaceConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.hidden != null && Object.hasOwnProperty.call(message, \"hidden\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hidden);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNewNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNewNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.security = reader.int32();\n                                break;\n                            case 4:\n                                message.credentials = $root.particle.ctrl.wifi.Credentials.decode(reader, reader.uint32());\n                                break;\n                            case 5:\n                                message.interfaceConfig = $root.particle.ctrl.Interface.decode(reader, reader.uint32());\n                                break;\n                            case 6:\n                                message.hidden = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNewNetworkRequest;\n                })();\n    \n                wifi.JoinNewNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinNewNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinNewNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinNewNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a JoinNewNetworkReply.\n                     * @implements IJoinNewNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinNewNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinNewNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply instance\n                     */\n                    JoinNewNetworkReply.create = function create(properties) {\n                        return new JoinNewNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNewNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply} message JoinNewNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNewNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNewNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNewNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNewNetworkReply;\n                })();\n    \n                wifi.JoinKnownNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinKnownNetworkRequest\n                     * @property {string|null} [ssid] JoinKnownNetworkRequest ssid\n                     */\n    \n                    /**\n                     * Constructs a new JoinKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Join a known network.\n                     * @implements IJoinKnownNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinKnownNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinKnownNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @instance\n                     */\n                    JoinKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * Creates a new JoinKnownNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest instance\n                     */\n                    JoinKnownNetworkRequest.create = function create(properties) {\n                        return new JoinKnownNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest} message JoinKnownNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinKnownNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinKnownNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinKnownNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinKnownNetworkRequest;\n                })();\n    \n                wifi.JoinKnownNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinKnownNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a JoinKnownNetworkReply.\n                     * @implements IJoinKnownNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinKnownNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinKnownNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply instance\n                     */\n                    JoinKnownNetworkReply.create = function create(properties) {\n                        return new JoinKnownNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply} message JoinKnownNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinKnownNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinKnownNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinKnownNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinKnownNetworkReply;\n                })();\n    \n                wifi.GetKnownNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a GetKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetKnownNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Get the list of known networks.\n                     * @implements IGetKnownNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set\n                     */\n                    function GetKnownNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetKnownNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest instance\n                     */\n                    GetKnownNetworksRequest.create = function create(properties) {\n                        return new GetKnownNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest} message GetKnownNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetKnownNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetKnownNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetKnownNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetKnownNetworksRequest;\n                })();\n    \n                wifi.GetKnownNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a GetKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetKnownNetworksReply\n                     * @property {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>|null} [networks] GetKnownNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new GetKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a GetKnownNetworksReply.\n                     * @implements IGetKnownNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set\n                     */\n                    function GetKnownNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetKnownNetworksReply networks.\n                     * @member {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>} networks\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @instance\n                     */\n                    GetKnownNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetKnownNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply instance\n                     */\n                    GetKnownNetworksReply.create = function create(properties) {\n                        return new GetKnownNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply} message GetKnownNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetKnownNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.wifi.GetKnownNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetKnownNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetKnownNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.wifi.GetKnownNetworksReply.Network.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    GetKnownNetworksReply.Network = (function() {\n    \n                        /**\n                         * Properties of a Network.\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                         * @interface INetwork\n                         * @property {string|null} [ssid] Network ssid\n                         * @property {particle.ctrl.wifi.Security|null} [security] Network security\n                         * @property {particle.ctrl.wifi.CredentialsType|null} [credentialsType] Network credentialsType\n                         */\n    \n                        /**\n                         * Constructs a new Network.\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                         * @classdesc Represents a Network.\n                         * @implements INetwork\n                         * @constructor\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set\n                         */\n                        function Network(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Network ssid.\n                         * @member {string} ssid\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.ssid = \"\";\n    \n                        /**\n                         * Network security.\n                         * @member {particle.ctrl.wifi.Security} security\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.security = 0;\n    \n                        /**\n                         * Network credentialsType.\n                         * @member {particle.ctrl.wifi.CredentialsType} credentialsType\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.credentialsType = 0;\n    \n                        /**\n                         * Creates a new Network instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set\n                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network instance\n                         */\n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.Network.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork} message Network message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Network.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                            if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.security);\n                            if (message.credentialsType != null && Object.hasOwnProperty.call(message, \"credentialsType\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.credentialsType);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Network message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Network.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply.Network();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ssid = reader.string();\n                                    break;\n                                case 2:\n                                    message.security = reader.int32();\n                                    break;\n                                case 3:\n                                    message.credentialsType = reader.int32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return GetKnownNetworksReply;\n                })();\n    \n                wifi.RemoveKnownNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IRemoveKnownNetworkRequest\n                     * @property {string|null} [ssid] RemoveKnownNetworkRequest ssid\n                     */\n    \n                    /**\n                     * Constructs a new RemoveKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Remove the network from the list of known networks.\n                     * @implements IRemoveKnownNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set\n                     */\n                    function RemoveKnownNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveKnownNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @instance\n                     */\n                    RemoveKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * Creates a new RemoveKnownNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest instance\n                     */\n                    RemoveKnownNetworkRequest.create = function create(properties) {\n                        return new RemoveKnownNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest} message RemoveKnownNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveKnownNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveKnownNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveKnownNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveKnownNetworkRequest;\n                })();\n    \n                wifi.RemoveKnownNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IRemoveKnownNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a RemoveKnownNetworkReply.\n                     * @implements IRemoveKnownNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set\n                     */\n                    function RemoveKnownNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveKnownNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply instance\n                     */\n                    RemoveKnownNetworkReply.create = function create(properties) {\n                        return new RemoveKnownNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply} message RemoveKnownNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveKnownNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveKnownNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveKnownNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveKnownNetworkReply;\n                })();\n    \n                wifi.ClearKnownNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ClearKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IClearKnownNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new ClearKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Remove all known networks.\n                     * @implements IClearKnownNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set\n                     */\n                    function ClearKnownNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ClearKnownNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest instance\n                     */\n                    ClearKnownNetworksRequest.create = function create(properties) {\n                        return new ClearKnownNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ClearKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest} message ClearKnownNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ClearKnownNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ClearKnownNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ClearKnownNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ClearKnownNetworksRequest;\n                })();\n    \n                wifi.ClearKnownNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ClearKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IClearKnownNetworksReply\n                     */\n    \n                    /**\n                     * Constructs a new ClearKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a ClearKnownNetworksReply.\n                     * @implements IClearKnownNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set\n                     */\n                    function ClearKnownNetworksReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ClearKnownNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply instance\n                     */\n                    ClearKnownNetworksReply.create = function create(properties) {\n                        return new ClearKnownNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ClearKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply} message ClearKnownNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ClearKnownNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ClearKnownNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ClearKnownNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ClearKnownNetworksReply;\n                })();\n    \n                wifi.GetCurrentNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a GetCurrentNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetCurrentNetworkRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetCurrentNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Get the current network.\n                     * \n                     * This request gets the network which the device is currently connected to.\n                     * @implements IGetCurrentNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set\n                     */\n                    function GetCurrentNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetCurrentNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest instance\n                     */\n                    GetCurrentNetworkRequest.create = function create(properties) {\n                        return new GetCurrentNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetCurrentNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest} message GetCurrentNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetCurrentNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetCurrentNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetCurrentNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetCurrentNetworkRequest;\n                })();\n    \n                wifi.GetCurrentNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a GetCurrentNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetCurrentNetworkReply\n                     * @property {string|null} [ssid] GetCurrentNetworkReply ssid\n                     * @property {Uint8Array|null} [bssid] GetCurrentNetworkReply bssid\n                     * @property {number|null} [channel] GetCurrentNetworkReply channel\n                     * @property {number|null} [rssi] GetCurrentNetworkReply rssi\n                     */\n    \n                    /**\n                     * Constructs a new GetCurrentNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a GetCurrentNetworkReply.\n                     * @implements IGetCurrentNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set\n                     */\n                    function GetCurrentNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetCurrentNetworkReply ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.ssid = \"\";\n    \n                    /**\n                     * GetCurrentNetworkReply bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * GetCurrentNetworkReply channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.channel = 0;\n    \n                    /**\n                     * GetCurrentNetworkReply rssi.\n                     * @member {number} rssi\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.rssi = 0;\n    \n                    /**\n                     * Creates a new GetCurrentNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply instance\n                     */\n                    GetCurrentNetworkReply.create = function create(properties) {\n                        return new GetCurrentNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetCurrentNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply} message GetCurrentNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetCurrentNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channel);\n                        if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rssi);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetCurrentNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetCurrentNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.channel = reader.int32();\n                                break;\n                            case 4:\n                                message.rssi = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetCurrentNetworkReply;\n                })();\n    \n                wifi.ScanNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IScanNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Scan for networks.\n                     * @implements IScanNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set\n                     */\n                    function ScanNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ScanNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest instance\n                     */\n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                wifi.ScanNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IScanNetworksReply\n                     * @property {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>|null} [networks] ScanNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a ScanNetworksReply.\n                     * @implements IScanNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set\n                     */\n                    function ScanNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksReply networks.\n                     * @member {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>} networks\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @instance\n                     */\n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new ScanNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply instance\n                     */\n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksReply} message ScanNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.wifi.ScanNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.wifi.ScanNetworksReply.Network.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    ScanNetworksReply.Network = (function() {\n    \n                        /**\n                         * Properties of a Network.\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply\n                         * @interface INetwork\n                         * @property {string|null} [ssid] Network ssid\n                         * @property {Uint8Array|null} [bssid] Network bssid\n                         * @property {particle.ctrl.wifi.Security|null} [security] Network security\n                         * @property {number|null} [channel] Network channel\n                         * @property {number|null} [rssi] Network rssi\n                         */\n    \n                        /**\n                         * Constructs a new Network.\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply\n                         * @classdesc Represents a Network.\n                         * @implements INetwork\n                         * @constructor\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set\n                         */\n                        function Network(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Network ssid.\n                         * @member {string} ssid\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.ssid = \"\";\n    \n                        /**\n                         * Network bssid.\n                         * @member {Uint8Array} bssid\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.bssid = $util.newBuffer([]);\n    \n                        /**\n                         * Network security.\n                         * @member {particle.ctrl.wifi.Security} security\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.security = 0;\n    \n                        /**\n                         * Network channel.\n                         * @member {number} channel\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.channel = 0;\n    \n                        /**\n                         * Network rssi.\n                         * @member {number} rssi\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.rssi = 0;\n    \n                        /**\n                         * Creates a new Network instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set\n                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network instance\n                         */\n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.Network.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork} message Network message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Network.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                            if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                            if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                            if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.channel);\n                            if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rssi);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Network message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Network.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply.Network();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ssid = reader.string();\n                                    break;\n                                case 2:\n                                    message.bssid = reader.bytes();\n                                    break;\n                                case 3:\n                                    message.security = reader.int32();\n                                    break;\n                                case 4:\n                                    message.channel = reader.int32();\n                                    break;\n                                case 5:\n                                    message.rssi = reader.int32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return ScanNetworksReply;\n                })();\n    \n                wifi.SetNetworkCredentialsRequest = (function() {\n    \n                    /**\n                     * Properties of a SetNetworkCredentialsRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface ISetNetworkCredentialsRequest\n                     * @property {string|null} [ssid] SetNetworkCredentialsRequest ssid\n                     * @property {Uint8Array|null} [bssid] SetNetworkCredentialsRequest bssid\n                     * @property {particle.ctrl.wifi.Security|null} [security] SetNetworkCredentialsRequest security\n                     * @property {particle.ctrl.wifi.ICredentials|null} [credentials] SetNetworkCredentialsRequest credentials\n                     * @property {particle.ctrl.IInterface|null} [interfaceConfig] SetNetworkCredentialsRequest interfaceConfig\n                     * @property {boolean|null} [hidden] SetNetworkCredentialsRequest hidden\n                     */\n    \n                    /**\n                     * Constructs a new SetNetworkCredentialsRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Store network credential but do not attempt to power on wifi or connect.\n                     * \n                     * On success, the network credentials get saved to a persistent storage.\n                     * On failure, there was not enough room to store the credentials\n                     * @implements ISetNetworkCredentialsRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsRequest=} [properties] Properties to set\n                     */\n                    function SetNetworkCredentialsRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SetNetworkCredentialsRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * SetNetworkCredentialsRequest bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * SetNetworkCredentialsRequest security.\n                     * @member {particle.ctrl.wifi.Security} security\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.security = 0;\n    \n                    /**\n                     * SetNetworkCredentialsRequest credentials.\n                     * @member {particle.ctrl.wifi.ICredentials|null|undefined} credentials\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.credentials = null;\n    \n                    /**\n                     * SetNetworkCredentialsRequest interfaceConfig.\n                     * @member {particle.ctrl.IInterface|null|undefined} interfaceConfig\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.interfaceConfig = null;\n    \n                    /**\n                     * SetNetworkCredentialsRequest hidden.\n                     * @member {boolean} hidden\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @instance\n                     */\n                    SetNetworkCredentialsRequest.prototype.hidden = false;\n    \n                    /**\n                     * Creates a new SetNetworkCredentialsRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.SetNetworkCredentialsRequest} SetNetworkCredentialsRequest instance\n                     */\n                    SetNetworkCredentialsRequest.create = function create(properties) {\n                        return new SetNetworkCredentialsRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetNetworkCredentialsRequest message. Does not implicitly {@link particle.ctrl.wifi.SetNetworkCredentialsRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsRequest} message SetNetworkCredentialsRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetNetworkCredentialsRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                        if (message.credentials != null && Object.hasOwnProperty.call(message, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(message.credentials, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        if (message.interfaceConfig != null && Object.hasOwnProperty.call(message, \"interfaceConfig\"))\n                            $root.particle.ctrl.Interface.encode(message.interfaceConfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.hidden != null && Object.hasOwnProperty.call(message, \"hidden\"))\n                            writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hidden);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetNetworkCredentialsRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.SetNetworkCredentialsRequest} SetNetworkCredentialsRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetNetworkCredentialsRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.SetNetworkCredentialsRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.security = reader.int32();\n                                break;\n                            case 4:\n                                message.credentials = $root.particle.ctrl.wifi.Credentials.decode(reader, reader.uint32());\n                                break;\n                            case 5:\n                                message.interfaceConfig = $root.particle.ctrl.Interface.decode(reader, reader.uint32());\n                                break;\n                            case 6:\n                                message.hidden = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetNetworkCredentialsRequest;\n                })();\n    \n                wifi.SetNetworkCredentialsReply = (function() {\n    \n                    /**\n                     * Properties of a SetNetworkCredentialsReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface ISetNetworkCredentialsReply\n                     */\n    \n                    /**\n                     * Constructs a new SetNetworkCredentialsReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a SetNetworkCredentialsReply.\n                     * @implements ISetNetworkCredentialsReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsReply=} [properties] Properties to set\n                     */\n                    function SetNetworkCredentialsReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetNetworkCredentialsReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsReply\n                     * @static\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.SetNetworkCredentialsReply} SetNetworkCredentialsReply instance\n                     */\n                    SetNetworkCredentialsReply.create = function create(properties) {\n                        return new SetNetworkCredentialsReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetNetworkCredentialsReply message. Does not implicitly {@link particle.ctrl.wifi.SetNetworkCredentialsReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsReply\n                     * @static\n                     * @param {particle.ctrl.wifi.ISetNetworkCredentialsReply} message SetNetworkCredentialsReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetNetworkCredentialsReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetNetworkCredentialsReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.SetNetworkCredentialsReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.SetNetworkCredentialsReply} SetNetworkCredentialsReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetNetworkCredentialsReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.SetNetworkCredentialsReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetNetworkCredentialsReply;\n                })();\n    \n                return wifi;\n            })();\n    \n            return ctrl;\n        })();\n    \n        particle.cloud = (function() {\n    \n            /**\n             * Namespace cloud.\n             * @memberof particle\n             * @namespace\n             */\n            var cloud = {};\n    \n            cloud.Request = (function() {\n    \n                /**\n                 * Properties of a Request.\n                 * @memberof particle.cloud\n                 * @interface IRequest\n                 * @property {particle.cloud.Request.Type|null} [type] < Request type.\n                 * @property {particle.cloud.ledger.IGetInfoRequest|null} [ledgerGetInfo] Request ledgerGetInfo\n                 * @property {particle.cloud.ledger.ISetDataRequest|null} [ledgerSetData] Request ledgerSetData\n                 * @property {particle.cloud.ledger.IGetDataRequest|null} [ledgerGetData] Request ledgerGetData\n                 * @property {particle.cloud.ledger.ISubscribeRequest|null} [ledgerSubscribe] Request ledgerSubscribe\n                 * @property {particle.cloud.ledger.INotifyUpdateRequest|null} [ledgerNotifyUpdate] Request ledgerNotifyUpdate\n                 * @property {particle.cloud.ledger.IResetInfoRequest|null} [ledgerResetInfo] Request ledgerResetInfo\n                 */\n    \n                /**\n                 * Constructs a new Request.\n                 * @memberof particle.cloud\n                 * @classdesc Request message.\n                 * @implements IRequest\n                 * @constructor\n                 * @param {particle.cloud.IRequest=} [properties] Properties to set\n                 */\n                function Request(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < Request type.\n                 * @member {particle.cloud.Request.Type} type\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.type = 0;\n    \n                /**\n                 * Request ledgerGetInfo.\n                 * @member {particle.cloud.ledger.IGetInfoRequest|null|undefined} ledgerGetInfo\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerGetInfo = null;\n    \n                /**\n                 * Request ledgerSetData.\n                 * @member {particle.cloud.ledger.ISetDataRequest|null|undefined} ledgerSetData\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerSetData = null;\n    \n                /**\n                 * Request ledgerGetData.\n                 * @member {particle.cloud.ledger.IGetDataRequest|null|undefined} ledgerGetData\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerGetData = null;\n    \n                /**\n                 * Request ledgerSubscribe.\n                 * @member {particle.cloud.ledger.ISubscribeRequest|null|undefined} ledgerSubscribe\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerSubscribe = null;\n    \n                /**\n                 * Request ledgerNotifyUpdate.\n                 * @member {particle.cloud.ledger.INotifyUpdateRequest|null|undefined} ledgerNotifyUpdate\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerNotifyUpdate = null;\n    \n                /**\n                 * Request ledgerResetInfo.\n                 * @member {particle.cloud.ledger.IResetInfoRequest|null|undefined} ledgerResetInfo\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Request.prototype.ledgerResetInfo = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * Request data.\n                 * @member {\"ledgerGetInfo\"|\"ledgerSetData\"|\"ledgerGetData\"|\"ledgerSubscribe\"|\"ledgerNotifyUpdate\"|\"ledgerResetInfo\"|undefined} data\n                 * @memberof particle.cloud.Request\n                 * @instance\n                 */\n                Object.defineProperty(Request.prototype, \"data\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"ledgerGetInfo\", \"ledgerSetData\", \"ledgerGetData\", \"ledgerSubscribe\", \"ledgerNotifyUpdate\", \"ledgerResetInfo\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new Request instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.Request\n                 * @static\n                 * @param {particle.cloud.IRequest=} [properties] Properties to set\n                 * @returns {particle.cloud.Request} Request instance\n                 */\n                Request.create = function create(properties) {\n                    return new Request(properties);\n                };\n    \n                /**\n                 * Encodes the specified Request message. Does not implicitly {@link particle.cloud.Request.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.Request\n                 * @static\n                 * @param {particle.cloud.IRequest} message Request message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Request.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.ledgerGetInfo != null && Object.hasOwnProperty.call(message, \"ledgerGetInfo\"))\n                        $root.particle.cloud.ledger.GetInfoRequest.encode(message.ledgerGetInfo, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.ledgerSetData != null && Object.hasOwnProperty.call(message, \"ledgerSetData\"))\n                        $root.particle.cloud.ledger.SetDataRequest.encode(message.ledgerSetData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.ledgerGetData != null && Object.hasOwnProperty.call(message, \"ledgerGetData\"))\n                        $root.particle.cloud.ledger.GetDataRequest.encode(message.ledgerGetData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.ledgerSubscribe != null && Object.hasOwnProperty.call(message, \"ledgerSubscribe\"))\n                        $root.particle.cloud.ledger.SubscribeRequest.encode(message.ledgerSubscribe, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.ledgerNotifyUpdate != null && Object.hasOwnProperty.call(message, \"ledgerNotifyUpdate\"))\n                        $root.particle.cloud.ledger.NotifyUpdateRequest.encode(message.ledgerNotifyUpdate, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.ledgerResetInfo != null && Object.hasOwnProperty.call(message, \"ledgerResetInfo\"))\n                        $root.particle.cloud.ledger.ResetInfoRequest.encode(message.ledgerResetInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a Request message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.Request\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.Request} Request\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Request.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.Request();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.ledgerGetInfo = $root.particle.cloud.ledger.GetInfoRequest.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.ledgerSetData = $root.particle.cloud.ledger.SetDataRequest.decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            message.ledgerGetData = $root.particle.cloud.ledger.GetDataRequest.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.ledgerSubscribe = $root.particle.cloud.ledger.SubscribeRequest.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.ledgerNotifyUpdate = $root.particle.cloud.ledger.NotifyUpdateRequest.decode(reader, reader.uint32());\n                            break;\n                        case 7:\n                            message.ledgerResetInfo = $root.particle.cloud.ledger.ResetInfoRequest.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Request type.\n                 * @name particle.cloud.Request.Type\n                 * @enum {number}\n                 * @property {number} INVALID=0 < Invalid request type.\n                 * @property {number} LEDGER_GET_INFO=1 < Get the ledger info.\n                 * @property {number} LEDGER_SET_DATA=2 < Update the contents of a remote ledger.\n                 * @property {number} LEDGER_GET_DATA=3 < Get the contents of a remote ledger.\n                 * @property {number} LEDGER_SUBSCRIBE=4 < Subscribe to ledger updates.\n                 * @property {number} LEDGER_NOTIFY_UPDATE=5 < Notify a ledger update.\n                 * @property {number} LEDGER_RESET_INFO=6 < Reset ledger info.\n                 */\n                Request.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID\"] = 0;\n                    values[valuesById[1] = \"LEDGER_GET_INFO\"] = 1;\n                    values[valuesById[2] = \"LEDGER_SET_DATA\"] = 2;\n                    values[valuesById[3] = \"LEDGER_GET_DATA\"] = 3;\n                    values[valuesById[4] = \"LEDGER_SUBSCRIBE\"] = 4;\n                    values[valuesById[5] = \"LEDGER_NOTIFY_UPDATE\"] = 5;\n                    values[valuesById[6] = \"LEDGER_RESET_INFO\"] = 6;\n                    return values;\n                })();\n    \n                return Request;\n            })();\n    \n            cloud.Response = (function() {\n    \n                /**\n                 * Properties of a Response.\n                 * @memberof particle.cloud\n                 * @interface IResponse\n                 * @property {number|null} [result] Result code.\n                 * \n                 * Possible result codes are defined by the `Result` enum. If the response is sent by the device,\n                 * the result code may be negative in which case it indicates a Device OS system error:\n                 * \n                 * https://github.com/particle-iot/device-os/blob/develop/services/inc/system_error.h\n                 * @property {string|null} [message] < Diagnostic message.\n                 * @property {particle.cloud.ledger.IGetInfoResponse|null} [ledgerGetInfo] Response ledgerGetInfo\n                 * @property {particle.cloud.ledger.ISetDataResponse|null} [ledgerSetData] Response ledgerSetData\n                 * @property {particle.cloud.ledger.IGetDataResponse|null} [ledgerGetData] Response ledgerGetData\n                 * @property {particle.cloud.ledger.ISubscribeResponse|null} [ledgerSubscribe] Response ledgerSubscribe\n                 * @property {particle.cloud.ledger.INotifyUpdateResponse|null} [ledgerNotifyUpdate] Response ledgerNotifyUpdate\n                 * @property {particle.cloud.ledger.IResetInfoResponse|null} [ledgerResetInfo] Response ledgerResetInfo\n                 */\n    \n                /**\n                 * Constructs a new Response.\n                 * @memberof particle.cloud\n                 * @classdesc Response message.\n                 * @implements IResponse\n                 * @constructor\n                 * @param {particle.cloud.IResponse=} [properties] Properties to set\n                 */\n                function Response(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Result code.\n                 * \n                 * Possible result codes are defined by the `Result` enum. If the response is sent by the device,\n                 * the result code may be negative in which case it indicates a Device OS system error:\n                 * \n                 * https://github.com/particle-iot/device-os/blob/develop/services/inc/system_error.h\n                 * @member {number} result\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.result = 0;\n    \n                /**\n                 * < Diagnostic message.\n                 * @member {string|null|undefined} message\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.message = null;\n    \n                /**\n                 * Response ledgerGetInfo.\n                 * @member {particle.cloud.ledger.IGetInfoResponse|null|undefined} ledgerGetInfo\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerGetInfo = null;\n    \n                /**\n                 * Response ledgerSetData.\n                 * @member {particle.cloud.ledger.ISetDataResponse|null|undefined} ledgerSetData\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerSetData = null;\n    \n                /**\n                 * Response ledgerGetData.\n                 * @member {particle.cloud.ledger.IGetDataResponse|null|undefined} ledgerGetData\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerGetData = null;\n    \n                /**\n                 * Response ledgerSubscribe.\n                 * @member {particle.cloud.ledger.ISubscribeResponse|null|undefined} ledgerSubscribe\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerSubscribe = null;\n    \n                /**\n                 * Response ledgerNotifyUpdate.\n                 * @member {particle.cloud.ledger.INotifyUpdateResponse|null|undefined} ledgerNotifyUpdate\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerNotifyUpdate = null;\n    \n                /**\n                 * Response ledgerResetInfo.\n                 * @member {particle.cloud.ledger.IResetInfoResponse|null|undefined} ledgerResetInfo\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Response.prototype.ledgerResetInfo = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * Response _message.\n                 * @member {\"message\"|undefined} _message\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Object.defineProperty(Response.prototype, \"_message\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"message\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Response data.\n                 * @member {\"ledgerGetInfo\"|\"ledgerSetData\"|\"ledgerGetData\"|\"ledgerSubscribe\"|\"ledgerNotifyUpdate\"|\"ledgerResetInfo\"|undefined} data\n                 * @memberof particle.cloud.Response\n                 * @instance\n                 */\n                Object.defineProperty(Response.prototype, \"data\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"ledgerGetInfo\", \"ledgerSetData\", \"ledgerGetData\", \"ledgerSubscribe\", \"ledgerNotifyUpdate\", \"ledgerResetInfo\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new Response instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.Response\n                 * @static\n                 * @param {particle.cloud.IResponse=} [properties] Properties to set\n                 * @returns {particle.cloud.Response} Response instance\n                 */\n                Response.create = function create(properties) {\n                    return new Response(properties);\n                };\n    \n                /**\n                 * Encodes the specified Response message. Does not implicitly {@link particle.cloud.Response.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.Response\n                 * @static\n                 * @param {particle.cloud.IResponse} message Response message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Response.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.result != null && Object.hasOwnProperty.call(message, \"result\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).sint32(message.result);\n                    if (message.message != null && Object.hasOwnProperty.call(message, \"message\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);\n                    if (message.ledgerGetInfo != null && Object.hasOwnProperty.call(message, \"ledgerGetInfo\"))\n                        $root.particle.cloud.ledger.GetInfoResponse.encode(message.ledgerGetInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.ledgerSetData != null && Object.hasOwnProperty.call(message, \"ledgerSetData\"))\n                        $root.particle.cloud.ledger.SetDataResponse.encode(message.ledgerSetData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.ledgerGetData != null && Object.hasOwnProperty.call(message, \"ledgerGetData\"))\n                        $root.particle.cloud.ledger.GetDataResponse.encode(message.ledgerGetData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.ledgerSubscribe != null && Object.hasOwnProperty.call(message, \"ledgerSubscribe\"))\n                        $root.particle.cloud.ledger.SubscribeResponse.encode(message.ledgerSubscribe, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.ledgerNotifyUpdate != null && Object.hasOwnProperty.call(message, \"ledgerNotifyUpdate\"))\n                        $root.particle.cloud.ledger.NotifyUpdateResponse.encode(message.ledgerNotifyUpdate, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.ledgerResetInfo != null && Object.hasOwnProperty.call(message, \"ledgerResetInfo\"))\n                        $root.particle.cloud.ledger.ResetInfoResponse.encode(message.ledgerResetInfo, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a Response message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.Response\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.Response} Response\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Response.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.Response();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.result = reader.sint32();\n                            break;\n                        case 2:\n                            message.message = reader.string();\n                            break;\n                        case 3:\n                            message.ledgerGetInfo = $root.particle.cloud.ledger.GetInfoResponse.decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            message.ledgerSetData = $root.particle.cloud.ledger.SetDataResponse.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.ledgerGetData = $root.particle.cloud.ledger.GetDataResponse.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.ledgerSubscribe = $root.particle.cloud.ledger.SubscribeResponse.decode(reader, reader.uint32());\n                            break;\n                        case 7:\n                            message.ledgerNotifyUpdate = $root.particle.cloud.ledger.NotifyUpdateResponse.decode(reader, reader.uint32());\n                            break;\n                        case 8:\n                            message.ledgerResetInfo = $root.particle.cloud.ledger.ResetInfoResponse.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Result code.\n                 * @name particle.cloud.Response.Result\n                 * @enum {number}\n                 * @property {number} OK=0 < Operation succeeded.\n                 * @property {number} ERROR=1 < Operation failed. See the CoAP response code and diagnostic message for details.\n                 * @property {number} LEDGER_NOT_FOUND=2 < Requested ledger is not found.\n                 * @property {number} LEDGER_INVALID_SYNC_DIRECTION=3 < Sync direction of the ledger is invalid.\n                 * @property {number} LEDGER_SCOPE_CHANGED=4 < Ledger scope changed.\n                 * @property {number} LEDGER_INVALID_DATA=5 < Invalid format of ledger data.\n                 * @property {number} LEDGER_TOO_LARGE_DATA=6 < Ledger data is too large.\n                 */\n                Response.Result = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"OK\"] = 0;\n                    values[valuesById[1] = \"ERROR\"] = 1;\n                    values[valuesById[2] = \"LEDGER_NOT_FOUND\"] = 2;\n                    values[valuesById[3] = \"LEDGER_INVALID_SYNC_DIRECTION\"] = 3;\n                    values[valuesById[4] = \"LEDGER_SCOPE_CHANGED\"] = 4;\n                    values[valuesById[5] = \"LEDGER_INVALID_DATA\"] = 5;\n                    values[valuesById[6] = \"LEDGER_TOO_LARGE_DATA\"] = 6;\n                    return values;\n                })();\n    \n                return Response;\n            })();\n    \n            cloud.ServerMovedPermanentlyRequest = (function() {\n    \n                /**\n                 * Properties of a ServerMovedPermanentlyRequest.\n                 * @memberof particle.cloud\n                 * @interface IServerMovedPermanentlyRequest\n                 * @property {string|null} [serverAddr] The address of the new server.\n                 * \n                 * The address can be a domain name or IP address. A domain name may contain placeholder arguments\n                 * such as `$id`.\n                 * @property {number|null} [serverPort] The port number of the new server. The default value is 5684.\n                 * @property {Uint8Array|null} [serverPubKey] The public key of the new server in DER format.\n                 * @property {Uint8Array|null} [sign] The signature of the server details.\n                 */\n    \n                /**\n                 * Constructs a new ServerMovedPermanentlyRequest.\n                 * @memberof particle.cloud\n                 * @classdesc A request sent to the device to notify it that it must disconnect from the current server and\n                 * use another server for further connections to the Cloud.\n                 * @implements IServerMovedPermanentlyRequest\n                 * @constructor\n                 * @param {particle.cloud.IServerMovedPermanentlyRequest=} [properties] Properties to set\n                 */\n                function ServerMovedPermanentlyRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * The address of the new server.\n                 * \n                 * The address can be a domain name or IP address. A domain name may contain placeholder arguments\n                 * such as `$id`.\n                 * @member {string} serverAddr\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @instance\n                 */\n                ServerMovedPermanentlyRequest.prototype.serverAddr = \"\";\n    \n                /**\n                 * The port number of the new server. The default value is 5684.\n                 * @member {number} serverPort\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @instance\n                 */\n                ServerMovedPermanentlyRequest.prototype.serverPort = 0;\n    \n                /**\n                 * The public key of the new server in DER format.\n                 * @member {Uint8Array} serverPubKey\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @instance\n                 */\n                ServerMovedPermanentlyRequest.prototype.serverPubKey = $util.newBuffer([]);\n    \n                /**\n                 * The signature of the server details.\n                 * @member {Uint8Array} sign\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @instance\n                 */\n                ServerMovedPermanentlyRequest.prototype.sign = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new ServerMovedPermanentlyRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @static\n                 * @param {particle.cloud.IServerMovedPermanentlyRequest=} [properties] Properties to set\n                 * @returns {particle.cloud.ServerMovedPermanentlyRequest} ServerMovedPermanentlyRequest instance\n                 */\n                ServerMovedPermanentlyRequest.create = function create(properties) {\n                    return new ServerMovedPermanentlyRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServerMovedPermanentlyRequest message. Does not implicitly {@link particle.cloud.ServerMovedPermanentlyRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @static\n                 * @param {particle.cloud.IServerMovedPermanentlyRequest} message ServerMovedPermanentlyRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServerMovedPermanentlyRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.serverAddr != null && Object.hasOwnProperty.call(message, \"serverAddr\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverAddr);\n                    if (message.serverPort != null && Object.hasOwnProperty.call(message, \"serverPort\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.serverPort);\n                    if (message.serverPubKey != null && Object.hasOwnProperty.call(message, \"serverPubKey\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.serverPubKey);\n                    if (message.sign != null && Object.hasOwnProperty.call(message, \"sign\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.sign);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServerMovedPermanentlyRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.ServerMovedPermanentlyRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.ServerMovedPermanentlyRequest} ServerMovedPermanentlyRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServerMovedPermanentlyRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ServerMovedPermanentlyRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.serverAddr = reader.string();\n                            break;\n                        case 2:\n                            message.serverPort = reader.uint32();\n                            break;\n                        case 3:\n                            message.serverPubKey = reader.bytes();\n                            break;\n                        case 4:\n                            message.sign = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServerMovedPermanentlyRequest;\n            })();\n    \n            cloud.ServerMovedPermanentlyResponse = (function() {\n    \n                /**\n                 * Properties of a ServerMovedPermanentlyResponse.\n                 * @memberof particle.cloud\n                 * @interface IServerMovedPermanentlyResponse\n                 */\n    \n                /**\n                 * Constructs a new ServerMovedPermanentlyResponse.\n                 * @memberof particle.cloud\n                 * @classdesc A response for a ServerMovedPermanentlyRequest.\n                 * @implements IServerMovedPermanentlyResponse\n                 * @constructor\n                 * @param {particle.cloud.IServerMovedPermanentlyResponse=} [properties] Properties to set\n                 */\n                function ServerMovedPermanentlyResponse(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new ServerMovedPermanentlyResponse instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.ServerMovedPermanentlyResponse\n                 * @static\n                 * @param {particle.cloud.IServerMovedPermanentlyResponse=} [properties] Properties to set\n                 * @returns {particle.cloud.ServerMovedPermanentlyResponse} ServerMovedPermanentlyResponse instance\n                 */\n                ServerMovedPermanentlyResponse.create = function create(properties) {\n                    return new ServerMovedPermanentlyResponse(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServerMovedPermanentlyResponse message. Does not implicitly {@link particle.cloud.ServerMovedPermanentlyResponse.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.ServerMovedPermanentlyResponse\n                 * @static\n                 * @param {particle.cloud.IServerMovedPermanentlyResponse} message ServerMovedPermanentlyResponse message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServerMovedPermanentlyResponse.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServerMovedPermanentlyResponse message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.ServerMovedPermanentlyResponse\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.ServerMovedPermanentlyResponse} ServerMovedPermanentlyResponse\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServerMovedPermanentlyResponse.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ServerMovedPermanentlyResponse();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServerMovedPermanentlyResponse;\n            })();\n    \n            cloud.ledger = (function() {\n    \n                /**\n                 * Namespace ledger.\n                 * @memberof particle.cloud\n                 * @namespace\n                 */\n                var ledger = {};\n    \n                /**\n                 * Scope type.\n                 * @name particle.cloud.ledger.ScopeType\n                 * @enum {number}\n                 * @property {number} SCOPE_TYPE_UNKNOWN=0 < Unknown scope.\n                 * @property {number} SCOPE_TYPE_DEVICE=1 < Device scope.\n                 * @property {number} SCOPE_TYPE_PRODUCT=2 < Product scope.\n                 * @property {number} SCOPE_TYPE_OWNER=3 < Owner scope.\n                 */\n                ledger.ScopeType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"SCOPE_TYPE_UNKNOWN\"] = 0;\n                    values[valuesById[1] = \"SCOPE_TYPE_DEVICE\"] = 1;\n                    values[valuesById[2] = \"SCOPE_TYPE_PRODUCT\"] = 2;\n                    values[valuesById[3] = \"SCOPE_TYPE_OWNER\"] = 3;\n                    return values;\n                })();\n    \n                /**\n                 * Sync direction.\n                 * @name particle.cloud.ledger.SyncDirection\n                 * @enum {number}\n                 * @property {number} SYNC_DIRECTION_UNKNOWN=0 < Unknown direction.\n                 * @property {number} SYNC_DIRECTION_DEVICE_TO_CLOUD=1 < Device to cloud.\n                 * @property {number} SYNC_DIRECTION_CLOUD_TO_DEVICE=2 < Cloud to device.\n                 */\n                ledger.SyncDirection = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"SYNC_DIRECTION_UNKNOWN\"] = 0;\n                    values[valuesById[1] = \"SYNC_DIRECTION_DEVICE_TO_CLOUD\"] = 1;\n                    values[valuesById[2] = \"SYNC_DIRECTION_CLOUD_TO_DEVICE\"] = 2;\n                    return values;\n                })();\n    \n                ledger.GetInfoRequest = (function() {\n    \n                    /**\n                     * Properties of a GetInfoRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface IGetInfoRequest\n                     * @property {Array.<string>|null} [ledgers] Names of the ledgers for which to request the info.\n                     */\n    \n                    /**\n                     * Constructs a new GetInfoRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Get the ledger info.\n                     * \n                     * This request is sent by the device.\n                     * @implements IGetInfoRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.IGetInfoRequest=} [properties] Properties to set\n                     */\n                    function GetInfoRequest(properties) {\n                        this.ledgers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Names of the ledgers for which to request the info.\n                     * @member {Array.<string>} ledgers\n                     * @memberof particle.cloud.ledger.GetInfoRequest\n                     * @instance\n                     */\n                    GetInfoRequest.prototype.ledgers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetInfoRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.GetInfoRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IGetInfoRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.GetInfoRequest} GetInfoRequest instance\n                     */\n                    GetInfoRequest.create = function create(properties) {\n                        return new GetInfoRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetInfoRequest message. Does not implicitly {@link particle.cloud.ledger.GetInfoRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.GetInfoRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IGetInfoRequest} message GetInfoRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetInfoRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ledgers != null && message.ledgers.length)\n                            for (var i = 0; i < message.ledgers.length; ++i)\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ledgers[i]);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetInfoRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.GetInfoRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.GetInfoRequest} GetInfoRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetInfoRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.GetInfoRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.ledgers && message.ledgers.length))\n                                    message.ledgers = [];\n                                message.ledgers.push(reader.string());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetInfoRequest;\n                })();\n    \n                ledger.GetInfoResponse = (function() {\n    \n                    /**\n                     * Properties of a GetInfoResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface IGetInfoResponse\n                     * @property {Array.<particle.cloud.ledger.GetInfoResponse.ILedger>|null} [ledgers] Ledger info.\n                     * \n                     * A ledger is omitted in the response if it cannot be found or is not accessible by the device.\n                     */\n    \n                    /**\n                     * Constructs a new GetInfoResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `GetInfoRequest`.\n                     * @implements IGetInfoResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.IGetInfoResponse=} [properties] Properties to set\n                     */\n                    function GetInfoResponse(properties) {\n                        this.ledgers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Ledger info.\n                     * \n                     * A ledger is omitted in the response if it cannot be found or is not accessible by the device.\n                     * @member {Array.<particle.cloud.ledger.GetInfoResponse.ILedger>} ledgers\n                     * @memberof particle.cloud.ledger.GetInfoResponse\n                     * @instance\n                     */\n                    GetInfoResponse.prototype.ledgers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetInfoResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.GetInfoResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IGetInfoResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.GetInfoResponse} GetInfoResponse instance\n                     */\n                    GetInfoResponse.create = function create(properties) {\n                        return new GetInfoResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetInfoResponse message. Does not implicitly {@link particle.cloud.ledger.GetInfoResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.GetInfoResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IGetInfoResponse} message GetInfoResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetInfoResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ledgers != null && message.ledgers.length)\n                            for (var i = 0; i < message.ledgers.length; ++i)\n                                $root.particle.cloud.ledger.GetInfoResponse.Ledger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetInfoResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.GetInfoResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.GetInfoResponse} GetInfoResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetInfoResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.GetInfoResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.ledgers && message.ledgers.length))\n                                    message.ledgers = [];\n                                message.ledgers.push($root.particle.cloud.ledger.GetInfoResponse.Ledger.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    GetInfoResponse.Ledger = (function() {\n    \n                        /**\n                         * Properties of a Ledger.\n                         * @memberof particle.cloud.ledger.GetInfoResponse\n                         * @interface ILedger\n                         * @property {string|null} [name] < Ledger name.\n                         * @property {Uint8Array|null} [scopeId] < Scope ID.\n                         * @property {particle.cloud.ledger.ScopeType|null} [scopeType] < Scope type.\n                         * @property {particle.cloud.ledger.SyncDirection|null} [syncDirection] Ledger syncDirection\n                         * @property {number|Long|null} [lastUpdated] Ledger lastUpdated\n                         */\n    \n                        /**\n                         * Constructs a new Ledger.\n                         * @memberof particle.cloud.ledger.GetInfoResponse\n                         * @classdesc Ledger info.\n                         * @implements ILedger\n                         * @constructor\n                         * @param {particle.cloud.ledger.GetInfoResponse.ILedger=} [properties] Properties to set\n                         */\n                        function Ledger(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * < Ledger name.\n                         * @member {string} name\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.name = \"\";\n    \n                        /**\n                         * < Scope ID.\n                         * @member {Uint8Array} scopeId\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.scopeId = $util.newBuffer([]);\n    \n                        /**\n                         * < Scope type.\n                         * @member {particle.cloud.ledger.ScopeType} scopeType\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.scopeType = 0;\n    \n                        /**\n                         * Ledger syncDirection.\n                         * @member {particle.cloud.ledger.SyncDirection} syncDirection\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.syncDirection = 0;\n    \n                        /**\n                         * Ledger lastUpdated.\n                         * @member {number|Long|null|undefined} lastUpdated\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.lastUpdated = null;\n    \n                        // OneOf field names bound to virtual getters and setters\n                        var $oneOfFields;\n    \n                        /**\n                         * Ledger _lastUpdated.\n                         * @member {\"lastUpdated\"|undefined} _lastUpdated\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @instance\n                         */\n                        Object.defineProperty(Ledger.prototype, \"_lastUpdated\", {\n                            get: $util.oneOfGetter($oneOfFields = [\"lastUpdated\"]),\n                            set: $util.oneOfSetter($oneOfFields)\n                        });\n    \n                        /**\n                         * Creates a new Ledger instance using the specified properties.\n                         * @function create\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.GetInfoResponse.ILedger=} [properties] Properties to set\n                         * @returns {particle.cloud.ledger.GetInfoResponse.Ledger} Ledger instance\n                         */\n                        Ledger.create = function create(properties) {\n                            return new Ledger(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Ledger message. Does not implicitly {@link particle.cloud.ledger.GetInfoResponse.Ledger.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.GetInfoResponse.ILedger} message Ledger message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Ledger.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                            if (message.scopeId != null && Object.hasOwnProperty.call(message, \"scopeId\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.scopeId);\n                            if (message.scopeType != null && Object.hasOwnProperty.call(message, \"scopeType\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.scopeType);\n                            if (message.syncDirection != null && Object.hasOwnProperty.call(message, \"syncDirection\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.syncDirection);\n                            if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                                writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.lastUpdated);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Ledger message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.cloud.ledger.GetInfoResponse.Ledger\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.cloud.ledger.GetInfoResponse.Ledger} Ledger\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Ledger.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.GetInfoResponse.Ledger();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.name = reader.string();\n                                    break;\n                                case 2:\n                                    message.scopeId = reader.bytes();\n                                    break;\n                                case 3:\n                                    message.scopeType = reader.int32();\n                                    break;\n                                case 4:\n                                    message.syncDirection = reader.int32();\n                                    break;\n                                case 5:\n                                    message.lastUpdated = reader.fixed64();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Ledger;\n                    })();\n    \n                    return GetInfoResponse;\n                })();\n    \n                ledger.SetDataRequest = (function() {\n    \n                    /**\n                     * Properties of a SetDataRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface ISetDataRequest\n                     * @property {string|null} [name] < Ledger name.\n                     * @property {Uint8Array|null} [scopeId] SetDataRequest scopeId\n                     * @property {number|Long|null} [lastUpdated] SetDataRequest lastUpdated\n                     * @property {Uint8Array|null} [data] SetDataRequest data\n                     */\n    \n                    /**\n                     * Constructs a new SetDataRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Update the contents of a remote device-to-cloud ledger.\n                     * \n                     * This request is sent by the device.\n                     * @implements ISetDataRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.ISetDataRequest=} [properties] Properties to set\n                     */\n                    function SetDataRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * < Ledger name.\n                     * @member {string} name\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @instance\n                     */\n                    SetDataRequest.prototype.name = \"\";\n    \n                    /**\n                     * SetDataRequest scopeId.\n                     * @member {Uint8Array} scopeId\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @instance\n                     */\n                    SetDataRequest.prototype.scopeId = $util.newBuffer([]);\n    \n                    /**\n                     * SetDataRequest lastUpdated.\n                     * @member {number|Long|null|undefined} lastUpdated\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @instance\n                     */\n                    SetDataRequest.prototype.lastUpdated = null;\n    \n                    /**\n                     * SetDataRequest data.\n                     * @member {Uint8Array} data\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @instance\n                     */\n                    SetDataRequest.prototype.data = $util.newBuffer([]);\n    \n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n    \n                    /**\n                     * SetDataRequest _lastUpdated.\n                     * @member {\"lastUpdated\"|undefined} _lastUpdated\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @instance\n                     */\n                    Object.defineProperty(SetDataRequest.prototype, \"_lastUpdated\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"lastUpdated\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * Creates a new SetDataRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @static\n                     * @param {particle.cloud.ledger.ISetDataRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.SetDataRequest} SetDataRequest instance\n                     */\n                    SetDataRequest.create = function create(properties) {\n                        return new SetDataRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetDataRequest message. Does not implicitly {@link particle.cloud.ledger.SetDataRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @static\n                     * @param {particle.cloud.ledger.ISetDataRequest} message SetDataRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetDataRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.scopeId != null && Object.hasOwnProperty.call(message, \"scopeId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.scopeId);\n                        if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.lastUpdated);\n                        if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.data);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetDataRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.SetDataRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.SetDataRequest} SetDataRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetDataRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SetDataRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.scopeId = reader.bytes();\n                                break;\n                            case 3:\n                                message.lastUpdated = reader.fixed64();\n                                break;\n                            case 10:\n                                message.data = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetDataRequest;\n                })();\n    \n                ledger.SetDataResponse = (function() {\n    \n                    /**\n                     * Properties of a SetDataResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface ISetDataResponse\n                     */\n    \n                    /**\n                     * Constructs a new SetDataResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `SetDataRequest`.\n                     * @implements ISetDataResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.ISetDataResponse=} [properties] Properties to set\n                     */\n                    function SetDataResponse(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetDataResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.SetDataResponse\n                     * @static\n                     * @param {particle.cloud.ledger.ISetDataResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.SetDataResponse} SetDataResponse instance\n                     */\n                    SetDataResponse.create = function create(properties) {\n                        return new SetDataResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetDataResponse message. Does not implicitly {@link particle.cloud.ledger.SetDataResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.SetDataResponse\n                     * @static\n                     * @param {particle.cloud.ledger.ISetDataResponse} message SetDataResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetDataResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetDataResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.SetDataResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.SetDataResponse} SetDataResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetDataResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SetDataResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetDataResponse;\n                })();\n    \n                ledger.GetDataRequest = (function() {\n    \n                    /**\n                     * Properties of a GetDataRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface IGetDataRequest\n                     * @property {string|null} [name] < Ledger name.\n                     * @property {Uint8Array|null} [scopeId] GetDataRequest scopeId\n                     * @property {number|Long|null} [lastUpdated] GetDataRequest lastUpdated\n                     */\n    \n                    /**\n                     * Constructs a new GetDataRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Get the contents of a remote cloud-to-device ledger.\n                     * \n                     * This request is sent by the device.\n                     * @implements IGetDataRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.IGetDataRequest=} [properties] Properties to set\n                     */\n                    function GetDataRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * < Ledger name.\n                     * @member {string} name\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @instance\n                     */\n                    GetDataRequest.prototype.name = \"\";\n    \n                    /**\n                     * GetDataRequest scopeId.\n                     * @member {Uint8Array} scopeId\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @instance\n                     */\n                    GetDataRequest.prototype.scopeId = $util.newBuffer([]);\n    \n                    /**\n                     * GetDataRequest lastUpdated.\n                     * @member {number|Long|null|undefined} lastUpdated\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @instance\n                     */\n                    GetDataRequest.prototype.lastUpdated = null;\n    \n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n    \n                    /**\n                     * GetDataRequest _lastUpdated.\n                     * @member {\"lastUpdated\"|undefined} _lastUpdated\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @instance\n                     */\n                    Object.defineProperty(GetDataRequest.prototype, \"_lastUpdated\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"lastUpdated\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * Creates a new GetDataRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IGetDataRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.GetDataRequest} GetDataRequest instance\n                     */\n                    GetDataRequest.create = function create(properties) {\n                        return new GetDataRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetDataRequest message. Does not implicitly {@link particle.cloud.ledger.GetDataRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IGetDataRequest} message GetDataRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetDataRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.scopeId != null && Object.hasOwnProperty.call(message, \"scopeId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.scopeId);\n                        if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                            writer.uint32(/* id 3, wireType 1 =*/25).fixed64(message.lastUpdated);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetDataRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.GetDataRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.GetDataRequest} GetDataRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetDataRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.GetDataRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.scopeId = reader.bytes();\n                                break;\n                            case 3:\n                                message.lastUpdated = reader.fixed64();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetDataRequest;\n                })();\n    \n                ledger.GetDataResponse = (function() {\n    \n                    /**\n                     * Properties of a GetDataResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface IGetDataResponse\n                     * @property {number|Long|null} [lastUpdated] Time the ledger was last updated, in milliseconds since the Unix epoch.\n                     * \n                     * If not set, the ledger has not yet been assigned any data.\n                     * @property {Uint8Array|null} [data] GetDataResponse data\n                     */\n    \n                    /**\n                     * Constructs a new GetDataResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `GetDataRequest`.\n                     * @implements IGetDataResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.IGetDataResponse=} [properties] Properties to set\n                     */\n                    function GetDataResponse(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Time the ledger was last updated, in milliseconds since the Unix epoch.\n                     * \n                     * If not set, the ledger has not yet been assigned any data.\n                     * @member {number|Long|null|undefined} lastUpdated\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @instance\n                     */\n                    GetDataResponse.prototype.lastUpdated = null;\n    \n                    /**\n                     * GetDataResponse data.\n                     * @member {Uint8Array|null|undefined} data\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @instance\n                     */\n                    GetDataResponse.prototype.data = null;\n    \n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n    \n                    /**\n                     * GetDataResponse _lastUpdated.\n                     * @member {\"lastUpdated\"|undefined} _lastUpdated\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @instance\n                     */\n                    Object.defineProperty(GetDataResponse.prototype, \"_lastUpdated\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"lastUpdated\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * GetDataResponse _data.\n                     * @member {\"data\"|undefined} _data\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @instance\n                     */\n                    Object.defineProperty(GetDataResponse.prototype, \"_data\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"data\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * Creates a new GetDataResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IGetDataResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.GetDataResponse} GetDataResponse instance\n                     */\n                    GetDataResponse.create = function create(properties) {\n                        return new GetDataResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetDataResponse message. Does not implicitly {@link particle.cloud.ledger.GetDataResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IGetDataResponse} message GetDataResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetDataResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                            writer.uint32(/* id 1, wireType 1 =*/9).fixed64(message.lastUpdated);\n                        if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                            writer.uint32(/* id 10, wireType 2 =*/82).bytes(message.data);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetDataResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.GetDataResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.GetDataResponse} GetDataResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetDataResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.GetDataResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.lastUpdated = reader.fixed64();\n                                break;\n                            case 10:\n                                message.data = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetDataResponse;\n                })();\n    \n                ledger.SubscribeRequest = (function() {\n    \n                    /**\n                     * Properties of a SubscribeRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface ISubscribeRequest\n                     * @property {Array.<particle.cloud.ledger.SubscribeRequest.ILedger>|null} [ledgers] < Ledgers to subscribe to.\n                     */\n    \n                    /**\n                     * Constructs a new SubscribeRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Subscribe to notifications about updates made to one or multiple cloud-to-device ledgers.\n                     * \n                     * Subscriptions listed in this request will replace all the subscriptions currently registered on\n                     * the server.\n                     * \n                     * This request is sent by the device.\n                     * @implements ISubscribeRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.ISubscribeRequest=} [properties] Properties to set\n                     */\n                    function SubscribeRequest(properties) {\n                        this.ledgers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * < Ledgers to subscribe to.\n                     * @member {Array.<particle.cloud.ledger.SubscribeRequest.ILedger>} ledgers\n                     * @memberof particle.cloud.ledger.SubscribeRequest\n                     * @instance\n                     */\n                    SubscribeRequest.prototype.ledgers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new SubscribeRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.SubscribeRequest\n                     * @static\n                     * @param {particle.cloud.ledger.ISubscribeRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.SubscribeRequest} SubscribeRequest instance\n                     */\n                    SubscribeRequest.create = function create(properties) {\n                        return new SubscribeRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SubscribeRequest message. Does not implicitly {@link particle.cloud.ledger.SubscribeRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.SubscribeRequest\n                     * @static\n                     * @param {particle.cloud.ledger.ISubscribeRequest} message SubscribeRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SubscribeRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ledgers != null && message.ledgers.length)\n                            for (var i = 0; i < message.ledgers.length; ++i)\n                                $root.particle.cloud.ledger.SubscribeRequest.Ledger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SubscribeRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.SubscribeRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.SubscribeRequest} SubscribeRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SubscribeRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SubscribeRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.ledgers && message.ledgers.length))\n                                    message.ledgers = [];\n                                message.ledgers.push($root.particle.cloud.ledger.SubscribeRequest.Ledger.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    SubscribeRequest.Ledger = (function() {\n    \n                        /**\n                         * Properties of a Ledger.\n                         * @memberof particle.cloud.ledger.SubscribeRequest\n                         * @interface ILedger\n                         * @property {string|null} [name] < Ledger name.\n                         * @property {Uint8Array|null} [scopeId] < Scope ID.\n                         */\n    \n                        /**\n                         * Constructs a new Ledger.\n                         * @memberof particle.cloud.ledger.SubscribeRequest\n                         * @classdesc Ledger info.\n                         * @implements ILedger\n                         * @constructor\n                         * @param {particle.cloud.ledger.SubscribeRequest.ILedger=} [properties] Properties to set\n                         */\n                        function Ledger(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * < Ledger name.\n                         * @member {string} name\n                         * @memberof particle.cloud.ledger.SubscribeRequest.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.name = \"\";\n    \n                        /**\n                         * < Scope ID.\n                         * @member {Uint8Array} scopeId\n                         * @memberof particle.cloud.ledger.SubscribeRequest.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.scopeId = $util.newBuffer([]);\n    \n                        /**\n                         * Creates a new Ledger instance using the specified properties.\n                         * @function create\n                         * @memberof particle.cloud.ledger.SubscribeRequest.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.SubscribeRequest.ILedger=} [properties] Properties to set\n                         * @returns {particle.cloud.ledger.SubscribeRequest.Ledger} Ledger instance\n                         */\n                        Ledger.create = function create(properties) {\n                            return new Ledger(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Ledger message. Does not implicitly {@link particle.cloud.ledger.SubscribeRequest.Ledger.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.cloud.ledger.SubscribeRequest.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.SubscribeRequest.ILedger} message Ledger message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Ledger.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                            if (message.scopeId != null && Object.hasOwnProperty.call(message, \"scopeId\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.scopeId);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Ledger message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.cloud.ledger.SubscribeRequest.Ledger\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.cloud.ledger.SubscribeRequest.Ledger} Ledger\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Ledger.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SubscribeRequest.Ledger();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.name = reader.string();\n                                    break;\n                                case 2:\n                                    message.scopeId = reader.bytes();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Ledger;\n                    })();\n    \n                    return SubscribeRequest;\n                })();\n    \n                ledger.SubscribeResponse = (function() {\n    \n                    /**\n                     * Properties of a SubscribeResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface ISubscribeResponse\n                     * @property {Array.<particle.cloud.ledger.SubscribeResponse.ILedger>|null} [ledgers] < Ledger info.\n                     */\n    \n                    /**\n                     * Constructs a new SubscribeResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `SubscribeRequest`.\n                     * @implements ISubscribeResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.ISubscribeResponse=} [properties] Properties to set\n                     */\n                    function SubscribeResponse(properties) {\n                        this.ledgers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * < Ledger info.\n                     * @member {Array.<particle.cloud.ledger.SubscribeResponse.ILedger>} ledgers\n                     * @memberof particle.cloud.ledger.SubscribeResponse\n                     * @instance\n                     */\n                    SubscribeResponse.prototype.ledgers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new SubscribeResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.SubscribeResponse\n                     * @static\n                     * @param {particle.cloud.ledger.ISubscribeResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.SubscribeResponse} SubscribeResponse instance\n                     */\n                    SubscribeResponse.create = function create(properties) {\n                        return new SubscribeResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SubscribeResponse message. Does not implicitly {@link particle.cloud.ledger.SubscribeResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.SubscribeResponse\n                     * @static\n                     * @param {particle.cloud.ledger.ISubscribeResponse} message SubscribeResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SubscribeResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ledgers != null && message.ledgers.length)\n                            for (var i = 0; i < message.ledgers.length; ++i)\n                                $root.particle.cloud.ledger.SubscribeResponse.Ledger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SubscribeResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.SubscribeResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.SubscribeResponse} SubscribeResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SubscribeResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SubscribeResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.ledgers && message.ledgers.length))\n                                    message.ledgers = [];\n                                message.ledgers.push($root.particle.cloud.ledger.SubscribeResponse.Ledger.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    SubscribeResponse.Ledger = (function() {\n    \n                        /**\n                         * Properties of a Ledger.\n                         * @memberof particle.cloud.ledger.SubscribeResponse\n                         * @interface ILedger\n                         * @property {string|null} [name] Ledger name\n                         * @property {number|Long|null} [lastUpdated] Ledger lastUpdated\n                         */\n    \n                        /**\n                         * Constructs a new Ledger.\n                         * @memberof particle.cloud.ledger.SubscribeResponse\n                         * @classdesc Ledger info.\n                         * @implements ILedger\n                         * @constructor\n                         * @param {particle.cloud.ledger.SubscribeResponse.ILedger=} [properties] Properties to set\n                         */\n                        function Ledger(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Ledger name.\n                         * @member {string} name\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.name = \"\";\n    \n                        /**\n                         * Ledger lastUpdated.\n                         * @member {number|Long|null|undefined} lastUpdated\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.lastUpdated = null;\n    \n                        // OneOf field names bound to virtual getters and setters\n                        var $oneOfFields;\n    \n                        /**\n                         * Ledger _lastUpdated.\n                         * @member {\"lastUpdated\"|undefined} _lastUpdated\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @instance\n                         */\n                        Object.defineProperty(Ledger.prototype, \"_lastUpdated\", {\n                            get: $util.oneOfGetter($oneOfFields = [\"lastUpdated\"]),\n                            set: $util.oneOfSetter($oneOfFields)\n                        });\n    \n                        /**\n                         * Creates a new Ledger instance using the specified properties.\n                         * @function create\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.SubscribeResponse.ILedger=} [properties] Properties to set\n                         * @returns {particle.cloud.ledger.SubscribeResponse.Ledger} Ledger instance\n                         */\n                        Ledger.create = function create(properties) {\n                            return new Ledger(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Ledger message. Does not implicitly {@link particle.cloud.ledger.SubscribeResponse.Ledger.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.SubscribeResponse.ILedger} message Ledger message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Ledger.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                            if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.lastUpdated);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Ledger message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.cloud.ledger.SubscribeResponse.Ledger\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.cloud.ledger.SubscribeResponse.Ledger} Ledger\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Ledger.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.SubscribeResponse.Ledger();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.name = reader.string();\n                                    break;\n                                case 2:\n                                    message.lastUpdated = reader.fixed64();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Ledger;\n                    })();\n    \n                    return SubscribeResponse;\n                })();\n    \n                ledger.NotifyUpdateRequest = (function() {\n    \n                    /**\n                     * Properties of a NotifyUpdateRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface INotifyUpdateRequest\n                     * @property {Array.<particle.cloud.ledger.NotifyUpdateRequest.ILedger>|null} [ledgers] < Ledger info.\n                     */\n    \n                    /**\n                     * Constructs a new NotifyUpdateRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Notify the device that one or more cloud-to-device ledgers were updated.\n                     * \n                     * This request is sent by the server.\n                     * @implements INotifyUpdateRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.INotifyUpdateRequest=} [properties] Properties to set\n                     */\n                    function NotifyUpdateRequest(properties) {\n                        this.ledgers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * < Ledger info.\n                     * @member {Array.<particle.cloud.ledger.NotifyUpdateRequest.ILedger>} ledgers\n                     * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                     * @instance\n                     */\n                    NotifyUpdateRequest.prototype.ledgers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new NotifyUpdateRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                     * @static\n                     * @param {particle.cloud.ledger.INotifyUpdateRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.NotifyUpdateRequest} NotifyUpdateRequest instance\n                     */\n                    NotifyUpdateRequest.create = function create(properties) {\n                        return new NotifyUpdateRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NotifyUpdateRequest message. Does not implicitly {@link particle.cloud.ledger.NotifyUpdateRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                     * @static\n                     * @param {particle.cloud.ledger.INotifyUpdateRequest} message NotifyUpdateRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NotifyUpdateRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ledgers != null && message.ledgers.length)\n                            for (var i = 0; i < message.ledgers.length; ++i)\n                                $root.particle.cloud.ledger.NotifyUpdateRequest.Ledger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NotifyUpdateRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.NotifyUpdateRequest} NotifyUpdateRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NotifyUpdateRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.NotifyUpdateRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.ledgers && message.ledgers.length))\n                                    message.ledgers = [];\n                                message.ledgers.push($root.particle.cloud.ledger.NotifyUpdateRequest.Ledger.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    NotifyUpdateRequest.Ledger = (function() {\n    \n                        /**\n                         * Properties of a Ledger.\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                         * @interface ILedger\n                         * @property {string|null} [name] Ledger name\n                         * @property {number|Long|null} [lastUpdated] Ledger lastUpdated\n                         */\n    \n                        /**\n                         * Constructs a new Ledger.\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest\n                         * @classdesc Ledger info.\n                         * @implements ILedger\n                         * @constructor\n                         * @param {particle.cloud.ledger.NotifyUpdateRequest.ILedger=} [properties] Properties to set\n                         */\n                        function Ledger(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Ledger name.\n                         * @member {string} name\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.name = \"\";\n    \n                        /**\n                         * Ledger lastUpdated.\n                         * @member {number|Long} lastUpdated\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest.Ledger\n                         * @instance\n                         */\n                        Ledger.prototype.lastUpdated = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n    \n                        /**\n                         * Creates a new Ledger instance using the specified properties.\n                         * @function create\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.NotifyUpdateRequest.ILedger=} [properties] Properties to set\n                         * @returns {particle.cloud.ledger.NotifyUpdateRequest.Ledger} Ledger instance\n                         */\n                        Ledger.create = function create(properties) {\n                            return new Ledger(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Ledger message. Does not implicitly {@link particle.cloud.ledger.NotifyUpdateRequest.Ledger.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest.Ledger\n                         * @static\n                         * @param {particle.cloud.ledger.NotifyUpdateRequest.ILedger} message Ledger message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Ledger.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                            if (message.lastUpdated != null && Object.hasOwnProperty.call(message, \"lastUpdated\"))\n                                writer.uint32(/* id 2, wireType 1 =*/17).fixed64(message.lastUpdated);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Ledger message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.cloud.ledger.NotifyUpdateRequest.Ledger\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.cloud.ledger.NotifyUpdateRequest.Ledger} Ledger\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Ledger.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.NotifyUpdateRequest.Ledger();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.name = reader.string();\n                                    break;\n                                case 2:\n                                    message.lastUpdated = reader.fixed64();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Ledger;\n                    })();\n    \n                    return NotifyUpdateRequest;\n                })();\n    \n                ledger.NotifyUpdateResponse = (function() {\n    \n                    /**\n                     * Properties of a NotifyUpdateResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface INotifyUpdateResponse\n                     */\n    \n                    /**\n                     * Constructs a new NotifyUpdateResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `NotifyUpdateRequest`.\n                     * @implements INotifyUpdateResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.INotifyUpdateResponse=} [properties] Properties to set\n                     */\n                    function NotifyUpdateResponse(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new NotifyUpdateResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.NotifyUpdateResponse\n                     * @static\n                     * @param {particle.cloud.ledger.INotifyUpdateResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.NotifyUpdateResponse} NotifyUpdateResponse instance\n                     */\n                    NotifyUpdateResponse.create = function create(properties) {\n                        return new NotifyUpdateResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NotifyUpdateResponse message. Does not implicitly {@link particle.cloud.ledger.NotifyUpdateResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.NotifyUpdateResponse\n                     * @static\n                     * @param {particle.cloud.ledger.INotifyUpdateResponse} message NotifyUpdateResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NotifyUpdateResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NotifyUpdateResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.NotifyUpdateResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.NotifyUpdateResponse} NotifyUpdateResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NotifyUpdateResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.NotifyUpdateResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return NotifyUpdateResponse;\n                })();\n    \n                ledger.ResetInfoRequest = (function() {\n    \n                    /**\n                     * Properties of a ResetInfoRequest.\n                     * @memberof particle.cloud.ledger\n                     * @interface IResetInfoRequest\n                     */\n    \n                    /**\n                     * Constructs a new ResetInfoRequest.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Notify the device that it needs to re-request the info about all ledgers in use.\n                     * \n                     * This request is sent by the server.\n                     * @implements IResetInfoRequest\n                     * @constructor\n                     * @param {particle.cloud.ledger.IResetInfoRequest=} [properties] Properties to set\n                     */\n                    function ResetInfoRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ResetInfoRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.ResetInfoRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IResetInfoRequest=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.ResetInfoRequest} ResetInfoRequest instance\n                     */\n                    ResetInfoRequest.create = function create(properties) {\n                        return new ResetInfoRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ResetInfoRequest message. Does not implicitly {@link particle.cloud.ledger.ResetInfoRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.ResetInfoRequest\n                     * @static\n                     * @param {particle.cloud.ledger.IResetInfoRequest} message ResetInfoRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResetInfoRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ResetInfoRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.ResetInfoRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.ResetInfoRequest} ResetInfoRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResetInfoRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.ResetInfoRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ResetInfoRequest;\n                })();\n    \n                ledger.ResetInfoResponse = (function() {\n    \n                    /**\n                     * Properties of a ResetInfoResponse.\n                     * @memberof particle.cloud.ledger\n                     * @interface IResetInfoResponse\n                     */\n    \n                    /**\n                     * Constructs a new ResetInfoResponse.\n                     * @memberof particle.cloud.ledger\n                     * @classdesc Response for `ResetInfoRequest`.\n                     * @implements IResetInfoResponse\n                     * @constructor\n                     * @param {particle.cloud.ledger.IResetInfoResponse=} [properties] Properties to set\n                     */\n                    function ResetInfoResponse(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ResetInfoResponse instance using the specified properties.\n                     * @function create\n                     * @memberof particle.cloud.ledger.ResetInfoResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IResetInfoResponse=} [properties] Properties to set\n                     * @returns {particle.cloud.ledger.ResetInfoResponse} ResetInfoResponse instance\n                     */\n                    ResetInfoResponse.create = function create(properties) {\n                        return new ResetInfoResponse(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ResetInfoResponse message. Does not implicitly {@link particle.cloud.ledger.ResetInfoResponse.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.cloud.ledger.ResetInfoResponse\n                     * @static\n                     * @param {particle.cloud.ledger.IResetInfoResponse} message ResetInfoResponse message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ResetInfoResponse.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ResetInfoResponse message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.cloud.ledger.ResetInfoResponse\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.cloud.ledger.ResetInfoResponse} ResetInfoResponse\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ResetInfoResponse.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.ledger.ResetInfoResponse();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ResetInfoResponse;\n                })();\n    \n                return ledger;\n            })();\n    \n            /**\n             * Firmware module types.\n             * @name particle.cloud.FirmwareModuleType\n             * @enum {number}\n             * @property {number} INVALID_MODULE=0 < Invalid\n             * @property {number} RESOURCE_MODULE=1 < Resource module\n             * @property {number} BOOTLOADER_MODULE=2 < Bootloader module\n             * @property {number} MONO_FIRMWARE_MODULE=3 < Monolithic firmware module\n             * @property {number} SYSTEM_PART_MODULE=4 < System part module\n             * @property {number} USER_PART_MODULE=5 < User part module\n             * @property {number} SETTINGS_MODULE=6 < Settings module\n             * @property {number} NCP_FIRMWARE_MODULE=7 < NCP firmware module\n             * @property {number} RADIO_STACK_MODULE=8 < Radio stack module\n             * @property {number} ASSET_MODULE=9 < Asset module\n             */\n            cloud.FirmwareModuleType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_MODULE\"] = 0;\n                values[valuesById[1] = \"RESOURCE_MODULE\"] = 1;\n                values[valuesById[2] = \"BOOTLOADER_MODULE\"] = 2;\n                values[valuesById[3] = \"MONO_FIRMWARE_MODULE\"] = 3;\n                values[valuesById[4] = \"SYSTEM_PART_MODULE\"] = 4;\n                values[valuesById[5] = \"USER_PART_MODULE\"] = 5;\n                values[valuesById[6] = \"SETTINGS_MODULE\"] = 6;\n                values[valuesById[7] = \"NCP_FIRMWARE_MODULE\"] = 7;\n                values[valuesById[8] = \"RADIO_STACK_MODULE\"] = 8;\n                values[valuesById[9] = \"ASSET_MODULE\"] = 9;\n                return values;\n            })();\n    \n            /**\n             * Firmware module store.\n             * @name particle.cloud.FirmwareModuleStore\n             * @enum {number}\n             * @property {number} MAIN_MODULE_STORE=0 < Main store\n             * @property {number} FACTORY_MODULE_STORE=1 < Factory store\n             * @property {number} BACKUP_MODULE_STORE=2 < Backup store\n             * @property {number} SCRATCHPAD_MODULE_STORE=3 < Scratchpad store\n             */\n            cloud.FirmwareModuleStore = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"MAIN_MODULE_STORE\"] = 0;\n                values[valuesById[1] = \"FACTORY_MODULE_STORE\"] = 1;\n                values[valuesById[2] = \"BACKUP_MODULE_STORE\"] = 2;\n                values[valuesById[3] = \"SCRATCHPAD_MODULE_STORE\"] = 3;\n                return values;\n            })();\n    \n            /**\n             * Firmware module validation flags.\n             * @name particle.cloud.FirmwareModuleValidityFlag\n             * @enum {number}\n             * @property {number} MODULE_NO_VALID_FLAGS=0 MODULE_NO_VALID_FLAGS value\n             * @property {number} MODULE_INTEGRITY_VALID_FLAG=2 < Module integrity\n             * @property {number} MODULE_DEPENDENCIES_VALID_FLAG=4 < Module dependencies\n             * @property {number} MODULE_RANGE_VALID_FLAG=8 < Module address and size\n             * @property {number} MODULE_PLATFORM_VALID_FLAG=16 < Module platform\n             */\n            cloud.FirmwareModuleValidityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"MODULE_NO_VALID_FLAGS\"] = 0;\n                values[valuesById[2] = \"MODULE_INTEGRITY_VALID_FLAG\"] = 2;\n                values[valuesById[4] = \"MODULE_DEPENDENCIES_VALID_FLAG\"] = 4;\n                values[valuesById[8] = \"MODULE_RANGE_VALID_FLAG\"] = 8;\n                values[valuesById[16] = \"MODULE_PLATFORM_VALID_FLAG\"] = 16;\n                return values;\n            })();\n    \n            /**\n             * Firmware module security\n             * @name particle.cloud.FirmwareModuleSecurityMode\n             * @enum {number}\n             * @property {number} NONE=0 NONE value\n             * @property {number} PROTECTED=1 PROTECTED value\n             */\n            cloud.FirmwareModuleSecurityMode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NONE\"] = 0;\n                values[valuesById[1] = \"PROTECTED\"] = 1;\n                return values;\n            })();\n    \n            cloud.FirmwareModuleSecurity = (function() {\n    \n                /**\n                 * Properties of a FirmwareModuleSecurity.\n                 * @memberof particle.cloud\n                 * @interface IFirmwareModuleSecurity\n                 * @property {particle.cloud.FirmwareModuleSecurityMode|null} [mode] < Security mode\n                 * @property {Uint8Array|null} [certificateFingerprint] < Certificate fingerprint (SHA-256)\n                 */\n    \n                /**\n                 * Constructs a new FirmwareModuleSecurity.\n                 * @memberof particle.cloud\n                 * @classdesc Represents a FirmwareModuleSecurity.\n                 * @implements IFirmwareModuleSecurity\n                 * @constructor\n                 * @param {particle.cloud.IFirmwareModuleSecurity=} [properties] Properties to set\n                 */\n                function FirmwareModuleSecurity(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < Security mode\n                 * @member {particle.cloud.FirmwareModuleSecurityMode} mode\n                 * @memberof particle.cloud.FirmwareModuleSecurity\n                 * @instance\n                 */\n                FirmwareModuleSecurity.prototype.mode = 0;\n    \n                /**\n                 * < Certificate fingerprint (SHA-256)\n                 * @member {Uint8Array} certificateFingerprint\n                 * @memberof particle.cloud.FirmwareModuleSecurity\n                 * @instance\n                 */\n                FirmwareModuleSecurity.prototype.certificateFingerprint = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new FirmwareModuleSecurity instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.FirmwareModuleSecurity\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleSecurity=} [properties] Properties to set\n                 * @returns {particle.cloud.FirmwareModuleSecurity} FirmwareModuleSecurity instance\n                 */\n                FirmwareModuleSecurity.create = function create(properties) {\n                    return new FirmwareModuleSecurity(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareModuleSecurity message. Does not implicitly {@link particle.cloud.FirmwareModuleSecurity.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.FirmwareModuleSecurity\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleSecurity} message FirmwareModuleSecurity message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareModuleSecurity.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);\n                    if (message.certificateFingerprint != null && Object.hasOwnProperty.call(message, \"certificateFingerprint\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.certificateFingerprint);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareModuleSecurity message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.FirmwareModuleSecurity\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.FirmwareModuleSecurity} FirmwareModuleSecurity\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareModuleSecurity.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModuleSecurity();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.mode = reader.int32();\n                            break;\n                        case 2:\n                            message.certificateFingerprint = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareModuleSecurity;\n            })();\n    \n            cloud.FirmwareModuleDependency = (function() {\n    \n                /**\n                 * Properties of a FirmwareModuleDependency.\n                 * @memberof particle.cloud\n                 * @interface IFirmwareModuleDependency\n                 * @property {particle.cloud.FirmwareModuleType|null} [type] < Module type\n                 * @property {number|null} [index] < Module index\n                 * @property {number|null} [version] < Module version\n                 */\n    \n                /**\n                 * Constructs a new FirmwareModuleDependency.\n                 * @memberof particle.cloud\n                 * @classdesc Firmware module dependency.\n                 * @implements IFirmwareModuleDependency\n                 * @constructor\n                 * @param {particle.cloud.IFirmwareModuleDependency=} [properties] Properties to set\n                 */\n                function FirmwareModuleDependency(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < Module type\n                 * @member {particle.cloud.FirmwareModuleType} type\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @instance\n                 */\n                FirmwareModuleDependency.prototype.type = 0;\n    \n                /**\n                 * < Module index\n                 * @member {number} index\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @instance\n                 */\n                FirmwareModuleDependency.prototype.index = 0;\n    \n                /**\n                 * < Module version\n                 * @member {number} version\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @instance\n                 */\n                FirmwareModuleDependency.prototype.version = 0;\n    \n                /**\n                 * Creates a new FirmwareModuleDependency instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleDependency=} [properties] Properties to set\n                 * @returns {particle.cloud.FirmwareModuleDependency} FirmwareModuleDependency instance\n                 */\n                FirmwareModuleDependency.create = function create(properties) {\n                    return new FirmwareModuleDependency(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareModuleDependency message. Does not implicitly {@link particle.cloud.FirmwareModuleDependency.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleDependency} message FirmwareModuleDependency message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareModuleDependency.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareModuleDependency message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.FirmwareModuleDependency\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.FirmwareModuleDependency} FirmwareModuleDependency\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareModuleDependency.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModuleDependency();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.index = reader.uint32();\n                            break;\n                        case 3:\n                            message.version = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareModuleDependency;\n            })();\n    \n            cloud.FirmwareModuleAsset = (function() {\n    \n                /**\n                 * Properties of a FirmwareModuleAsset.\n                 * @memberof particle.cloud\n                 * @interface IFirmwareModuleAsset\n                 * @property {Uint8Array|null} [hash] < SHA-256 hash\n                 * @property {string|null} [name] < Asset name\n                 * @property {number|null} [size] < Asset size\n                 * @property {number|null} [storageSize] < Asset storage size (taking into account compression and metadata)\n                 */\n    \n                /**\n                 * Constructs a new FirmwareModuleAsset.\n                 * @memberof particle.cloud\n                 * @classdesc Represents a FirmwareModuleAsset.\n                 * @implements IFirmwareModuleAsset\n                 * @constructor\n                 * @param {particle.cloud.IFirmwareModuleAsset=} [properties] Properties to set\n                 */\n                function FirmwareModuleAsset(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < SHA-256 hash\n                 * @member {Uint8Array} hash\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @instance\n                 */\n                FirmwareModuleAsset.prototype.hash = $util.newBuffer([]);\n    \n                /**\n                 * < Asset name\n                 * @member {string} name\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @instance\n                 */\n                FirmwareModuleAsset.prototype.name = \"\";\n    \n                /**\n                 * < Asset size\n                 * @member {number} size\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @instance\n                 */\n                FirmwareModuleAsset.prototype.size = 0;\n    \n                /**\n                 * < Asset storage size (taking into account compression and metadata)\n                 * @member {number} storageSize\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @instance\n                 */\n                FirmwareModuleAsset.prototype.storageSize = 0;\n    \n                /**\n                 * Creates a new FirmwareModuleAsset instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleAsset=} [properties] Properties to set\n                 * @returns {particle.cloud.FirmwareModuleAsset} FirmwareModuleAsset instance\n                 */\n                FirmwareModuleAsset.create = function create(properties) {\n                    return new FirmwareModuleAsset(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareModuleAsset message. Does not implicitly {@link particle.cloud.FirmwareModuleAsset.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @static\n                 * @param {particle.cloud.IFirmwareModuleAsset} message FirmwareModuleAsset message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareModuleAsset.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.hash);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.size);\n                    if (message.storageSize != null && Object.hasOwnProperty.call(message, \"storageSize\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.storageSize);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareModuleAsset message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.FirmwareModuleAsset\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.FirmwareModuleAsset} FirmwareModuleAsset\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareModuleAsset.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModuleAsset();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.hash = reader.bytes();\n                            break;\n                        case 2:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.size = reader.uint32();\n                            break;\n                        case 4:\n                            message.storageSize = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareModuleAsset;\n            })();\n    \n            cloud.FirmwareModule = (function() {\n    \n                /**\n                 * Properties of a FirmwareModule.\n                 * @memberof particle.cloud\n                 * @interface IFirmwareModule\n                 * @property {particle.cloud.FirmwareModuleType|null} [type] < Module type\n                 * @property {number|null} [index] < Module index\n                 * @property {number|null} [version] < Module version\n                 * @property {particle.cloud.FirmwareModuleStore|null} [store] < Module store\n                 * @property {number|null} [maxSize] < Maximum module size\n                 * @property {number|null} [checkedFlags] < Performed validation checks (see FirmwareModuleValidityFlag)\n                 * @property {number|null} [passedFlags] < Passed validation checks (see FirmwareModuleValidityFlag)\n                 * @property {Uint8Array|null} [hash] < SHA-256 hash\n                 * @property {Array.<particle.cloud.IFirmwareModuleDependency>|null} [dependencies] < Module dependencies\n                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [assetDependencies] < Asset dependencies\n                 * @property {number|null} [size] < Actual module size\n                 * @property {particle.cloud.IFirmwareModuleSecurity|null} [security] < Security mode\n                 */\n    \n                /**\n                 * Constructs a new FirmwareModule.\n                 * @memberof particle.cloud\n                 * @classdesc Firmware module info.\n                 * @implements IFirmwareModule\n                 * @constructor\n                 * @param {particle.cloud.IFirmwareModule=} [properties] Properties to set\n                 */\n                function FirmwareModule(properties) {\n                    this.dependencies = [];\n                    this.assetDependencies = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < Module type\n                 * @member {particle.cloud.FirmwareModuleType} type\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.type = 0;\n    \n                /**\n                 * < Module index\n                 * @member {number} index\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.index = 0;\n    \n                /**\n                 * < Module version\n                 * @member {number} version\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.version = 0;\n    \n                /**\n                 * < Module store\n                 * @member {particle.cloud.FirmwareModuleStore} store\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.store = 0;\n    \n                /**\n                 * < Maximum module size\n                 * @member {number} maxSize\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.maxSize = 0;\n    \n                /**\n                 * < Performed validation checks (see FirmwareModuleValidityFlag)\n                 * @member {number} checkedFlags\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.checkedFlags = 0;\n    \n                /**\n                 * < Passed validation checks (see FirmwareModuleValidityFlag)\n                 * @member {number} passedFlags\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.passedFlags = 0;\n    \n                /**\n                 * < SHA-256 hash\n                 * @member {Uint8Array|null|undefined} hash\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.hash = null;\n    \n                /**\n                 * < Module dependencies\n                 * @member {Array.<particle.cloud.IFirmwareModuleDependency>} dependencies\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.dependencies = $util.emptyArray;\n    \n                /**\n                 * < Asset dependencies\n                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} assetDependencies\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.assetDependencies = $util.emptyArray;\n    \n                /**\n                 * < Actual module size\n                 * @member {number} size\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.size = 0;\n    \n                /**\n                 * < Security mode\n                 * @member {particle.cloud.IFirmwareModuleSecurity|null|undefined} security\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                FirmwareModule.prototype.security = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * FirmwareModule _hash.\n                 * @member {\"hash\"|undefined} _hash\n                 * @memberof particle.cloud.FirmwareModule\n                 * @instance\n                 */\n                Object.defineProperty(FirmwareModule.prototype, \"_hash\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"hash\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new FirmwareModule instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.FirmwareModule\n                 * @static\n                 * @param {particle.cloud.IFirmwareModule=} [properties] Properties to set\n                 * @returns {particle.cloud.FirmwareModule} FirmwareModule instance\n                 */\n                FirmwareModule.create = function create(properties) {\n                    return new FirmwareModule(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareModule message. Does not implicitly {@link particle.cloud.FirmwareModule.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.FirmwareModule\n                 * @static\n                 * @param {particle.cloud.IFirmwareModule} message FirmwareModule message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareModule.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                    if (message.store != null && Object.hasOwnProperty.call(message, \"store\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.store);\n                    if (message.maxSize != null && Object.hasOwnProperty.call(message, \"maxSize\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.maxSize);\n                    if (message.checkedFlags != null && Object.hasOwnProperty.call(message, \"checkedFlags\"))\n                        writer.uint32(/* id 6, wireType 5 =*/53).fixed32(message.checkedFlags);\n                    if (message.passedFlags != null && Object.hasOwnProperty.call(message, \"passedFlags\"))\n                        writer.uint32(/* id 7, wireType 5 =*/61).fixed32(message.passedFlags);\n                    if (message.hash != null && Object.hasOwnProperty.call(message, \"hash\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.hash);\n                    if (message.dependencies != null && message.dependencies.length)\n                        for (var i = 0; i < message.dependencies.length; ++i)\n                            $root.particle.cloud.FirmwareModuleDependency.encode(message.dependencies[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.assetDependencies != null && message.assetDependencies.length)\n                        for (var i = 0; i < message.assetDependencies.length; ++i)\n                            $root.particle.cloud.FirmwareModuleAsset.encode(message.assetDependencies[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 11, wireType 0 =*/88).uint32(message.size);\n                    if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                        $root.particle.cloud.FirmwareModuleSecurity.encode(message.security, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareModule message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.FirmwareModule\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.FirmwareModule} FirmwareModule\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareModule.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.FirmwareModule();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.index = reader.uint32();\n                            break;\n                        case 3:\n                            message.version = reader.uint32();\n                            break;\n                        case 4:\n                            message.store = reader.int32();\n                            break;\n                        case 5:\n                            message.maxSize = reader.uint32();\n                            break;\n                        case 6:\n                            message.checkedFlags = reader.fixed32();\n                            break;\n                        case 7:\n                            message.passedFlags = reader.fixed32();\n                            break;\n                        case 8:\n                            message.hash = reader.bytes();\n                            break;\n                        case 9:\n                            if (!(message.dependencies && message.dependencies.length))\n                                message.dependencies = [];\n                            message.dependencies.push($root.particle.cloud.FirmwareModuleDependency.decode(reader, reader.uint32()));\n                            break;\n                        case 10:\n                            if (!(message.assetDependencies && message.assetDependencies.length))\n                                message.assetDependencies = [];\n                            message.assetDependencies.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));\n                            break;\n                        case 11:\n                            message.size = reader.uint32();\n                            break;\n                        case 12:\n                            message.security = $root.particle.cloud.FirmwareModuleSecurity.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareModule;\n            })();\n    \n            cloud.SystemDescribe = (function() {\n    \n                /**\n                 * Properties of a SystemDescribe.\n                 * @memberof particle.cloud\n                 * @interface ISystemDescribe\n                 * @property {Array.<particle.cloud.IFirmwareModule>|null} [firmwareModules] < Firmware modules\n                 * @property {string|null} [imei] < IMEI (cellular platforms only)\n                 * @property {string|null} [iccid] < ICCID (cellular platforms only)\n                 * @property {string|null} [modemFirmwareVersion] < Modem firmware version (cellular platforms only)\n                 * @property {Array.<particle.cloud.IFirmwareModuleAsset>|null} [assets] < List of valid assets currently present in device storage\n                 * @property {boolean|null} [protectedState] < Protected state\n                 */\n    \n                /**\n                 * Constructs a new SystemDescribe.\n                 * @memberof particle.cloud\n                 * @classdesc System describe.\n                 * @implements ISystemDescribe\n                 * @constructor\n                 * @param {particle.cloud.ISystemDescribe=} [properties] Properties to set\n                 */\n                function SystemDescribe(properties) {\n                    this.firmwareModules = [];\n                    this.assets = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * < Firmware modules\n                 * @member {Array.<particle.cloud.IFirmwareModule>} firmwareModules\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.firmwareModules = $util.emptyArray;\n    \n                /**\n                 * < IMEI (cellular platforms only)\n                 * @member {string|null|undefined} imei\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.imei = null;\n    \n                /**\n                 * < ICCID (cellular platforms only)\n                 * @member {string|null|undefined} iccid\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.iccid = null;\n    \n                /**\n                 * < Modem firmware version (cellular platforms only)\n                 * @member {string|null|undefined} modemFirmwareVersion\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.modemFirmwareVersion = null;\n    \n                /**\n                 * < List of valid assets currently present in device storage\n                 * @member {Array.<particle.cloud.IFirmwareModuleAsset>} assets\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.assets = $util.emptyArray;\n    \n                /**\n                 * < Protected state\n                 * @member {boolean} protectedState\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                SystemDescribe.prototype.protectedState = false;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * SystemDescribe _imei.\n                 * @member {\"imei\"|undefined} _imei\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                Object.defineProperty(SystemDescribe.prototype, \"_imei\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"imei\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * SystemDescribe _iccid.\n                 * @member {\"iccid\"|undefined} _iccid\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                Object.defineProperty(SystemDescribe.prototype, \"_iccid\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"iccid\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * SystemDescribe _modemFirmwareVersion.\n                 * @member {\"modemFirmwareVersion\"|undefined} _modemFirmwareVersion\n                 * @memberof particle.cloud.SystemDescribe\n                 * @instance\n                 */\n                Object.defineProperty(SystemDescribe.prototype, \"_modemFirmwareVersion\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"modemFirmwareVersion\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new SystemDescribe instance using the specified properties.\n                 * @function create\n                 * @memberof particle.cloud.SystemDescribe\n                 * @static\n                 * @param {particle.cloud.ISystemDescribe=} [properties] Properties to set\n                 * @returns {particle.cloud.SystemDescribe} SystemDescribe instance\n                 */\n                SystemDescribe.create = function create(properties) {\n                    return new SystemDescribe(properties);\n                };\n    \n                /**\n                 * Encodes the specified SystemDescribe message. Does not implicitly {@link particle.cloud.SystemDescribe.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.cloud.SystemDescribe\n                 * @static\n                 * @param {particle.cloud.ISystemDescribe} message SystemDescribe message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SystemDescribe.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.firmwareModules != null && message.firmwareModules.length)\n                        for (var i = 0; i < message.firmwareModules.length; ++i)\n                            $root.particle.cloud.FirmwareModule.encode(message.firmwareModules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.imei != null && Object.hasOwnProperty.call(message, \"imei\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.imei);\n                    if (message.iccid != null && Object.hasOwnProperty.call(message, \"iccid\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.iccid);\n                    if (message.modemFirmwareVersion != null && Object.hasOwnProperty.call(message, \"modemFirmwareVersion\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.modemFirmwareVersion);\n                    if (message.assets != null && message.assets.length)\n                        for (var i = 0; i < message.assets.length; ++i)\n                            $root.particle.cloud.FirmwareModuleAsset.encode(message.assets[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.protectedState != null && Object.hasOwnProperty.call(message, \"protectedState\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.protectedState);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SystemDescribe message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.cloud.SystemDescribe\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.cloud.SystemDescribe} SystemDescribe\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SystemDescribe.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.cloud.SystemDescribe();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.firmwareModules && message.firmwareModules.length))\n                                message.firmwareModules = [];\n                            message.firmwareModules.push($root.particle.cloud.FirmwareModule.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            message.imei = reader.string();\n                            break;\n                        case 3:\n                            message.iccid = reader.string();\n                            break;\n                        case 4:\n                            message.modemFirmwareVersion = reader.string();\n                            break;\n                        case 5:\n                            if (!(message.assets && message.assets.length))\n                                message.assets = [];\n                            message.assets.push($root.particle.cloud.FirmwareModuleAsset.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            message.protectedState = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SystemDescribe;\n            })();\n    \n            return cloud;\n        })();\n    \n        return particle;\n    })();\n    \n    $root.google = (function() {\n    \n        /**\n         * Namespace google.\n         * @exports google\n         * @namespace\n         */\n        var google = {};\n    \n        google.protobuf = (function() {\n    \n            /**\n             * Namespace protobuf.\n             * @memberof google\n             * @namespace\n             */\n            var protobuf = {};\n    \n            protobuf.FileDescriptorSet = (function() {\n    \n                /**\n                 * Properties of a FileDescriptorSet.\n                 * @memberof google.protobuf\n                 * @interface IFileDescriptorSet\n                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file\n                 */\n    \n                /**\n                 * Constructs a new FileDescriptorSet.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileDescriptorSet.\n                 * @implements IFileDescriptorSet\n                 * @constructor\n                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n                 */\n                function FileDescriptorSet(properties) {\n                    this.file = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileDescriptorSet file.\n                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @instance\n                 */\n                FileDescriptorSet.prototype.file = $util.emptyArray;\n    \n                /**\n                 * Creates a new FileDescriptorSet instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance\n                 */\n                FileDescriptorSet.create = function create(properties) {\n                    return new FileDescriptorSet(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileDescriptorSet.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.file != null && message.file.length)\n                        for (var i = 0; i < message.file.length; ++i)\n                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileDescriptorSet message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileDescriptorSet.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.file && message.file.length))\n                                message.file = [];\n                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FileDescriptorSet;\n            })();\n    \n            protobuf.FileDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a FileDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IFileDescriptorProto\n                 * @property {string|null} [name] FileDescriptorProto name\n                 * @property {string|null} [\"package\"] FileDescriptorProto package\n                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency\n                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency\n                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency\n                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType\n                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType\n                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension\n                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options\n                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo\n                 * @property {string|null} [syntax] FileDescriptorProto syntax\n                 */\n    \n                /**\n                 * Constructs a new FileDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileDescriptorProto.\n                 * @implements IFileDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n                 */\n                function FileDescriptorProto(properties) {\n                    this.dependency = [];\n                    this.publicDependency = [];\n                    this.weakDependency = [];\n                    this.messageType = [];\n                    this.enumType = [];\n                    this.service = [];\n                    this.extension = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * FileDescriptorProto package.\n                 * @member {string} package\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype[\"package\"] = \"\";\n    \n                /**\n                 * FileDescriptorProto dependency.\n                 * @member {Array.<string>} dependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.dependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto publicDependency.\n                 * @member {Array.<number>} publicDependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto weakDependency.\n                 * @member {Array.<number>} weakDependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto messageType.\n                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.messageType = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto enumType.\n                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.enumType = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto service.\n                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.service = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto extension.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.extension = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto options.\n                 * @member {google.protobuf.IFileOptions|null|undefined} options\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.options = null;\n    \n                /**\n                 * FileDescriptorProto sourceCodeInfo.\n                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.sourceCodeInfo = null;\n    \n                /**\n                 * FileDescriptorProto syntax.\n                 * @member {string} syntax\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.syntax = \"\";\n    \n                /**\n                 * Creates a new FileDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance\n                 */\n                FileDescriptorProto.create = function create(properties) {\n                    return new FileDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message[\"package\"] != null && Object.hasOwnProperty.call(message, \"package\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message[\"package\"]);\n                    if (message.dependency != null && message.dependency.length)\n                        for (var i = 0; i < message.dependency.length; ++i)\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);\n                    if (message.messageType != null && message.messageType.length)\n                        for (var i = 0; i < message.messageType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.enumType != null && message.enumType.length)\n                        for (var i = 0; i < message.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.service != null && message.service.length)\n                        for (var i = 0; i < message.service.length; ++i)\n                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.extension != null && message.extension.length)\n                        for (var i = 0; i < message.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, \"sourceCodeInfo\"))\n                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.publicDependency != null && message.publicDependency.length)\n                        for (var i = 0; i < message.publicDependency.length; ++i)\n                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);\n                    if (message.weakDependency != null && message.weakDependency.length)\n                        for (var i = 0; i < message.weakDependency.length; ++i)\n                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);\n                    if (message.syntax != null && Object.hasOwnProperty.call(message, \"syntax\"))\n                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message[\"package\"] = reader.string();\n                            break;\n                        case 3:\n                            if (!(message.dependency && message.dependency.length))\n                                message.dependency = [];\n                            message.dependency.push(reader.string());\n                            break;\n                        case 10:\n                            if (!(message.publicDependency && message.publicDependency.length))\n                                message.publicDependency = [];\n                            if ((tag & 7) === 2) {\n                                var end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.publicDependency.push(reader.int32());\n                            } else\n                                message.publicDependency.push(reader.int32());\n                            break;\n                        case 11:\n                            if (!(message.weakDependency && message.weakDependency.length))\n                                message.weakDependency = [];\n                            if ((tag & 7) === 2) {\n                                var end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.weakDependency.push(reader.int32());\n                            } else\n                                message.weakDependency.push(reader.int32());\n                            break;\n                        case 4:\n                            if (!(message.messageType && message.messageType.length))\n                                message.messageType = [];\n                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.service && message.service.length))\n                                message.service = [];\n                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());\n                            break;\n                        case 12:\n                            message.syntax = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FileDescriptorProto;\n            })();\n    \n            protobuf.DescriptorProto = (function() {\n    \n                /**\n                 * Properties of a DescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IDescriptorProto\n                 * @property {string|null} [name] DescriptorProto name\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension\n                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType\n                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType\n                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange\n                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl\n                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options\n                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange\n                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName\n                 */\n    \n                /**\n                 * Constructs a new DescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a DescriptorProto.\n                 * @implements IDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n                 */\n                function DescriptorProto(properties) {\n                    this.field = [];\n                    this.extension = [];\n                    this.nestedType = [];\n                    this.enumType = [];\n                    this.extensionRange = [];\n                    this.oneofDecl = [];\n                    this.reservedRange = [];\n                    this.reservedName = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * DescriptorProto field.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.field = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto extension.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.extension = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto nestedType.\n                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.nestedType = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto enumType.\n                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.enumType = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto extensionRange.\n                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.extensionRange = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto oneofDecl.\n                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto options.\n                 * @member {google.protobuf.IMessageOptions|null|undefined} options\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.options = null;\n    \n                /**\n                 * DescriptorProto reservedRange.\n                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.reservedRange = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto reservedName.\n                 * @member {Array.<string>} reservedName\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.reservedName = $util.emptyArray;\n    \n                /**\n                 * Creates a new DescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance\n                 */\n                DescriptorProto.create = function create(properties) {\n                    return new DescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.field != null && message.field.length)\n                        for (var i = 0; i < message.field.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.nestedType != null && message.nestedType.length)\n                        for (var i = 0; i < message.nestedType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.enumType != null && message.enumType.length)\n                        for (var i = 0; i < message.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.extensionRange != null && message.extensionRange.length)\n                        for (var i = 0; i < message.extensionRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.extension != null && message.extension.length)\n                        for (var i = 0; i < message.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.oneofDecl != null && message.oneofDecl.length)\n                        for (var i = 0; i < message.oneofDecl.length; ++i)\n                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.reservedRange != null && message.reservedRange.length)\n                        for (var i = 0; i < message.reservedRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.reservedName != null && message.reservedName.length)\n                        for (var i = 0; i < message.reservedName.length; ++i)\n                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.DescriptorProto} DescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.field && message.field.length))\n                                message.field = [];\n                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            if (!(message.nestedType && message.nestedType.length))\n                                message.nestedType = [];\n                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 4:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.extensionRange && message.extensionRange.length))\n                                message.extensionRange = [];\n                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            if (!(message.oneofDecl && message.oneofDecl.length))\n                                message.oneofDecl = [];\n                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            if (!(message.reservedRange && message.reservedRange.length))\n                                message.reservedRange = [];\n                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));\n                            break;\n                        case 10:\n                            if (!(message.reservedName && message.reservedName.length))\n                                message.reservedName = [];\n                            message.reservedName.push(reader.string());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                DescriptorProto.ExtensionRange = (function() {\n    \n                    /**\n                     * Properties of an ExtensionRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @interface IExtensionRange\n                     * @property {number|null} [start] ExtensionRange start\n                     * @property {number|null} [end] ExtensionRange end\n                     */\n    \n                    /**\n                     * Constructs a new ExtensionRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @classdesc Represents an ExtensionRange.\n                     * @implements IExtensionRange\n                     * @constructor\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n                     */\n                    function ExtensionRange(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ExtensionRange start.\n                     * @member {number} start\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @instance\n                     */\n                    ExtensionRange.prototype.start = 0;\n    \n                    /**\n                     * ExtensionRange end.\n                     * @member {number} end\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @instance\n                     */\n                    ExtensionRange.prototype.end = 0;\n    \n                    /**\n                     * Creates a new ExtensionRange instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance\n                     */\n                    ExtensionRange.create = function create(properties) {\n                        return new ExtensionRange(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExtensionRange.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.start != null && Object.hasOwnProperty.call(message, \"start\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an ExtensionRange message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExtensionRange.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ExtensionRange;\n                })();\n    \n                DescriptorProto.ReservedRange = (function() {\n    \n                    /**\n                     * Properties of a ReservedRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @interface IReservedRange\n                     * @property {number|null} [start] ReservedRange start\n                     * @property {number|null} [end] ReservedRange end\n                     */\n    \n                    /**\n                     * Constructs a new ReservedRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @classdesc Represents a ReservedRange.\n                     * @implements IReservedRange\n                     * @constructor\n                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n                     */\n                    function ReservedRange(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ReservedRange start.\n                     * @member {number} start\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @instance\n                     */\n                    ReservedRange.prototype.start = 0;\n    \n                    /**\n                     * ReservedRange end.\n                     * @member {number} end\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @instance\n                     */\n                    ReservedRange.prototype.end = 0;\n    \n                    /**\n                     * Creates a new ReservedRange instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance\n                     */\n                    ReservedRange.create = function create(properties) {\n                        return new ReservedRange(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ReservedRange.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.start != null && Object.hasOwnProperty.call(message, \"start\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ReservedRange message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ReservedRange.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ReservedRange;\n                })();\n    \n                return DescriptorProto;\n            })();\n    \n            protobuf.FieldDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a FieldDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IFieldDescriptorProto\n                 * @property {string|null} [name] FieldDescriptorProto name\n                 * @property {number|null} [number] FieldDescriptorProto number\n                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label\n                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type\n                 * @property {string|null} [typeName] FieldDescriptorProto typeName\n                 * @property {string|null} [extendee] FieldDescriptorProto extendee\n                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue\n                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex\n                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName\n                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new FieldDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FieldDescriptorProto.\n                 * @implements IFieldDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n                 */\n                function FieldDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FieldDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * FieldDescriptorProto number.\n                 * @member {number} number\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.number = 0;\n    \n                /**\n                 * FieldDescriptorProto label.\n                 * @member {google.protobuf.FieldDescriptorProto.Label} label\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.label = 1;\n    \n                /**\n                 * FieldDescriptorProto type.\n                 * @member {google.protobuf.FieldDescriptorProto.Type} type\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.type = 1;\n    \n                /**\n                 * FieldDescriptorProto typeName.\n                 * @member {string} typeName\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.typeName = \"\";\n    \n                /**\n                 * FieldDescriptorProto extendee.\n                 * @member {string} extendee\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.extendee = \"\";\n    \n                /**\n                 * FieldDescriptorProto defaultValue.\n                 * @member {string} defaultValue\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.defaultValue = \"\";\n    \n                /**\n                 * FieldDescriptorProto oneofIndex.\n                 * @member {number} oneofIndex\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.oneofIndex = 0;\n    \n                /**\n                 * FieldDescriptorProto jsonName.\n                 * @member {string} jsonName\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.jsonName = \"\";\n    \n                /**\n                 * FieldDescriptorProto options.\n                 * @member {google.protobuf.IFieldOptions|null|undefined} options\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new FieldDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance\n                 */\n                FieldDescriptorProto.create = function create(properties) {\n                    return new FieldDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FieldDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.extendee != null && Object.hasOwnProperty.call(message, \"extendee\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);\n                    if (message.number != null && Object.hasOwnProperty.call(message, \"number\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);\n                    if (message.label != null && Object.hasOwnProperty.call(message, \"label\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);\n                    if (message.typeName != null && Object.hasOwnProperty.call(message, \"typeName\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);\n                    if (message.defaultValue != null && Object.hasOwnProperty.call(message, \"defaultValue\"))\n                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.oneofIndex != null && Object.hasOwnProperty.call(message, \"oneofIndex\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);\n                    if (message.jsonName != null && Object.hasOwnProperty.call(message, \"jsonName\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FieldDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.number = reader.int32();\n                            break;\n                        case 4:\n                            message.label = reader.int32();\n                            break;\n                        case 5:\n                            message.type = reader.int32();\n                            break;\n                        case 6:\n                            message.typeName = reader.string();\n                            break;\n                        case 2:\n                            message.extendee = reader.string();\n                            break;\n                        case 7:\n                            message.defaultValue = reader.string();\n                            break;\n                        case 9:\n                            message.oneofIndex = reader.int32();\n                            break;\n                        case 10:\n                            message.jsonName = reader.string();\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Type enum.\n                 * @name google.protobuf.FieldDescriptorProto.Type\n                 * @enum {number}\n                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value\n                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value\n                 * @property {number} TYPE_INT64=3 TYPE_INT64 value\n                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value\n                 * @property {number} TYPE_INT32=5 TYPE_INT32 value\n                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value\n                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value\n                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value\n                 * @property {number} TYPE_STRING=9 TYPE_STRING value\n                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value\n                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value\n                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value\n                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value\n                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value\n                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value\n                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value\n                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value\n                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value\n                 */\n                FieldDescriptorProto.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n                    values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n                    values[valuesById[3] = \"TYPE_INT64\"] = 3;\n                    values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n                    values[valuesById[5] = \"TYPE_INT32\"] = 5;\n                    values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n                    values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n                    values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n                    values[valuesById[9] = \"TYPE_STRING\"] = 9;\n                    values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n                    values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n                    values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n                    values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n                    values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n                    values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n                    values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n                    values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n                    values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n                    return values;\n                })();\n    \n                /**\n                 * Label enum.\n                 * @name google.protobuf.FieldDescriptorProto.Label\n                 * @enum {number}\n                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value\n                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value\n                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value\n                 */\n                FieldDescriptorProto.Label = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n                    values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n                    values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n                    return values;\n                })();\n    \n                return FieldDescriptorProto;\n            })();\n    \n            protobuf.OneofDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an OneofDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IOneofDescriptorProto\n                 * @property {string|null} [name] OneofDescriptorProto name\n                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new OneofDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an OneofDescriptorProto.\n                 * @implements IOneofDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n                 */\n                function OneofDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * OneofDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @instance\n                 */\n                OneofDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * OneofDescriptorProto options.\n                 * @member {google.protobuf.IOneofOptions|null|undefined} options\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @instance\n                 */\n                OneofDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new OneofDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance\n                 */\n                OneofDescriptorProto.create = function create(properties) {\n                    return new OneofDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                OneofDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                OneofDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return OneofDescriptorProto;\n            })();\n    \n            protobuf.EnumDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an EnumDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IEnumDescriptorProto\n                 * @property {string|null} [name] EnumDescriptorProto name\n                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value\n                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new EnumDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumDescriptorProto.\n                 * @implements IEnumDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n                 */\n                function EnumDescriptorProto(properties) {\n                    this.value = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * EnumDescriptorProto value.\n                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.value = $util.emptyArray;\n    \n                /**\n                 * EnumDescriptorProto options.\n                 * @member {google.protobuf.IEnumOptions|null|undefined} options\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new EnumDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance\n                 */\n                EnumDescriptorProto.create = function create(properties) {\n                    return new EnumDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.value != null && message.value.length)\n                        for (var i = 0; i < message.value.length; ++i)\n                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.value && message.value.length))\n                                message.value = [];\n                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumDescriptorProto;\n            })();\n    \n            protobuf.EnumValueDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an EnumValueDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IEnumValueDescriptorProto\n                 * @property {string|null} [name] EnumValueDescriptorProto name\n                 * @property {number|null} [number] EnumValueDescriptorProto number\n                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new EnumValueDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumValueDescriptorProto.\n                 * @implements IEnumValueDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n                 */\n                function EnumValueDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumValueDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * EnumValueDescriptorProto number.\n                 * @member {number} number\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.number = 0;\n    \n                /**\n                 * EnumValueDescriptorProto options.\n                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new EnumValueDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance\n                 */\n                EnumValueDescriptorProto.create = function create(properties) {\n                    return new EnumValueDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumValueDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.number != null && Object.hasOwnProperty.call(message, \"number\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumValueDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.number = reader.int32();\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumValueDescriptorProto;\n            })();\n    \n            protobuf.ServiceDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a ServiceDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IServiceDescriptorProto\n                 * @property {string|null} [name] ServiceDescriptorProto name\n                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method\n                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new ServiceDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a ServiceDescriptorProto.\n                 * @implements IServiceDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n                 */\n                function ServiceDescriptorProto(properties) {\n                    this.method = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ServiceDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * ServiceDescriptorProto method.\n                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.method = $util.emptyArray;\n    \n                /**\n                 * ServiceDescriptorProto options.\n                 * @member {google.protobuf.IServiceOptions|null|undefined} options\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new ServiceDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance\n                 */\n                ServiceDescriptorProto.create = function create(properties) {\n                    return new ServiceDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServiceDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.method != null && message.method.length)\n                        for (var i = 0; i < message.method.length; ++i)\n                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServiceDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.method && message.method.length))\n                                message.method = [];\n                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServiceDescriptorProto;\n            })();\n    \n            protobuf.MethodDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a MethodDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IMethodDescriptorProto\n                 * @property {string|null} [name] MethodDescriptorProto name\n                 * @property {string|null} [inputType] MethodDescriptorProto inputType\n                 * @property {string|null} [outputType] MethodDescriptorProto outputType\n                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options\n                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming\n                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming\n                 */\n    \n                /**\n                 * Constructs a new MethodDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MethodDescriptorProto.\n                 * @implements IMethodDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n                 */\n                function MethodDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MethodDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * MethodDescriptorProto inputType.\n                 * @member {string} inputType\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.inputType = \"\";\n    \n                /**\n                 * MethodDescriptorProto outputType.\n                 * @member {string} outputType\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.outputType = \"\";\n    \n                /**\n                 * MethodDescriptorProto options.\n                 * @member {google.protobuf.IMethodOptions|null|undefined} options\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.options = null;\n    \n                /**\n                 * MethodDescriptorProto clientStreaming.\n                 * @member {boolean} clientStreaming\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.clientStreaming = false;\n    \n                /**\n                 * MethodDescriptorProto serverStreaming.\n                 * @member {boolean} serverStreaming\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.serverStreaming = false;\n    \n                /**\n                 * Creates a new MethodDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance\n                 */\n                MethodDescriptorProto.create = function create(properties) {\n                    return new MethodDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MethodDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.inputType != null && Object.hasOwnProperty.call(message, \"inputType\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);\n                    if (message.outputType != null && Object.hasOwnProperty.call(message, \"outputType\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.clientStreaming != null && Object.hasOwnProperty.call(message, \"clientStreaming\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);\n                    if (message.serverStreaming != null && Object.hasOwnProperty.call(message, \"serverStreaming\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MethodDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.inputType = reader.string();\n                            break;\n                        case 3:\n                            message.outputType = reader.string();\n                            break;\n                        case 4:\n                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.clientStreaming = reader.bool();\n                            break;\n                        case 6:\n                            message.serverStreaming = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MethodDescriptorProto;\n            })();\n    \n            protobuf.FileOptions = (function() {\n    \n                /**\n                 * Properties of a FileOptions.\n                 * @memberof google.protobuf\n                 * @interface IFileOptions\n                 * @property {string|null} [javaPackage] FileOptions javaPackage\n                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname\n                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles\n                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash\n                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8\n                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor\n                 * @property {string|null} [goPackage] FileOptions goPackage\n                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices\n                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices\n                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices\n                 * @property {boolean|null} [deprecated] FileOptions deprecated\n                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas\n                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix\n                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopbFileopt\"] FileOptions .nanopbFileopt\n                 */\n    \n                /**\n                 * Constructs a new FileOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileOptions.\n                 * @implements IFileOptions\n                 * @constructor\n                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n                 */\n                function FileOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileOptions javaPackage.\n                 * @member {string} javaPackage\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaPackage = \"\";\n    \n                /**\n                 * FileOptions javaOuterClassname.\n                 * @member {string} javaOuterClassname\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaOuterClassname = \"\";\n    \n                /**\n                 * FileOptions javaMultipleFiles.\n                 * @member {boolean} javaMultipleFiles\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaMultipleFiles = false;\n    \n                /**\n                 * FileOptions javaGenerateEqualsAndHash.\n                 * @member {boolean} javaGenerateEqualsAndHash\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaGenerateEqualsAndHash = false;\n    \n                /**\n                 * FileOptions javaStringCheckUtf8.\n                 * @member {boolean} javaStringCheckUtf8\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaStringCheckUtf8 = false;\n    \n                /**\n                 * FileOptions optimizeFor.\n                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.optimizeFor = 1;\n    \n                /**\n                 * FileOptions goPackage.\n                 * @member {string} goPackage\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.goPackage = \"\";\n    \n                /**\n                 * FileOptions ccGenericServices.\n                 * @member {boolean} ccGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.ccGenericServices = false;\n    \n                /**\n                 * FileOptions javaGenericServices.\n                 * @member {boolean} javaGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaGenericServices = false;\n    \n                /**\n                 * FileOptions pyGenericServices.\n                 * @member {boolean} pyGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.pyGenericServices = false;\n    \n                /**\n                 * FileOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.deprecated = false;\n    \n                /**\n                 * FileOptions ccEnableArenas.\n                 * @member {boolean} ccEnableArenas\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.ccEnableArenas = false;\n    \n                /**\n                 * FileOptions objcClassPrefix.\n                 * @member {string} objcClassPrefix\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.objcClassPrefix = \"\";\n    \n                /**\n                 * FileOptions csharpNamespace.\n                 * @member {string} csharpNamespace\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.csharpNamespace = \"\";\n    \n                /**\n                 * FileOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * FileOptions .nanopbFileopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbFileopt\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype[\".nanopbFileopt\"] = null;\n    \n                /**\n                 * Creates a new FileOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.FileOptions} FileOptions instance\n                 */\n                FileOptions.create = function create(properties) {\n                    return new FileOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.javaPackage != null && Object.hasOwnProperty.call(message, \"javaPackage\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);\n                    if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, \"javaOuterClassname\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);\n                    if (message.optimizeFor != null && Object.hasOwnProperty.call(message, \"optimizeFor\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);\n                    if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, \"javaMultipleFiles\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);\n                    if (message.goPackage != null && Object.hasOwnProperty.call(message, \"goPackage\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);\n                    if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, \"ccGenericServices\"))\n                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);\n                    if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, \"javaGenericServices\"))\n                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);\n                    if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, \"pyGenericServices\"))\n                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);\n                    if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, \"javaGenerateEqualsAndHash\"))\n                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);\n                    if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, \"javaStringCheckUtf8\"))\n                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);\n                    if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, \"ccEnableArenas\"))\n                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);\n                    if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, \"objcClassPrefix\"))\n                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);\n                    if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, \"csharpNamespace\"))\n                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbFileopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbFileopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbFileopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileOptions} FileOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.javaPackage = reader.string();\n                            break;\n                        case 8:\n                            message.javaOuterClassname = reader.string();\n                            break;\n                        case 10:\n                            message.javaMultipleFiles = reader.bool();\n                            break;\n                        case 20:\n                            message.javaGenerateEqualsAndHash = reader.bool();\n                            break;\n                        case 27:\n                            message.javaStringCheckUtf8 = reader.bool();\n                            break;\n                        case 9:\n                            message.optimizeFor = reader.int32();\n                            break;\n                        case 11:\n                            message.goPackage = reader.string();\n                            break;\n                        case 16:\n                            message.ccGenericServices = reader.bool();\n                            break;\n                        case 17:\n                            message.javaGenericServices = reader.bool();\n                            break;\n                        case 18:\n                            message.pyGenericServices = reader.bool();\n                            break;\n                        case 23:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 31:\n                            message.ccEnableArenas = reader.bool();\n                            break;\n                        case 36:\n                            message.objcClassPrefix = reader.string();\n                            break;\n                        case 37:\n                            message.csharpNamespace = reader.string();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopbFileopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * OptimizeMode enum.\n                 * @name google.protobuf.FileOptions.OptimizeMode\n                 * @enum {number}\n                 * @property {number} SPEED=1 SPEED value\n                 * @property {number} CODE_SIZE=2 CODE_SIZE value\n                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value\n                 */\n                FileOptions.OptimizeMode = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"SPEED\"] = 1;\n                    values[valuesById[2] = \"CODE_SIZE\"] = 2;\n                    values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n                    return values;\n                })();\n    \n                return FileOptions;\n            })();\n    \n            protobuf.MessageOptions = (function() {\n    \n                /**\n                 * Properties of a MessageOptions.\n                 * @memberof google.protobuf\n                 * @interface IMessageOptions\n                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat\n                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor\n                 * @property {boolean|null} [deprecated] MessageOptions deprecated\n                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption\n                 * @property {number|null} [\".typeId\"] MessageOptions .typeId\n                 * @property {INanoPBOptions|null} [\".nanopbMsgopt\"] MessageOptions .nanopbMsgopt\n                 */\n    \n                /**\n                 * Constructs a new MessageOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MessageOptions.\n                 * @implements IMessageOptions\n                 * @constructor\n                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n                 */\n                function MessageOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MessageOptions messageSetWireFormat.\n                 * @member {boolean} messageSetWireFormat\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.messageSetWireFormat = false;\n    \n                /**\n                 * MessageOptions noStandardDescriptorAccessor.\n                 * @member {boolean} noStandardDescriptorAccessor\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.noStandardDescriptorAccessor = false;\n    \n                /**\n                 * MessageOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.deprecated = false;\n    \n                /**\n                 * MessageOptions mapEntry.\n                 * @member {boolean} mapEntry\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.mapEntry = false;\n    \n                /**\n                 * MessageOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * MessageOptions .typeId.\n                 * @member {number} .typeId\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype[\".typeId\"] = 0;\n    \n                /**\n                 * MessageOptions .nanopbMsgopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbMsgopt\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype[\".nanopbMsgopt\"] = null;\n    \n                /**\n                 * Creates a new MessageOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.MessageOptions} MessageOptions instance\n                 */\n                MessageOptions.create = function create(properties) {\n                    return new MessageOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MessageOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, \"messageSetWireFormat\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);\n                    if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, \"noStandardDescriptorAccessor\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.mapEntry != null && Object.hasOwnProperty.call(message, \"mapEntry\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbMsgopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbMsgopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbMsgopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    if (message[\".typeId\"] != null && Object.hasOwnProperty.call(message, \".typeId\"))\n                        writer.uint32(/* id 50001, wireType 0 =*/400008).int32(message[\".typeId\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MessageOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MessageOptions} MessageOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MessageOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.messageSetWireFormat = reader.bool();\n                            break;\n                        case 2:\n                            message.noStandardDescriptorAccessor = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 7:\n                            message.mapEntry = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 50001:\n                            message[\".typeId\"] = reader.int32();\n                            break;\n                        case 1010:\n                            message[\".nanopbMsgopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MessageOptions;\n            })();\n    \n            protobuf.FieldOptions = (function() {\n    \n                /**\n                 * Properties of a FieldOptions.\n                 * @memberof google.protobuf\n                 * @interface IFieldOptions\n                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n                 * @property {boolean|null} [packed] FieldOptions packed\n                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n                 * @property {boolean|null} [lazy] FieldOptions lazy\n                 * @property {boolean|null} [deprecated] FieldOptions deprecated\n                 * @property {boolean|null} [weak] FieldOptions weak\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopb\"] FieldOptions .nanopb\n                 */\n    \n                /**\n                 * Constructs a new FieldOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FieldOptions.\n                 * @implements IFieldOptions\n                 * @constructor\n                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n                 */\n                function FieldOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FieldOptions ctype.\n                 * @member {google.protobuf.FieldOptions.CType} ctype\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.ctype = 0;\n    \n                /**\n                 * FieldOptions packed.\n                 * @member {boolean} packed\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.packed = false;\n    \n                /**\n                 * FieldOptions jstype.\n                 * @member {google.protobuf.FieldOptions.JSType} jstype\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.jstype = 0;\n    \n                /**\n                 * FieldOptions lazy.\n                 * @member {boolean} lazy\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.lazy = false;\n    \n                /**\n                 * FieldOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.deprecated = false;\n    \n                /**\n                 * FieldOptions weak.\n                 * @member {boolean} weak\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.weak = false;\n    \n                /**\n                 * FieldOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * FieldOptions .nanopb.\n                 * @member {INanoPBOptions|null|undefined} .nanopb\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype[\".nanopb\"] = null;\n    \n                /**\n                 * Creates a new FieldOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.FieldOptions} FieldOptions instance\n                 */\n                FieldOptions.create = function create(properties) {\n                    return new FieldOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FieldOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ctype != null && Object.hasOwnProperty.call(message, \"ctype\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);\n                    if (message.packed != null && Object.hasOwnProperty.call(message, \"packed\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.lazy != null && Object.hasOwnProperty.call(message, \"lazy\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);\n                    if (message.jstype != null && Object.hasOwnProperty.call(message, \"jstype\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);\n                    if (message.weak != null && Object.hasOwnProperty.call(message, \"weak\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopb\"] != null && Object.hasOwnProperty.call(message, \".nanopb\"))\n                        $root.NanoPBOptions.encode(message[\".nanopb\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FieldOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FieldOptions} FieldOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FieldOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ctype = reader.int32();\n                            break;\n                        case 2:\n                            message.packed = reader.bool();\n                            break;\n                        case 6:\n                            message.jstype = reader.int32();\n                            break;\n                        case 5:\n                            message.lazy = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 10:\n                            message.weak = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopb\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * CType enum.\n                 * @name google.protobuf.FieldOptions.CType\n                 * @enum {number}\n                 * @property {number} STRING=0 STRING value\n                 * @property {number} CORD=1 CORD value\n                 * @property {number} STRING_PIECE=2 STRING_PIECE value\n                 */\n                FieldOptions.CType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"STRING\"] = 0;\n                    values[valuesById[1] = \"CORD\"] = 1;\n                    values[valuesById[2] = \"STRING_PIECE\"] = 2;\n                    return values;\n                })();\n    \n                /**\n                 * JSType enum.\n                 * @name google.protobuf.FieldOptions.JSType\n                 * @enum {number}\n                 * @property {number} JS_NORMAL=0 JS_NORMAL value\n                 * @property {number} JS_STRING=1 JS_STRING value\n                 * @property {number} JS_NUMBER=2 JS_NUMBER value\n                 */\n                FieldOptions.JSType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"JS_NORMAL\"] = 0;\n                    values[valuesById[1] = \"JS_STRING\"] = 1;\n                    values[valuesById[2] = \"JS_NUMBER\"] = 2;\n                    return values;\n                })();\n    \n                return FieldOptions;\n            })();\n    \n            protobuf.OneofOptions = (function() {\n    \n                /**\n                 * Properties of an OneofOptions.\n                 * @memberof google.protobuf\n                 * @interface IOneofOptions\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new OneofOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an OneofOptions.\n                 * @implements IOneofOptions\n                 * @constructor\n                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n                 */\n                function OneofOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * OneofOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.OneofOptions\n                 * @instance\n                 */\n                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new OneofOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.OneofOptions} OneofOptions instance\n                 */\n                OneofOptions.create = function create(properties) {\n                    return new OneofOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                OneofOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an OneofOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.OneofOptions} OneofOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                OneofOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return OneofOptions;\n            })();\n    \n            protobuf.EnumOptions = (function() {\n    \n                /**\n                 * Properties of an EnumOptions.\n                 * @memberof google.protobuf\n                 * @interface IEnumOptions\n                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias\n                 * @property {boolean|null} [deprecated] EnumOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopbEnumopt\"] EnumOptions .nanopbEnumopt\n                 */\n    \n                /**\n                 * Constructs a new EnumOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumOptions.\n                 * @implements IEnumOptions\n                 * @constructor\n                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n                 */\n                function EnumOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumOptions allowAlias.\n                 * @member {boolean} allowAlias\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.allowAlias = false;\n    \n                /**\n                 * EnumOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.deprecated = false;\n    \n                /**\n                 * EnumOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * EnumOptions .nanopbEnumopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbEnumopt\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype[\".nanopbEnumopt\"] = null;\n    \n                /**\n                 * Creates a new EnumOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumOptions} EnumOptions instance\n                 */\n                EnumOptions.create = function create(properties) {\n                    return new EnumOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.allowAlias != null && Object.hasOwnProperty.call(message, \"allowAlias\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbEnumopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbEnumopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbEnumopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumOptions} EnumOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 2:\n                            message.allowAlias = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopbEnumopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumOptions;\n            })();\n    \n            protobuf.EnumValueOptions = (function() {\n    \n                /**\n                 * Properties of an EnumValueOptions.\n                 * @memberof google.protobuf\n                 * @interface IEnumValueOptions\n                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption\n                 * @property {number|null} [\".intValue\"] EnumValueOptions .intValue\n                 */\n    \n                /**\n                 * Constructs a new EnumValueOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumValueOptions.\n                 * @implements IEnumValueOptions\n                 * @constructor\n                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n                 */\n                function EnumValueOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumValueOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype.deprecated = false;\n    \n                /**\n                 * EnumValueOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * EnumValueOptions .intValue.\n                 * @member {number} .intValue\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype[\".intValue\"] = 0;\n    \n                /**\n                 * Creates a new EnumValueOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance\n                 */\n                EnumValueOptions.create = function create(properties) {\n                    return new EnumValueOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumValueOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".intValue\"] != null && Object.hasOwnProperty.call(message, \".intValue\"))\n                        writer.uint32(/* id 50002, wireType 0 =*/400016).int32(message[\".intValue\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumValueOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumValueOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 50002:\n                            message[\".intValue\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumValueOptions;\n            })();\n    \n            protobuf.ServiceOptions = (function() {\n    \n                /**\n                 * Properties of a ServiceOptions.\n                 * @memberof google.protobuf\n                 * @interface IServiceOptions\n                 * @property {boolean|null} [deprecated] ServiceOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new ServiceOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a ServiceOptions.\n                 * @implements IServiceOptions\n                 * @constructor\n                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n                 */\n                function ServiceOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ServiceOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.ServiceOptions\n                 * @instance\n                 */\n                ServiceOptions.prototype.deprecated = false;\n    \n                /**\n                 * ServiceOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.ServiceOptions\n                 * @instance\n                 */\n                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new ServiceOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance\n                 */\n                ServiceOptions.create = function create(properties) {\n                    return new ServiceOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServiceOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServiceOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.ServiceOptions} ServiceOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServiceOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServiceOptions;\n            })();\n    \n            protobuf.MethodOptions = (function() {\n    \n                /**\n                 * Properties of a MethodOptions.\n                 * @memberof google.protobuf\n                 * @interface IMethodOptions\n                 * @property {boolean|null} [deprecated] MethodOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new MethodOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MethodOptions.\n                 * @implements IMethodOptions\n                 * @constructor\n                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n                 */\n                function MethodOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MethodOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.MethodOptions\n                 * @instance\n                 */\n                MethodOptions.prototype.deprecated = false;\n    \n                /**\n                 * MethodOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.MethodOptions\n                 * @instance\n                 */\n                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new MethodOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.MethodOptions} MethodOptions instance\n                 */\n                MethodOptions.create = function create(properties) {\n                    return new MethodOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MethodOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MethodOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MethodOptions} MethodOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MethodOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MethodOptions;\n            })();\n    \n            protobuf.UninterpretedOption = (function() {\n    \n                /**\n                 * Properties of an UninterpretedOption.\n                 * @memberof google.protobuf\n                 * @interface IUninterpretedOption\n                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name\n                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue\n                 * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue\n                 * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue\n                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue\n                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue\n                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue\n                 */\n    \n                /**\n                 * Constructs a new UninterpretedOption.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an UninterpretedOption.\n                 * @implements IUninterpretedOption\n                 * @constructor\n                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n                 */\n                function UninterpretedOption(properties) {\n                    this.name = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * UninterpretedOption name.\n                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.name = $util.emptyArray;\n    \n                /**\n                 * UninterpretedOption identifierValue.\n                 * @member {string} identifierValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.identifierValue = \"\";\n    \n                /**\n                 * UninterpretedOption positiveIntValue.\n                 * @member {number|Long} positiveIntValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n    \n                /**\n                 * UninterpretedOption negativeIntValue.\n                 * @member {number|Long} negativeIntValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n    \n                /**\n                 * UninterpretedOption doubleValue.\n                 * @member {number} doubleValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.doubleValue = 0;\n    \n                /**\n                 * UninterpretedOption stringValue.\n                 * @member {Uint8Array} stringValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n    \n                /**\n                 * UninterpretedOption aggregateValue.\n                 * @member {string} aggregateValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.aggregateValue = \"\";\n    \n                /**\n                 * Creates a new UninterpretedOption instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance\n                 */\n                UninterpretedOption.create = function create(properties) {\n                    return new UninterpretedOption(properties);\n                };\n    \n                /**\n                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UninterpretedOption.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && message.name.length)\n                        for (var i = 0; i < message.name.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.identifierValue != null && Object.hasOwnProperty.call(message, \"identifierValue\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);\n                    if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, \"positiveIntValue\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);\n                    if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, \"negativeIntValue\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);\n                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\"))\n                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);\n                    if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);\n                    if (message.aggregateValue != null && Object.hasOwnProperty.call(message, \"aggregateValue\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an UninterpretedOption message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UninterpretedOption.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 2:\n                            if (!(message.name && message.name.length))\n                                message.name = [];\n                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.identifierValue = reader.string();\n                            break;\n                        case 4:\n                            message.positiveIntValue = reader.uint64();\n                            break;\n                        case 5:\n                            message.negativeIntValue = reader.int64();\n                            break;\n                        case 6:\n                            message.doubleValue = reader.double();\n                            break;\n                        case 7:\n                            message.stringValue = reader.bytes();\n                            break;\n                        case 8:\n                            message.aggregateValue = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                UninterpretedOption.NamePart = (function() {\n    \n                    /**\n                     * Properties of a NamePart.\n                     * @memberof google.protobuf.UninterpretedOption\n                     * @interface INamePart\n                     * @property {string} namePart NamePart namePart\n                     * @property {boolean} isExtension NamePart isExtension\n                     */\n    \n                    /**\n                     * Constructs a new NamePart.\n                     * @memberof google.protobuf.UninterpretedOption\n                     * @classdesc Represents a NamePart.\n                     * @implements INamePart\n                     * @constructor\n                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n                     */\n                    function NamePart(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * NamePart namePart.\n                     * @member {string} namePart\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @instance\n                     */\n                    NamePart.prototype.namePart = \"\";\n    \n                    /**\n                     * NamePart isExtension.\n                     * @member {boolean} isExtension\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @instance\n                     */\n                    NamePart.prototype.isExtension = false;\n    \n                    /**\n                     * Creates a new NamePart instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance\n                     */\n                    NamePart.create = function create(properties) {\n                        return new NamePart(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NamePart.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NamePart message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NamePart.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.namePart = reader.string();\n                                break;\n                            case 2:\n                                message.isExtension = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        if (!message.hasOwnProperty(\"namePart\"))\n                            throw $util.ProtocolError(\"missing required 'namePart'\", { instance: message });\n                        if (!message.hasOwnProperty(\"isExtension\"))\n                            throw $util.ProtocolError(\"missing required 'isExtension'\", { instance: message });\n                        return message;\n                    };\n    \n                    return NamePart;\n                })();\n    \n                return UninterpretedOption;\n            })();\n    \n            protobuf.SourceCodeInfo = (function() {\n    \n                /**\n                 * Properties of a SourceCodeInfo.\n                 * @memberof google.protobuf\n                 * @interface ISourceCodeInfo\n                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location\n                 */\n    \n                /**\n                 * Constructs a new SourceCodeInfo.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a SourceCodeInfo.\n                 * @implements ISourceCodeInfo\n                 * @constructor\n                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n                 */\n                function SourceCodeInfo(properties) {\n                    this.location = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SourceCodeInfo location.\n                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @instance\n                 */\n                SourceCodeInfo.prototype.location = $util.emptyArray;\n    \n                /**\n                 * Creates a new SourceCodeInfo instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance\n                 */\n                SourceCodeInfo.create = function create(properties) {\n                    return new SourceCodeInfo(properties);\n                };\n    \n                /**\n                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SourceCodeInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.location != null && message.location.length)\n                        for (var i = 0; i < message.location.length; ++i)\n                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SourceCodeInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SourceCodeInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.location && message.location.length))\n                                message.location = [];\n                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                SourceCodeInfo.Location = (function() {\n    \n                    /**\n                     * Properties of a Location.\n                     * @memberof google.protobuf.SourceCodeInfo\n                     * @interface ILocation\n                     * @property {Array.<number>|null} [path] Location path\n                     * @property {Array.<number>|null} [span] Location span\n                     * @property {string|null} [leadingComments] Location leadingComments\n                     * @property {string|null} [trailingComments] Location trailingComments\n                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments\n                     */\n    \n                    /**\n                     * Constructs a new Location.\n                     * @memberof google.protobuf.SourceCodeInfo\n                     * @classdesc Represents a Location.\n                     * @implements ILocation\n                     * @constructor\n                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n                     */\n                    function Location(properties) {\n                        this.path = [];\n                        this.span = [];\n                        this.leadingDetachedComments = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Location path.\n                     * @member {Array.<number>} path\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.path = $util.emptyArray;\n    \n                    /**\n                     * Location span.\n                     * @member {Array.<number>} span\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.span = $util.emptyArray;\n    \n                    /**\n                     * Location leadingComments.\n                     * @member {string} leadingComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.leadingComments = \"\";\n    \n                    /**\n                     * Location trailingComments.\n                     * @member {string} trailingComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.trailingComments = \"\";\n    \n                    /**\n                     * Location leadingDetachedComments.\n                     * @member {Array.<string>} leadingDetachedComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.leadingDetachedComments = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Location instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance\n                     */\n                    Location.create = function create(properties) {\n                        return new Location(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Location.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.path != null && message.path.length) {\n                            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                            for (var i = 0; i < message.path.length; ++i)\n                                writer.int32(message.path[i]);\n                            writer.ldelim();\n                        }\n                        if (message.span != null && message.span.length) {\n                            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                            for (var i = 0; i < message.span.length; ++i)\n                                writer.int32(message.span[i]);\n                            writer.ldelim();\n                        }\n                        if (message.leadingComments != null && Object.hasOwnProperty.call(message, \"leadingComments\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);\n                        if (message.trailingComments != null && Object.hasOwnProperty.call(message, \"trailingComments\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);\n                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)\n                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)\n                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Location message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.SourceCodeInfo.Location} Location\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Location.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                } else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                if (!(message.span && message.span.length))\n                                    message.span = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.span.push(reader.int32());\n                                } else\n                                    message.span.push(reader.int32());\n                                break;\n                            case 3:\n                                message.leadingComments = reader.string();\n                                break;\n                            case 4:\n                                message.trailingComments = reader.string();\n                                break;\n                            case 6:\n                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))\n                                    message.leadingDetachedComments = [];\n                                message.leadingDetachedComments.push(reader.string());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Location;\n                })();\n    \n                return SourceCodeInfo;\n            })();\n    \n            protobuf.GeneratedCodeInfo = (function() {\n    \n                /**\n                 * Properties of a GeneratedCodeInfo.\n                 * @memberof google.protobuf\n                 * @interface IGeneratedCodeInfo\n                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation\n                 */\n    \n                /**\n                 * Constructs a new GeneratedCodeInfo.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a GeneratedCodeInfo.\n                 * @implements IGeneratedCodeInfo\n                 * @constructor\n                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n                 */\n                function GeneratedCodeInfo(properties) {\n                    this.annotation = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GeneratedCodeInfo annotation.\n                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @instance\n                 */\n                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n    \n                /**\n                 * Creates a new GeneratedCodeInfo instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance\n                 */\n                GeneratedCodeInfo.create = function create(properties) {\n                    return new GeneratedCodeInfo(properties);\n                };\n    \n                /**\n                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GeneratedCodeInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.annotation != null && message.annotation.length)\n                        for (var i = 0; i < message.annotation.length; ++i)\n                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GeneratedCodeInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.annotation && message.annotation.length))\n                                message.annotation = [];\n                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                GeneratedCodeInfo.Annotation = (function() {\n    \n                    /**\n                     * Properties of an Annotation.\n                     * @memberof google.protobuf.GeneratedCodeInfo\n                     * @interface IAnnotation\n                     * @property {Array.<number>|null} [path] Annotation path\n                     * @property {string|null} [sourceFile] Annotation sourceFile\n                     * @property {number|null} [begin] Annotation begin\n                     * @property {number|null} [end] Annotation end\n                     */\n    \n                    /**\n                     * Constructs a new Annotation.\n                     * @memberof google.protobuf.GeneratedCodeInfo\n                     * @classdesc Represents an Annotation.\n                     * @implements IAnnotation\n                     * @constructor\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n                     */\n                    function Annotation(properties) {\n                        this.path = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Annotation path.\n                     * @member {Array.<number>} path\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.path = $util.emptyArray;\n    \n                    /**\n                     * Annotation sourceFile.\n                     * @member {string} sourceFile\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.sourceFile = \"\";\n    \n                    /**\n                     * Annotation begin.\n                     * @member {number} begin\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.begin = 0;\n    \n                    /**\n                     * Annotation end.\n                     * @member {number} end\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.end = 0;\n    \n                    /**\n                     * Creates a new Annotation instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance\n                     */\n                    Annotation.create = function create(properties) {\n                        return new Annotation(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Annotation.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.path != null && message.path.length) {\n                            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                            for (var i = 0; i < message.path.length; ++i)\n                                writer.int32(message.path[i]);\n                            writer.ldelim();\n                        }\n                        if (message.sourceFile != null && Object.hasOwnProperty.call(message, \"sourceFile\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);\n                        if (message.begin != null && Object.hasOwnProperty.call(message, \"begin\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an Annotation message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Annotation.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                } else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                message.sourceFile = reader.string();\n                                break;\n                            case 3:\n                                message.begin = reader.int32();\n                                break;\n                            case 4:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Annotation;\n                })();\n    \n                return GeneratedCodeInfo;\n            })();\n    \n            return protobuf;\n        })();\n    \n        return google;\n    })();\n    \n    $root.NanoPBOptions = (function() {\n    \n        /**\n         * Properties of a NanoPBOptions.\n         * @exports INanoPBOptions\n         * @interface INanoPBOptions\n         * @property {number|null} [maxSize] NanoPBOptions maxSize\n         * @property {number|null} [maxLength] NanoPBOptions maxLength\n         * @property {number|null} [maxCount] NanoPBOptions maxCount\n         * @property {IntSize|null} [intSize] NanoPBOptions intSize\n         * @property {FieldType|null} [type] NanoPBOptions type\n         * @property {boolean|null} [longNames] NanoPBOptions longNames\n         * @property {boolean|null} [packedStruct] NanoPBOptions packedStruct\n         * @property {boolean|null} [packedEnum] NanoPBOptions packedEnum\n         * @property {boolean|null} [skipMessage] NanoPBOptions skipMessage\n         * @property {boolean|null} [noUnions] NanoPBOptions noUnions\n         * @property {number|null} [msgid] NanoPBOptions msgid\n         * @property {boolean|null} [anonymousOneof] NanoPBOptions anonymousOneof\n         * @property {boolean|null} [proto3] NanoPBOptions proto3\n         * @property {boolean|null} [proto3SingularMsgs] NanoPBOptions proto3SingularMsgs\n         * @property {boolean|null} [enumToString] NanoPBOptions enumToString\n         * @property {boolean|null} [fixedLength] NanoPBOptions fixedLength\n         * @property {boolean|null} [fixedCount] NanoPBOptions fixedCount\n         * @property {boolean|null} [submsgCallback] NanoPBOptions submsgCallback\n         * @property {TypenameMangling|null} [mangleNames] NanoPBOptions mangleNames\n         * @property {string|null} [callbackDatatype] NanoPBOptions callbackDatatype\n         * @property {string|null} [callbackFunction] NanoPBOptions callbackFunction\n         * @property {DescriptorSize|null} [descriptorsize] NanoPBOptions descriptorsize\n         * @property {boolean|null} [defaultHas] NanoPBOptions defaultHas\n         * @property {Array.<string>|null} [include] NanoPBOptions include\n         * @property {Array.<string>|null} [exclude] NanoPBOptions exclude\n         * @property {string|null} [\"package\"] NanoPBOptions package\n         * @property {google.protobuf.FieldDescriptorProto.Type|null} [typeOverride] NanoPBOptions typeOverride\n         * @property {boolean|null} [sortByTag] NanoPBOptions sortByTag\n         */\n    \n        /**\n         * Constructs a new NanoPBOptions.\n         * @exports NanoPBOptions\n         * @classdesc Represents a NanoPBOptions.\n         * @implements INanoPBOptions\n         * @constructor\n         * @param {INanoPBOptions=} [properties] Properties to set\n         */\n        function NanoPBOptions(properties) {\n            this.include = [];\n            this.exclude = [];\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * NanoPBOptions maxSize.\n         * @member {number} maxSize\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxSize = 0;\n    \n        /**\n         * NanoPBOptions maxLength.\n         * @member {number} maxLength\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxLength = 0;\n    \n        /**\n         * NanoPBOptions maxCount.\n         * @member {number} maxCount\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxCount = 0;\n    \n        /**\n         * NanoPBOptions intSize.\n         * @member {IntSize} intSize\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.intSize = 0;\n    \n        /**\n         * NanoPBOptions type.\n         * @member {FieldType} type\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.type = 0;\n    \n        /**\n         * NanoPBOptions longNames.\n         * @member {boolean} longNames\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.longNames = true;\n    \n        /**\n         * NanoPBOptions packedStruct.\n         * @member {boolean} packedStruct\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.packedStruct = false;\n    \n        /**\n         * NanoPBOptions packedEnum.\n         * @member {boolean} packedEnum\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.packedEnum = false;\n    \n        /**\n         * NanoPBOptions skipMessage.\n         * @member {boolean} skipMessage\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.skipMessage = false;\n    \n        /**\n         * NanoPBOptions noUnions.\n         * @member {boolean} noUnions\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.noUnions = false;\n    \n        /**\n         * NanoPBOptions msgid.\n         * @member {number} msgid\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.msgid = 0;\n    \n        /**\n         * NanoPBOptions anonymousOneof.\n         * @member {boolean} anonymousOneof\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.anonymousOneof = false;\n    \n        /**\n         * NanoPBOptions proto3.\n         * @member {boolean} proto3\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.proto3 = false;\n    \n        /**\n         * NanoPBOptions proto3SingularMsgs.\n         * @member {boolean} proto3SingularMsgs\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.proto3SingularMsgs = true;\n    \n        /**\n         * NanoPBOptions enumToString.\n         * @member {boolean} enumToString\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.enumToString = false;\n    \n        /**\n         * NanoPBOptions fixedLength.\n         * @member {boolean} fixedLength\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.fixedLength = false;\n    \n        /**\n         * NanoPBOptions fixedCount.\n         * @member {boolean} fixedCount\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.fixedCount = false;\n    \n        /**\n         * NanoPBOptions submsgCallback.\n         * @member {boolean} submsgCallback\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.submsgCallback = false;\n    \n        /**\n         * NanoPBOptions mangleNames.\n         * @member {TypenameMangling} mangleNames\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.mangleNames = 0;\n    \n        /**\n         * NanoPBOptions callbackDatatype.\n         * @member {string} callbackDatatype\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.callbackDatatype = \"pb_callback_t\";\n    \n        /**\n         * NanoPBOptions callbackFunction.\n         * @member {string} callbackFunction\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.callbackFunction = \"pb_default_field_callback\";\n    \n        /**\n         * NanoPBOptions descriptorsize.\n         * @member {DescriptorSize} descriptorsize\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.descriptorsize = 0;\n    \n        /**\n         * NanoPBOptions defaultHas.\n         * @member {boolean} defaultHas\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.defaultHas = false;\n    \n        /**\n         * NanoPBOptions include.\n         * @member {Array.<string>} include\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.include = $util.emptyArray;\n    \n        /**\n         * NanoPBOptions exclude.\n         * @member {Array.<string>} exclude\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.exclude = $util.emptyArray;\n    \n        /**\n         * NanoPBOptions package.\n         * @member {string} package\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype[\"package\"] = \"\";\n    \n        /**\n         * NanoPBOptions typeOverride.\n         * @member {google.protobuf.FieldDescriptorProto.Type} typeOverride\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.typeOverride = 1;\n    \n        /**\n         * NanoPBOptions sortByTag.\n         * @member {boolean} sortByTag\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.sortByTag = true;\n    \n        /**\n         * Creates a new NanoPBOptions instance using the specified properties.\n         * @function create\n         * @memberof NanoPBOptions\n         * @static\n         * @param {INanoPBOptions=} [properties] Properties to set\n         * @returns {NanoPBOptions} NanoPBOptions instance\n         */\n        NanoPBOptions.create = function create(properties) {\n            return new NanoPBOptions(properties);\n        };\n    \n        /**\n         * Encodes the specified NanoPBOptions message. Does not implicitly {@link NanoPBOptions.verify|verify} messages.\n         * @function encode\n         * @memberof NanoPBOptions\n         * @static\n         * @param {INanoPBOptions} message NanoPBOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NanoPBOptions.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.maxSize != null && Object.hasOwnProperty.call(message, \"maxSize\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxSize);\n            if (message.maxCount != null && Object.hasOwnProperty.call(message, \"maxCount\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxCount);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n            if (message.longNames != null && Object.hasOwnProperty.call(message, \"longNames\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.longNames);\n            if (message.packedStruct != null && Object.hasOwnProperty.call(message, \"packedStruct\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.packedStruct);\n            if (message.skipMessage != null && Object.hasOwnProperty.call(message, \"skipMessage\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.skipMessage);\n            if (message.intSize != null && Object.hasOwnProperty.call(message, \"intSize\"))\n                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.intSize);\n            if (message.noUnions != null && Object.hasOwnProperty.call(message, \"noUnions\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.noUnions);\n            if (message.msgid != null && Object.hasOwnProperty.call(message, \"msgid\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.msgid);\n            if (message.packedEnum != null && Object.hasOwnProperty.call(message, \"packedEnum\"))\n                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.packedEnum);\n            if (message.anonymousOneof != null && Object.hasOwnProperty.call(message, \"anonymousOneof\"))\n                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.anonymousOneof);\n            if (message.proto3 != null && Object.hasOwnProperty.call(message, \"proto3\"))\n                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.proto3);\n            if (message.enumToString != null && Object.hasOwnProperty.call(message, \"enumToString\"))\n                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.enumToString);\n            if (message.maxLength != null && Object.hasOwnProperty.call(message, \"maxLength\"))\n                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.maxLength);\n            if (message.fixedLength != null && Object.hasOwnProperty.call(message, \"fixedLength\"))\n                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.fixedLength);\n            if (message.fixedCount != null && Object.hasOwnProperty.call(message, \"fixedCount\"))\n                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.fixedCount);\n            if (message.mangleNames != null && Object.hasOwnProperty.call(message, \"mangleNames\"))\n                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.mangleNames);\n            if (message.callbackDatatype != null && Object.hasOwnProperty.call(message, \"callbackDatatype\"))\n                writer.uint32(/* id 18, wireType 2 =*/146).string(message.callbackDatatype);\n            if (message.callbackFunction != null && Object.hasOwnProperty.call(message, \"callbackFunction\"))\n                writer.uint32(/* id 19, wireType 2 =*/154).string(message.callbackFunction);\n            if (message.descriptorsize != null && Object.hasOwnProperty.call(message, \"descriptorsize\"))\n                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.descriptorsize);\n            if (message.proto3SingularMsgs != null && Object.hasOwnProperty.call(message, \"proto3SingularMsgs\"))\n                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.proto3SingularMsgs);\n            if (message.submsgCallback != null && Object.hasOwnProperty.call(message, \"submsgCallback\"))\n                writer.uint32(/* id 22, wireType 0 =*/176).bool(message.submsgCallback);\n            if (message.defaultHas != null && Object.hasOwnProperty.call(message, \"defaultHas\"))\n                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.defaultHas);\n            if (message.include != null && message.include.length)\n                for (var i = 0; i < message.include.length; ++i)\n                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.include[i]);\n            if (message[\"package\"] != null && Object.hasOwnProperty.call(message, \"package\"))\n                writer.uint32(/* id 25, wireType 2 =*/202).string(message[\"package\"]);\n            if (message.exclude != null && message.exclude.length)\n                for (var i = 0; i < message.exclude.length; ++i)\n                    writer.uint32(/* id 26, wireType 2 =*/210).string(message.exclude[i]);\n            if (message.typeOverride != null && Object.hasOwnProperty.call(message, \"typeOverride\"))\n                writer.uint32(/* id 27, wireType 0 =*/216).int32(message.typeOverride);\n            if (message.sortByTag != null && Object.hasOwnProperty.call(message, \"sortByTag\"))\n                writer.uint32(/* id 28, wireType 0 =*/224).bool(message.sortByTag);\n            return writer;\n        };\n    \n        /**\n         * Decodes a NanoPBOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof NanoPBOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {NanoPBOptions} NanoPBOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NanoPBOptions.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.NanoPBOptions();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.maxSize = reader.int32();\n                    break;\n                case 14:\n                    message.maxLength = reader.int32();\n                    break;\n                case 2:\n                    message.maxCount = reader.int32();\n                    break;\n                case 7:\n                    message.intSize = reader.int32();\n                    break;\n                case 3:\n                    message.type = reader.int32();\n                    break;\n                case 4:\n                    message.longNames = reader.bool();\n                    break;\n                case 5:\n                    message.packedStruct = reader.bool();\n                    break;\n                case 10:\n                    message.packedEnum = reader.bool();\n                    break;\n                case 6:\n                    message.skipMessage = reader.bool();\n                    break;\n                case 8:\n                    message.noUnions = reader.bool();\n                    break;\n                case 9:\n                    message.msgid = reader.uint32();\n                    break;\n                case 11:\n                    message.anonymousOneof = reader.bool();\n                    break;\n                case 12:\n                    message.proto3 = reader.bool();\n                    break;\n                case 21:\n                    message.proto3SingularMsgs = reader.bool();\n                    break;\n                case 13:\n                    message.enumToString = reader.bool();\n                    break;\n                case 15:\n                    message.fixedLength = reader.bool();\n                    break;\n                case 16:\n                    message.fixedCount = reader.bool();\n                    break;\n                case 22:\n                    message.submsgCallback = reader.bool();\n                    break;\n                case 17:\n                    message.mangleNames = reader.int32();\n                    break;\n                case 18:\n                    message.callbackDatatype = reader.string();\n                    break;\n                case 19:\n                    message.callbackFunction = reader.string();\n                    break;\n                case 20:\n                    message.descriptorsize = reader.int32();\n                    break;\n                case 23:\n                    message.defaultHas = reader.bool();\n                    break;\n                case 24:\n                    if (!(message.include && message.include.length))\n                        message.include = [];\n                    message.include.push(reader.string());\n                    break;\n                case 26:\n                    if (!(message.exclude && message.exclude.length))\n                        message.exclude = [];\n                    message.exclude.push(reader.string());\n                    break;\n                case 25:\n                    message[\"package\"] = reader.string();\n                    break;\n                case 27:\n                    message.typeOverride = reader.int32();\n                    break;\n                case 28:\n                    message.sortByTag = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        return NanoPBOptions;\n    })();\n    \n    /**\n     * FieldType enum.\n     * @exports FieldType\n     * @enum {number}\n     * @property {number} FT_DEFAULT=0 FT_DEFAULT value\n     * @property {number} FT_CALLBACK=1 FT_CALLBACK value\n     * @property {number} FT_POINTER=4 FT_POINTER value\n     * @property {number} FT_STATIC=2 FT_STATIC value\n     * @property {number} FT_IGNORE=3 FT_IGNORE value\n     * @property {number} FT_INLINE=5 FT_INLINE value\n     */\n    $root.FieldType = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"FT_DEFAULT\"] = 0;\n        values[valuesById[1] = \"FT_CALLBACK\"] = 1;\n        values[valuesById[4] = \"FT_POINTER\"] = 4;\n        values[valuesById[2] = \"FT_STATIC\"] = 2;\n        values[valuesById[3] = \"FT_IGNORE\"] = 3;\n        values[valuesById[5] = \"FT_INLINE\"] = 5;\n        return values;\n    })();\n    \n    /**\n     * IntSize enum.\n     * @exports IntSize\n     * @enum {number}\n     * @property {number} IS_DEFAULT=0 IS_DEFAULT value\n     * @property {number} IS_8=8 IS_8 value\n     * @property {number} IS_16=16 IS_16 value\n     * @property {number} IS_32=32 IS_32 value\n     * @property {number} IS_64=64 IS_64 value\n     */\n    $root.IntSize = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"IS_DEFAULT\"] = 0;\n        values[valuesById[8] = \"IS_8\"] = 8;\n        values[valuesById[16] = \"IS_16\"] = 16;\n        values[valuesById[32] = \"IS_32\"] = 32;\n        values[valuesById[64] = \"IS_64\"] = 64;\n        return values;\n    })();\n    \n    /**\n     * TypenameMangling enum.\n     * @exports TypenameMangling\n     * @enum {number}\n     * @property {number} M_NONE=0 M_NONE value\n     * @property {number} M_STRIP_PACKAGE=1 M_STRIP_PACKAGE value\n     * @property {number} M_FLATTEN=2 M_FLATTEN value\n     * @property {number} M_PACKAGE_INITIALS=3 M_PACKAGE_INITIALS value\n     */\n    $root.TypenameMangling = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"M_NONE\"] = 0;\n        values[valuesById[1] = \"M_STRIP_PACKAGE\"] = 1;\n        values[valuesById[2] = \"M_FLATTEN\"] = 2;\n        values[valuesById[3] = \"M_PACKAGE_INITIALS\"] = 3;\n        return values;\n    })();\n    \n    /**\n     * DescriptorSize enum.\n     * @exports DescriptorSize\n     * @enum {number}\n     * @property {number} DS_AUTO=0 DS_AUTO value\n     * @property {number} DS_1=1 DS_1 value\n     * @property {number} DS_2=2 DS_2 value\n     * @property {number} DS_4=4 DS_4 value\n     * @property {number} DS_8=8 DS_8 value\n     */\n    $root.DescriptorSize = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"DS_AUTO\"] = 0;\n        values[valuesById[1] = \"DS_1\"] = 1;\n        values[valuesById[2] = \"DS_2\"] = 2;\n        values[valuesById[4] = \"DS_4\"] = 4;\n        values[valuesById[8] = \"DS_8\"] = 8;\n        return values;\n    })();\n\n    return $root;\n});\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/address-error.js":
/*!*******************************************************!*\
  !*** ./node_modules/ip-address/dist/address-error.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AddressError = void 0;\nclass AddressError extends Error {\n    constructor(message, parseMessage) {\n        super(message);\n        this.name = 'AddressError';\n        if (parseMessage !== null) {\n            this.parseMessage = parseMessage;\n        }\n    }\n}\nexports.AddressError = AddressError;\n//# sourceMappingURL=address-error.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/address-error.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/common.js":
/*!************************************************!*\
  !*** ./node_modules/ip-address/dist/common.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isCorrect = exports.isInSubnet = void 0;\nfunction isInSubnet(address) {\n    if (this.subnetMask < address.subnetMask) {\n        return false;\n    }\n    if (this.mask(address.subnetMask) === address.mask()) {\n        return true;\n    }\n    return false;\n}\nexports.isInSubnet = isInSubnet;\nfunction isCorrect(defaultBits) {\n    return function () {\n        if (this.addressMinusSuffix !== this.correctForm()) {\n            return false;\n        }\n        if (this.subnetMask === defaultBits && !this.parsedSubnet) {\n            return true;\n        }\n        return this.parsedSubnet === String(this.subnetMask);\n    };\n}\nexports.isCorrect = isCorrect;\n//# sourceMappingURL=common.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/common.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/ip-address.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/ip-address.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"./node_modules/ip-address/dist/ipv4.js\");\nObject.defineProperty(exports, \"Address4\", ({ enumerable: true, get: function () { return ipv4_1.Address4; } }));\nconst ipv6_1 = __webpack_require__(/*! ./ipv6 */ \"./node_modules/ip-address/dist/ipv6.js\");\nObject.defineProperty(exports, \"Address6\", ({ enumerable: true, get: function () { return ipv6_1.Address6; } }));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"./node_modules/ip-address/dist/address-error.js\");\nObject.defineProperty(exports, \"AddressError\", ({ enumerable: true, get: function () { return address_error_1.AddressError; } }));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"./node_modules/ip-address/dist/v6/helpers.js\"));\nexports.v6 = { helpers };\n//# sourceMappingURL=ip-address.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/ip-address.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/ipv4.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv4.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address4 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"./node_modules/ip-address/dist/common.js\"));\nconst constants = __importStar(__webpack_require__(/*! ./v4/constants */ \"./node_modules/ip-address/dist/v4/constants.js\"));\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"./node_modules/ip-address/dist/address-error.js\");\nconst jsbn_1 = __webpack_require__(/*! jsbn */ \"./node_modules/jsbn/index.js\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js\");\n/**\n * Represents an IPv4 address\n * @class Address4\n * @param {string} address - An IPv4 address string\n */\nclass Address4 {\n    constructor(address) {\n        this.groups = constants.GROUPS;\n        this.parsedAddress = [];\n        this.parsedSubnet = '';\n        this.subnet = '/32';\n        this.subnetMask = 32;\n        this.v4 = true;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address4\n         * @instance\n         * @returns {Boolean}\n         */\n        this.isCorrect = common.isCorrect(constants.BITS);\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address4\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        this.address = address;\n        const subnet = constants.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants.RE_SUBNET_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(address);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address4(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /*\n     * Parses a v4 address\n     */\n    parse(address) {\n        const groups = address.split('.');\n        if (!address.match(constants.RE_ADDRESS)) {\n            throw new address_error_1.AddressError('Invalid IPv4 address.');\n        }\n        return groups;\n    }\n    /**\n     * Returns the correct form of an address\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        return this.parsedAddress.map((part) => parseInt(part, 10)).join('.');\n    }\n    /**\n     * Converts a hex string to an IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {string} hex - a hex string to convert\n     * @returns {Address4}\n     */\n    static fromHex(hex) {\n        const padded = hex.replace(/:/g, '').padStart(8, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < 8; i += 2) {\n            const h = padded.slice(i, i + 2);\n            groups.push(parseInt(h, 16));\n        }\n        return new Address4(groups.join('.'));\n    }\n    /**\n     * Converts an integer into a IPv4 address object\n     * @memberof Address4\n     * @static\n     * @param {integer} integer - a number to convert\n     * @returns {Address4}\n     */\n    static fromInteger(integer) {\n        return Address4.fromHex(integer.toString(16));\n    }\n    /**\n     * Return an address from in-addr.arpa form\n     * @memberof Address4\n     * @static\n     * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address\n     * @returns {Adress4}\n     * @example\n     * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)\n     * address.correctForm(); // '192.0.2.42'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".in-addr.arpa.\" or just \".\"\n        const leader = arpaFormAddress.replace(/(\\.in-addr\\.arpa)?\\.$/, '');\n        const address = leader.split('.').reverse().join('.');\n        return new Address4(address);\n    }\n    /**\n     * Converts an IPv4 address object to a hex string\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toHex() {\n        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)('%02x', parseInt(part, 10))).join(':');\n    }\n    /**\n     * Converts an IPv4 address object to an array of bytes\n     * @memberof Address4\n     * @instance\n     * @returns {Array}\n     */\n    toArray() {\n        return this.parsedAddress.map((part) => parseInt(part, 10));\n    }\n    /**\n     * Converts an IPv4 address object to an IPv6 address group\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    toGroup6() {\n        const output = [];\n        let i;\n        for (i = 0; i < constants.GROUPS; i += 2) {\n            const hex = (0, sprintf_js_1.sprintf)('%02x%02x', parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));\n            output.push((0, sprintf_js_1.sprintf)('%x', parseInt(hex, 16)));\n        }\n        return output.join(':');\n    }\n    /**\n     * Returns the address as a BigInteger\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    bigInteger() {\n        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)('%02x', parseInt(n, 10))).join(''), 16);\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    _startAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The first address in the range given by this address' subnet.\n     * Often referred to as the Network Address.\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddress() {\n        return Address4.fromBigInteger(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    startAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address4.fromBigInteger(this._startAddress().add(adjust));\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address4\n     * @instance\n     * @returns {BigInteger}\n     */\n    _endAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddress() {\n        return Address4.fromBigInteger(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address4\n     * @instance\n     * @returns {Address4}\n     */\n    endAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address4.fromBigInteger(this._endAddress().subtract(adjust));\n    }\n    /**\n     * Converts a BigInteger to a v4 address object\n     * @memberof Address4\n     * @static\n     * @param {BigInteger} bigInteger - a BigInteger to convert\n     * @returns {Address4}\n     */\n    static fromBigInteger(bigInteger) {\n        return Address4.fromInteger(parseInt(bigInteger.toString(), 10));\n    }\n    /**\n     * Returns the first n bits of the address, defaulting to the\n     * subnet mask\n     * @memberof Address4\n     * @instance\n     * @returns {String}\n     */\n    mask(mask) {\n        if (mask === undefined) {\n            mask = this.subnetMask;\n        }\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Returns the bits in the given range as a base-2 string\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address4\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"in-addr.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const reversed = this.correctForm().split('.').reverse().join('.');\n        if (options.omitSuffix) {\n            return reversed;\n        }\n        return (0, sprintf_js_1.sprintf)('%s.in-addr.arpa.', reversed);\n    }\n    /**\n     * Returns true if the given address is a multicast address\n     * @memberof Address4\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.isInSubnet(new Address4('224.0.0.0/4'));\n    }\n    /**\n     * Returns a zero-padded base-2 string representation of the address\n     * @memberof Address4\n     * @instance\n     * @returns {string}\n     */\n    binaryZeroPad() {\n        return this.bigInteger().toString(2).padStart(constants.BITS, '0');\n    }\n    /**\n     * Groups an IPv4 address for inclusion at the end of an IPv6 address\n     * @returns {String}\n     */\n    groupForV6() {\n        const segments = this.parsedAddress;\n        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class=\"hover-group group-v4 group-6\">%s</span>.<span class=\"hover-group group-v4 group-7\">%s</span>', segments.slice(0, 2).join('.'), segments.slice(2, 4).join('.')));\n    }\n}\nexports.Address4 = Address4;\n//# sourceMappingURL=ipv4.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/ipv4.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/ipv6.js":
/*!**********************************************!*\
  !*** ./node_modules/ip-address/dist/ipv6.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-param-reassign */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Address6 = void 0;\nconst common = __importStar(__webpack_require__(/*! ./common */ \"./node_modules/ip-address/dist/common.js\"));\nconst constants4 = __importStar(__webpack_require__(/*! ./v4/constants */ \"./node_modules/ip-address/dist/v4/constants.js\"));\nconst constants6 = __importStar(__webpack_require__(/*! ./v6/constants */ \"./node_modules/ip-address/dist/v6/constants.js\"));\nconst helpers = __importStar(__webpack_require__(/*! ./v6/helpers */ \"./node_modules/ip-address/dist/v6/helpers.js\"));\nconst ipv4_1 = __webpack_require__(/*! ./ipv4 */ \"./node_modules/ip-address/dist/ipv4.js\");\nconst regular_expressions_1 = __webpack_require__(/*! ./v6/regular-expressions */ \"./node_modules/ip-address/dist/v6/regular-expressions.js\");\nconst address_error_1 = __webpack_require__(/*! ./address-error */ \"./node_modules/ip-address/dist/address-error.js\");\nconst jsbn_1 = __webpack_require__(/*! jsbn */ \"./node_modules/jsbn/index.js\");\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js\");\nfunction assert(condition) {\n    if (!condition) {\n        throw new Error('Assertion failed.');\n    }\n}\nfunction addCommas(number) {\n    const r = /(\\d+)(\\d{3})/;\n    while (r.test(number)) {\n        number = number.replace(r, '$1,$2');\n    }\n    return number;\n}\nfunction spanLeadingZeroes4(n) {\n    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class=\"parse-error\">$1</span>$2');\n    n = n.replace(/^(0{1,})(0)$/, '<span class=\"parse-error\">$1</span>$2');\n    return n;\n}\n/*\n * A helper function to compact an array\n */\nfunction compact(address, slice) {\n    const s1 = [];\n    const s2 = [];\n    let i;\n    for (i = 0; i < address.length; i++) {\n        if (i < slice[0]) {\n            s1.push(address[i]);\n        }\n        else if (i > slice[1]) {\n            s2.push(address[i]);\n        }\n    }\n    return s1.concat(['compact']).concat(s2);\n}\nfunction paddedHex(octet) {\n    return (0, sprintf_js_1.sprintf)('%04x', parseInt(octet, 16));\n}\nfunction unsignByte(b) {\n    // eslint-disable-next-line no-bitwise\n    return b & 0xff;\n}\n/**\n * Represents an IPv6 address\n * @class Address6\n * @param {string} address - An IPv6 address string\n * @param {number} [groups=8] - How many octets to parse\n * @example\n * var address = new Address6('2001::/32');\n */\nclass Address6 {\n    constructor(address, optionalGroups) {\n        this.addressMinusSuffix = '';\n        this.parsedSubnet = '';\n        this.subnet = '/128';\n        this.subnetMask = 128;\n        this.v4 = false;\n        this.zone = '';\n        // #region Attributes\n        /**\n         * Returns true if the given address is in the subnet of the current address\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isInSubnet = common.isInSubnet;\n        /**\n         * Returns true if the address is correct, false otherwise\n         * @memberof Address6\n         * @instance\n         * @returns {boolean}\n         */\n        this.isCorrect = common.isCorrect(constants6.BITS);\n        if (optionalGroups === undefined) {\n            this.groups = constants6.GROUPS;\n        }\n        else {\n            this.groups = optionalGroups;\n        }\n        this.address = address;\n        const subnet = constants6.RE_SUBNET_STRING.exec(address);\n        if (subnet) {\n            this.parsedSubnet = subnet[0].replace('/', '');\n            this.subnetMask = parseInt(this.parsedSubnet, 10);\n            this.subnet = `/${this.subnetMask}`;\n            if (Number.isNaN(this.subnetMask) ||\n                this.subnetMask < 0 ||\n                this.subnetMask > constants6.BITS) {\n                throw new address_error_1.AddressError('Invalid subnet mask.');\n            }\n            address = address.replace(constants6.RE_SUBNET_STRING, '');\n        }\n        else if (/\\//.test(address)) {\n            throw new address_error_1.AddressError('Invalid subnet mask.');\n        }\n        const zone = constants6.RE_ZONE_STRING.exec(address);\n        if (zone) {\n            this.zone = zone[0];\n            address = address.replace(constants6.RE_ZONE_STRING, '');\n        }\n        this.addressMinusSuffix = address;\n        this.parsedAddress = this.parse(this.addressMinusSuffix);\n    }\n    static isValid(address) {\n        try {\n            // eslint-disable-next-line no-new\n            new Address6(address);\n            return true;\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    /**\n     * Convert a BigInteger to a v6 address object\n     * @memberof Address6\n     * @static\n     * @param {BigInteger} bigInteger - a BigInteger to convert\n     * @returns {Address6}\n     * @example\n     * var bigInteger = new BigInteger('1000000000000');\n     * var address = Address6.fromBigInteger(bigInteger);\n     * address.correctForm(); // '::e8:d4a5:1000'\n     */\n    static fromBigInteger(bigInteger) {\n        const hex = bigInteger.toString(16).padStart(32, '0');\n        const groups = [];\n        let i;\n        for (i = 0; i < constants6.GROUPS; i++) {\n            groups.push(hex.slice(i * 4, (i + 1) * 4));\n        }\n        return new Address6(groups.join(':'));\n    }\n    /**\n     * Convert a URL (with optional port number) to an address object\n     * @memberof Address6\n     * @static\n     * @param {string} url - a URL with optional port number\n     * @example\n     * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');\n     * addressAndPort.address.correctForm(); // 'ffff::'\n     * addressAndPort.port; // 8080\n     */\n    static fromURL(url) {\n        let host;\n        let port = null;\n        let result;\n        // If we have brackets parse them and find a port\n        if (url.indexOf('[') !== -1 && url.indexOf(']:') !== -1) {\n            result = constants6.RE_URL_WITH_PORT.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address with port',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            port = result[2];\n            // If there's a URL extract the address\n        }\n        else if (url.indexOf('/') !== -1) {\n            // Remove the protocol prefix\n            url = url.replace(/^[a-z0-9]+:\\/\\//, '');\n            // Parse the address\n            result = constants6.RE_URL.exec(url);\n            if (result === null) {\n                return {\n                    error: 'failed to parse address from URL',\n                    address: null,\n                    port: null,\n                };\n            }\n            host = result[1];\n            // Otherwise just assign the URL to the host and let the library parse it\n        }\n        else {\n            host = url;\n        }\n        // If there's a port convert it to an integer\n        if (port) {\n            port = parseInt(port, 10);\n            // squelch out of range ports\n            if (port < 0 || port > 65536) {\n                port = null;\n            }\n        }\n        else {\n            // Standardize `undefined` to `null`\n            port = null;\n        }\n        return {\n            address: new Address6(host),\n            port,\n        };\n    }\n    /**\n     * Create an IPv6-mapped address given an IPv4 address\n     * @memberof Address6\n     * @static\n     * @param {string} address - An IPv4 address string\n     * @returns {Address6}\n     * @example\n     * var address = Address6.fromAddress4('192.168.0.1');\n     * address.correctForm(); // '::ffff:c0a8:1'\n     * address.to4in6(); // '::ffff:192.168.0.1'\n     */\n    static fromAddress4(address) {\n        const address4 = new ipv4_1.Address4(address);\n        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);\n        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);\n    }\n    /**\n     * Return an address from ip6.arpa form\n     * @memberof Address6\n     * @static\n     * @param {string} arpaFormAddress - an 'ip6.arpa' form address\n     * @returns {Adress6}\n     * @example\n     * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)\n     * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'\n     */\n    static fromArpa(arpaFormAddress) {\n        // remove ending \".ip6.arpa.\" or just \".\"\n        let address = arpaFormAddress.replace(/(\\.ip6\\.arpa)?\\.$/, '');\n        const semicolonAmount = 7;\n        // correct ip6.arpa form with ending removed will be 63 characters\n        if (address.length !== 63) {\n            throw new address_error_1.AddressError(\"Invalid 'ip6.arpa' form.\");\n        }\n        const parts = address.split('.').reverse();\n        for (let i = semicolonAmount; i > 0; i--) {\n            const insertIndex = i * 4;\n            parts.splice(insertIndex, 0, ':');\n        }\n        address = parts.join('');\n        return new Address6(address);\n    }\n    /**\n     * Return the Microsoft UNC transcription of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String} the Microsoft UNC transcription of the address\n     */\n    microsoftTranscription() {\n        return (0, sprintf_js_1.sprintf)('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'));\n    }\n    /**\n     * Return the first n bits of the address, defaulting to the subnet mask\n     * @memberof Address6\n     * @instance\n     * @param {number} [mask=subnet] - the number of bits to mask\n     * @returns {String} the first n bits of the address as a string\n     */\n    mask(mask = this.subnetMask) {\n        return this.getBitsBase2(0, mask);\n    }\n    /**\n     * Return the number of possible subnets of a given size in the address\n     * @memberof Address6\n     * @instance\n     * @param {number} [size=128] - the subnet size\n     * @returns {String}\n     */\n    // TODO: probably useful to have a numeric version of this too\n    possibleSubnets(subnetSize = 128) {\n        const availableBits = constants6.BITS - this.subnetMask;\n        const subnetBits = Math.abs(subnetSize - constants6.BITS);\n        const subnetPowers = availableBits - subnetBits;\n        if (subnetPowers < 0) {\n            return '0';\n        }\n        return addCommas(new jsbn_1.BigInteger('2', 10).pow(subnetPowers).toString(10));\n    }\n    /**\n     * Helper function getting start address.\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    _startAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '0'.repeat(constants6.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The first address in the range given by this address' subnet\n     * Often referred to as the Network Address.\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddress() {\n        return Address6.fromBigInteger(this._startAddress());\n    }\n    /**\n     * The first host address in the range given by this address's subnet ie\n     * the first address after the Network Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    startAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address6.fromBigInteger(this._startAddress().add(adjust));\n    }\n    /**\n     * Helper function getting end address.\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    _endAddress() {\n        return new jsbn_1.BigInteger(this.mask() + '1'.repeat(constants6.BITS - this.subnetMask), 2);\n    }\n    /**\n     * The last address in the range given by this address' subnet\n     * Often referred to as the Broadcast\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddress() {\n        return Address6.fromBigInteger(this._endAddress());\n    }\n    /**\n     * The last host address in the range given by this address's subnet ie\n     * the last address prior to the Broadcast Address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    endAddressExclusive() {\n        const adjust = new jsbn_1.BigInteger('1');\n        return Address6.fromBigInteger(this._endAddress().subtract(adjust));\n    }\n    /**\n     * Return the scope of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getScope() {\n        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];\n        if (this.getType() === 'Global unicast' && scope !== 'Link local') {\n            scope = 'Global';\n        }\n        return scope || 'Unknown';\n    }\n    /**\n     * Return the type of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getType() {\n        for (const subnet of Object.keys(constants6.TYPES)) {\n            if (this.isInSubnet(new Address6(subnet))) {\n                return constants6.TYPES[subnet];\n            }\n        }\n        return 'Global unicast';\n    }\n    /**\n     * Return the bits in the given range as a BigInteger\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    getBits(start, end) {\n        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);\n    }\n    /**\n     * Return the bits in the given range as a base-2 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase2(start, end) {\n        return this.binaryZeroPad().slice(start, end);\n    }\n    /**\n     * Return the bits in the given range as a base-16 string\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsBase16(start, end) {\n        const length = end - start;\n        if (length % 4 !== 0) {\n            throw new Error('Length of bits to retrieve must be divisible by four');\n        }\n        return this.getBits(start, end)\n            .toString(16)\n            .padStart(length / 4, '0');\n    }\n    /**\n     * Return the bits that are set past the subnet mask length\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    getBitsPastSubnet() {\n        return this.getBitsBase2(this.subnetMask, constants6.BITS);\n    }\n    /**\n     * Return the reversed ip6.arpa form of the address\n     * @memberof Address6\n     * @param {Object} options\n     * @param {boolean} options.omitSuffix - omit the \"ip6.arpa\" suffix\n     * @instance\n     * @returns {String}\n     */\n    reverseForm(options) {\n        if (!options) {\n            options = {};\n        }\n        const characters = Math.floor(this.subnetMask / 4);\n        const reversed = this.canonicalForm()\n            .replace(/:/g, '')\n            .split('')\n            .slice(0, characters)\n            .reverse()\n            .join('.');\n        if (characters > 0) {\n            if (options.omitSuffix) {\n                return reversed;\n            }\n            return (0, sprintf_js_1.sprintf)('%s.ip6.arpa.', reversed);\n        }\n        if (options.omitSuffix) {\n            return '';\n        }\n        return 'ip6.arpa.';\n    }\n    /**\n     * Return the correct form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    correctForm() {\n        let i;\n        let groups = [];\n        let zeroCounter = 0;\n        const zeroes = [];\n        for (i = 0; i < this.parsedAddress.length; i++) {\n            const value = parseInt(this.parsedAddress[i], 16);\n            if (value === 0) {\n                zeroCounter++;\n            }\n            if (value !== 0 && zeroCounter > 0) {\n                if (zeroCounter > 1) {\n                    zeroes.push([i - zeroCounter, i - 1]);\n                }\n                zeroCounter = 0;\n            }\n        }\n        // Do we end with a string of zeroes?\n        if (zeroCounter > 1) {\n            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);\n        }\n        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);\n        if (zeroes.length > 0) {\n            const index = zeroLengths.indexOf(Math.max(...zeroLengths));\n            groups = compact(this.parsedAddress, zeroes[index]);\n        }\n        else {\n            groups = this.parsedAddress;\n        }\n        for (i = 0; i < groups.length; i++) {\n            if (groups[i] !== 'compact') {\n                groups[i] = parseInt(groups[i], 16).toString(16);\n            }\n        }\n        let correct = groups.join(':');\n        correct = correct.replace(/^compact$/, '::');\n        correct = correct.replace(/^compact|compact$/, ':');\n        correct = correct.replace(/compact/, '');\n        return correct;\n    }\n    /**\n     * Return a zero-padded base-2 string representation of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     * @example\n     * var address = new Address6('2001:4860:4001:803::1011');\n     * address.binaryZeroPad();\n     * // '0010000000000001010010000110000001000000000000010000100000000011\n     * //  0000000000000000000000000000000000000000000000000001000000010001'\n     */\n    binaryZeroPad() {\n        return this.bigInteger().toString(2).padStart(constants6.BITS, '0');\n    }\n    // TODO: Improve the semantics of this helper function\n    parse4in6(address) {\n        const groups = address.split(':');\n        const lastGroup = groups.slice(-1)[0];\n        const address4 = lastGroup.match(constants4.RE_ADDRESS);\n        if (address4) {\n            this.parsedAddress4 = address4[0];\n            this.address4 = new ipv4_1.Address4(this.parsedAddress4);\n            for (let i = 0; i < this.address4.groups; i++) {\n                if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {\n                    throw new address_error_1.AddressError(\"IPv4 addresses can't have leading zeroes.\", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join('.')));\n                }\n            }\n            this.v4 = true;\n            groups[groups.length - 1] = this.address4.toGroup6();\n            address = groups.join(':');\n        }\n        return address;\n    }\n    // TODO: Make private?\n    parse(address) {\n        address = this.parse4in6(address);\n        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);\n        if (badCharacters) {\n            throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Bad character%s detected in address: %s', badCharacters.length > 1 ? 's' : '', badCharacters.join('')), address.replace(constants6.RE_BAD_CHARACTERS, '<span class=\"parse-error\">$1</span>'));\n        }\n        const badAddress = address.match(constants6.RE_BAD_ADDRESS);\n        if (badAddress) {\n            throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)('Address failed regex: %s', badAddress.join('')), address.replace(constants6.RE_BAD_ADDRESS, '<span class=\"parse-error\">$1</span>'));\n        }\n        let groups = [];\n        const halves = address.split('::');\n        if (halves.length === 2) {\n            let first = halves[0].split(':');\n            let last = halves[1].split(':');\n            if (first.length === 1 && first[0] === '') {\n                first = [];\n            }\n            if (last.length === 1 && last[0] === '') {\n                last = [];\n            }\n            const remaining = this.groups - (first.length + last.length);\n            if (!remaining) {\n                throw new address_error_1.AddressError('Error parsing groups');\n            }\n            this.elidedGroups = remaining;\n            this.elisionBegin = first.length;\n            this.elisionEnd = first.length + this.elidedGroups;\n            groups = groups.concat(first);\n            for (let i = 0; i < remaining; i++) {\n                groups.push('0');\n            }\n            groups = groups.concat(last);\n        }\n        else if (halves.length === 1) {\n            groups = address.split(':');\n            this.elidedGroups = 0;\n        }\n        else {\n            throw new address_error_1.AddressError('Too many :: groups found');\n        }\n        groups = groups.map((group) => (0, sprintf_js_1.sprintf)('%x', parseInt(group, 16)));\n        if (groups.length !== this.groups) {\n            throw new address_error_1.AddressError('Incorrect number of groups found');\n        }\n        return groups;\n    }\n    /**\n     * Return the canonical form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    canonicalForm() {\n        return this.parsedAddress.map(paddedHex).join(':');\n    }\n    /**\n     * Return the decimal form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    decimal() {\n        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)('%05d', parseInt(n, 16))).join(':');\n    }\n    /**\n     * Return the address as a BigInteger\n     * @memberof Address6\n     * @instance\n     * @returns {BigInteger}\n     */\n    bigInteger() {\n        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(''), 16);\n    }\n    /**\n     * Return the last two groups of this address as an IPv4 address string\n     * @memberof Address6\n     * @instance\n     * @returns {Address4}\n     * @example\n     * var address = new Address6('2001:4860:4001::1825:bf11');\n     * address.to4().correctForm(); // '24.37.191.17'\n     */\n    to4() {\n        const binary = this.binaryZeroPad().split('');\n        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(''), 2).toString(16));\n    }\n    /**\n     * Return the v4-in-v6 form of the address\n     * @memberof Address6\n     * @instance\n     * @returns {String}\n     */\n    to4in6() {\n        const address4 = this.to4();\n        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(':'), 6);\n        const correct = address6.correctForm();\n        let infix = '';\n        if (!/:$/.test(correct)) {\n            infix = ':';\n        }\n        return correct + infix + address4.address;\n    }\n    /**\n     * Return an object containing the Teredo properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspectTeredo() {\n        /*\n        - Bits 0 to 31 are set to the Teredo prefix (normally 2001:0000::/32).\n        - Bits 32 to 63 embed the primary IPv4 address of the Teredo server that\n          is used.\n        - Bits 64 to 79 can be used to define some flags. Currently only the\n          higher order bit is used; it is set to 1 if the Teredo client is\n          located behind a cone NAT, 0 otherwise. For Microsoft's Windows Vista\n          and Windows Server 2008 implementations, more bits are used. In those\n          implementations, the format for these 16 bits is \"CRAAAAUG AAAAAAAA\",\n          where \"C\" remains the \"Cone\" flag. The \"R\" bit is reserved for future\n          use. The \"U\" bit is for the Universal/Local flag (set to 0). The \"G\" bit\n          is Individual/Group flag (set to 0). The A bits are set to a 12-bit\n          randomly generated number chosen by the Teredo client to introduce\n          additional protection for the Teredo node against IPv6-based scanning\n          attacks.\n        - Bits 80 to 95 contains the obfuscated UDP port number. This is the\n          port number that is mapped by the NAT to the Teredo client with all\n          bits inverted.\n        - Bits 96 to 127 contains the obfuscated IPv4 address. This is the\n          public IPv4 address of the NAT with all bits inverted.\n        */\n        const prefix = this.getBitsBase16(0, 32);\n        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger('ffff', 16)).toString();\n        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));\n        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger('ffffffff', 16)).toString(16));\n        const flags = this.getBits(64, 80);\n        const flagsBase2 = this.getBitsBase2(64, 80);\n        const coneNat = flags.testBit(15);\n        const reserved = flags.testBit(14);\n        const groupIndividual = flags.testBit(8);\n        const universalLocal = flags.testBit(9);\n        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);\n        return {\n            prefix: (0, sprintf_js_1.sprintf)('%s:%s', prefix.slice(0, 4), prefix.slice(4, 8)),\n            server4: server4.address,\n            client4: client4.address,\n            flags: flagsBase2,\n            coneNat,\n            microsoft: {\n                reserved,\n                universalLocal,\n                groupIndividual,\n                nonce,\n            },\n            udpPort,\n        };\n    }\n    /**\n     * Return an object containing the 6to4 properties of the address\n     * @memberof Address6\n     * @instance\n     * @returns {Object}\n     */\n    inspect6to4() {\n        /*\n        - Bits 0 to 15 are set to the 6to4 prefix (2002::/16).\n        - Bits 16 to 48 embed the IPv4 address of the 6to4 gateway that is used.\n        */\n        const prefix = this.getBitsBase16(0, 16);\n        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));\n        return {\n            prefix: (0, sprintf_js_1.sprintf)('%s', prefix.slice(0, 4)),\n            gateway: gateway.address,\n        };\n    }\n    /**\n     * Return a v6 6to4 address from a v6 v4inv6 address\n     * @memberof Address6\n     * @instance\n     * @returns {Address6}\n     */\n    to6to4() {\n        if (!this.is4()) {\n            return null;\n        }\n        const addr6to4 = [\n            '2002',\n            this.getBitsBase16(96, 112),\n            this.getBitsBase16(112, 128),\n            '',\n            '/16',\n        ].join(':');\n        return new Address6(addr6to4);\n    }\n    /**\n     * Return a byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toByteArray() {\n        const byteArray = this.bigInteger().toByteArray();\n        // work around issue where `toByteArray` returns a leading 0 element\n        if (byteArray.length === 17 && byteArray[0] === 0) {\n            return byteArray.slice(1);\n        }\n        return byteArray;\n    }\n    /**\n     * Return an unsigned byte array\n     * @memberof Address6\n     * @instance\n     * @returns {Array}\n     */\n    toUnsignedByteArray() {\n        return this.toByteArray().map(unsignByte);\n    }\n    /**\n     * Convert a byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromByteArray(bytes) {\n        return this.fromUnsignedByteArray(bytes.map(unsignByte));\n    }\n    /**\n     * Convert an unsigned byte array to an Address6 object\n     * @memberof Address6\n     * @static\n     * @returns {Address6}\n     */\n    static fromUnsignedByteArray(bytes) {\n        const BYTE_MAX = new jsbn_1.BigInteger('256', 10);\n        let result = new jsbn_1.BigInteger('0', 10);\n        let multiplier = new jsbn_1.BigInteger('1', 10);\n        for (let i = bytes.length - 1; i >= 0; i--) {\n            result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));\n            multiplier = multiplier.multiply(BYTE_MAX);\n        }\n        return Address6.fromBigInteger(result);\n    }\n    /**\n     * Returns true if the address is in the canonical form, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isCanonical() {\n        return this.addressMinusSuffix === this.canonicalForm();\n    }\n    /**\n     * Returns true if the address is a link local address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLinkLocal() {\n        // Zeroes are required, i.e. we can't check isInSubnet with 'fe80::/10'\n        if (this.getBitsBase2(0, 64) ===\n            '1111111010000000000000000000000000000000000000000000000000000000') {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Returns true if the address is a multicast address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isMulticast() {\n        return this.getType() === 'Multicast';\n    }\n    /**\n     * Returns true if the address is a v4-in-v6 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is4() {\n        return this.v4;\n    }\n    /**\n     * Returns true if the address is a Teredo address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isTeredo() {\n        return this.isInSubnet(new Address6('2001::/32'));\n    }\n    /**\n     * Returns true if the address is a 6to4 address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    is6to4() {\n        return this.isInSubnet(new Address6('2002::/16'));\n    }\n    /**\n     * Returns true if the address is a loopback address, false otherwise\n     * @memberof Address6\n     * @instance\n     * @returns {boolean}\n     */\n    isLoopback() {\n        return this.getType() === 'Loopback';\n    }\n    // #endregion\n    // #region HTML\n    /**\n     * @returns {String} the address in link form with a default port of 80\n     */\n    href(optionalPort) {\n        if (optionalPort === undefined) {\n            optionalPort = '';\n        }\n        else {\n            optionalPort = (0, sprintf_js_1.sprintf)(':%s', optionalPort);\n        }\n        return (0, sprintf_js_1.sprintf)('http://[%s]%s/', this.correctForm(), optionalPort);\n    }\n    /**\n     * @returns {String} a link suitable for conveying the address via a URL hash\n     */\n    link(options) {\n        if (!options) {\n            options = {};\n        }\n        if (options.className === undefined) {\n            options.className = '';\n        }\n        if (options.prefix === undefined) {\n            options.prefix = '/#address=';\n        }\n        if (options.v4 === undefined) {\n            options.v4 = false;\n        }\n        let formFunction = this.correctForm;\n        if (options.v4) {\n            formFunction = this.to4in6;\n        }\n        if (options.className) {\n            return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\" class=\"%3$s\">%2$s</a>', options.prefix, formFunction.call(this), options.className);\n        }\n        return (0, sprintf_js_1.sprintf)('<a href=\"%1$s%2$s\">%2$s</a>', options.prefix, formFunction.call(this));\n    }\n    /**\n     * Groups an address\n     * @returns {String}\n     */\n    group() {\n        if (this.elidedGroups === 0) {\n            // The simple case\n            return helpers.simpleGroup(this.address).join(':');\n        }\n        assert(typeof this.elidedGroups === 'number');\n        assert(typeof this.elisionBegin === 'number');\n        // The elided case\n        const output = [];\n        const [left, right] = this.address.split('::');\n        if (left.length) {\n            output.push(...helpers.simpleGroup(left));\n        }\n        else {\n            output.push('');\n        }\n        const classes = ['hover-group'];\n        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {\n            classes.push((0, sprintf_js_1.sprintf)('group-%d', i));\n        }\n        output.push((0, sprintf_js_1.sprintf)('<span class=\"%s\"></span>', classes.join(' ')));\n        if (right.length) {\n            output.push(...helpers.simpleGroup(right, this.elisionEnd));\n        }\n        else {\n            output.push('');\n        }\n        if (this.is4()) {\n            assert(this.address4 instanceof ipv4_1.Address4);\n            output.pop();\n            output.push(this.address4.groupForV6());\n        }\n        return output.join(':');\n    }\n    // #endregion\n    // #region Regular expressions\n    /**\n     * Generate a regular expression string that can be used to find or validate\n     * all variations of this address\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {string}\n     */\n    regularExpressionString(substringSearch = false) {\n        let output = [];\n        // TODO: revisit why this is necessary\n        const address6 = new Address6(this.correctForm());\n        if (address6.elidedGroups === 0) {\n            // The simple case\n            output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));\n        }\n        else if (address6.elidedGroups === constants6.GROUPS) {\n            // A completely elided address\n            output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));\n        }\n        else {\n            // A partially elided address\n            const halves = address6.address.split('::');\n            if (halves[0].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(':')));\n            }\n            assert(typeof address6.elidedGroups === 'number');\n            output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));\n            if (halves[1].length) {\n                output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(':')));\n            }\n            output = [output.join(':')];\n        }\n        if (!substringSearch) {\n            output = [\n                '(?=^|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|[^\\\\w\\\\:])(',\n                ...output,\n                ')(?=[^\\\\w\\\\:]|',\n                regular_expressions_1.ADDRESS_BOUNDARY,\n                '|$)',\n            ];\n        }\n        return output.join('');\n    }\n    /**\n     * Generate a regular expression that can be used to find or validate all\n     * variations of this address.\n     * @memberof Address6\n     * @instance\n     * @param {boolean} substringSearch\n     * @returns {RegExp}\n     */\n    regularExpression(substringSearch = false) {\n        return new RegExp(this.regularExpressionString(substringSearch), 'i');\n    }\n}\nexports.Address6 = Address6;\n//# sourceMappingURL=ipv6.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/ipv6.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/v4/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v4/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_SUBNET_STRING = exports.RE_ADDRESS = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 32;\nexports.GROUPS = 4;\nexports.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;\nexports.RE_SUBNET_STRING = /\\/\\d{1,2}$/;\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/v4/constants.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/v6/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/constants.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RE_URL_WITH_PORT = exports.RE_URL = exports.RE_ZONE_STRING = exports.RE_SUBNET_STRING = exports.RE_BAD_ADDRESS = exports.RE_BAD_CHARACTERS = exports.TYPES = exports.SCOPES = exports.GROUPS = exports.BITS = void 0;\nexports.BITS = 128;\nexports.GROUPS = 8;\n/**\n * Represents IPv6 address scopes\n * @memberof Address6\n * @static\n */\nexports.SCOPES = {\n    0: 'Reserved',\n    1: 'Interface local',\n    2: 'Link local',\n    4: 'Admin local',\n    5: 'Site local',\n    8: 'Organization local',\n    14: 'Global',\n    15: 'Reserved',\n};\n/**\n * Represents IPv6 address types\n * @memberof Address6\n * @static\n */\nexports.TYPES = {\n    'ff01::1/128': 'Multicast (All nodes on this interface)',\n    'ff01::2/128': 'Multicast (All routers on this interface)',\n    'ff02::1/128': 'Multicast (All nodes on this link)',\n    'ff02::2/128': 'Multicast (All routers on this link)',\n    'ff05::2/128': 'Multicast (All routers in this site)',\n    'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',\n    'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',\n    'ff02::9/128': 'Multicast (RIP routers)',\n    'ff02::a/128': 'Multicast (EIGRP routers)',\n    'ff02::d/128': 'Multicast (PIM routers)',\n    'ff02::16/128': 'Multicast (MLDv2 reports)',\n    'ff01::fb/128': 'Multicast (mDNSv6)',\n    'ff02::fb/128': 'Multicast (mDNSv6)',\n    'ff05::fb/128': 'Multicast (mDNSv6)',\n    'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',\n    'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',\n    'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',\n    'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',\n    '::/128': 'Unspecified',\n    '::1/128': 'Loopback',\n    'ff00::/8': 'Multicast',\n    'fe80::/10': 'Link-local unicast',\n};\n/**\n * A regular expression that matches bad characters in an IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;\n/**\n * A regular expression that matches an incorrect IPv6 address\n * @memberof Address6\n * @static\n */\nexports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\\/$)/gi;\n/**\n * A regular expression that matches an IPv6 subnet\n * @memberof Address6\n * @static\n */\nexports.RE_SUBNET_STRING = /\\/\\d{1,3}(?=%|$)/;\n/**\n * A regular expression that matches an IPv6 zone\n * @memberof Address6\n * @static\n */\nexports.RE_ZONE_STRING = /%.*$/;\nexports.RE_URL = new RegExp(/^\\[{0,1}([0-9a-f:]+)\\]{0,1}/);\nexports.RE_URL_WITH_PORT = new RegExp(/\\[([0-9a-f:]+)\\]:([0-9]{1,5})/);\n//# sourceMappingURL=constants.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/v6/constants.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/v6/helpers.js":
/*!****************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/helpers.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.simpleGroup = exports.spanLeadingZeroes = exports.spanAll = exports.spanAllZeroes = void 0;\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js\");\n/**\n * @returns {String} the string with all zeroes contained in a <span>\n */\nfunction spanAllZeroes(s) {\n    return s.replace(/(0+)/g, '<span class=\"zero\">$1</span>');\n}\nexports.spanAllZeroes = spanAllZeroes;\n/**\n * @returns {String} the string with each character contained in a <span>\n */\nfunction spanAll(s, offset = 0) {\n    const letters = s.split('');\n    return letters\n        .map((n, i) => (0, sprintf_js_1.sprintf)('<span class=\"digit value-%s position-%d\">%s</span>', n, i + offset, spanAllZeroes(n)) // XXX Use #base-2 .value-0 instead?\n    )\n        .join('');\n}\nexports.spanAll = spanAll;\nfunction spanLeadingZeroesSimple(group) {\n    return group.replace(/^(0+)/, '<span class=\"zero\">$1</span>');\n}\n/**\n * @returns {String} the string with leading zeroes contained in a <span>\n */\nfunction spanLeadingZeroes(address) {\n    const groups = address.split(':');\n    return groups.map((g) => spanLeadingZeroesSimple(g)).join(':');\n}\nexports.spanLeadingZeroes = spanLeadingZeroes;\n/**\n * Groups an address\n * @returns {String} a grouped address\n */\nfunction simpleGroup(addressString, offset = 0) {\n    const groups = addressString.split(':');\n    return groups.map((g, i) => {\n        if (/group-v4/.test(g)) {\n            return g;\n        }\n        return (0, sprintf_js_1.sprintf)('<span class=\"hover-group group-%d\">%s</span>', i + offset, spanLeadingZeroesSimple(g));\n    });\n}\nexports.simpleGroup = simpleGroup;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/v6/helpers.js?");

/***/ }),

/***/ "./node_modules/ip-address/dist/v6/regular-expressions.js":
/*!****************************************************************!*\
  !*** ./node_modules/ip-address/dist/v6/regular-expressions.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.possibleElisions = exports.simpleRegularExpression = exports.ADDRESS_BOUNDARY = exports.padGroup = exports.groupPossibilities = void 0;\nconst v6 = __importStar(__webpack_require__(/*! ./constants */ \"./node_modules/ip-address/dist/v6/constants.js\"));\nconst sprintf_js_1 = __webpack_require__(/*! sprintf-js */ \"./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js\");\nfunction groupPossibilities(possibilities) {\n    return (0, sprintf_js_1.sprintf)('(%s)', possibilities.join('|'));\n}\nexports.groupPossibilities = groupPossibilities;\nfunction padGroup(group) {\n    if (group.length < 4) {\n        return (0, sprintf_js_1.sprintf)('0{0,%d}%s', 4 - group.length, group);\n    }\n    return group;\n}\nexports.padGroup = padGroup;\nexports.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]';\nfunction simpleRegularExpression(groups) {\n    const zeroIndexes = [];\n    groups.forEach((group, i) => {\n        const groupInteger = parseInt(group, 16);\n        if (groupInteger === 0) {\n            zeroIndexes.push(i);\n        }\n    });\n    // You can technically elide a single 0, this creates the regular expressions\n    // to match that eventuality\n    const possibilities = zeroIndexes.map((zeroIndex) => groups\n        .map((group, i) => {\n        if (i === zeroIndex) {\n            const elision = i === 0 || i === v6.GROUPS - 1 ? ':' : '';\n            return groupPossibilities([padGroup(group), elision]);\n        }\n        return padGroup(group);\n    })\n        .join(':'));\n    // The simplest case\n    possibilities.push(groups.map(padGroup).join(':'));\n    return groupPossibilities(possibilities);\n}\nexports.simpleRegularExpression = simpleRegularExpression;\nfunction possibleElisions(elidedGroups, moreLeft, moreRight) {\n    const left = moreLeft ? '' : ':';\n    const right = moreRight ? '' : ':';\n    const possibilities = [];\n    // 1. elision of everything (::)\n    if (!moreLeft && !moreRight) {\n        possibilities.push('::');\n    }\n    // 2. complete elision of the middle\n    if (moreLeft && moreRight) {\n        possibilities.push('');\n    }\n    if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {\n        // 3. complete elision of one side\n        possibilities.push(':');\n    }\n    // 4. elision from the left side\n    possibilities.push((0, sprintf_js_1.sprintf)('%s(:0{1,4}){1,%d}', left, elidedGroups - 1));\n    // 5. elision from the right side\n    possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){1,%d}%s', elidedGroups - 1, right));\n    // 6. no elision\n    possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}0{1,4}', elidedGroups - 1));\n    // 7. elision (including sloppy elision) from the middle\n    for (let groups = 1; groups < elidedGroups - 1; groups++) {\n        for (let position = 1; position < elidedGroups - groups; position++) {\n            possibilities.push((0, sprintf_js_1.sprintf)('(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}', position, elidedGroups - position - groups - 1));\n        }\n    }\n    return groupPossibilities(possibilities);\n}\nexports.possibleElisions = possibleElisions;\n//# sourceMappingURL=regular-expressions.js.map\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/dist/v6/regular-expressions.js?");

/***/ }),

/***/ "./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js":
/*!************************************************************************!*\
  !*** ./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* global window, exports, define */\n\n!function() {\n    'use strict'\n\n    var re = {\n        not_string: /[^s]/,\n        not_bool: /[^t]/,\n        not_type: /[^T]/,\n        not_primitive: /[^v]/,\n        number: /[diefg]/,\n        numeric_arg: /[bcdiefguxX]/,\n        json: /[j]/,\n        not_json: /[^j]/,\n        text: /^[^\\x25]+/,\n        modulo: /^\\x25{2}/,\n        placeholder: /^\\x25(?:([1-9]\\d*)\\$|\\(([^)]+)\\))?(\\+)?(0|'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-gijostTuvxX])/,\n        key: /^([a-z_][a-z_\\d]*)/i,\n        key_access: /^\\.([a-z_][a-z_\\d]*)/i,\n        index_access: /^\\[(\\d+)\\]/,\n        sign: /^[+-]/\n    }\n\n    function sprintf(key) {\n        // `arguments` is not an array, but should be fine for this call\n        return sprintf_format(sprintf_parse(key), arguments)\n    }\n\n    function vsprintf(fmt, argv) {\n        return sprintf.apply(null, [fmt].concat(argv || []))\n    }\n\n    function sprintf_format(parse_tree, argv) {\n        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign\n        for (i = 0; i < tree_length; i++) {\n            if (typeof parse_tree[i] === 'string') {\n                output += parse_tree[i]\n            }\n            else if (typeof parse_tree[i] === 'object') {\n                ph = parse_tree[i] // convenience purposes only\n                if (ph.keys) { // keyword argument\n                    arg = argv[cursor]\n                    for (k = 0; k < ph.keys.length; k++) {\n                        if (arg == undefined) {\n                            throw new Error(sprintf('[sprintf] Cannot access property \"%s\" of undefined value \"%s\"', ph.keys[k], ph.keys[k-1]))\n                        }\n                        arg = arg[ph.keys[k]]\n                    }\n                }\n                else if (ph.param_no) { // positional argument (explicit)\n                    arg = argv[ph.param_no]\n                }\n                else { // positional argument (implicit)\n                    arg = argv[cursor++]\n                }\n\n                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {\n                    arg = arg()\n                }\n\n                if (re.numeric_arg.test(ph.type) && (typeof arg !== 'number' && isNaN(arg))) {\n                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg))\n                }\n\n                if (re.number.test(ph.type)) {\n                    is_positive = arg >= 0\n                }\n\n                switch (ph.type) {\n                    case 'b':\n                        arg = parseInt(arg, 10).toString(2)\n                        break\n                    case 'c':\n                        arg = String.fromCharCode(parseInt(arg, 10))\n                        break\n                    case 'd':\n                    case 'i':\n                        arg = parseInt(arg, 10)\n                        break\n                    case 'j':\n                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0)\n                        break\n                    case 'e':\n                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential()\n                        break\n                    case 'f':\n                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg)\n                        break\n                    case 'g':\n                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg)\n                        break\n                    case 'o':\n                        arg = (parseInt(arg, 10) >>> 0).toString(8)\n                        break\n                    case 's':\n                        arg = String(arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 't':\n                        arg = String(!!arg)\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'T':\n                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'u':\n                        arg = parseInt(arg, 10) >>> 0\n                        break\n                    case 'v':\n                        arg = arg.valueOf()\n                        arg = (ph.precision ? arg.substring(0, ph.precision) : arg)\n                        break\n                    case 'x':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16)\n                        break\n                    case 'X':\n                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase()\n                        break\n                }\n                if (re.json.test(ph.type)) {\n                    output += arg\n                }\n                else {\n                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {\n                        sign = is_positive ? '+' : '-'\n                        arg = arg.toString().replace(re.sign, '')\n                    }\n                    else {\n                        sign = ''\n                    }\n                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' '\n                    pad_length = ph.width - (sign + arg).length\n                    pad = ph.width ? (pad_length > 0 ? pad_character.repeat(pad_length) : '') : ''\n                    output += ph.align ? sign + arg + pad : (pad_character === '0' ? sign + pad + arg : pad + sign + arg)\n                }\n            }\n        }\n        return output\n    }\n\n    var sprintf_cache = Object.create(null)\n\n    function sprintf_parse(fmt) {\n        if (sprintf_cache[fmt]) {\n            return sprintf_cache[fmt]\n        }\n\n        var _fmt = fmt, match, parse_tree = [], arg_names = 0\n        while (_fmt) {\n            if ((match = re.text.exec(_fmt)) !== null) {\n                parse_tree.push(match[0])\n            }\n            else if ((match = re.modulo.exec(_fmt)) !== null) {\n                parse_tree.push('%')\n            }\n            else if ((match = re.placeholder.exec(_fmt)) !== null) {\n                if (match[2]) {\n                    arg_names |= 1\n                    var field_list = [], replacement_field = match[2], field_match = []\n                    if ((field_match = re.key.exec(replacement_field)) !== null) {\n                        field_list.push(field_match[1])\n                        while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {\n                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else if ((field_match = re.index_access.exec(replacement_field)) !== null) {\n                                field_list.push(field_match[1])\n                            }\n                            else {\n                                throw new SyntaxError('[sprintf] failed to parse named argument key')\n                            }\n                        }\n                    }\n                    else {\n                        throw new SyntaxError('[sprintf] failed to parse named argument key')\n                    }\n                    match[2] = field_list\n                }\n                else {\n                    arg_names |= 2\n                }\n                if (arg_names === 3) {\n                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')\n                }\n\n                parse_tree.push(\n                    {\n                        placeholder: match[0],\n                        param_no:    match[1],\n                        keys:        match[2],\n                        sign:        match[3],\n                        pad_char:    match[4],\n                        align:       match[5],\n                        width:       match[6],\n                        precision:   match[7],\n                        type:        match[8]\n                    }\n                )\n            }\n            else {\n                throw new SyntaxError('[sprintf] unexpected placeholder')\n            }\n            _fmt = _fmt.substring(match[0].length)\n        }\n        return sprintf_cache[fmt] = parse_tree\n    }\n\n    /**\n     * export to either browser or node.js\n     */\n    /* eslint-disable quote-props */\n    if (true) {\n        exports.sprintf = sprintf\n        exports.vsprintf = vsprintf\n    }\n    if (typeof window !== 'undefined') {\n        window['sprintf'] = sprintf\n        window['vsprintf'] = vsprintf\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return {\n                    'sprintf': sprintf,\n                    'vsprintf': vsprintf\n                }\n            }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n        }\n    }\n    /* eslint-enable quote-props */\n}(); // eslint-disable-line\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip-address/node_modules/sprintf-js/src/sprintf.js?");

/***/ }),

/***/ "./node_modules/jsbn/index.js":
/*!************************************!*\
  !*** ./node_modules/jsbn/index.js ***!
  \************************************/
/***/ (function(module, exports) {

eval("(function(){\n\n    // Copyright (c) 2005  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Basic JavaScript BN library - subset useful for RSA encryption.\n\n    // Bits per digit\n    var dbits;\n\n    // JavaScript engine analysis\n    var canary = 0xdeadbeefcafe;\n    var j_lm = ((canary&0xffffff)==0xefcafe);\n\n    // (public) Constructor\n    function BigInteger(a,b,c) {\n      if(a != null)\n        if(\"number\" == typeof a) this.fromNumber(a,b,c);\n        else if(b == null && \"string\" != typeof a) this.fromString(a,256);\n        else this.fromString(a,b);\n    }\n\n    // return new, unset BigInteger\n    function nbi() { return new BigInteger(null); }\n\n    // am: Compute w_j += (x*this_i), propagate carries,\n    // c is initial carry, returns final carry.\n    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n    // We need to select the fastest one that works in this environment.\n\n    // am1: use a single mult and divide to get the high bits,\n    // max digit bits should be 26 because\n    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n    function am1(i,x,w,j,c,n) {\n      while(--n >= 0) {\n        var v = x*this[i++]+w[j]+c;\n        c = Math.floor(v/0x4000000);\n        w[j++] = v&0x3ffffff;\n      }\n      return c;\n    }\n    // am2 avoids a big mult-and-extract completely.\n    // Max digit bits should be <= 30 because we do bitwise ops\n    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n    function am2(i,x,w,j,c,n) {\n      var xl = x&0x7fff, xh = x>>15;\n      while(--n >= 0) {\n        var l = this[i]&0x7fff;\n        var h = this[i++]>>15;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);\n        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);\n        w[j++] = l&0x3fffffff;\n      }\n      return c;\n    }\n    // Alternately, set max digit bits to 28 since some\n    // browsers slow down when dealing with 32-bit numbers.\n    function am3(i,x,w,j,c,n) {\n      var xl = x&0x3fff, xh = x>>14;\n      while(--n >= 0) {\n        var l = this[i]&0x3fff;\n        var h = this[i++]>>14;\n        var m = xh*l+h*xl;\n        l = xl*l+((m&0x3fff)<<14)+w[j]+c;\n        c = (l>>28)+(m>>14)+xh*h;\n        w[j++] = l&0xfffffff;\n      }\n      return c;\n    }\n    var inBrowser = typeof navigator !== \"undefined\";\n    if(inBrowser && j_lm && (navigator.appName == \"Microsoft Internet Explorer\")) {\n      BigInteger.prototype.am = am2;\n      dbits = 30;\n    }\n    else if(inBrowser && j_lm && (navigator.appName != \"Netscape\")) {\n      BigInteger.prototype.am = am1;\n      dbits = 26;\n    }\n    else { // Mozilla/Netscape seems to prefer am3\n      BigInteger.prototype.am = am3;\n      dbits = 28;\n    }\n\n    BigInteger.prototype.DB = dbits;\n    BigInteger.prototype.DM = ((1<<dbits)-1);\n    BigInteger.prototype.DV = (1<<dbits);\n\n    var BI_FP = 52;\n    BigInteger.prototype.FV = Math.pow(2,BI_FP);\n    BigInteger.prototype.F1 = BI_FP-dbits;\n    BigInteger.prototype.F2 = 2*dbits-BI_FP;\n\n    // Digit conversions\n    var BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n    var BI_RC = new Array();\n    var rr,vv;\n    rr = \"0\".charCodeAt(0);\n    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;\n    rr = \"a\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n    rr = \"A\".charCodeAt(0);\n    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;\n\n    function int2char(n) { return BI_RM.charAt(n); }\n    function intAt(s,i) {\n      var c = BI_RC[s.charCodeAt(i)];\n      return (c==null)?-1:c;\n    }\n\n    // (protected) copy this to r\n    function bnpCopyTo(r) {\n      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];\n      r.t = this.t;\n      r.s = this.s;\n    }\n\n    // (protected) set from integer value x, -DV <= x < DV\n    function bnpFromInt(x) {\n      this.t = 1;\n      this.s = (x<0)?-1:0;\n      if(x > 0) this[0] = x;\n      else if(x < -1) this[0] = x+this.DV;\n      else this.t = 0;\n    }\n\n    // return bigint initialized to value\n    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }\n\n    // (protected) set from string and radix\n    function bnpFromString(s,b) {\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 256) k = 8; // byte array\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else { this.fromRadix(s,b); return; }\n      this.t = 0;\n      this.s = 0;\n      var i = s.length, mi = false, sh = 0;\n      while(--i >= 0) {\n        var x = (k==8)?s[i]&0xff:intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\") mi = true;\n          continue;\n        }\n        mi = false;\n        if(sh == 0)\n          this[this.t++] = x;\n        else if(sh+k > this.DB) {\n          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;\n          this[this.t++] = (x>>(this.DB-sh));\n        }\n        else\n          this[this.t-1] |= x<<sh;\n        sh += k;\n        if(sh >= this.DB) sh -= this.DB;\n      }\n      if(k == 8 && (s[0]&0x80) != 0) {\n        this.s = -1;\n        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;\n      }\n      this.clamp();\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) clamp off excess high words\n    function bnpClamp() {\n      var c = this.s&this.DM;\n      while(this.t > 0 && this[this.t-1] == c) --this.t;\n    }\n\n    // (public) return string representation in given radix\n    function bnToString(b) {\n      if(this.s < 0) return \"-\"+this.negate().toString(b);\n      var k;\n      if(b == 16) k = 4;\n      else if(b == 8) k = 3;\n      else if(b == 2) k = 1;\n      else if(b == 32) k = 5;\n      else if(b == 4) k = 2;\n      else return this.toRadix(b);\n      var km = (1<<k)-1, d, m = false, r = \"\", i = this.t;\n      var p = this.DB-(i*this.DB)%k;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }\n        while(i >= 0) {\n          if(p < k) {\n            d = (this[i]&((1<<p)-1))<<(k-p);\n            d |= this[--i]>>(p+=this.DB-k);\n          }\n          else {\n            d = (this[i]>>(p-=k))&km;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if(d > 0) m = true;\n          if(m) r += int2char(d);\n        }\n      }\n      return m?r:\"0\";\n    }\n\n    // (public) -this\n    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }\n\n    // (public) |this|\n    function bnAbs() { return (this.s<0)?this.negate():this; }\n\n    // (public) return + if this > a, - if this < a, 0 if equal\n    function bnCompareTo(a) {\n      var r = this.s-a.s;\n      if(r != 0) return r;\n      var i = this.t;\n      r = i-a.t;\n      if(r != 0) return (this.s<0)?-r:r;\n      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;\n      return 0;\n    }\n\n    // returns bit length of the integer x\n    function nbits(x) {\n      var r = 1, t;\n      if((t=x>>>16) != 0) { x = t; r += 16; }\n      if((t=x>>8) != 0) { x = t; r += 8; }\n      if((t=x>>4) != 0) { x = t; r += 4; }\n      if((t=x>>2) != 0) { x = t; r += 2; }\n      if((t=x>>1) != 0) { x = t; r += 1; }\n      return r;\n    }\n\n    // (public) return the number of bits in \"this\"\n    function bnBitLength() {\n      if(this.t <= 0) return 0;\n      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));\n    }\n\n    // (protected) r = this << n*DB\n    function bnpDLShiftTo(n,r) {\n      var i;\n      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];\n      for(i = n-1; i >= 0; --i) r[i] = 0;\n      r.t = this.t+n;\n      r.s = this.s;\n    }\n\n    // (protected) r = this >> n*DB\n    function bnpDRShiftTo(n,r) {\n      for(var i = n; i < this.t; ++i) r[i-n] = this[i];\n      r.t = Math.max(this.t-n,0);\n      r.s = this.s;\n    }\n\n    // (protected) r = this << n\n    function bnpLShiftTo(n,r) {\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<cbs)-1;\n      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;\n      for(i = this.t-1; i >= 0; --i) {\n        r[i+ds+1] = (this[i]>>cbs)|c;\n        c = (this[i]&bm)<<bs;\n      }\n      for(i = ds-1; i >= 0; --i) r[i] = 0;\n      r[ds] = c;\n      r.t = this.t+ds+1;\n      r.s = this.s;\n      r.clamp();\n    }\n\n    // (protected) r = this >> n\n    function bnpRShiftTo(n,r) {\n      r.s = this.s;\n      var ds = Math.floor(n/this.DB);\n      if(ds >= this.t) { r.t = 0; return; }\n      var bs = n%this.DB;\n      var cbs = this.DB-bs;\n      var bm = (1<<bs)-1;\n      r[0] = this[ds]>>bs;\n      for(var i = ds+1; i < this.t; ++i) {\n        r[i-ds-1] |= (this[i]&bm)<<cbs;\n        r[i-ds] = this[i]>>bs;\n      }\n      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;\n      r.t = this.t-ds;\n      r.clamp();\n    }\n\n    // (protected) r = this - a\n    function bnpSubTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]-a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c -= a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c -= a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c -= a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c < -1) r[i++] = this.DV+c;\n      else if(c > 0) r[i++] = c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (protected) r = this * a, r != this,a (HAC 14.12)\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyTo(a,r) {\n      var x = this.abs(), y = a.abs();\n      var i = x.t;\n      r.t = i+y.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);\n      r.s = 0;\n      r.clamp();\n      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (protected) r = this^2, r != this (HAC 14.16)\n    function bnpSquareTo(r) {\n      var x = this.abs();\n      var i = r.t = 2*x.t;\n      while(--i >= 0) r[i] = 0;\n      for(i = 0; i < x.t-1; ++i) {\n        var c = x.am(i,x[i],r,2*i,0,1);\n        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {\n          r[i+x.t] -= x.DV;\n          r[i+x.t+1] = 1;\n        }\n      }\n      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);\n      r.s = 0;\n      r.clamp();\n    }\n\n    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n    // r != q, this != m.  q or r may be null.\n    function bnpDivRemTo(m,q,r) {\n      var pm = m.abs();\n      if(pm.t <= 0) return;\n      var pt = this.abs();\n      if(pt.t < pm.t) {\n        if(q != null) q.fromInt(0);\n        if(r != null) this.copyTo(r);\n        return;\n      }\n      if(r == null) r = nbi();\n      var y = nbi(), ts = this.s, ms = m.s;\n      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus\n      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }\n      else { pm.copyTo(y); pt.copyTo(r); }\n      var ys = y.t;\n      var y0 = y[ys-1];\n      if(y0 == 0) return;\n      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);\n      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;\n      var i = r.t, j = i-ys, t = (q==null)?nbi():q;\n      y.dlShiftTo(j,t);\n      if(r.compareTo(t) >= 0) {\n        r[r.t++] = 1;\n        r.subTo(t,r);\n      }\n      BigInteger.ONE.dlShiftTo(ys,t);\n      t.subTo(y,y);  // \"negative\" y so we can replace sub with am later\n      while(y.t < ys) y[y.t++] = 0;\n      while(--j >= 0) {\n        // Estimate quotient digit\n        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);\n        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out\n          y.dlShiftTo(j,t);\n          r.subTo(t,r);\n          while(r[i] < --qd) r.subTo(t,r);\n        }\n      }\n      if(q != null) {\n        r.drShiftTo(ys,q);\n        if(ts != ms) BigInteger.ZERO.subTo(q,q);\n      }\n      r.t = ys;\n      r.clamp();\n      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder\n      if(ts < 0) BigInteger.ZERO.subTo(r,r);\n    }\n\n    // (public) this mod a\n    function bnMod(a) {\n      var r = nbi();\n      this.abs().divRemTo(a,null,r);\n      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);\n      return r;\n    }\n\n    // Modular reduction using \"classic\" algorithm\n    function Classic(m) { this.m = m; }\n    function cConvert(x) {\n      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);\n      else return x;\n    }\n    function cRevert(x) { return x; }\n    function cReduce(x) { x.divRemTo(this.m,null,x); }\n    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    Classic.prototype.convert = cConvert;\n    Classic.prototype.revert = cRevert;\n    Classic.prototype.reduce = cReduce;\n    Classic.prototype.mulTo = cMulTo;\n    Classic.prototype.sqrTo = cSqrTo;\n\n    // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n    // justification:\n    //         xy == 1 (mod m)\n    //         xy =  1+km\n    //   xy(2-xy) = (1+km)(1-km)\n    // x[y(2-xy)] = 1-k^2m^2\n    // x[y(2-xy)] == 1 (mod m^2)\n    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n    // JS multiply \"overflows\" differently from C/C++, so care is needed here.\n    function bnpInvDigit() {\n      if(this.t < 1) return 0;\n      var x = this[0];\n      if((x&1) == 0) return 0;\n      var y = x&3;       // y == 1/x mod 2^2\n      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4\n      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8\n      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16\n      // last step - calculate inverse mod DV directly;\n      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits\n      // we really want the negative inverse, and -DV < y < DV\n      return (y>0)?this.DV-y:-y;\n    }\n\n    // Montgomery reduction\n    function Montgomery(m) {\n      this.m = m;\n      this.mp = m.invDigit();\n      this.mpl = this.mp&0x7fff;\n      this.mph = this.mp>>15;\n      this.um = (1<<(m.DB-15))-1;\n      this.mt2 = 2*m.t;\n    }\n\n    // xR mod m\n    function montConvert(x) {\n      var r = nbi();\n      x.abs().dlShiftTo(this.m.t,r);\n      r.divRemTo(this.m,null,r);\n      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);\n      return r;\n    }\n\n    // x/R mod m\n    function montRevert(x) {\n      var r = nbi();\n      x.copyTo(r);\n      this.reduce(r);\n      return r;\n    }\n\n    // x = x/R mod m (HAC 14.32)\n    function montReduce(x) {\n      while(x.t <= this.mt2) // pad x so am has enough room later\n        x[x.t++] = 0;\n      for(var i = 0; i < this.m.t; ++i) {\n        // faster way of calculating u0 = x[i]*mp mod DV\n        var j = x[i]&0x7fff;\n        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;\n        // use am to combine the multiply-shift-add into one call\n        j = i+this.m.t;\n        x[j] += this.m.am(0,u0,x,i,0,this.m.t);\n        // propagate carry\n        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }\n      }\n      x.clamp();\n      x.drShiftTo(this.m.t,x);\n      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = \"x^2/R mod m\"; x != r\n    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = \"xy/R mod m\"; x,y != r\n    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Montgomery.prototype.convert = montConvert;\n    Montgomery.prototype.revert = montRevert;\n    Montgomery.prototype.reduce = montReduce;\n    Montgomery.prototype.mulTo = montMulTo;\n    Montgomery.prototype.sqrTo = montSqrTo;\n\n    // (protected) true iff this is even\n    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }\n\n    // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n    function bnpExp(e,z) {\n      if(e > 0xffffffff || e < 1) return BigInteger.ONE;\n      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;\n      g.copyTo(r);\n      while(--i >= 0) {\n        z.sqrTo(r,r2);\n        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);\n        else { var t = r; r = r2; r2 = t; }\n      }\n      return z.revert(r);\n    }\n\n    // (public) this^e % m, 0 <= e < 2^32\n    function bnModPowInt(e,m) {\n      var z;\n      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);\n      return this.exp(e,z);\n    }\n\n    // protected\n    BigInteger.prototype.copyTo = bnpCopyTo;\n    BigInteger.prototype.fromInt = bnpFromInt;\n    BigInteger.prototype.fromString = bnpFromString;\n    BigInteger.prototype.clamp = bnpClamp;\n    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;\n    BigInteger.prototype.drShiftTo = bnpDRShiftTo;\n    BigInteger.prototype.lShiftTo = bnpLShiftTo;\n    BigInteger.prototype.rShiftTo = bnpRShiftTo;\n    BigInteger.prototype.subTo = bnpSubTo;\n    BigInteger.prototype.multiplyTo = bnpMultiplyTo;\n    BigInteger.prototype.squareTo = bnpSquareTo;\n    BigInteger.prototype.divRemTo = bnpDivRemTo;\n    BigInteger.prototype.invDigit = bnpInvDigit;\n    BigInteger.prototype.isEven = bnpIsEven;\n    BigInteger.prototype.exp = bnpExp;\n\n    // public\n    BigInteger.prototype.toString = bnToString;\n    BigInteger.prototype.negate = bnNegate;\n    BigInteger.prototype.abs = bnAbs;\n    BigInteger.prototype.compareTo = bnCompareTo;\n    BigInteger.prototype.bitLength = bnBitLength;\n    BigInteger.prototype.mod = bnMod;\n    BigInteger.prototype.modPowInt = bnModPowInt;\n\n    // \"constants\"\n    BigInteger.ZERO = nbv(0);\n    BigInteger.ONE = nbv(1);\n\n    // Copyright (c) 2005-2009  Tom Wu\n    // All Rights Reserved.\n    // See \"LICENSE\" for details.\n\n    // Extended JavaScript BN functions, required for RSA private ops.\n\n    // Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n    // Version 1.2: square() API, isProbablePrime fix\n\n    // (public)\n    function bnClone() { var r = nbi(); this.copyTo(r); return r; }\n\n    // (public) return value as integer\n    function bnIntValue() {\n      if(this.s < 0) {\n        if(this.t == 1) return this[0]-this.DV;\n        else if(this.t == 0) return -1;\n      }\n      else if(this.t == 1) return this[0];\n      else if(this.t == 0) return 0;\n      // assumes 16 < DB < 32\n      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];\n    }\n\n    // (public) return value as byte\n    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }\n\n    // (public) return value as short (assumes DB>=16)\n    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }\n\n    // (protected) return x s.t. r^x < DV\n    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }\n\n    // (public) 0 if this == 0, 1 if this > 0\n    function bnSigNum() {\n      if(this.s < 0) return -1;\n      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;\n      else return 1;\n    }\n\n    // (protected) convert to radix string\n    function bnpToRadix(b) {\n      if(b == null) b = 10;\n      if(this.signum() == 0 || b < 2 || b > 36) return \"0\";\n      var cs = this.chunkSize(b);\n      var a = Math.pow(b,cs);\n      var d = nbv(a), y = nbi(), z = nbi(), r = \"\";\n      this.divRemTo(d,y,z);\n      while(y.signum() > 0) {\n        r = (a+z.intValue()).toString(b).substr(1) + r;\n        y.divRemTo(d,y,z);\n      }\n      return z.intValue().toString(b) + r;\n    }\n\n    // (protected) convert from radix string\n    function bnpFromRadix(s,b) {\n      this.fromInt(0);\n      if(b == null) b = 10;\n      var cs = this.chunkSize(b);\n      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;\n      for(var i = 0; i < s.length; ++i) {\n        var x = intAt(s,i);\n        if(x < 0) {\n          if(s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n          continue;\n        }\n        w = b*w+x;\n        if(++j >= cs) {\n          this.dMultiply(d);\n          this.dAddOffset(w,0);\n          j = 0;\n          w = 0;\n        }\n      }\n      if(j > 0) {\n        this.dMultiply(Math.pow(b,j));\n        this.dAddOffset(w,0);\n      }\n      if(mi) BigInteger.ZERO.subTo(this,this);\n    }\n\n    // (protected) alternate constructor\n    function bnpFromNumber(a,b,c) {\n      if(\"number\" == typeof b) {\n        // new BigInteger(int,int,RNG)\n        if(a < 2) this.fromInt(1);\n        else {\n          this.fromNumber(a,c);\n          if(!this.testBit(a-1))    // force MSB set\n            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);\n          if(this.isEven()) this.dAddOffset(1,0); // force odd\n          while(!this.isProbablePrime(b)) {\n            this.dAddOffset(2,0);\n            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);\n          }\n        }\n      }\n      else {\n        // new BigInteger(int,RNG)\n        var x = new Array(), t = a&7;\n        x.length = (a>>3)+1;\n        b.nextBytes(x);\n        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;\n        this.fromString(x,256);\n      }\n    }\n\n    // (public) convert to bigendian byte array\n    function bnToByteArray() {\n      var i = this.t, r = new Array();\n      r[0] = this.s;\n      var p = this.DB-(i*this.DB)%8, d, k = 0;\n      if(i-- > 0) {\n        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)\n          r[k++] = d|(this.s<<(this.DB-p));\n        while(i >= 0) {\n          if(p < 8) {\n            d = (this[i]&((1<<p)-1))<<(8-p);\n            d |= this[--i]>>(p+=this.DB-8);\n          }\n          else {\n            d = (this[i]>>(p-=8))&0xff;\n            if(p <= 0) { p += this.DB; --i; }\n          }\n          if((d&0x80) != 0) d |= -256;\n          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;\n          if(k > 0 || d != this.s) r[k++] = d;\n        }\n      }\n      return r;\n    }\n\n    function bnEquals(a) { return(this.compareTo(a)==0); }\n    function bnMin(a) { return(this.compareTo(a)<0)?this:a; }\n    function bnMax(a) { return(this.compareTo(a)>0)?this:a; }\n\n    // (protected) r = this op a (bitwise)\n    function bnpBitwiseTo(a,op,r) {\n      var i, f, m = Math.min(a.t,this.t);\n      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);\n      if(a.t < this.t) {\n        f = a.s&this.DM;\n        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);\n        r.t = this.t;\n      }\n      else {\n        f = this.s&this.DM;\n        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);\n        r.t = a.t;\n      }\n      r.s = op(this.s,a.s);\n      r.clamp();\n    }\n\n    // (public) this & a\n    function op_and(x,y) { return x&y; }\n    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }\n\n    // (public) this | a\n    function op_or(x,y) { return x|y; }\n    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }\n\n    // (public) this ^ a\n    function op_xor(x,y) { return x^y; }\n    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }\n\n    // (public) this & ~a\n    function op_andnot(x,y) { return x&~y; }\n    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }\n\n    // (public) ~this\n    function bnNot() {\n      var r = nbi();\n      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];\n      r.t = this.t;\n      r.s = ~this.s;\n      return r;\n    }\n\n    // (public) this << n\n    function bnShiftLeft(n) {\n      var r = nbi();\n      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);\n      return r;\n    }\n\n    // (public) this >> n\n    function bnShiftRight(n) {\n      var r = nbi();\n      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);\n      return r;\n    }\n\n    // return index of lowest 1-bit in x, x < 2^31\n    function lbit(x) {\n      if(x == 0) return -1;\n      var r = 0;\n      if((x&0xffff) == 0) { x >>= 16; r += 16; }\n      if((x&0xff) == 0) { x >>= 8; r += 8; }\n      if((x&0xf) == 0) { x >>= 4; r += 4; }\n      if((x&3) == 0) { x >>= 2; r += 2; }\n      if((x&1) == 0) ++r;\n      return r;\n    }\n\n    // (public) returns index of lowest 1-bit (or -1 if none)\n    function bnGetLowestSetBit() {\n      for(var i = 0; i < this.t; ++i)\n        if(this[i] != 0) return i*this.DB+lbit(this[i]);\n      if(this.s < 0) return this.t*this.DB;\n      return -1;\n    }\n\n    // return number of 1 bits in x\n    function cbit(x) {\n      var r = 0;\n      while(x != 0) { x &= x-1; ++r; }\n      return r;\n    }\n\n    // (public) return number of set bits\n    function bnBitCount() {\n      var r = 0, x = this.s&this.DM;\n      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);\n      return r;\n    }\n\n    // (public) true iff nth bit is set\n    function bnTestBit(n) {\n      var j = Math.floor(n/this.DB);\n      if(j >= this.t) return(this.s!=0);\n      return((this[j]&(1<<(n%this.DB)))!=0);\n    }\n\n    // (protected) this op (1<<n)\n    function bnpChangeBit(n,op) {\n      var r = BigInteger.ONE.shiftLeft(n);\n      this.bitwiseTo(r,op,r);\n      return r;\n    }\n\n    // (public) this | (1<<n)\n    function bnSetBit(n) { return this.changeBit(n,op_or); }\n\n    // (public) this & ~(1<<n)\n    function bnClearBit(n) { return this.changeBit(n,op_andnot); }\n\n    // (public) this ^ (1<<n)\n    function bnFlipBit(n) { return this.changeBit(n,op_xor); }\n\n    // (protected) r = this + a\n    function bnpAddTo(a,r) {\n      var i = 0, c = 0, m = Math.min(a.t,this.t);\n      while(i < m) {\n        c += this[i]+a[i];\n        r[i++] = c&this.DM;\n        c >>= this.DB;\n      }\n      if(a.t < this.t) {\n        c += a.s;\n        while(i < this.t) {\n          c += this[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += this.s;\n      }\n      else {\n        c += this.s;\n        while(i < a.t) {\n          c += a[i];\n          r[i++] = c&this.DM;\n          c >>= this.DB;\n        }\n        c += a.s;\n      }\n      r.s = (c<0)?-1:0;\n      if(c > 0) r[i++] = c;\n      else if(c < -1) r[i++] = this.DV+c;\n      r.t = i;\n      r.clamp();\n    }\n\n    // (public) this + a\n    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }\n\n    // (public) this - a\n    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }\n\n    // (public) this * a\n    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }\n\n    // (public) this^2\n    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }\n\n    // (public) this / a\n    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }\n\n    // (public) this % a\n    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }\n\n    // (public) [this/a,this%a]\n    function bnDivideAndRemainder(a) {\n      var q = nbi(), r = nbi();\n      this.divRemTo(a,q,r);\n      return new Array(q,r);\n    }\n\n    // (protected) this *= n, this >= 0, 1 < n < DV\n    function bnpDMultiply(n) {\n      this[this.t] = this.am(0,n-1,this,0,0,this.t);\n      ++this.t;\n      this.clamp();\n    }\n\n    // (protected) this += n << w words, this >= 0\n    function bnpDAddOffset(n,w) {\n      if(n == 0) return;\n      while(this.t <= w) this[this.t++] = 0;\n      this[w] += n;\n      while(this[w] >= this.DV) {\n        this[w] -= this.DV;\n        if(++w >= this.t) this[this.t++] = 0;\n        ++this[w];\n      }\n    }\n\n    // A \"null\" reducer\n    function NullExp() {}\n    function nNop(x) { return x; }\n    function nMulTo(x,y,r) { x.multiplyTo(y,r); }\n    function nSqrTo(x,r) { x.squareTo(r); }\n\n    NullExp.prototype.convert = nNop;\n    NullExp.prototype.revert = nNop;\n    NullExp.prototype.mulTo = nMulTo;\n    NullExp.prototype.sqrTo = nSqrTo;\n\n    // (public) this^e\n    function bnPow(e) { return this.exp(e,new NullExp()); }\n\n    // (protected) r = lower n words of \"this * a\", a.t <= n\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyLowerTo(a,n,r) {\n      var i = Math.min(this.t+a.t,n);\n      r.s = 0; // assumes a,this >= 0\n      r.t = i;\n      while(i > 0) r[--i] = 0;\n      var j;\n      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);\n      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);\n      r.clamp();\n    }\n\n    // (protected) r = \"this * a\" without lower n words, n > 0\n    // \"this\" should be the larger one if appropriate.\n    function bnpMultiplyUpperTo(a,n,r) {\n      --n;\n      var i = r.t = this.t+a.t-n;\n      r.s = 0; // assumes a,this >= 0\n      while(--i >= 0) r[i] = 0;\n      for(i = Math.max(n-this.t,0); i < a.t; ++i)\n        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);\n      r.clamp();\n      r.drShiftTo(1,r);\n    }\n\n    // Barrett modular reduction\n    function Barrett(m) {\n      // setup Barrett\n      this.r2 = nbi();\n      this.q3 = nbi();\n      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);\n      this.mu = this.r2.divide(m);\n      this.m = m;\n    }\n\n    function barrettConvert(x) {\n      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);\n      else if(x.compareTo(this.m) < 0) return x;\n      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }\n    }\n\n    function barrettRevert(x) { return x; }\n\n    // x = x mod m (HAC 14.42)\n    function barrettReduce(x) {\n      x.drShiftTo(this.m.t-1,this.r2);\n      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }\n      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);\n      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);\n      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);\n      x.subTo(this.r2,x);\n      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);\n    }\n\n    // r = x^2 mod m; x != r\n    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }\n\n    // r = x*y mod m; x,y != r\n    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }\n\n    Barrett.prototype.convert = barrettConvert;\n    Barrett.prototype.revert = barrettRevert;\n    Barrett.prototype.reduce = barrettReduce;\n    Barrett.prototype.mulTo = barrettMulTo;\n    Barrett.prototype.sqrTo = barrettSqrTo;\n\n    // (public) this^e % m (HAC 14.85)\n    function bnModPow(e,m) {\n      var i = e.bitLength(), k, r = nbv(1), z;\n      if(i <= 0) return r;\n      else if(i < 18) k = 1;\n      else if(i < 48) k = 3;\n      else if(i < 144) k = 4;\n      else if(i < 768) k = 5;\n      else k = 6;\n      if(i < 8)\n        z = new Classic(m);\n      else if(m.isEven())\n        z = new Barrett(m);\n      else\n        z = new Montgomery(m);\n\n      // precomputation\n      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;\n      g[1] = z.convert(this);\n      if(k > 1) {\n        var g2 = nbi();\n        z.sqrTo(g[1],g2);\n        while(n <= km) {\n          g[n] = nbi();\n          z.mulTo(g2,g[n-2],g[n]);\n          n += 2;\n        }\n      }\n\n      var j = e.t-1, w, is1 = true, r2 = nbi(), t;\n      i = nbits(e[j])-1;\n      while(j >= 0) {\n        if(i >= k1) w = (e[j]>>(i-k1))&km;\n        else {\n          w = (e[j]&((1<<(i+1))-1))<<(k1-i);\n          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);\n        }\n\n        n = k;\n        while((w&1) == 0) { w >>= 1; --n; }\n        if((i -= n) < 0) { i += this.DB; --j; }\n        if(is1) {    // ret == 1, don't bother squaring or multiplying it\n          g[w].copyTo(r);\n          is1 = false;\n        }\n        else {\n          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }\n          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }\n          z.mulTo(r2,g[w],r);\n        }\n\n        while(j >= 0 && (e[j]&(1<<i)) == 0) {\n          z.sqrTo(r,r2); t = r; r = r2; r2 = t;\n          if(--i < 0) { i = this.DB-1; --j; }\n        }\n      }\n      return z.revert(r);\n    }\n\n    // (public) gcd(this,a) (HAC 14.54)\n    function bnGCD(a) {\n      var x = (this.s<0)?this.negate():this.clone();\n      var y = (a.s<0)?a.negate():a.clone();\n      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }\n      var i = x.getLowestSetBit(), g = y.getLowestSetBit();\n      if(g < 0) return x;\n      if(i < g) g = i;\n      if(g > 0) {\n        x.rShiftTo(g,x);\n        y.rShiftTo(g,y);\n      }\n      while(x.signum() > 0) {\n        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);\n        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);\n        if(x.compareTo(y) >= 0) {\n          x.subTo(y,x);\n          x.rShiftTo(1,x);\n        }\n        else {\n          y.subTo(x,y);\n          y.rShiftTo(1,y);\n        }\n      }\n      if(g > 0) y.lShiftTo(g,y);\n      return y;\n    }\n\n    // (protected) this % n, n < 2^26\n    function bnpModInt(n) {\n      if(n <= 0) return 0;\n      var d = this.DV%n, r = (this.s<0)?n-1:0;\n      if(this.t > 0)\n        if(d == 0) r = this[0]%n;\n        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;\n      return r;\n    }\n\n    // (public) 1/this % m (HAC 14.61)\n    function bnModInverse(m) {\n      var ac = m.isEven();\n      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;\n      var u = m.clone(), v = this.clone();\n      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);\n      while(u.signum() != 0) {\n        while(u.isEven()) {\n          u.rShiftTo(1,u);\n          if(ac) {\n            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }\n            a.rShiftTo(1,a);\n          }\n          else if(!b.isEven()) b.subTo(m,b);\n          b.rShiftTo(1,b);\n        }\n        while(v.isEven()) {\n          v.rShiftTo(1,v);\n          if(ac) {\n            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }\n            c.rShiftTo(1,c);\n          }\n          else if(!d.isEven()) d.subTo(m,d);\n          d.rShiftTo(1,d);\n        }\n        if(u.compareTo(v) >= 0) {\n          u.subTo(v,u);\n          if(ac) a.subTo(c,a);\n          b.subTo(d,b);\n        }\n        else {\n          v.subTo(u,v);\n          if(ac) c.subTo(a,c);\n          d.subTo(b,d);\n        }\n      }\n      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n      if(d.compareTo(m) >= 0) return d.subtract(m);\n      if(d.signum() < 0) d.addTo(m,d); else return d;\n      if(d.signum() < 0) return d.add(m); else return d;\n    }\n\n    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];\n    var lplim = (1<<26)/lowprimes[lowprimes.length-1];\n\n    // (public) test primality with certainty >= 1-.5^t\n    function bnIsProbablePrime(t) {\n      var i, x = this.abs();\n      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {\n        for(i = 0; i < lowprimes.length; ++i)\n          if(x[0] == lowprimes[i]) return true;\n        return false;\n      }\n      if(x.isEven()) return false;\n      i = 1;\n      while(i < lowprimes.length) {\n        var m = lowprimes[i], j = i+1;\n        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];\n        m = x.modInt(m);\n        while(i < j) if(m%lowprimes[i++] == 0) return false;\n      }\n      return x.millerRabin(t);\n    }\n\n    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n    function bnpMillerRabin(t) {\n      var n1 = this.subtract(BigInteger.ONE);\n      var k = n1.getLowestSetBit();\n      if(k <= 0) return false;\n      var r = n1.shiftRight(k);\n      t = (t+1)>>1;\n      if(t > lowprimes.length) t = lowprimes.length;\n      var a = nbi();\n      for(var i = 0; i < t; ++i) {\n        //Pick bases at random, instead of starting at 2\n        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);\n        var y = a.modPow(r,this);\n        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n          var j = 1;\n          while(j++ < k && y.compareTo(n1) != 0) {\n            y = y.modPowInt(2,this);\n            if(y.compareTo(BigInteger.ONE) == 0) return false;\n          }\n          if(y.compareTo(n1) != 0) return false;\n        }\n      }\n      return true;\n    }\n\n    // protected\n    BigInteger.prototype.chunkSize = bnpChunkSize;\n    BigInteger.prototype.toRadix = bnpToRadix;\n    BigInteger.prototype.fromRadix = bnpFromRadix;\n    BigInteger.prototype.fromNumber = bnpFromNumber;\n    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;\n    BigInteger.prototype.changeBit = bnpChangeBit;\n    BigInteger.prototype.addTo = bnpAddTo;\n    BigInteger.prototype.dMultiply = bnpDMultiply;\n    BigInteger.prototype.dAddOffset = bnpDAddOffset;\n    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\n    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\n    BigInteger.prototype.modInt = bnpModInt;\n    BigInteger.prototype.millerRabin = bnpMillerRabin;\n\n    // public\n    BigInteger.prototype.clone = bnClone;\n    BigInteger.prototype.intValue = bnIntValue;\n    BigInteger.prototype.byteValue = bnByteValue;\n    BigInteger.prototype.shortValue = bnShortValue;\n    BigInteger.prototype.signum = bnSigNum;\n    BigInteger.prototype.toByteArray = bnToByteArray;\n    BigInteger.prototype.equals = bnEquals;\n    BigInteger.prototype.min = bnMin;\n    BigInteger.prototype.max = bnMax;\n    BigInteger.prototype.and = bnAnd;\n    BigInteger.prototype.or = bnOr;\n    BigInteger.prototype.xor = bnXor;\n    BigInteger.prototype.andNot = bnAndNot;\n    BigInteger.prototype.not = bnNot;\n    BigInteger.prototype.shiftLeft = bnShiftLeft;\n    BigInteger.prototype.shiftRight = bnShiftRight;\n    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\n    BigInteger.prototype.bitCount = bnBitCount;\n    BigInteger.prototype.testBit = bnTestBit;\n    BigInteger.prototype.setBit = bnSetBit;\n    BigInteger.prototype.clearBit = bnClearBit;\n    BigInteger.prototype.flipBit = bnFlipBit;\n    BigInteger.prototype.add = bnAdd;\n    BigInteger.prototype.subtract = bnSubtract;\n    BigInteger.prototype.multiply = bnMultiply;\n    BigInteger.prototype.divide = bnDivide;\n    BigInteger.prototype.remainder = bnRemainder;\n    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\n    BigInteger.prototype.modPow = bnModPow;\n    BigInteger.prototype.modInverse = bnModInverse;\n    BigInteger.prototype.pow = bnPow;\n    BigInteger.prototype.gcd = bnGCD;\n    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;\n\n    // JSBN-specific extension\n    BigInteger.prototype.square = bnSquare;\n\n    // Expose the Barrett function\n    BigInteger.prototype.Barrett = Barrett\n\n    // BigInteger interfaces not implemented in jsbn:\n\n    // BigInteger(int signum, byte[] magnitude)\n    // double doubleValue()\n    // float floatValue()\n    // int hashCode()\n    // long longValue()\n    // static BigInteger valueOf(long val)\n\n    // Random number generator - requires a PRNG backend, e.g. prng4.js\n\n    // For best results, put code like\n    // <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>\n    // in your main HTML document.\n\n    var rng_state;\n    var rng_pool;\n    var rng_pptr;\n\n    // Mix in a 32-bit integer into the pool\n    function rng_seed_int(x) {\n      rng_pool[rng_pptr++] ^= x & 255;\n      rng_pool[rng_pptr++] ^= (x >> 8) & 255;\n      rng_pool[rng_pptr++] ^= (x >> 16) & 255;\n      rng_pool[rng_pptr++] ^= (x >> 24) & 255;\n      if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;\n    }\n\n    // Mix in the current time (w/milliseconds) into the pool\n    function rng_seed_time() {\n      rng_seed_int(new Date().getTime());\n    }\n\n    // Initialize the pool with junk if needed.\n    if(rng_pool == null) {\n      rng_pool = new Array();\n      rng_pptr = 0;\n      var t;\n      if(typeof window !== \"undefined\" && window.crypto) {\n        if (window.crypto.getRandomValues) {\n          // Use webcrypto if available\n          var ua = new Uint8Array(32);\n          window.crypto.getRandomValues(ua);\n          for(t = 0; t < 32; ++t)\n            rng_pool[rng_pptr++] = ua[t];\n        }\n        else if(navigator.appName == \"Netscape\" && navigator.appVersion < \"5\") {\n          // Extract entropy (256 bits) from NS4 RNG if available\n          var z = window.crypto.random(32);\n          for(t = 0; t < z.length; ++t)\n            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;\n        }\n      }\n      while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()\n        t = Math.floor(65536 * Math.random());\n        rng_pool[rng_pptr++] = t >>> 8;\n        rng_pool[rng_pptr++] = t & 255;\n      }\n      rng_pptr = 0;\n      rng_seed_time();\n      //rng_seed_int(window.screenX);\n      //rng_seed_int(window.screenY);\n    }\n\n    function rng_get_byte() {\n      if(rng_state == null) {\n        rng_seed_time();\n        rng_state = prng_newstate();\n        rng_state.init(rng_pool);\n        for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)\n          rng_pool[rng_pptr] = 0;\n        rng_pptr = 0;\n        //rng_pool = null;\n      }\n      // TODO: allow reseeding after first request\n      return rng_state.next();\n    }\n\n    function rng_get_bytes(ba) {\n      var i;\n      for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();\n    }\n\n    function SecureRandom() {}\n\n    SecureRandom.prototype.nextBytes = rng_get_bytes;\n\n    // prng4.js - uses Arcfour as a PRNG\n\n    function Arcfour() {\n      this.i = 0;\n      this.j = 0;\n      this.S = new Array();\n    }\n\n    // Initialize arcfour context from key, an array of ints, each from [0..255]\n    function ARC4init(key) {\n      var i, j, t;\n      for(i = 0; i < 256; ++i)\n        this.S[i] = i;\n      j = 0;\n      for(i = 0; i < 256; ++i) {\n        j = (j + this.S[i] + key[i % key.length]) & 255;\n        t = this.S[i];\n        this.S[i] = this.S[j];\n        this.S[j] = t;\n      }\n      this.i = 0;\n      this.j = 0;\n    }\n\n    function ARC4next() {\n      var t;\n      this.i = (this.i + 1) & 255;\n      this.j = (this.j + this.S[this.i]) & 255;\n      t = this.S[this.i];\n      this.S[this.i] = this.S[this.j];\n      this.S[this.j] = t;\n      return this.S[(t + this.S[this.i]) & 255];\n    }\n\n    Arcfour.prototype.init = ARC4init;\n    Arcfour.prototype.next = ARC4next;\n\n    // Plug in your RNG constructor here\n    function prng_newstate() {\n      return new Arcfour();\n    }\n\n    // Pool size must be a multiple of 4 and greater than 32.\n    // An array of bytes the size of the pool will be passed to init()\n    var rng_psize = 256;\n\n    if (true) {\n        exports = module.exports = {\n            default: BigInteger,\n            BigInteger: BigInteger,\n            SecureRandom: SecureRandom,\n        };\n    } else {}\n\n}).call(this);\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/jsbn/index.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\"\n                   && __webpack_require__.g\n                   && __webpack_require__.g.process\n                   && __webpack_require__.g.process.versions\n                   && __webpack_require__.g.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && __webpack_require__.g\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./src/address-util.js":
/*!*****************************!*\
  !*** ./src/address-util.js ***!
  \*****************************/
/***/ ((module) => {

eval("// Convert a buffer to a MAC address string\nfunction convertBufferToMacAddress(buffer) {\n\tif (!buffer) {\n\t\treturn buffer;\n\t}\n\n\tconst bytes = Array.from(buffer);\n\treturn bytes.map(byte => byte.toString(16).padStart(2, '0')).join(':');\n}\n\nmodule.exports = {\n\tconvertBufferToMacAddress\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/address-util.js?");

/***/ }),

/***/ "./src/cellular-device.js":
/*!********************************!*\
  !*** ./src/cellular-device.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\n/**\n * Cellular device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CellularDevice = base => class extends base {\n\t/**\n\t * Get ICCID of the active SIM card, and the IMEI of the cell radio.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 5.8.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Object>}\n\t */\n\tasync getCellularInfo({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.CELLULAR_GET_ICCID, null /* msg */, { timeout });\n\t\treturn {\n\t\t\ticcid: r.iccid,\n\t\t\timei: r.imei\n\t\t};\n\t}\n\n\t/**\n\t * Get ICCID of the active SIM card\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getIccid({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.CELLULAR_GET_ICCID, null /* msg */, { timeout });\n\t\treturn r.iccid;\n\t}\n\n\t/**\n\t * Set to `true` if this is a cellular device.\n\t */\n\tget isCellularDevice() {\n\t\treturn true;\n\t}\n};\n\nmodule.exports = {\n\tCellularDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cellular-device.js?");

/***/ }),

/***/ "./src/cloud-device.js":
/*!*****************************!*\
  !*** ./src/cloud-device.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst usbProto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { definitions: proto } = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\n\n/**\n * Cloud connection status.\n *\n * @enum {String}\n */\nconst CloudConnectionStatus = fromProtobufEnum(proto.cloud.ConnectionStatus, {\n\t/** Disconnected. */\n\tDISCONNECTED: 'DISCONNECTED',\n\t/** Connecting. */\n\tCONNECTING: 'CONNECTING',\n\t/** Connected. */\n\tCONNECTED: 'CONNECTED',\n\t/** Disconnecting. */\n\tDISCONNECTING: 'DISCONNECTING'\n});\n\n/**\n * Server protocol types.\n *\n * @enum {String}\n */\nconst ServerProtocol = fromProtobufEnum(proto.ServerProtocolType, {\n\t/** TCP. */\n\tTCP: 'TCP_PROTOCOL',\n\t/** UDP. */\n\tUDP: 'UDP_PROTOCOL'\n});\n\n/**\n * Cloud-enabled device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CloudDevice = base => class extends base {\n\t/**\n\t * Connect to the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually connect to the cloud and\n\t *        return immediately.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync connectToCloud({ dontWait = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(Request.CLOUD_CONNECT);\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(Request.CLOUD_STATUS);\n\t\t\t\t\tif (r.status === proto.cloud.ConnectionStatus.CONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Disconnect from the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually disconnect from the cloud\n\t *        and return immediately.\n\t * @param {Boolean} [options.force] Disconnect immediately, even if the device is busy performing\n\t *        some operation with the cloud.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync disconnectFromCloud({ dontWait = false, force = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (force) {\n\t\t\tconst setup = {\n\t\t\t\tbmRequestType: usbProto.BmRequestType.HOST_TO_DEVICE,\n\t\t\t\tbRequest: usbProto.PARTICLE_BREQUEST,\n\t\t\t\twIndex: Request.CLOUD_DISCONNECT.id,\n\t\t\t\twValue: 0\n\t\t\t};\n\t\t\tawait this.usbDevice.transferOut(setup);\n\t\t\tif (dontWait) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tif (!force) {\n\t\t\t\tawait s.sendRequest(Request.CLOUD_DISCONNECT);\n\t\t\t}\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(Request.CLOUD_STATUS);\n\t\t\t\t\tif (r.status === proto.cloud.ConnectionStatus.DISCONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the cloud connection status.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<CloudConnectionStatus>}\n\t */\n\tasync getCloudConnectionStatus({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.CLOUD_STATUS, null /* msg */, { timeout });\n\t\treturn CloudConnectionStatus.fromProtobuf(r.status);\n\t}\n\n\t/**\n\t * Set the claim code.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {String} code Claim code.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tsetClaimCode(code, { timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.SET_CLAIM_CODE, { code }, { timeout });\n\t}\n\n\t/**\n\t * Check if the device is claimed.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Boolean>}\n\t */\n\tisClaimed({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.IS_CLAIMED, null /* msg */, { timeout }).then(rep => rep.claimed);\n\t}\n\n\t/**\n\t * Set the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePrivateKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PRIVATE_KEY : proto.SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePrivateKey(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PRIVATE_KEY : proto.SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PUBLIC_KEY : proto.SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PUBLIC_KEY : proto.SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_SERVER_PUBLIC_KEY : proto.SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_SERVER_PUBLIC_KEY : proto.SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} data Host address.\n\t * @param {Number} port Port number.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerAddress(address, port, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(Request.SET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol,\n\t\t\t\taddress: address,\n\t\t\t\tport: port // TODO: Make port number optional\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Object>}\n\t */\n\tgetServerAddress(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(Request.GET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} protocol Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerProtocol(protocol) {\n\t\treturn this.sendRequest(Request.SET_SERVER_PROTOCOL, {\n\t\t\tprotocol: ServerProtocol.toProtobuf(protocol)\n\t\t});\n\t}\n\n\t/**\n\t * Get the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetServerProtocol() {\n\t\treturn this._getServerProtocol().then(protocol => ServerProtocol.fromProtobuf(protocol));\n\t}\n\n\t_setSecurityKey(type, data) {\n\t\treturn this.sendRequest(Request.SET_SECURITY_KEY, { type: type, data: data });\n\t}\n\n\t_getSecurityKey(type) {\n\t\treturn this.sendRequest(Request.GET_SECURITY_KEY, { type: type }).then(rep => rep.data);\n\t}\n\n\t_getServerProtocol(protocol) {\n\t\tif (protocol) {\n\t\t\treturn Promise.resolve(ServerProtocol.toProtobuf(protocol));\n\t\t}\n\t\treturn this.sendRequest(Request.GET_SERVER_PROTOCOL).then(rep => rep.protocol);\n\t}\n};\n\nmodule.exports = {\n\tCloudConnectionStatus,\n\tServerProtocol,\n\tCloudDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cloud-device.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((module) => {

eval("// Global configuration\nconst globalOptions = {\n\t// Request timeout\n\trequestTimeout: 60000,\n\t// Logger instance\n\tlog: {\n\t\ttrace: () => {},\n\t\tinfo: () => {},\n\t\twarn: () => {},\n\t\terror: () => {}\n\t}\n};\n\n/**\n * Set global options.\n *\n * @param {Object} [options] Options.\n * @param {Number} [options.requestTimeout=60000] Default request timeout (milliseconds).\n * @param {Object} [options.log] Logger instance. The logger is expected to have the following methods:\n *                 `trace(String)`, `info(String)`, `warn(String)`, `error(String)`.\n * @return {Object} Current options.\n */\nfunction config(options) {\n\treturn Object.assign(globalOptions, options);\n}\n\nmodule.exports = {\n\tglobalOptions,\n\tconfig\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/config.js?");

/***/ }),

/***/ "./src/device-base.js":
/*!****************************!*\
  !*** ./src/device-base.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { getUsbDevices, UsbDevice, MAX_CONTROL_TRANSFER_DATA_SIZE } = __webpack_require__(/*! ./usb-device-node */ \"./src/usb-device-webusb.js\");\nconst proto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { PLATFORMS } = __webpack_require__(/*! ./platforms */ \"./src/platforms.js\");\nconst { DeviceError, NotFoundError, StateError, TimeoutError, MemoryError, ProtocolError, NotAllowedError, assert } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { Dfu } = __webpack_require__(/*! ./dfu */ \"./src/dfu.js\");\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\n// Platforms arranged by vendor/product IDs\nconst PLATFORM_USB_IDS = PLATFORMS.reduce((obj, platform) => {\n\tconst addMapping = (obj, { vendorId, productId, quirks }, dfu) => {\n\t\tif (!vendorId) {\n\t\t\treturn;\n\t\t}\n\t\tif (!obj[vendorId]) {\n\t\t\tobj[vendorId] = {};\n\t\t}\n\t\tobj[vendorId][productId] = {\n\t\t\ttype: platform.name,\n\t\t\tid: platform.id,\n\t\t\tvendorId,\n\t\t\tproductId,\n\t\t\tdfu,\n\t\t\tquirks\n\t\t};\n\t};\n\n\tif (platform.usb) {\n\t\taddMapping(obj, platform.usb, false);\n\t}\n\tif (platform.dfu) {\n\t\taddMapping(obj, platform.dfu, true);\n\t}\n\treturn obj;\n}, {});\n\nfunction platformForUsbIds(vendorId, productId) {\n\treturn (PLATFORM_USB_IDS[vendorId] || {})[productId];\n}\n\n// Default backoff intervals for the CHECK service request\nconst DEFAULT_CHECK_INTERVALS = [50, 50, 100, 100, 250, 250, 500, 500, 1000];\n\nfunction checkInterval(attempts, intervals) {\n\tif (attempts < intervals.length) {\n\t\treturn intervals[attempts];\n\t}\n\treturn intervals[intervals.length - 1];\n}\n\n/**\n * Predefined polling policies.\n *\n * @enum {Function}\n */\nconst PollingPolicy = {\n\t/** Default polling policy. */\n\tDEFAULT: n => checkInterval(n, DEFAULT_CHECK_INTERVALS)\n};\n\n// Device state\nconst DeviceState = {\n\tCLOSED: 0,\n\tOPENING: 1,\n\tOPEN: 2,\n\tCLOSING: 3\n};\n\n// Low-level vendor requests as defined by the firmware's ctrl_request_type enum\nconst VendorRequest = {\n\tSYSTEM_VERSION: 30 // Get system version\n};\n\n// Dummy callback function\nfunction ignore() {\n}\n\n/**\n * Base class for a Particle USB device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass DeviceBase extends EventEmitter {\n\tconstructor(dev, info) {\n\t\tsuper();\n\t\tthis._dev = dev; // USB device handle\n\t\tthis._info = info; // Device info\n\t\tthis._log = globalOptions.log; // Logger instance\n\t\tthis._state = DeviceState.CLOSED; // Device state\n\t\tthis._reqs = new Map(); // All known requests\n\t\tthis._reqQueue = []; // Unprocessed requests\n\t\tthis._checkQueue = []; // Active requests that need to be checked\n\t\tthis._resetQueue = []; // Active requests that need to be reset\n\t\tthis._activeReqs = 0; // Number of active requests\n\t\tthis._maxActiveReqs = null; // Maximum number of active requests\n\t\tthis._lastReqId = 0; // Last used request ID\n\t\tthis._closeTimer = null; // Timer for the closing operation\n\t\tthis._wantClose = false; // Set to true if the device needs to be closed\n\t\tthis._resetAllReqs = false; // Set to true if all requests need to be reset\n\t\tthis._busy = false; // Set to true if there's an activity on the USB connection\n\t\tthis._fwVer = null; // Firmware version\n\t\tthis._id = null; // Device ID\n\t\tthis._dfu = null; // DFU class implementation\n\t\t// Whether the device supports all the expected USB control requests. A device without such support\n\t\t// can only be opened/closed but we still want it to be discoverable as a Particle device\n\t\tthis._supported = !this._info.quirks.controlRequestsNotSupported;\n\t}\n\n\t/**\n\t * Open the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.concurrentRequests] Maximum number of requests that can be sent to the\n\t *        device concurrently. Requests that exceed this limit are queued. By default, this parameter\n\t *        is set to the maximum number of concurrent requests supported by the device.\n\t * @return {Promise}\n\t */\n\topen(options) {\n\t\t// Apply device quirks\n\t\tthis._dev.quirks = this._info.quirks;\n\n\t\toptions = Object.assign({\n\t\t\tconcurrentRequests: null // The maximum number of concurrent requests is limited by the device\n\t\t}, options);\n\t\tif (this._state !== DeviceState.CLOSED) {\n\t\t\treturn Promise.reject(new StateError('Device is already open'));\n\t\t}\n\t\t// Open USB device\n\t\tthis._log.trace('Opening device');\n\t\tthis._state = DeviceState.OPENING;\n\t\tlet devOpen = false;\n\t\treturn this._dev.open().then(() => {\n\t\t\tdevOpen = true;\n\t\t\t// Normalize the device ID string\n\t\t\tthis._id = this._dev.serialNumber.replace(/[^\\x20-\\x7e]/g, '').toLowerCase();\n\t\t\tthis._log.trace(`Device ID: ${this._id}`);\n\n\t\t\tif (this._supported) {\n\t\t\t\t// Get firmware version\n\t\t\t\treturn this._getFirmwareVersion().then(ver => {\n\t\t\t\t\tthis._fwVer = ver;\n\t\t\t\t\tthis._log.trace(`Firmware version: ${this._fwVer}`);\n\t\t\t\t}).catch(err => {\n\t\t\t\t\t// Pre-0.6.0 firmwares and devices in DFU mode don't support the firmware version request\n\t\t\t\t\tif (!this._info.dfu) {\n\t\t\t\t\t\tthis._log.trace(`Unable to get firmware version: ${err.message}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tif (this._info.dfu) {\n\t\t\t\tthis._dfu = new Dfu(this._dev, this._log);\n\t\t\t\treturn this._dfu.open(options);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tthis._log.trace('Device is open');\n\t\t\tthis._maxActiveReqs = options.concurrentRequests;\n\t\t\tif (!this._dfu) {\n\t\t\t\tthis._resetAllReqs = true; // Reset all requests remaining from a previous session\n\t\t\t}\n\t\t\tthis._state = DeviceState.OPEN;\n\t\t\tthis.emit('open');\n\t\t\tthis._process();\n\t\t}).catch(err => {\n\t\t\tif (!devOpen) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\treturn this._close(err).catch(ignore).then(() => {\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Close the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.processPendingRequests=true] Whether to complete processing of the\n\t *        pending requests before closing the device.\n\t * @param {Number} [options.timeout] Timeout for processing pending requests (milliseconds).\n\t *        By default, the device is kept open until all requests are processed.\n\t * @return {Promise}\n\t */\n\tclose(options) {\n\t\toptions = Object.assign({\n\t\t\tprocessPendingRequests: true, // Process pending requests before closing the device\n\t\t\ttimeout: null // Wait until all requests are processed\n\t\t}, options);\n\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\t// Check if pending requests need to be processed before closing the device\n\t\tif (!options.processPendingRequests) {\n\t\t\tthis._rejectAllRequests(new StateError('Device is being closed'));\n\t\t\tif (this._closeTimer) {\n\t\t\t\tclearTimeout(this._closeTimer);\n\t\t\t\tthis._closeTimer = null;\n\t\t\t}\n\t\t} else if (options.timeout && !this._wantClose) { // Timeout cannot be overriden\n\t\t\tthis._closeTimer = setTimeout(() => {\n\t\t\t\tthis._rejectAllRequests(new StateError('Device is being closed'));\n\t\t\t\tthis._process();\n\t\t\t}, options.timeout);\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\t// Use EventEmitter's queue to resolve the promise\n\t\t\tthis.once('closed', () => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t\tthis._wantClose = true;\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Send a control request to the device.\n\t *\n\t * @param {Number} type Request type.\n\t * @param {Buffer|String} data Request data.\n\t * @param {Object} [options] Request options.\n\t * @param {Function|Number} [options.pollingPolicy=PollingPolicy.DEFAULT] Request polling policy.\n\t *        This parameter specifies how frequently the device will be polled to determine the result\n\t *        of the request. The argument can either be a function that returns the number of milliseconds\n\t *        to wait before polling the device again or a number that specifies a fixed interval.\n\t * @param {Number} [options.timeout] Request timeout. The default timeout can be configured via\n\t *        {@link config}.\n\t * @return {Promise<Object>} Response object.\n\t */\n\tsendControlRequest(type, data, options) {\n\t\toptions = Object.assign({\n\t\t\tpollingPolicy: PollingPolicy.DEFAULT, // Polling policy\n\t\t\ttimeout: globalOptions.requestTimeout // Request timeout\n\t\t}, options);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\t\tthrow new StateError('Device is not open');\n\t\t\t}\n\t\t\tif (this._state === DeviceState.CLOSING || this._wantClose) {\n\t\t\t\tthrow new StateError('Device is being closed');\n\t\t\t}\n\t\t\tif (type < 0 || type > proto.MAX_REQUEST_TYPE) {\n\t\t\t\tthrow new RangeError('Invalid request type');\n\t\t\t}\n\t\t\tif (!this._supported) {\n\t\t\t\tthrow new NotAllowedError('Control requests are not supported');\n\t\t\t}\n\t\t\tconst dataIsStr = (typeof data === 'string');\n\t\t\tif (dataIsStr) {\n\t\t\t\tdata = Buffer.from(data);\n\t\t\t}\n\t\t\tif (data && data.length > proto.MAX_PAYLOAD_SIZE) {\n\t\t\t\tthrow new RangeError('Request data is too large');\n\t\t\t}\n\t\t\tconst req = {\n\t\t\t\tid: ++this._lastReqId, // Internal request ID\n\t\t\t\ttype: type,\n\t\t\t\tdata: data,\n\t\t\t\tdataIsStr: dataIsStr,\n\t\t\t\tdataSent: false,\n\t\t\t\tprotoId: null, // Protocol request ID\n\t\t\t\tcheckInterval: options.pollingPolicy,\n\t\t\t\tcheckIntervalIsFunc: (typeof options.pollingPolicy === 'function'),\n\t\t\t\tcheckTimer: null,\n\t\t\t\tcheckCount: 0,\n\t\t\t\treqTimer: null,\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t\tif (options.timeout) {\n\t\t\t\t// Start request timer\n\t\t\t\treq.reqTimer = setTimeout(() => {\n\t\t\t\t\tthis._rejectRequest(req, new TimeoutError('Request timeout'));\n\t\t\t\t\tthis._process();\n\t\t\t\t}, options.timeout);\n\t\t\t}\n\t\t\tthis._reqs.set(req.id, req);\n\t\t\tthis._reqQueue.push(req);\n\t\t\tthis._log.trace(`Request ${req.id}: Enqueued`);\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * This method only works in DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync reset() {\n\t\tif (this._dfu) {\n\t\t\treturn this._dfu.leave();\n\t\t}\n\t\tthrow new StateError();\n\t}\n\n\t/**\n\t * Set to `true` if the device is open.\n\t */\n\tget isOpen() {\n\t\treturn (this._state !== DeviceState.CLOSED);\n\t}\n\n\t/**\n\t * Device ID.\n\t *\n\t * This property is set to `null` if the device is closed.\n\t */\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Device OS system version.\n\t *\n\t * This property is set to `null` if the device is closed or the version could not be determined.\n\t */\n\tget firmwareVersion() {\n\t\treturn this._fwVer;\n\t}\n\n\t/**\n\t * Device type (photon, boron, tracker, etc)\n\t */\n\tget type() {\n\t\treturn this._info.type;\n\t}\n\n\t/**\n\t * Platform ID\n\t */\n\tget platformId() {\n\t\treturn this._info.id;\n\t}\n\n\t/**\n\t * USB vendor ID.\n\t */\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\t/**\n\t * USB product ID.\n\t */\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\t/**\n\t * Set to `true` if this device is in the DFU mode.\n\t */\n\tget isInDfuMode() {\n\t\treturn this._info.dfu;\n\t}\n\n\t/**\n\t * Internal USB device handle.\n\t */\n\tget usbDevice() {\n\t\treturn this._dev;\n\t}\n\n\t/**\n\t * Device USB quirks\n\t */\n\tget quirks() {\n\t\treturn this._info.quirks;\n\t}\n\n\t_process() {\n\t\tif (this._state === DeviceState.CLOSED || this._state === DeviceState.OPENING || this._busy) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._wantClose && this._state !== DeviceState.CLOSING) {\n\t\t\tthis._log.trace('Closing device');\n\t\t\tthis._state = DeviceState.CLOSING;\n\t\t}\n\t\tif (this._supported) {\n\t\t\tif (this._resetAllRequests()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._resetNextRequest()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._checkNextRequest()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._sendNextRequest()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (this._state === DeviceState.CLOSING && this._activeReqs === 0) {\n\t\t\tthis._close();\n\t\t\t// Prevent the underlying device handle from being closed concurrently\n\t\t\tthis._busy = true;\n\t\t}\n\t}\n\n\t_resetAllRequests() {\n\t\tif (!this._resetAllReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace('Sending RESET');\n\t\tassert(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = proto.resetRequest();\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tthis._resetAllReqs = false;\n\t\t\tthis._activeReqs = 0;\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_resetNextRequest() {\n\t\tif (this._resetQueue.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst req = this._resetQueue.shift();\n\t\tthis._log.trace(`Request ${req.id}: Sending RESET`);\n\t\tassert(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = proto.resetRequest(req.protoId);\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tassert(--this._activeReqs >= 0);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_checkNextRequest() {\n\t\tlet req = null;\n\t\twhile (this._checkQueue.length !== 0) {\n\t\t\tconst r = this._checkQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending CHECK (${req.checkCount})`);\n\t\tassert(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = proto.checkRequest(req.protoId);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase proto.Status.OK: {\n\t\t\t\t\tif (req.dataSent) {\n\t\t\t\t\t\t// Request processing is completed\n\t\t\t\t\t\tconst rep = {\n\t\t\t\t\t\t\tresult: srep.result\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (srep.size) {\n\t\t\t\t\t\t\t// Receive payload data\n\t\t\t\t\t\t\treturn this._recvReplyData(req, srep.size).then(data => {\n\t\t\t\t\t\t\t\trep.data = req.dataIsStr ? data.toString() : data;\n\t\t\t\t\t\t\t\tthis._resolveRequest(req, rep);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveRequest(req, rep); // No reply data\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Buffer allocation is completed, send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\treq.checkCount = 0; // Reset check counter\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.PENDING: {\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NO_MEMORY: {\n\t\t\t\t\tthrow new MemoryError('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NOT_FOUND: {\n\t\t\t\t\tthrow new DeviceError('Request was cancelled');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new ProtocolError(`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendNextRequest() {\n\t\tif (this._maxActiveReqs && this._activeReqs >= this._maxActiveReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tlet req = null;\n\t\twhile (this._reqQueue.length !== 0) {\n\t\t\tconst r = this._reqQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending INIT`);\n\t\tassert(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = proto.initRequest(req.type, req.data ? req.data.length : 0);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tif (srep.status === proto.Status.OK || srep.status === proto.Status.PENDING) {\n\t\t\t\treq.protoId = srep.id;\n\t\t\t\t++this._activeReqs;\n\t\t\t\tthis._log.trace(`Request ${req.id}: Protocol ID: ${req.protoId}`);\n\t\t\t}\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase proto.Status.OK: {\n\t\t\t\t\tif (req.data && req.data.length > 0) {\n\t\t\t\t\t\t// Send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.dataSent = true; // No payload data\n\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.PENDING: {\n\t\t\t\t\tif (!req.data || req.data.length === 0) {\n\t\t\t\t\t\tthrow new ProtocolError(`Unexpected status code: ${srep.status}`);\n\t\t\t\t\t}\n\t\t\t\t\t// Buffer allocation is pending\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.BUSY: {\n\t\t\t\t\t// Update maximum number of active requests\n\t\t\t\t\tthis._maxActiveReqs = this._activeReqs;\n\t\t\t\t\t// Return the request back to queue\n\t\t\t\t\tthis._reqQueue.unshift(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NO_MEMORY: {\n\t\t\t\t\tthrow new MemoryError('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new ProtocolError(`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendRequestData(req) {\n\t\tassert(req.data && req.data.length > 0);\n\t\tlet offs = 0;\n\t\tconst sendNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(MAX_CONTROL_TRANSFER_DATA_SIZE, req.data.length - offs);\n\t\t\tconst chunk = req.data.slice(offs, offs + chunkSize);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending SEND`);\n\t\t\tconst setup = proto.sendRequest(req.protoId, chunkSize);\n\t\t\treturn this._dev.transferOut(setup, chunk).then(() => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Sent ${chunkSize} bytes`);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < req.data.length) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn sendNextChunk();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\treturn sendNextChunk();\n\t}\n\n\t_recvReplyData(req, size) {\n\t\tassert(size > 0);\n\t\tconst buf = Buffer.alloc(size);\n\t\tlet offs = 0;\n\t\tconst recvNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(MAX_CONTROL_TRANSFER_DATA_SIZE, size - offs);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending RECV`);\n\t\t\tconst setup = proto.recvRequest(req.protoId, chunkSize);\n\t\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Received ${data.length} bytes`);\n\t\t\t\tif (data.length !== chunkSize) {\n\t\t\t\t\tthrow new Error('Unexpected size of the control transfer');\n\t\t\t\t}\n\t\t\t\tdata.copy(buf, offs);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < size) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn recvNextChunk();\n\t\t\t\t}\n\t\t\t\treturn buf;\n\t\t\t});\n\t\t};\n\t\treturn recvNextChunk();\n\t}\n\n\t_close(err = null) {\n\t\tassert(!this._busy);\n\t\t// Cancel all requests\n\t\tif (this._reqs.size !== 0) {\n\t\t\tif (!err) {\n\t\t\t\terr = new StateError('Device has been closed');\n\t\t\t}\n\t\t\tthis._rejectAllRequests(err);\n\t\t}\n\t\tthis._activeReqs = 0;\n\t\tthis._resetAllReqs = false;\n\t\t// Cancel timers\n\t\tif (this._closeTimer) {\n\t\t\tclearTimeout(this._closeTimer);\n\t\t\tthis._closeTimer = null;\n\t\t}\n\n\t\tlet p = Promise.resolve();\n\t\tif (this._dfu) {\n\t\t\tp = p.then(() => this._dfu.close()).catch(err => {\n\t\t\t\tthis._log.warn(`Unable to close DFU interface: ${err.message}`);\n\t\t\t});\n\t\t}\n\t\t// Close USB device\n\t\treturn p.then(() => this._dev.close()).catch(err => {\n\t\t\tthis._log.warn(`Unable to close USB device: ${err.message}`);\n\t\t}).then(() => {\n\t\t\t// Reset device state\n\t\t\tconst emitEvent = (this._state === DeviceState.CLOSING);\n\t\t\tthis._state = DeviceState.CLOSED;\n\t\t\tthis._wantClose = false;\n\t\t\tthis._busy = false;\n\t\t\tthis._maxActiveReqs = null;\n\t\t\tthis._dfu = null;\n\t\t\tthis._fwVer = null;\n\t\t\tthis._id = null;\n\t\t\tif (emitEvent) {\n\t\t\t\tthis.emit('closed');\n\t\t\t}\n\t\t});\n\t}\n\n\t_rejectAllRequests(err) {\n\t\tthis._reqs.forEach(req => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t});\n\t\tthis._reqQueue = [];\n\t\tthis._checkQueue = [];\n\t\tthis._resetQueue = [];\n\t\tif (this._activeReqs > 0) {\n\t\t\tthis._resetAllReqs = true;\n\t\t}\n\t}\n\n\t_rejectRequest(req, err) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Failed: ${err.message}`);\n\t\tthis._clearRequest(req);\n\t\tif (req.protoId) {\n\t\t\tthis._resetQueue.push(req);\n\t\t}\n\t\treq.reject(err);\n\t}\n\n\t_resolveRequest(req, rep) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Completed`);\n\t\tthis._clearRequest(req);\n\t\tassert(--this._activeReqs >= 0);\n\t\treq.resolve(rep);\n\t}\n\n\t_clearRequest(req) {\n\t\tif (req.checkTimer) {\n\t\t\tclearTimeout(req.checkTimer);\n\t\t\treq.checkTimer = null;\n\t\t}\n\t\tif (req.reqTimer) {\n\t\t\tclearTimeout(req.reqTimer);\n\t\t\treq.reqTimer = null;\n\t\t}\n\t\tthis._reqs.delete(req.id);\n\t\treq.done = true;\n\t}\n\n\t_startCheckTimer(req) {\n\t\tlet timeout = req.checkInterval;\n\t\tif (req.checkIntervalIsFunc) {\n\t\t\ttimeout = timeout(req.checkCount);\n\t\t}\n\t\t++req.checkCount;\n\t\tsetTimeout(() => {\n\t\t\tthis._checkQueue.push(req);\n\t\t\tthis._process();\n\t\t}, timeout);\n\t}\n\n\t_getFirmwareVersion() {\n\t\tconst setup = {\n\t\t\tbmRequestType: proto.BmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: proto.PARTICLE_BREQUEST,\n\t\t\twIndex: VendorRequest.SYSTEM_VERSION,\n\t\t\twValue: 0,\n\t\t\twLength: proto.MIN_WLENGTH\n\t\t};\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\t// filter out null bytes\n\t\t\tconst nullPos = data.indexOf(0);\n\t\t\treturn (nullPos === -1 ? data : data.slice(0, nullPos)).toString();\n\t\t});\n\t}\n\n\t// Sends a service request and parses the reply data\n\t_sendServiceRequest(setup) {\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\treturn proto.parseReply(data);\n\t\t});\n\t}\n}\n\nasync function getDevices({ types = [], includeDfu = true } = {}) {\n\ttypes = types.map(type => type.toLowerCase());\n\tconst filters = [];\n\tPLATFORMS.forEach((platform) => {\n\t\tif (types.length === 0 || types.includes(platform.name)) {\n\t\t\tif (platform && platform.usb && platform.usb.vendorId) {\n\t\t\t\tfilters.push(platform.usb);\n\t\t\t}\n\t\t\tif (includeDfu && platform && platform.dfu && platform.dfu.vendorId) {\n\t\t\t\tfilters.push(platform.dfu);\n\t\t\t}\n\t\t}\n\t});\n\tif (filters.length === 0) {\n\t\treturn [];\n\t}\n\tconst devs = await getUsbDevices(filters);\n\treturn devs.map(dev => {\n\t\tconst platform = platformForUsbIds(dev.vendorId, dev.productId);\n\t\tassert(platform);\n\t\treturn new DeviceBase(dev, platform);\n\t});\n}\n\nasync function openDeviceById(id, options = null) {\n\tconst log = globalOptions.log;\n\tconst filters = [];\n\tPLATFORMS.forEach((platform) => {\n\t\tif (platform && platform.usb && platform.usb.vendorId) {\n\t\t\tfilters.push(Object.assign({ serialNumber: id }, platform.usb));\n\t\t}\n\t\tif (platform && platform.dfu && platform.dfu.vendorId) {\n\t\t\tfilters.push(Object.assign({ serialNumber: id }, platform.dfu));\n\t\t}\n\t});\n\tconst devs = await getUsbDevices(filters);\n\tif (devs.length === 0) {\n\t\tthrow new NotFoundError('Device is not found');\n\t}\n\tif (devs.length !== 1) {\n\t\tlog.warn(`Found multiple devices with the same ID: ${id}`); // lol\n\t}\n\tlet dev = devs[0];\n\tconst platform = platformForUsbIds(dev.vendorId, dev.productId);\n\tassert(platform);\n\tdev = new DeviceBase(dev, platform);\n\tawait dev.open(options);\n\treturn dev;\n}\n\nasync function openNativeUsbDevice(nativeUsbDevice, options = null) {\n\n\tconst usbDevice = new UsbDevice(nativeUsbDevice);\n\n\tconst platform = platformForUsbIds(usbDevice.vendorId, usbDevice.productId);\n\tif (!platform) {\n\t\tthrow new NotFoundError('Unsupported device type');\n\t}\n\tconst dev = new DeviceBase(usbDevice, platform);\n\n\tawait dev.open(options);\n\n\treturn dev;\n}\n\nmodule.exports = {\n\tPollingPolicy,\n\tDeviceBase,\n\tgetDevices,\n\topenDeviceById,\n\topenNativeUsbDevice,\n\tplatformForUsbIds // For testing\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/device-base.js?");

/***/ }),

/***/ "./src/device.js":
/*!***********************!*\
  !*** ./src/device.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { DeviceBase, openDeviceById } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { Result, errorForRequest } = __webpack_require__(/*! ./result */ \"./src/result.js\");\nconst { fromProtobufEnum, extractBits } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst usbProto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { RequestError, NotFoundError, TimeoutError, StateError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst DeviceOSProtobuf = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\nconst { definitions: proto, cloudDefinitions: protoCloud } = DeviceOSProtobuf;\n\nconst FirmwareModuleDeprecated = fromProtobufEnum(proto.FirmwareModuleType, {\n\t/** Bootloader module. */\n\tBOOTLOADER: 'BOOTLOADER',\n\t/** System part module. */\n\tSYSTEM_PART: 'SYSTEM_PART',\n\t/** User part module. */\n\tUSER_PART: 'USER_PART',\n\t/** Monolithic firmware module. */\n\tMONO_FIRMWARE: 'MONO_FIRMWARE',\n\t/** Network co-processor firmware module */\n\tNCP_FIRMWARE: 'NCP_FIRMWARE',\n\t/** Radio stack module */\n\tRADIO_STACK: 'RADIO_STACK'\n});\n\n/**\n * Firmware module types.\n *\n * @enum {String}\n */\nconst FirmwareModule = fromProtobufEnum(protoCloud.FirmwareModuleType, {\n\tINVALID: 'INVALID_MODULE',\n\tRESOURCE: 'RESOURCE_MODULE',\n\tBOOTLOADER: 'BOOTLOADER_MODULE',\n\tMONO_FIRMWARE: 'MONO_FIRMWARE_MODULE',\n\tSYSTEM_PART: 'SYSTEM_PART_MODULE',\n\tUSER_PART: 'USER_PART_MODULE',\n\tSETTINGS: 'SETTINGS_MODULE',\n\tNCP_FIRMWARE: 'NCP_FIRMWARE_MODULE',\n\tRADIO_STACK: 'RADIO_STACK_MODULE',\n\tASSET: 'ASSET_MODULE',\n});\n\n/**\n * Firmware module store.\n *\n * @enum {String}\n */\nconst FirmwareModuleStore = fromProtobufEnum(protoCloud.FirmwareModuleStore, {\n\tMAIN: 'MAIN_MODULE_STORE',\n\tFACTORY: 'FACTORY_MODULE_STORE',\n\tBACKUP: 'BACKUP_MODULE_STORE',\n\tSCRATCHPAD: 'SCRATCHPAD_MODULE_STORE',\n});\n\nconst LegacyFirmwareModuleValidityFlag = fromProtobufEnum(proto.FirmwareModuleValidityFlag, {\n\tINTEGRITY_CHECK_FAILED: 'INTEGRITY_CHECK_FAILED',\n\tDEPENDENCY_CHECK_FAILED: 'DEPENDENCY_CHECK_FAILED'\n});\n\nconst FirmwareModuleValidityFlag = fromProtobufEnum(protoCloud.FirmwareModuleValidityFlag, {\n\tINTEGRITY_CHECK_FAILED: 'MODULE_INTEGRITY_VALID_FLAG',\n\tDEPENDENCY_CHECK_FAILED: 'MODULE_DEPENDENCIES_VALID_FLAG',\n\tRANGE_CHECK_FAILED: 'MODULE_RANGE_VALID_FLAG',\n\tPLATFORM_CHECK_FAILED: 'MODULE_PLATFORM_VALID_FLAG'\n});\n\n/**\n * Firmware module readable names\n *\n * @enum {String}\n */\nconst FirmwareModuleDisplayNames = {\n\t[FirmwareModule.INVALID]: 'Invalid',\n\t[FirmwareModule.RESOURCE]: 'Resource',\n\t[FirmwareModule.BOOTLOADER]: 'Bootloader',\n\t[FirmwareModule.MONO_FIRMWARE]: 'Monolithic Firmware',\n\t[FirmwareModule.SYSTEM_PART]: 'System Part',\n\t[FirmwareModule.USER_PART]: 'User Part',\n\t[FirmwareModule.SETTINGS]: 'Settings',\n\t[FirmwareModule.NCP_FIRMWARE]: 'Network Co-processor Firmware',\n\t[FirmwareModule.RADIO_STACK]: 'Radio Stack Module',\n\t[FirmwareModule.ASSET]: 'Asset'\n};\n\n/**\n * Device modes.\n *\n * @enum {String}\n */\nconst DeviceMode = fromProtobufEnum(proto.DeviceMode, {\n\t/** Device is in normal mode. */\n\tNORMAL: 'NORMAL_MODE',\n\t/** Device is in listening mode. */\n\tLISTENING: 'LISTENING_MODE'\n});\n\n/**\n * Logging levels.\n *\n * @enum {String}\n */\nconst LogLevel = fromProtobufEnum(proto.logging.LogLevel, {\n\t/** Enables logging of all messages. */\n\tALL: 'ALL',\n\t/** Enables logging of trace messages. */\n\tTRACE: 'TRACE',\n\t/** Enables logging of info messages. */\n\tINFO: 'INFO',\n\t/** Enables logging of warning messages. */\n\tWARN: 'WARN',\n\t/** Enables logging of error messages. */\n\tERROR: 'ERROR',\n\t/** Disables logging of any messages. */\n\tNONE: 'NONE'\n});\n\nconst DEFAULT_FIRMWARE_UPDATE_TIMEOUT = 120000;\n\n// Helper class used by Device.timeout()\nclass RequestSender {\n\tconstructor(device, timeout) {\n\t\tthis.id = device.id;\n\t\tthis.device = device;\n\t\tthis._timeoutTime = Date.now() + timeout;\n\t}\n\n\tasync open(options) {\n\t\tthis.device = await openDeviceById(this.id, options);\n\t}\n\n\tasync close() {\n\t\tawait this.device.close();\n\t}\n\n\tasync sendRequest(req, msg, opts) {\n\t\tif (!opts || !opts.timeout) {\n\t\t\tconst t = this._timeoutTime - Date.now();\n\t\t\tif (t <= 0) {\n\t\t\t\tthrow new TimeoutError();\n\t\t\t}\n\t\t\topts = Object.assign({}, opts, { timeout: t });\n\t\t} else if (Date.now() + opts.timeout >= this._timeoutTime) {\n\t\t\tthrow new TimeoutError();\n\t\t}\n\t\treturn this.device.sendRequest(req, msg, opts);\n\t}\n\n\tasync delay(ms) {\n\t\tif (Date.now() + ms >= this._timeoutTime) {\n\t\t\tthrow new TimeoutError();\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\tsetTimeout(() => resolve(), ms);\n\t\t});\n\t}\n}\n\n/**\n * Basic functionality supported by most of Particle devices.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass Device extends DeviceBase {\n\t/**\n\t * Get the device's serial number.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.5.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getSerialNumber({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendProtobufRequest(\n\t\t\t'GetSerialNumberRequest',\n\t\t\tnull,\n\t\t\t{ timeout }\n\t\t);\n\t\treturn r.serial;\n\t}\n\n\t/**\n\t * Get the device's id.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.5.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getDeviceId({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendProtobufRequest(\n\t\t\t'GetDeviceIdRequest',\n\t\t\tnull,\n\t\t\t{ timeout }\n\t\t);\n\t\treturn r.id;\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.force] Reset the device immediately, even if it is busy performing\n\t *        some blocking operation, such as writing to flash.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync reset({ force = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn super.reset();\n\t\t}\n\t\tif (!force) {\n\t\t\treturn this.sendRequest(Request.RESET, null /* msg */, { timeout });\n\t\t}\n\t\tconst setup = {\n\t\t\tbmRequestType: usbProto.BmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: usbProto.PARTICLE_BREQUEST,\n\t\t\twIndex: Request.RESET.id,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this.usbDevice.transferOut(setup);\n\t}\n\n\t/**\n\t * Perform the factory reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tfactoryReset({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.FACTORY_RESET, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Reset and enter the DFU mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.noReconnectWait] After entering DFU mode, do not attempt to connect to the device to make sure it's in DFU mode.\n\t *     This can be useful in a web browser because connecting to the device in DFU mode may prompt the user to authorize\n\t *     access to the device.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterDfuMode({ noReconnectWait = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(Request.DFU_MODE);\n\t\t\tawait s.close();\n\t\t\tlet isInDfuMode;\n\n\t\t\tif (!noReconnectWait) {\n\t\t\t\twhile (!isInDfuMode) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait s.open({ includeDfu: true });\n\t\t\t\t\t\tisInDfuMode = s.device.isInDfuMode;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// device is reconnecting, ignore\n\t\t\t\t\t}\n\t\t\t\t\tawait s.close();\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * Reset and enter the safe mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterSafeMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn this._dfu.enterSafeMode();\n\t\t}\n\t\treturn this.sendRequest(Request.SAFE_MODE, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Enter listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise} Resolves when either device is confirmed to be in listening mode, throws an error, or timeout exceeded.\n\t */\n\tasync enterListeningMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait this.sendProtobufRequest('StartListeningModeRequest', {}, { timeout });\n\n\t\t\t// Wait until the device enters the listening mode\n\t\t\twhile (true) { // eslint-disable-line no-constant-condition\n\t\t\t\t// GetDeviceModeRequest may not be supported by the device even if start listening mode does work, hence try/catch\n\t\t\t\ttry {\n\t\t\t\t\tconst getDeviceModeReply = await this.sendProtobufRequest('GetDeviceModeRequest', {}, { timeout });\n\n\t\t\t\t\tconst deviceModeEnum = DeviceOSProtobuf.getDefinition('DeviceMode').message;\n\t\t\t\t\t// break if in listening mode\n\t\t\t\t\tif (getDeviceModeReply.mode === deviceModeEnum.LISTENING_MODE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof RequestError) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait s.delay(500);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Leave the listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tleaveListeningMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.STOP_LISTENING, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Get the device mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<DeviceMode>}\n\t */\n\tasync getDeviceMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.GET_DEVICE_MODE, null /* msg */, { timeout });\n\t\treturn DeviceMode.fromProtobuf(r.mode);\n\t}\n\n\t/**\n\t * Start the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstartNyanSignal({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.START_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Stop the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstopNyanSignal({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.STOP_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Perform the firmware update.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @param {Function} [options.progress] User's callback function to log progress of the flashing process.\n\t * @return {Promise}\n\t */\n\tasync updateFirmware(data, { timeout = DEFAULT_FIRMWARE_UPDATE_TIMEOUT, progress } = {}) {\n\t\tif (!data.length) {\n\t\t\tthrow new RangeError('Invalid firmware size');\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'start-erase', bytes: data.length });\n\t\t\t}\n\t\t\tconst { chunkSize } = await s.sendRequest(Request.START_FIRMWARE_UPDATE, { size: data.length });\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'erased', bytes: data.length });\n\t\t\t\tprogress({ event: 'start-download', bytes: data.length });\n\t\t\t}\n\t\t\tlet offs = 0;\n\t\t\twhile (offs < data.length) {\n\t\t\t\tconst n = Math.min(chunkSize, data.length - offs);\n\t\t\t\tawait s.sendRequest(Request.FIRMWARE_UPDATE_DATA, { data: data.slice(offs, offs + n) });\n\t\t\t\tif (progress) {\n\t\t\t\t\tprogress({ event: 'downloaded', bytes: n });\n\t\t\t\t}\n\t\t\t\toffs += n;\n\t\t\t}\n\t\t\tawait s.sendRequest(Request.FINISH_FIRMWARE_UPDATE, { validateOnly: false });\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'complete-download', bytes: data.length });\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get firmware module data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} module Module type.\n\t * @param {Number} [index] Module index.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFirmwareModule(module, index) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tconst section = storage.modules.find(section => {\n\t\t\t\treturn (section.moduleType === module && section.moduleIndex === index);\n\t\t\t});\n\t\t\tif (!section) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(section).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(section, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get asset info.\n\t *\n\t *\n\t * Supported platforms:\n\t * - Gen 3+ (since Device OS 5.6.0)\n\t *\n\t * @return {Promise<Array>} List of asssets available on the device.\n\t */\n\tasync getAssetInfo({ timeout = globalOptions.timeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\tthrow new StateError('Cannot get information when the device is in DFU mode');\n\t\t}\n\n\t\tconst assetInfoResponse = await this.sendProtobufRequest('GetAssetInfoRequest', null, { timeout });\n\t\tconst available = assetInfoResponse.available.map(asset => {\n\t\t\tconst { name, size, storageSize } = asset;\n\t\t\tconst hash = asset.hash.toString('hex');\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\thash,\n\t\t\t\tsize,\n\t\t\t\tstorageSize\n\t\t\t};\n\t\t});\n\t\tconst required = assetInfoResponse.required.map(asset => {\n\t\t\tconst { name } = asset;\n\t\t\tconst hash = asset.hash.toString('hex');\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\thash,\n\t\t\t};\n\t\t});\n\t\treturn { available, required };\n\t}\n\n\t/**\n\t * Get firmware module info.\n\t *\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t * - New format since 5.6.0 (old format in 'modules_deprecated')\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Array>} List of modules installed into the device and their dependencies\n\t */\n\tasync getFirmwareModuleInfo({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\tthrow new StateError('Cannot get information when the device is in DFU mode');\n\t\t}\n\n\t\tconst moduleInfoResponse = await this.sendProtobufRequest('GetModuleInfoRequest', null, { timeout });\n\t\tconst { modulesDeprecated, modules } = moduleInfoResponse;\n\n\t\tif (modulesDeprecated && modulesDeprecated.length > 0) {\n\t\t\treturn modulesDeprecated.map(module => {\n\t\t\t\tconst { index, type, dependencies, size, validity, version } = module;\n\t\t\t\tconst validityErrors = extractBits(validity, LegacyFirmwareModuleValidityFlag);\n\n\t\t\t\treturn {\n\t\t\t\t\ttype: FirmwareModuleDeprecated.fromProtobuf(type),\n\t\t\t\t\tindex,\n\t\t\t\t\tversion,\n\t\t\t\t\tsize,\n\t\t\t\t\tvalidity,\n\t\t\t\t\tvalidityErrors,\n\t\t\t\t\tdependencies: dependencies.map(dependency => {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tindex: dependency.index,\n\t\t\t\t\t\t\tversion: dependency.version,\n\t\t\t\t\t\t\ttype: FirmwareModuleDeprecated.fromProtobuf(dependency.type)\n\t\t\t\t\t\t};\n\t\t\t\t\t}),\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\n\t\treturn modules.map(module => {\n\t\t\tconst { index, type, dependencies, size, version, assetDependencies, maxSize, store, hash } = module;\n\t\t\tconst failedFlags = module.checkedFlags ^ module.passedFlags;\n\t\t\tconst validityErrors = extractBits(failedFlags, FirmwareModuleValidityFlag);\n\n\t\t\treturn {\n\t\t\t\ttype: FirmwareModule.fromProtobuf(type),\n\t\t\t\tstore: FirmwareModuleStore.fromProtobuf(store),\n\t\t\t\tindex,\n\t\t\t\tversion,\n\t\t\t\tsize,\n\t\t\t\tmaxSize,\n\t\t\t\thash: hash.toString('hex'),\n\t\t\t\tfailedFlags,\n\t\t\t\tvalidityErrors,\n\t\t\t\tdependencies: dependencies.map(dependency => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindex: dependency.index,\n\t\t\t\t\t\tversion: dependency.version,\n\t\t\t\t\t\ttype: FirmwareModule.fromProtobuf(dependency.type)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t\tassetDependencies: assetDependencies.map(asset => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tname: asset.name,\n\t\t\t\t\t\thash: asset.hash.toString('hex')\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Check if the device runs a modular firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Boolean>}\n\t */\n\thasModularFirmware() {\n\t\treturn this._getStorageInfo().then(storage => storage.hasModularFirmware);\n\t}\n\n\t/**\n\t * Set factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @return {Promise}\n\t */\n\tsetFactoryFirmware(data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.factory, 0, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFactoryFirmware() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(storage.factory).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(storage.factory, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Read configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadConfigData(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.config, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteConfigData(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.config, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetConfigDataSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn storage.config.size;\n\t\t});\n\t}\n\n\t/**\n\t * Read from EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadEeprom(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.eeprom, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write to EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteEeprom(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.eeprom, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Clear EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearEeprom() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._clearSectionData(storage.eeprom);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetEepromSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn storage.eeprom.size;\n\t\t});\n\t}\n\n\t/**\n\t * Add a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @param {String} options.stream Output stream: `Serial`, `Serial1`, `USBSerial1`, etc.\n\t * @param {String} [options.format] Message format: `default`, `json`.\n\t * @param {String} [options.level] Default logging level: `trace`, `info`, `warn`, `error`, `none`, `all`.\n\t * @param {Array} [options.filters] Category filters.\n\t * @param {Number} [options.baudRate] Baud rate.\n\t * @return {Promise}\n\t */\n\tasync addLogHandler({ id, stream, format, level, filters, baudRate }) {\n\t\tconst req = {\n\t\t\tid,\n\t\t\tlevel: LogLevel.toProtobuf(level || 'all')\n\t\t};\n\t\tswitch ((format || 'default').toLowerCase()) {\n\t\t\tcase 'default': {\n\t\t\t\treq.handlerType = proto.logging.LogHandlerType.DEFAULT_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'json': {\n\t\t\t\treq.handlerType = proto.logging.LogHandlerType.JSON_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown message format: ${format}`);\n\t\t\t}\n\t\t}\n\t\tif (!stream) {\n\t\t\tthrow new RangeError('Output stream is not specified');\n\t\t}\n\t\tswitch (stream.toLowerCase()) {\n\t\t\tcase 'serial': {\n\t\t\t\treq.streamType = proto.logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 0\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'usbserial1': {\n\t\t\t\treq.streamType = proto.logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'serial1': {\n\t\t\t\treq.streamType = proto.logging.StreamType.HW_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1,\n\t\t\t\t\tbaudRate\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown output stream: ${stream}`);\n\t\t\t}\n\t\t}\n\t\tif (filters) {\n\t\t\treq.filters = filters.map(f => ({\n\t\t\t\tcategory: f.category,\n\t\t\t\tlevel: LogLevel.toProtobuf(f.level)\n\t\t\t}));\n\t\t}\n\t\treturn this.sendRequest(Request.ADD_LOG_HANDLER, req);\n\t}\n\n\t/**\n\t * Remove a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @return {Promise}\n\t */\n\tasync removeLogHandler({ id }) {\n\t\treturn this.sendRequest(Request.REMOVE_LOG_HANDLER, { id });\n\t}\n\n\t/**\n\t * Get the list of active log handlers.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @return {Promise<Array<Object>>}\n\t */\n\tasync getLogHandlers() {\n\t\tconst rep = await this.sendRequest(Request.GET_LOG_HANDLERS);\n\t\treturn rep.handlers.map(h => ({\n\t\t\tid: h.id\n\t\t}));\n\t}\n\n\t/**\n\t * @typedef {Object} UnprotectDeviceResult\n\t * @property {Boolean} protected If `true`, device protection is enabled.\n\t * @property {Buffer} [deviceNonce] Device nonce.\n\t * @property {Buffer} [deviceSignatute] Device signature.\n\t * @property {Buffer} [devicePublicKeyFingerprint] Fingerprint of the device public key.\n\t */\n\n\t/**\n\t * Request the device to temporarily disable device protection.\n\t *\n\t * @param {Object} param Parameters.\n\t * @param {String} param.action `prepare`, `confirm` or `reset`.\n\t * @param {Buffer} [param.serverNonce] Server nonce. Mandatory if `action` is `prepare`.\n\t * @param {Buffer} [param.serverSignature] Server signature. Mandatory if `action` is `confirm`.\n\t * @param {Buffer} [param.serverPublicKeyFingerprint] Fingerprint of the server public key. Mandatory if `action` is `confirm`.\n\t * @returns {Promise<UnprotectDeviceResult>}\n\t */\n\tasync unprotectDevice({ action, serverNonce, serverSignature, serverPublicKeyFingerprint }) {\n\t\tif (this.isInDfuMode) {\n\t\t\tif (action !== 'reset') {\n\t\t\t\tthrow new StateError('Cannot perform operation when device is in DFU mode');\n\t\t\t}\n\t\t\tawait this._dfu.clearSecurityModeOverride();\n\t\t\treturn;\n\t\t}\n\t\tlet req;\n\t\tswitch (action) {\n\t\t\tcase 'prepare': {\n\t\t\t\tif (!Buffer.isBuffer(serverNonce)) {\n\t\t\t\t\tthrow new Error('Invalid arguments');\n\t\t\t\t}\n\t\t\t\treq = {\n\t\t\t\t\taction: proto.SetProtectedStateRequest.Action.PREPARE,\n\t\t\t\t\tprepare: { serverNonce }\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'confirm': {\n\t\t\t\tif (!Buffer.isBuffer(serverSignature) || !Buffer.isBuffer(serverPublicKeyFingerprint)) {\n\t\t\t\t\tthrow new Error('Invalid arguments');\n\t\t\t\t}\n\t\t\t\treq = {\n\t\t\t\t\taction: proto.SetProtectedStateRequest.Action.CONFIRM,\n\t\t\t\t\tconfirm: { serverSignature, serverPublicKeyFingerprint }\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'reset': {\n\t\t\t\treq = {\n\t\t\t\t\taction: proto.SetProtectedStateRequest.Action.RESET\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new Error('Invalid arguments');\n\t\t\t}\n\t\t}\n\t\tconst rep = await this.sendProtobufRequest('SetProtectedStateRequest', req);\n\t\tif (action === 'prepare') {\n\t\t\tif (!rep.prepare) {\n\t\t\t\treturn { protected: false };\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tdeviceNonce: rep.prepare.deviceNonce,\n\t\t\t\tdeviceSignature: rep.prepare.deviceSignature,\n\t\t\t\tdevicePublicKeyFingerprint: rep.prepare.devicePublicKeyFingerprint,\n\t\t\t\tprotected: true\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @typedef {Object} GetProtectionStateResult\n\t * @property {Boolean} protected If `true`, device protection is enabled.\n\t * @property {Boolean} overridden If `true`, device protection was disabled temporarily.\n\t */\n\n\t/**\n\t * Check if device protection is enabled.\n\t *\n\t * @returns {GetProtectionStateResult}\n\t */\n\tasync getProtectionState() {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn this._dfu.getProtectionState();\n\t\t}\n\n\t\tconst rep = await this.sendProtobufRequest('GetProtectedStateRequest');\n\t\tconst result = { protected: rep.state };\n\t\tif (rep.overridden) {\n\t\t\tresult.overridden = true;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sends a protobuf encoded request to Device and decodes response. Use higher level methods like getSerialNumber() than this if possible.\n\t * @param {String} protobufMessageName - The protobuf message name, see DeviceOSProtobuf.getDefinitions() for valid values.\n\t * @param {Object} protobufMessageData data that will be encoded into the protobuf request before sending to device\n\t * @param {*} opts See sendControlRequest(), same options are here.\n\t * @returns {Object} Depends on schema defined by `req.reply`\n\t * @throws {RequestError} thrown when message isn't supported by device or other USB related failures\n\t */\n\tasync sendProtobufRequest(protobufMessageName, protobufMessageData = {}, opts) {\n\t\tconst protobufDefinition = DeviceOSProtobuf.getDefinition(protobufMessageName);\n\t\tconst encodedProtobufBuffer = DeviceOSProtobuf.encode(protobufMessageName, protobufMessageData);\n\t\tconst rep = await this.sendControlRequest(\n\t\t\tprotobufDefinition.id,\n\t\t\tencodedProtobufBuffer,\n\t\t\topts\n\t\t);\n\n\t\tif (rep.result !== Result.OK) {\n\t\t\tthrow errorForRequest(rep.result);\n\t\t}\n\n\t\tif (rep.data) {\n\t\t\t// Parse the response message\n\t\t\treturn DeviceOSProtobuf.decode(\n\t\t\t\tprotobufDefinition.replyMessage,\n\t\t\t\trep.data\n\t\t\t);\n\t\t} else {\n\t\t\t// Create a message with default-initialized properties\n\t\t\treturn protobufDefinition.replyMessage.create();\n\t\t}\n\t}\n\n\tsendRequest(req, msg, opts) {\n\t\tlet buf = null;\n\t\tif (msg && req.request) {\n\t\t\tconst m = req.request.create(msg); // Protobuf message object\n\t\t\tbuf = req.request.encode(m).finish();\n\t\t}\n\t\treturn this.sendControlRequest(req.id, buf, opts).then(rep => {\n\t\t\tlet r = undefined;\n\t\t\t// Note: Nothing depends on opts.dontThrow anymore\n\t\t\tif (opts && opts.dontThrow) {\n\t\t\t\tr = { result: rep.result };\n\t\t\t} else if (rep.result !== Result.OK) {\n\t\t\t\tthrow errorForRequest(rep.result);\n\t\t\t}\n\t\t\tif (req.reply) {\n\t\t\t\tif (rep.data) {\n\t\t\t\t\t// Parse the response message\n\t\t\t\t\tr = Object.assign(req.reply.decode(rep.data), r);\n\t\t\t\t} else {\n\t\t\t\t\t// Create a message with default-initialized properties\n\t\t\t\t\tr = Object.assign(req.reply.create(), r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t});\n\t}\n\n\t// This method is used to send multiple requests to the device. The overall execution time can be\n\t// limited via the `ms` argument (optional)\n\tasync timeout(ms, fn) {\n\t\tif (typeof ms === 'function') {\n\t\t\tfn = ms;\n\t\t\tms = undefined;\n\t\t}\n\t\tif (!ms) {\n\t\t\tms = globalOptions.requestTimeout; // Default timeout\n\t\t}\n\t\tconst s = new RequestSender(this, ms);\n\t\treturn fn(s);\n\t}\n\n\t_readSectionData(section, offset, size) {\n\t\tconst data = Buffer.alloc(size);\n\t\tlet chunkSize = 4096;\n\t\tlet chunkOffs = 0;\n\t\tconst readChunk = () => {\n\t\t\tif (chunkOffs + chunkSize > size) {\n\t\t\t\tchunkSize = size - chunkOffs;\n\t\t\t}\n\t\t\tif (chunkSize === 0) {\n\t\t\t\treturn Promise.resolve(data);\n\t\t\t}\n\t\t\treturn this.sendRequest(Request.READ_SECTION_DATA, {\n\t\t\t\tstorage: section.storageIndex,\n\t\t\t\tsection: section.sectionIndex,\n\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\tsize: chunkSize\n\t\t\t}).then(rep => {\n\t\t\t\trep.data.copy(data, chunkOffs);\n\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\treturn readChunk();\n\t\t\t});\n\t\t};\n\t\treturn readChunk();\n\t}\n\n\t_writeSectionData(section, offset, data) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tif (section.needClear) {\n\t\t\t\treturn this._clearSectionData(section);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tlet chunkSize = 4096;\n\t\t\tlet chunkOffs = 0;\n\t\t\tconst writeChunk = () => {\n\t\t\t\tif (chunkOffs + chunkSize > data.length) {\n\t\t\t\t\tchunkSize = data.length - chunkOffs;\n\t\t\t\t}\n\t\t\t\tif (chunkSize === 0) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn this.sendRequest(Request.WRITE_SECTION_DATA, {\n\t\t\t\t\tstorage: section.storageIndex,\n\t\t\t\t\tsection: section.sectionIndex,\n\t\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\t\tdata: data.slice(chunkOffs, chunkOffs + chunkSize)\n\t\t\t\t}).then(() => {\n\t\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\t\treturn writeChunk();\n\t\t\t\t});\n\t\t\t};\n\t\t\treturn writeChunk();\n\t\t});\n\t}\n\n\t_clearSectionData(section) {\n\t\treturn this.sendRequest(Request.CLEAR_SECTION_DATA, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t});\n\t}\n\n\t_getSectionDataSize(section) {\n\t\treturn this.sendRequest(Request.GET_SECTION_DATA_SIZE, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t}).then(rep => rep.size);\n\t}\n\n\t_getStorageInfo() {\n\t\t// Check if there's a cached storage info\n\t\tif (this._storageInfo) {\n\t\t\treturn Promise.resolve(this._storageInfo);\n\t\t}\n\t\t// Request storage info from the device\n\t\treturn this.sendRequest(Request.DESCRIBE_STORAGE).then(rep => {\n\t\t\tconst storage = {\n\t\t\t\tmodules: [],\n\t\t\t\tfactory: null,\n\t\t\t\tconfig: null,\n\t\t\t\teeprom: null,\n\t\t\t\thasModularFirmware: true\n\t\t\t};\n\t\t\tfor (let storageIndex = 0; storageIndex < rep.storage.length; ++storageIndex) {\n\t\t\t\tconst pbStorage = rep.storage[storageIndex];\n\t\t\t\tfor (let sectionIndex = 0; sectionIndex < pbStorage.sections.length; ++sectionIndex) {\n\t\t\t\t\tconst pbSection = pbStorage.sections[sectionIndex];\n\t\t\t\t\tconst section = {\n\t\t\t\t\t\tstorageIndex: storageIndex,\n\t\t\t\t\t\tsectionIndex: sectionIndex,\n\t\t\t\t\t\tsize: pbSection.size,\n\t\t\t\t\t\tneedClear: !!(pbSection.flags & proto.SectionFlag.NEED_CLEAR)\n\t\t\t\t\t};\n\t\t\t\t\tswitch (pbSection.type) {\n\t\t\t\t\t\t// Firmware module\n\t\t\t\t\t\tcase proto.SectionType.FIRMWARE: {\n\t\t\t\t\t\t\tconst pbFirmwareModule = pbSection.firmwareModule;\n\t\t\t\t\t\t\tif (pbFirmwareModule.type === proto.FirmwareModuleType.MONO_FIRMWARE) {\n\t\t\t\t\t\t\t\tstorage.hasModularFirmware = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsection.moduleType = FirmwareModule.fromProtobuf(pbFirmwareModule.type);\n\t\t\t\t\t\t\tif (pbFirmwareModule.index) {\n\t\t\t\t\t\t\t\tsection.moduleIndex = pbFirmwareModule.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstorage.modules.push(section);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factory firmware\n\t\t\t\t\t\tcase proto.SectionType.FACTORY_BACKUP: {\n\t\t\t\t\t\t\tstorage.factory = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Device configuration\n\t\t\t\t\t\tcase proto.SectionType.CONFIG: {\n\t\t\t\t\t\t\tstorage.config = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// EEPROM\n\t\t\t\t\t\tcase proto.SectionType.EEPROM: {\n\t\t\t\t\t\t\tstorage.eeprom = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._storageInfo = storage;\n\t\t\tthis.once('closed', () => {\n\t\t\t\tthis._storageInfo = null;\n\t\t\t});\n\t\t\treturn this._storageInfo;\n\t\t});\n\t}\n}\n\nmodule.exports = {\n\tFirmwareModule,\n\tFirmwareModuleDisplayNames,\n\tFirmwareModuleStore,\n\tDeviceMode,\n\tLogLevel,\n\tDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/device.js?");

/***/ }),

/***/ "./src/dfu-device.js":
/*!***************************!*\
  !*** ./src/dfu-device.js ***!
  \***************************/
/***/ ((module) => {

eval("const DfuDevice = (base) => class extends base {\n\t/**\n\t * Flashes the firmware over DFU interface.\n\t *\n\t * @param {Buffer} data The binary firmware data to be flashed.\n\t * @param {Object} options Options.\n\t * @param {Number} options.altSetting The interface alternate setting.\n\t * @param {Number} options.startAddr The starting address where the firmware will be written.\n\t * @param {boolean} [options.noErase] - Skip erasing the device memory.\n\t * @param {boolean} [options.leave] - Leave DFU mode after download.\n\t * @param {Function} [options.progress] User's callback function to log progress of the flashing process.\n\t * @returns {Promise<void>} A Promise that resolves when the firmware is successfully flashed.\n\t */\n\tasync writeOverDfu(data, { altSetting, startAddr, noErase, leave, progress }) {\n\t\tawait this._dfu.setAltSetting(altSetting);\n\t\tawait this._dfu.doDownload({ startAddr, data, noErase, leave, progress });\n\t}\n\n\tasync readOverDfu({ altSetting, startAddr, size, progress }) {\n\t\tawait this._dfu.setAltSetting(altSetting);\n\t\tconst buffer = await this._dfu.doUpload({ startAddr, maxSize: size, progress });\n\t\treturn buffer;\n\t}\n};\n\nmodule.exports = {\n\tDfuDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/dfu-device.js?");

/***/ }),

/***/ "./src/dfu.js":
/*!********************!*\
  !*** ./src/dfu.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/*\n * dfu.js\n * Copyright (c) 2023, Particle\n *\n * Some functions are extracted from the web-dfu project:\n * Copyright (c) 2016, Devan Lai\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nconst { DeviceError, UsbStallError, DeviceProtectionError, UnsupportedDfuseCommandError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n/**\n * A generic DFU error.\n */\nclass DfuError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n// 3. Requests, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuRequestType = {\n\t// | wValue    | wIndex    | wLength | Data     |\n\t// +-----------+-----------+---------+----------+\n\tDFU_DETACH: 0, // | wTimeout  | Interface | Zero    | None     |\n\tDFU_DNLOAD: 1, // | wBlockNum | Interface | Length  | Firmware |\n\tDFU_UPLOAD: 2, // | Zero      | Interface | Length  | Firmware |\n\tDFU_GETSTATUS: 3, // | Zero      | Interface | 6       | Status   |\n\tDFU_CLRSTATUS: 4, // | Zero      | Interface | Zero    | None     |\n\tDFU_GETSTATE: 5, // | Zero      | Interface | 1       | State    |\n\tDFU_ABORT: 6 // | Zero      | Interface | Zero    | None     |\n};\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceStatus = {\n\t// No error condition is present.\n\tOK: 0x00,\n\t// File is not targeted for use by this device.\n\terrTARGET: 0x01,\n\t// File is for this device but fails some vendor-specific verification test.\n\terrFILE: 0x02,\n\t// Device is unable to write memory.\n\terrWRITE: 0x03,\n\t// Memory erase function failed.\n\terrERASE: 0x04,\n\t// Memory erase check failed.\n\terrCHECK_ERASED: 0x05,\n\t// Program memory function failed.\n\terrPROG: 0x06,\n\t// Programmed memory failed verification.\n\terrVERIFY: 0x07,\n\t// Cannot program memory due to received address that is out of range.\n\terrADDRESS: 0x08,\n\t// Received DFU_DNLOAD with wLength = 0, but device does not think it has all of the data yet.\n\terrNOTDONE: 0x09,\n\t// Device’s firmware is corrupt. It cannot return to run-time (non-DFU) operations.\n\terrFIRMWARE: 0x0A,\n\t// iString indicates a vendor-specific error.\n\terrVENDOR: 0x0B,\n\t// Device detected unexpected USB reset signaling.\n\terrUSBR: 0x0C,\n\t// Device detected unexpected power on reset.\n\terrPOR: 0x0D,\n\t// Something went wrong, but the device does not know what it was.\n\terrUNKNOWN: 0x0E,\n\t// Device stalled an unexpected request.\n\terrSTALLEDPKT: 0x0F,\n};\n\nconst DfuDeviceStatusMap = Object.keys(DfuDeviceStatus).reduce((obj, key) => {\n\tobj[DfuDeviceStatus[key]] = key;\n\treturn obj;\n}, {});\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceState = {\n\t// Device is running its normal application.\n\tappIDLE: 0,\n\t// Device is running its normal application, has received the DFU_DETACH request, and is waiting\n\t// for a USB reset.\n\tappDETACH: 1,\n\t// Device is operating in the DFU mode and is waiting for requests.\n\tdfuIDLE: 2,\n\t// Device has received a block and is waiting for the host to solicit the status via DFU_GETSTATUS.\n\tdfuDNLOAD_SYNC: 3,\n\t// Device is programming a control-write block into its nonvolatile memories.\n\tdfuDNBUSY: 4,\n\t// Device is processing a download operation. Expecting DFU_DNLOAD requests.\n\tdfuDNLOAD_IDLE: 5,\n\t// Device has received the final block of firmware from the host and is waiting for receipt of\n\t// DFU_GETSTATUS to begin the Manifestation phase; or device has completed the Manifestation\n\t// phase and is waiting for receipt of DFU_GETSTATUS. (Devices that can enter this state after\n\t// the Manifestation phase set bmAttributes bit bitManifestationTolerant to 1.)\n\tdfuMANIFEST_SYNC: 6,\n\t// Device is in the Manifestation phase. (Not all devices will be able to respond to DFU_GETSTATUS\n\t// when in this state.)\n\tdfuMANIFEST: 7,\n\t// Device has programmed its memories and is waiting for a USB reset or a power on reset. (Devices\n\t// that must enter this state clear bitManifestationTolerant to 0.)\n\tdfuMANIFEST_WAIT_RESET: 8,\n\t// The device is processing an upload operation. Expecting DFU_UPLOAD requests.\n\tdfuUPLOAD_IDLE: 9,\n\t// An error has occurred. Awaiting the DFU_CLRSTATUS request.\n\tdfuERROR: 10\n};\n\nconst DfuDeviceStateMap = Object.keys(DfuDeviceState).reduce((obj, key) => {\n\tobj[DfuDeviceState[key]] = key;\n\treturn obj;\n}, {});\n\n/**\n * DFU with ST Microsystems extensions.\n *\n * AN3156: USB DFU protocol used in the STM32 bootloader.\n */\nconst DfuseCommand = {\n\tDFUSE_COMMAND_NONE: 0xff,\n\tDFUSE_COMMAND_GET_COMMAND: 0x00,\n\tDFUSE_COMMAND_SET_ADDRESS_POINTER: 0x21,\n\tDFUSE_COMMAND_ERASE: 0x41,\n\tDFUSE_COMMAND_READ_UNPROTECT: 0x92,\n\tDFUSE_COMMAND_ENTER_SAFE_MODE: 0xfa, // Particle's extension\n\tDFUSE_COMMAND_CLEAR_SECURITY_MODE_OVERRIDE: 0xfb // ditto\n};\n\nconst DfuBmRequestType = {\n\tHOST_TO_DEVICE: 0x21,\n\tDEVICE_TO_HOST: 0xA1\n};\n\nconst DFU_STATUS_SIZE = 6;\n// FIXME:\nconst DEFAULT_INTERFACE = 0;\nconst DEFAULT_ALTERNATE = 0;\n\nconst DEFAULT_TRANSFER_SIZE = 1024;\n\nclass Dfu {\n\tconstructor(dev, logger) {\n\t\tthis._dev = dev;\n\t\tthis._log = logger;\n\t\tthis._interface = DEFAULT_INTERFACE;\n\t\tthis._alternate = DEFAULT_ALTERNATE;\n\t\tthis._claimed = false;\n\t\tthis._memoryInfo = null;\n\t\tthis._transferSize = DEFAULT_TRANSFER_SIZE;\n\t\tthis._allInterfaces = [];\n\t}\n\n\t/**\n\t * Open DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync open() {\n\t\tawait this._dev.claimInterface(this._interface);\n\t\tthis._claimed = true;\n\t\tawait this._dev.setAltSetting(this._interface, this._alternate);\n\t\tlet desc = await this._getConfigDescriptor(0); // Use the default config\n\t\tdesc = this._parseConfigDescriptor(desc);\n\t\tthis._allInterfaces = desc.interfaces;\n\t\tthis._supportedDfuseCommands = [];\n\t}\n\n\t/**\n\t * Close DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync close() {\n\t\tif (this._claimed) {\n\t\t\treturn this._dev.releaseInterface(this._interface);\n\t\t}\n\t}\n\n\t/**\n\t * Leave DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync leave() {\n\t\tawait this._goIntoIdleState({ dnloadIdle: true });\n\n\t\tawait this._sendDnloadRequest(Buffer.alloc(0), 2);\n\n\t\tawait this._pollUntil(\n\t\t\t// Wait for dfuDNLOAD_IDLE in case of Gen2 and for dfuMANIFEST in case of Gen3 and above.\n\t\t\t// This is a workaround for Gen 2 DFU implementation where in order to please dfu-util\n\t\t\t// for some reason we are going off-standard and instead of reporting the actual dfuMANIFEST state\n\t\t\t// report dfuDNLOAD_IDLE :|\n\t\t\tstate => (state === DfuDeviceState.dfuMANIFEST || state === DfuDeviceState.dfuDNLOAD_IDLE));\n\t}\n\n\t/**\n\t * Enter safe mode.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync enterSafeMode() {\n\t\tawait this._checkDfuseCommandSupported(DfuseCommand.DFUSE_COMMAND_ENTER_SAFE_MODE);\n\t\tawait this._goIntoIdleState({ dnloadIdle: true });\n\t\tconst data = Buffer.alloc(1);\n\t\tdata[0] = DfuseCommand.DFUSE_COMMAND_ENTER_SAFE_MODE;\n\t\tawait this._sendDnloadRequest(data, 0 /* wValue */);\n\t\tawait this._pollUntil((state) => state === DfuDeviceState.dfuMANIFEST);\n\t}\n\n\t/**\n\t * Re-enable device protection.\n\t *\n\t * @returns {Promise}\n\t */\n\tasync clearSecurityModeOverride() {\n\t\tawait this._checkDfuseCommandSupported(DfuseCommand.DFUSE_COMMAND_CLEAR_SECURITY_MODE_OVERRIDE);\n\t\tawait this._goIntoIdleState({ dnloadIdle: true });\n\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_CLEAR_SECURITY_MODE_OVERRIDE);\n\t}\n\n\t/**\n\t * Get the protection state of the device.\n\t * A device with protection enabled will have all segments not readable and not writeable.\n\t *\n\t * @return {Promise} Object with property 'protected'\n\t */\n\tasync getProtectionState() {\n\t\ttry {\n\t\t\tconst res = await this._getStringDescriptor(0xfa);\n\t\t\tconst state = res.split(';').find(kv => kv.startsWith('sm=')).split('=')[1].trim().charAt(0);\n\t\t\tswitch (state) {\n\t\t\t\tcase 'o': return { protected: false, overridden: false };\n\t\t\t\tcase 'p': return { protected: true };\n\t\t\t\tcase 's': return { protected: false, overridden: true };\n\t\t\t\tdefault: throw new Error('Unknown device state');\n\t\t\t}\n\t\t} catch (error) {\n\t\t\t// Fallback for devices with Device-OS < 6.1.2\n\t\t\tawait this.setAltSetting(0); // setting 0 is for Internal Flash\n\n\t\t\tconst allSegmentsProtected = this._memoryInfo.segments.every(s =>\n\t\t\t\ts.erasable === true && s.writable === false && s.readable === false\n\t\t\t);\n\n\t\t\t// Use `null` for `overridden` since we cannot distinguish between Open and Service Mode\n\t\t\treturn { protected: allSegmentsProtected, overridden: null };\n\t\t}\n\t}\n\n\t/**\n\t * Set the alternate interface for DFU and initialize memory information.\n\t *\n\t * @param {number} setting - The alternate interface index to set.\n\t * @return {Promise}\n\t */\n\tasync setAltSetting(setting) {\n\t\tlet iface = null;\n\t\tlet xferSize = null;\n\t\tfor (const i of this._allInterfaces) {\n\t\t\tif (i.bInterfaceNumber === this._interface) {\n\t\t\t\tif (!iface && i.bAlternateSetting === setting) {\n\t\t\t\t\tiface = i;\n\t\t\t\t\tif (i.dfuFunctional) {\n\t\t\t\t\t\txferSize = i.dfuFunctional.wTransferSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (xferSize) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// DFU_FUNCTIONAL descriptor may not be available for each interface with the given number\n\t\t\t\tif (!xferSize && i.dfuFunctional) {\n\t\t\t\t\txferSize = i.dfuFunctional.wTransferSize;\n\t\t\t\t\tif (iface) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!iface) {\n\t\t\tthrow new Error('Invalid alternate setting');\n\t\t}\n\t\tif (!iface.iInterface) {\n\t\t\tthrow new Error('Missing string descriptor');\n\t\t}\n\t\tconst ifaceName = await this._getStringDescriptor(iface.iInterface);\n\t\tconst memInfo = this._parseMemoryDescriptor(ifaceName);\n\t\tawait this._dev.setAltSetting(this._interface, setting);\n\t\tthis._transferSize = xferSize || DEFAULT_TRANSFER_SIZE;\n\t\tthis._memoryInfo = memInfo;\n\t\tthis._alternate = setting;\n\t}\n\n\t/**\n\t * Perform DFU download of binary data to the device.\n\t *\n\t * @param {Object} options Options.\n\t * @param {number} options.startAddr - The starting address to write the data.\n\t * @param {Buffer} options.data - The binary data to write.\n\t * @param {boolean} [options.noErase] - Skip erasing the device memory.\n\t * @param {boolean} [options.leave] - Leave DFU mode after download.\n\t * @param {function} [options.progress] - Callback function used to log progress.\n\t * @return {Promise}\n\t */\n\tasync doDownload({ startAddr, data, noErase, leave, progress }) {\n\t\tif (!this._memoryInfo || !this._memoryInfo.segments) {\n\t\t\tthrow new Error('No memory map available');\n\t\t}\n\n\t\tconst startAddress = startAddr;\n\t\tconst segment = this._getSegment(startAddr);\n\n\t\tif (segment === null) {\n\t\t\tthis._log.error(`Start address 0x${startAddress.toString(16)} outside of memory map bounds`);\n\t\t}\n\t\tif (segment && !segment.writable) {\n\t\t\tthrow new DeviceProtectionError('Segment is not writable');\n\t\t}\n\n\t\tconst expectedSize = data.byteLength;\n\n\t\tif (!noErase) {\n\t\t\tthis._log.info('Erasing DFU device memory');\n\t\t\tawait this._erase(startAddress, expectedSize, progress);\n\t\t}\n\n\t\tthis._log.info('Copying binary data to DFU device startAddress=' + startAddress + ' total_expected_size=' + expectedSize);\n\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-download', bytes: expectedSize });\n\t\t}\n\t\tlet bytesSent = 0;\n\t\tlet address = startAddress;\n\t\twhile (bytesSent < expectedSize) {\n\t\t\tconst bytesLeft = expectedSize - bytesSent;\n\t\t\tconst chunkSize = Math.min(bytesLeft, this._transferSize);\n\n\t\t\tlet dfuStatus;\n\t\t\ttry {\n\t\t\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_SET_ADDRESS_POINTER, address);\n\t\t\t\tthis._log.trace(`Set address to 0x${address.toString(16)}`);\n\t\t\t\tawait this._sendDnloadRequest(data.slice(bytesSent, bytesSent + chunkSize), 2);\n\t\t\t\tdfuStatus = await this._pollUntil(state => (state === DfuDeviceState.dfuDNLOAD_IDLE));\n\t\t\t\tthis._log.trace('Sent ' + chunkSize + ' bytes');\n\t\t\t\taddress += chunkSize;\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Error during DfuSe download: ' + error);\n\t\t\t}\n\n\t\t\tif (dfuStatus.status !== DfuDeviceStatus.OK) {\n\t\t\t\tif (progress) {\n\t\t\t\t\tprogress({ event: 'failed-download' });\n\t\t\t\t}\n\t\t\t\tthrow new Error(`DFU DOWNLOAD failed state=${dfuStatus.state}, status=${dfuStatus.status}`);\n\t\t\t}\n\n\t\t\tthis._log.trace('Wrote ' + chunkSize + ' bytes');\n\t\t\tbytesSent += chunkSize;\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'downloaded', bytes: chunkSize });\n\t\t\t}\n\t\t}\n\t\tthis._log.info(`Wrote ${bytesSent} bytes total`);\n\t\tif (progress) {\n\t\t\tprogress({ event: 'complete-download', bytes: bytesSent });\n\t\t}\n\n\t\tif (leave) {\n\t\t\tthis._log.info('Manifesting new firmware');\n\t\t\ttry {\n\t\t\t\tawait this.leave();\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Error during Dfu manifestation: ' + error);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _goIntoIdleState({ dnloadIdle = false, uploadIdle = false } = {}) {\n\t\ttry {\n\t\t\tconst state = await this._getStatus();\n\t\t\tif (state.state === DfuDeviceState.dfuERROR) {\n\t\t\t\t// If we are in dfuERROR state, simply issue DFU_CLRSTATUS and we'll go into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\n\t\t\tif (state.state !== DfuDeviceState.dfuIDLE &&\n\t\t\t\t\t!(dnloadIdle && state.state === DfuDeviceState.dfuDNLOAD_IDLE) &&\n\t\t\t\t\t!(uploadIdle && state.state === DfuDeviceState.dfuUPLOAD_IDLE)) {\n\t\t\t\t// If we are in some kind of an unknown state, issue DFU_CLRSTATUS, which may fail,\n\t\t\t\t// but the device will go into dfuERROR state, so a subsequent DFU_CLRSTATUS will get us\n\t\t\t\t// into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// DFU_GETSTATUS or DFU_CLRSTATUS failed, we are most likely in dfuERROR state, clear it\n\t\t\tawait this._clearStatus();\n\t\t}\n\n\t\t// Confirm we are in dfuIDLE or, optionally, in dfuDNLOAD_IDLE or dfuUPLOAD_IDLE\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== DfuDeviceState.dfuIDLE &&\n\t\t\t\t!(dnloadIdle && state.state === DfuDeviceState.dfuDNLOAD_IDLE) &&\n\t\t\t\t!(uploadIdle && state.state === DfuDeviceState.dfuUPLOAD_IDLE)) {\n\t\t\tthrow new DfuError('Invalid state');\n\t\t}\n\t\treturn state;\n\t}\n\n\t/**\n\t * Sends a download request to the DFU device with the specified request and value.\n\t * This request is sent via nodeusb or webusb\n\t *\n\t * @param {Buffer} req The request data buffer to be sent to the device.\n\t * @param {number} wValue The value to be sent as part of the request.\n\t */\n\tasync _sendDnloadRequest(data, wValue) {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_DNLOAD,\n\t\t\twIndex: this._interface,\n\t\t\twValue: wValue\n\t\t};\n\t\treturn this._dev.transferOut(setup, data);\n\t}\n\n\tasync _sendUploadReqest(length, value) {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: DfuRequestType.DFU_UPLOAD,\n\t\t\twIndex: this._interface,\n\t\t\twValue: value,\n\t\t\twLength: length\n\t\t};\n\t\treturn this._dev.transferIn(setup);\n\t}\n\n\tasync _sendAbortRequest() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_ABORT,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this._dev.transferOut(setup, Buffer.alloc(0));\n\t}\n\n\t/**\n\t * Retrieves the status from the DFU (Device Firmware Upgrade) device.\n\t *\n\t * @returns {Promise<object>} A Promise that resolves with the status object containing status, pollTimeout, and state.\n\t * @throws {DfuError} If parsing the DFU_GETSTATUS response fails or the status/state is invalid.\n\t */\n\tasync _getStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: DfuRequestType.DFU_GETSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0,\n\t\t\twLength: DFU_STATUS_SIZE\n\t\t};\n\t\tconst data = await this._dev.transferIn(setup);\n\t\tif (!data || data.length !== DFU_STATUS_SIZE) {\n\t\t\tthrow new DfuError('Could not parse DFU_GETSTATUS response');\n\t\t}\n\t\tlet bStatusWithPollTimeout = data.readUInt32LE(0);\n\n\t\tconst bStatus = (bStatusWithPollTimeout & 0xff);\n\t\tbStatusWithPollTimeout >>= 8;\n\t\tconst bState = data.readUInt8(4);\n\t\tconst iString = data.readUInt8(5);\n\n\t\tconst stat = {\n\t\t\tstatus: bStatus,\n\t\t\tpollTimeout: bStatusWithPollTimeout,\n\t\t\tstate: bState\n\t\t};\n\t\tif (iString) {\n\t\t\t// decode the vendor specific string descriptor\n\t\t\ttry {\n\t\t\t\tconst description = await this._getStringDescriptor(iString);\n\t\t\t\tif (description && description.length) {\n\t\t\t\t\tstat.description = description;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\treturn stat;\n\t}\n\n\t/**\n\t * Poll until the given statePredicate is true or the device goes into dfuERROR state.\n\t *\n\t * @param {function} statePredicate - The function to check the device state.\n\t * @return {object} - The DFU status object after polling.\n\t */\n\tasync _pollUntil(statePredicate) {\n\t\tlet dfuStatus = await this._getStatus();\n\n\t\tfunction asyncSleep(durationMs) {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\t// this._log.trace('Sleeping for ' + durationMs + 'ms');\n\t\t\t\tsetTimeout(resolve, durationMs);\n\t\t\t});\n\t\t}\n\n\t\twhile (!statePredicate(dfuStatus.state) && dfuStatus.state !== DfuDeviceState.dfuERROR) {\n\t\t\tawait asyncSleep(dfuStatus.pollTimeout);\n\t\t\tdfuStatus = await this._getStatus();\n\t\t}\n\n\t\treturn dfuStatus;\n\t}\n\n\t/**\n\t * Sends the DFU_CLRSTATUS request to the DFU device to clear any error status.\n\t */\n\tasync _clearStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_CLRSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this._dev.transferOut(setup, Buffer.alloc(0));\n\t}\n\n\t/**\n\t * Parse the memory descriptor string and create a memory map.\n\t *\n\t * @param {string} desc - The memory descriptor string.\n\t * @return {object} - Memory map information.\n\t */\n\t_parseMemoryDescriptor(desc) {\n\t\tconst nameEndIndex = desc.indexOf('/');\n\t\tif (!desc.startsWith('@') || nameEndIndex === -1) {\n\t\t\tthrow new Error(`Not a DfuSe memory descriptor: \"${desc}\"`);\n\t\t}\n\n\t\tconst name = desc.substring(1, nameEndIndex).trim();\n\t\tconst segmentString = desc.substring(nameEndIndex);\n\n\t\tconst segments = [];\n\n\t\tconst sectorMultipliers = {\n\t\t\t' ': 1,\n\t\t\t'B': 1,\n\t\t\t'K': 1024,\n\t\t\t'M': 1048576\n\t\t};\n\n\t\tconst rgx = /\\/\\s*(0x[0-9a-fA-F]{1,8})\\s*\\/(\\s*[0-9]+\\s*\\*\\s*[0-9]+\\s?[ BKM]\\s*[abcdefg]\\s*,?\\s*)+/g;\n\t\tlet contiguousSegmentMatch;\n\t\twhile ((contiguousSegmentMatch = rgx.exec(segmentString)) !== null) {\n\t\t\tconst segmentRegex = /([0-9]+)\\s*\\*\\s*([0-9]+)\\s?([ BKM])\\s*([abcdefg])\\s*,?\\s*/g;\n\t\t\tlet startAddress = parseInt(contiguousSegmentMatch[1], 16);\n\t\t\tlet segmentMatch;\n\t\t\twhile ((segmentMatch = segmentRegex.exec(contiguousSegmentMatch[0])) !== null) {\n\t\t\t\tconst segment = {};\n\t\t\t\tconst sectorCount = parseInt(segmentMatch[1], 10);\n\t\t\t\tconst sectorSize = parseInt(segmentMatch[2]) * sectorMultipliers[segmentMatch[3]];\n\t\t\t\tconst properties = segmentMatch[4].charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t\tsegment.start = startAddress;\n\t\t\t\tsegment.sectorSize = sectorSize;\n\t\t\t\tsegment.end = startAddress + sectorSize * sectorCount;\n\t\t\t\tsegment.readable = (properties & 0x1) !== 0;\n\t\t\t\tsegment.erasable = (properties & 0x2) !== 0;\n\t\t\t\tsegment.writable = (properties & 0x4) !== 0;\n\t\t\t\tsegments.push(segment);\n\n\t\t\t\tstartAddress += sectorSize * sectorCount;\n\t\t\t}\n\t\t}\n\n\t\treturn { 'name': name, 'segments': segments };\n\t}\n\n\t/**\n\t * Send a DfuSe command to the DFU device.\n\t *\n\t * @param {number} command - The DfuSe command to send.\n\t * @param {number} param - Optional. The parameter for the command.\n\t * @param {number} len - Optional. The length of the command payload.\n\t * @return {Promise}\n\t */\n\tasync _dfuseCommand(command, param) {\n\t\tif (typeof param === 'undefined') {\n\t\t\tparam = 0x00;\n\t\t}\n\n\t\tconst commandNames = {\n\t\t\t[DfuseCommand.DFUSE_COMMAND_GET_COMMAND]: 'GET_COMMANDS',\n\t\t\t[DfuseCommand.DFUSE_COMMAND_SET_ADDRESS_POINTER]: 'SET_ADDRESS',\n\t\t\t[DfuseCommand.DFUSE_COMMAND_ERASE]: 'ERASE_SECTOR',\n\t\t\t[DfuseCommand.DFUSE_COMMAND_READ_UNPROTECT]: 'READ_UNPROTECT',\n\t\t\t[DfuseCommand.DFUSE_COMMAND_ENTER_SAFE_MODE]: 'ENTER_SAFE_MODE',\n\t\t\t[DfuseCommand.DFUSE_COMMAND_CLEAR_SECURITY_MODE_OVERRIDE]: 'CLEAR_SECURITY_MODE_OVERRIDE'\n\t\t};\n\n\t\tconst payload = Buffer.alloc(5);\n\t\tpayload.writeUInt8(command, 0);\n\t\tpayload.writeUInt32LE(param, 1);\n\n\t\tfor (let triesLeft = 4; triesLeft >= 0; triesLeft--) {\n\t\t\ttry {\n\t\t\t\tawait this._sendDnloadRequest(payload, 0);\n\t\t\t\tbreak;\n\t\t\t} catch (error) {\n\t\t\t\tif (triesLeft === 0 || !(error instanceof UsbStallError)) {\n\t\t\t\t\tthrow new Error('Error during special DfuSe command ' + commandNames[command] + ':' + error);\n\t\t\t\t}\n\t\t\t\tthis._log.trace('dfuse error, retrying', error);\n\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\n\t\t\t}\n\t\t}\n\n\t\tconst status = await this._pollUntil(state => (state !== DfuDeviceState.dfuDNBUSY));\n\t\tif (status.status !== DfuDeviceStatus.OK) {\n\t\t\tthrow new Error('Special DfuSe command failed');\n\t\t}\n\t}\n\n\t/**\n\t * Get the memory segment that contains the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding memory segment.\n\t * @return {object|null} - The memory segment containing the address, or null if not found.\n\t */\n\t_getSegment(addr) {\n\t\tif (!this._memoryInfo || !this._memoryInfo.segments) {\n\t\t\tthrow new Error('No memory map information available');\n\t\t}\n\n\t\tfor (const segment of this._memoryInfo.segments) {\n\t\t\tif (segment.start <= addr && addr < segment.end) {\n\t\t\t\treturn segment;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the start address of the sector containing the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding sector start address.\n\t * @param {object} segment - Optional. The memory segment containing the address. If not provided, it will be looked up.\n\t * @return {number} - The start address of the sector.\n\t */\n\t_getSectorStart(addr, segment) {\n\t\tif (typeof segment === 'undefined') {\n\t\t\tsegment = this._getSegment(addr);\n\t\t}\n\n\t\tif (!segment) {\n\t\t\tthrow new Error(`Address ${addr.toString(16)} outside of memory map`);\n\t\t}\n\n\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\treturn segment.start + sectorIndex * segment.sectorSize;\n\t}\n\n\t/**\n\t * Get the end address of the sector containing the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding sector end address.\n\t * @param {object} segment - Optional. The memory segment containing the address. If not provided, it will be looked up.\n\t * @return {number} - The end address of the sector.\n\t */\n\t_getSectorEnd(addr, segment) {\n\t\tif (typeof segment === 'undefined') {\n\t\t\tsegment = this._getSegment(addr);\n\t\t}\n\n\t\tif (!segment) {\n\t\t\tthrow new Error(`Address ${addr.toString(16)} outside of memory map`);\n\t\t}\n\n\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\treturn segment.start + (sectorIndex + 1) * segment.sectorSize;\n\t}\n\n\t/**\n\t * Erases the memory of the DFU device starting from the specified address and for the given length.\n\t * This method erases memory sectors that are marked as erasable in the memory map.\n\t *\n\t * @param {number} startAddr The starting address of the memory range to be erased.\n\t * @param {number} length The length of the memory range to be erased in bytes.\n\t * @throws {Error} If the start address or the length is outside the memory map bounds, or if erasing fails.\n\t */\n\tasync _erase(startAddr, length, progress) {\n\t\tlet segment = this._getSegment(startAddr);\n\t\tif (segment && !segment.erasable) {\n\t\t\tthrow new DeviceProtectionError('Segment is not erasable');\n\t\t}\n\t\tlet addr = this._getSectorStart(startAddr, segment);\n\t\tconst endAddr = this._getSectorEnd(startAddr + length - 1);\n\n\t\tlet bytesErased = 0;\n\t\tconst bytesToErase = endAddr - addr;\n\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-erase', bytes: bytesToErase });\n\t\t}\n\t\twhile (addr < endAddr) {\n\t\t\tif (segment.end <= addr) {\n\t\t\t\tsegment = this._getSegment(addr);\n\t\t\t}\n\t\t\tif (!segment.erasable) {\n\t\t\t\t// Skip over the non-erasable section\n\t\t\t\tbytesErased = Math.min(bytesErased + segment.end - addr, bytesToErase);\n\t\t\t\tif (progress) {\n\t\t\t\t\t// include a progress event for the skipped section to ensure total matches\n\t\t\t\t\tprogress({ event: 'erased', bytes: segment.end - addr });\n\t\t\t\t}\n\t\t\t\taddr = segment.end;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\t\tconst sectorAddr = segment.start + sectorIndex * segment.sectorSize;\n\t\t\tthis._log.trace(`Erasing ${segment.sectorSize}B at 0x${sectorAddr.toString(16)}`);\n\t\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_ERASE, sectorAddr);\n\t\t\taddr = sectorAddr + segment.sectorSize;\n\t\t\tbytesErased += segment.sectorSize;\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'erased', bytes: segment.sectorSize });\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _getStringDescriptor(index) {\n\t\t// Read the size of the descriptor\n\t\tlet d = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06, // GET_DESCRIPTOR\n\t\t\twValue: (0x03 /* STRING */ << 8) | (index & 0xff),\n\t\t\twIndex: 0x0409, // English (US)\n\t\t\twLength: 1\n\t\t});\n\t\tconst len = d.readUInt8(0); // bLength\n\t\t// Read the descriptor\n\t\td = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06,\n\t\t\twValue: (0x03 << 8) | (index & 0xff),\n\t\t\twIndex: 0x0409,\n\t\t\twLength: len\n\t\t});\n\t\t// Decode the UTF-16 data\n\t\tconst utf16 = [];\n\t\tlet offs = 2; // Skip bLength and bDescriptorType\n\t\twhile (offs < d.length) {\n\t\t\tutf16.push(d.readUInt16LE(offs));\n\t\t\toffs += 2;\n\t\t}\n\t\treturn String.fromCharCode(...utf16);\n\t}\n\n\tasync _getConfigDescriptor(index) {\n\t\t// Read the total size of the descriptors\n\t\tconst d = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06, // GET_DESCRIPTOR\n\t\t\twValue: (0x02 /* CONFIGURATION */ << 8) | (index & 0xff),\n\t\t\twIndex: 0,\n\t\t\twLength: 4\n\t\t});\n\t\tconst len = d.readUInt16LE(2); // wTotalLength\n\t\t// Read the descriptors\n\t\treturn await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06,\n\t\t\twValue: (0x02 << 8) | (index & 0xff),\n\t\t\twIndex: 0,\n\t\t\twLength: len\n\t\t});\n\t}\n\n\t_parseConfigDescriptor(data) {\n\t\t// https://www.beyondlogic.org/usbnutshell/usb5.shtml#ConfigurationDescriptors\n\t\tif (data.length < 9) {\n\t\t\tthrow new Error('Invalid descriptor size');\n\t\t}\n\t\tconst type = data.readUInt8(1); // bDescriptorType\n\t\tif (type !== 0x02) { // CONFIGURATION\n\t\t\tthrow new Error('Invalid descriptor type');\n\t\t}\n\t\tconst desc = {\n\t\t\tinterfaces: []\n\t\t};\n\t\tlet curIface = null;\n\t\tlet dfuExpected = false;\n\t\tlet offs = 9;\n\t\twhile (offs < data.length) {\n\t\t\tconst len = data.readUInt8(offs); // bLength\n\t\t\tconst type = data.readUInt8(offs + 1); // bDescriptorType\n\t\t\t// Only parse the interface descriptors for now\n\t\t\tswitch (type) {\n\t\t\t\tcase 0x04: { // INTERFACE\n\t\t\t\t\tconst cls = data.readUInt8(offs + 5); // bInterfaceClass\n\t\t\t\t\tconst subclass = data.readUInt8(offs + 6); // bInterfaceSubClass\n\t\t\t\t\tcurIface = {\n\t\t\t\t\t\tbLength: len,\n\t\t\t\t\t\tbDescriptorType: type,\n\t\t\t\t\t\tbInterfaceNumber: data.readUInt8(offs + 2),\n\t\t\t\t\t\tbAlternateSetting: data.readUInt8(offs + 3),\n\t\t\t\t\t\tbNumEndpoints: data.readUInt8(offs + 4),\n\t\t\t\t\t\tbInterfaceClass: cls,\n\t\t\t\t\t\tbInterfaceSubClass: subclass,\n\t\t\t\t\t\tbInterfaceProtocol: data.readUInt8(offs + 7),\n\t\t\t\t\t\tiInterface: data.readUInt8(offs + 8)\n\t\t\t\t\t};\n\t\t\t\t\tdesc.interfaces.push(curIface);\n\t\t\t\t\tdfuExpected = cls === 0xfe && subclass === 0x01; // 4.1.2 Run-Time DFU Interface Descriptor\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 0x21: { // DFU_FUNCTIONAL\n\t\t\t\t\tif (!dfuExpected) {\n\t\t\t\t\t\tthrow new Error('Unexpected descriptor');\n\t\t\t\t\t}\n\t\t\t\t\tcurIface.dfuFunctional = {\n\t\t\t\t\t\tbLength: len,\n\t\t\t\t\t\tbDescriptorType: type,\n\t\t\t\t\t\tbmAttributes: data.readUInt8(offs + 2),\n\t\t\t\t\t\twDetachTimeOut: data.readUInt16LE(offs + 3),\n\t\t\t\t\t\twTransferSize: data.readUInt16LE(offs + 5),\n\t\t\t\t\t\tbcdDFUVersion: data.readUInt16LE(offs + 7)\n\t\t\t\t\t};\n\t\t\t\t\tdfuExpected = false; // 4.1 Run-Time Descriptor Set\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffs += len;\n\t\t}\n\t\treturn desc;\n\t}\n\n\tasync doUpload({ startAddr, maxSize, progress }) {\n\t\tconst segment = this._getSegment(startAddr);\n\t\tif (segment && !segment.readable) {\n\t\t\tthrow new DeviceProtectionError('Segment is not readable');\n\t\t}\n\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== DfuDeviceState.dfuIDLE) {\n\t\t\tawait this._clearStatus(); // suggested by dfu-util\n\t\t\tawait this.abortToIdle();\n\t\t}\n\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_SET_ADDRESS_POINTER, startAddr);\n\t\tawait this.abortToIdle();\n\n\t\t// DfuSe encodes the read address based on the transfer size,\n\t\t// the block number - 2, and the SET_ADDRESS pointer.\n\t\tconst data = await this._doUploadImpl(maxSize, 2, progress);\n\t\treturn data;\n\t}\n\n\tasync _doUploadImpl(maxSize = Infinity, firstBlock = 0, progress) {\n\t\tlet transaction = firstBlock;\n\t\tconst blocks = [];\n\t\tlet bytesRead = 0;\n\n\t\tthis._log.trace('Copying data from DFU device to browser');\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-upload', bytes: maxSize });\n\t\t}\n\n\t\tlet result;\n\t\tlet bytesToRead;\n\t\tdo {\n\t\t\tbytesToRead = Math.min(this._transferSize, maxSize - bytesRead);\n\t\t\tresult = await this._sendUploadReqest(bytesToRead, transaction++);\n\t\t\tthis._log.trace('Read ' + result.byteLength + ' bytes');\n\t\t\tif (result.byteLength > 0) {\n\t\t\t\tblocks.push(Buffer.from(result));\n\t\t\t\tbytesRead += result.byteLength;\n\t\t\t}\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'uploaded', bytes: bytesRead });\n\t\t\t}\n\t\t} while ((bytesRead < maxSize) && (result.byteLength === bytesToRead));\n\n\t\tif (bytesRead === maxSize) {\n\t\t\tawait this.abortToIdle();\n\t\t}\n\n\t\tthis._log.trace(`Read ${bytesRead} bytes`);\n\t\tif (progress) {\n\t\t\tprogress({ event: 'complete-upload', bytes: bytesRead });\n\t\t}\n\n\t\treturn Buffer.concat(blocks);\n\t}\n\n\tasync abortToIdle() {\n\t\tawait this._sendAbortRequest();\n\t\tlet state = await this._getStatus();\n\t\tif (state.state === DfuDeviceState.dfuERROR) {\n\t\t\tawait this._clearStatus();\n\t\t\tstate = await this._getStatus();\n\t\t}\n\t\tif (state.state !== DfuDeviceState.dfuIDLE) {\n\t\t\tthrow new Error('Failed to return to idle state after abort: state ' + state.state);\n\t\t}\n\t}\n\n\tasync _checkDfuseCommandSupported(cmd) {\n\t\tif (!this._supportedDfuseCommands.length) {\n\t\t\tawait this._goIntoIdleState({ uploadIdle: true });\n\t\t\tconst data = await this._sendUploadReqest(DEFAULT_TRANSFER_SIZE, 0 /* value */); // Get command\n\t\t\tthis._supportedDfuseCommands = [...data];\n\t\t}\n\t\tif (!this._supportedDfuseCommands.includes(cmd)) {\n\t\t\tthrow new UnsupportedDfuseCommandError('Unsupported DfuSe command');\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\tDfuError,\n\tDfuRequestType,\n\tDfuDeviceStatus,\n\tDfuDeviceStatusMap,\n\tDfuDeviceState,\n\tDfuDeviceStateMap,\n\tDfuseCommand,\n\tDfuBmRequestType,\n\tDFU_STATUS_SIZE,\n\tDfu\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/dfu.js?");

/***/ }),

/***/ "./src/edl-device.js":
/*!***************************!*\
  !*** ./src/edl-device.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { getUsbDevices } = __webpack_require__(/*! ./usb-device-node */ \"./src/usb-device-webusb.js\");\n\nconst VENDOR_ID_QUALCOMM = 0x05c6;\nconst PRODUCT_ID_EDL_DEVICE = 0x9008;\n\nclass EdlDevice {\n\tconstructor({ serialNumber }) {\n\t\tthis.serialNumber = serialNumber;\n\t}\n\n\tstatic async getEdlDevices() {\n\t\tconst filters = [\n\t\t\t{\n\t\t\t\tvendorId: VENDOR_ID_QUALCOMM,\n\t\t\t\tproductId: PRODUCT_ID_EDL_DEVICE\n\t\t\t}\n\t\t];\n\t\tconst devs = await getUsbDevices(filters);\n\t\treturn Promise.all(devs.map(async (dev) => {\n\t\t\ttry {\n\t\t\t\tawait dev.open();\n\t\t\t\tconst serialNumber = dev.productName.replace(/.*_SN:/, '');\n\t\t\t\treturn new EdlDevice({ serialNumber });\n\t\t\t} finally {\n\t\t\t\tdev.close();\n\t\t\t}\n\t\t}));\n\t}\n}\n\nmodule.exports = {\n\tEdlDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/edl-device.js?");

/***/ }),

/***/ "./src/error.js":
/*!**********************!*\
  !*** ./src/error.js ***!
  \**********************/
/***/ ((module) => {

eval("/**\n * Generic device error. This is a base class for all errors reported by the library.\n */\nclass DeviceError extends Error {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a requested resource cannot be found.\n */\nclass NotFoundError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a requested operation is not permitted.\n */\nclass NotAllowedError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when an object is not in an appropriate state to perform an operation.\n */\nclass StateError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Timeout error.\n */\nclass TimeoutError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a device has no enough memory to perform an operation.\n */\nclass MemoryError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Protocol error.\n */\nclass ProtocolError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * USB error.\n */\nclass UsbError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Internal error.\n */\nclass InternalError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Request error.\n */\nclass RequestError extends DeviceError {\n\tconstructor(result, ...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t\tthis.result = result;\n\t}\n}\n\n/**\n * USB stall error.\n */\nclass UsbStallError extends UsbError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Device Protection error.\n */\nclass DeviceProtectionError extends DeviceError {\n\tconstructor(result, ...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t\tthis.result = result;\n\t}\n}\n\n/**\n * An error reported when the issued DfuSe command is not supported by the device.\n */\nclass UnsupportedDfuseCommandError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\nfunction assert(val, msg = null) {\n\tif (!val) {\n\t\tthrow new InternalError(msg ? msg : 'Assertion failed');\n\t}\n}\n\nmodule.exports = {\n\tDeviceError,\n\tNotFoundError,\n\tNotAllowedError,\n\tStateError,\n\tTimeoutError,\n\tMemoryError,\n\tProtocolError,\n\tUsbError,\n\tInternalError,\n\tRequestError,\n\tUsbStallError,\n\tDeviceProtectionError,\n\tUnsupportedDfuseCommandError,\n\tassert\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/error.js?");

/***/ }),

/***/ "./src/gen3-device.js":
/*!****************************!*\
  !*** ./src/gen3-device.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\n\n/**\n * Gen 3 device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst Gen3Device = (base) => class extends base {\n\t/**\n\t * Set the setup done flag.\n\t *\n\t * @param {Boolean} [done] Flag value.\n\t * @return {Promise}\n\t */\n\tasync setSetupDone(done) {\n\t\tif (done === undefined) {\n\t\t\tdone = true;\n\t\t}\n\t\tawait this.sendRequest(Request.SET_DEVICE_SETUP_DONE, { done });\n\t}\n\n\t/**\n\t * Set to `true` if this is a Gen 3 device.\n\t */\n\tget isGen3Device() {\n\t\treturn true;\n\t}\n};\n\nmodule.exports = {\n\tGen3Device\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/gen3-device.js?");

/***/ }),

/***/ "./src/linux-device.js":
/*!*****************************!*\
  !*** ./src/linux-device.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { DeviceBase } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { DeviceMode } = __webpack_require__(/*! ./device */ \"./src/device.js\");\n\n/**\n * Base class for Linux devices.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass LinuxDevice extends DeviceBase {\n\t/**\n\t * Get the device mode.\n\t *\n\t * @return {Promise<DeviceMode>}\n\t */\n\tasync getDeviceMode() {\n\t\treturn DeviceMode.NORMAL;\n\t}\n}\n\nmodule.exports = {\n\tLinuxDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/linux-device.js?");

/***/ }),

/***/ "./src/network-device.js":
/*!*******************************!*\
  !*** ./src/network-device.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst { convertBufferToMacAddress } = __webpack_require__(/*! ./address-util.js */ \"./src/address-util.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { definitions: proto } = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\nconst { Address4, Address6 } = __webpack_require__(/*! ip-address */ \"./node_modules/ip-address/dist/ip-address.js\");\nconst { NotFoundError } = __webpack_require__(/*! ./error.js */ \"./src/error.js\");\n\nconst DEFAULT_INTERFACE = 1;\n\n/**\n * Network status.\n */\nconst NetworkStatus = fromProtobufEnum(proto.NetworkState, {\n\tDOWN: 'DOWN',\n\tUP: 'UP'\n});\n\nconst InterfaceType = fromProtobufEnum(proto.InterfaceType, {\n\tINVALID : 'INVALID_INTERFACE_TYPE',\n\tLOOPBACK : 'LOOPBACK',\n\tTHREAD : 'THREAD',\n\tETHERNET : 'ETHERNET',\n\tWIFI : 'WIFI',\n\tPPP : 'PPP'\n});\n\nconst InterfaceConfigurationSource = fromProtobufEnum(proto.InterfaceConfigurationSource, {\n\tNONE: 'NONE',\n\tDHCP: 'DHCP',\n\tSTATIC: 'STATIC',\n\tSLAAC: 'SLAAC',\n\tDHCPV6: 'DHCPV6'\n});\n\nconst InterfaceFlag = fromProtobufEnum(proto.InterfaceFlag, {\n\tNONE: 'IFF_NONE',\n\tUP: 'IFF_UP',\n\tBROADCAST: 'IFF_BROADCAST',\n\tDEBUG: 'IFF_DEBUG',\n\tLOOPBACK: 'IFF_LOOPBACK',\n\tPOINTOPOINT: 'IFF_POINTTOPOINT',\n\tRUNNING : 'IFF_RUNNING',\n\tLOWER_UP : 'IFF_LOWER_UP',\n\tNOARP : 'IFF_NOARP',\n\tPROMISC : 'IFF_PROMISC',\n\tALLMULTI : 'IFF_ALLMULTI',\n\tMULTICAST : 'IFF_MULTICAST',\n\tNOND6 : 'IFF_NOND6'\n});\n\n/**\n* Converts a given interface IP address into a string\n*\n* @param {object} ifaceAddr Object with address and prefixLength keys\n* @returns {string} address in ${ip}/${prefixLength} format\n*/\nfunction convertInterfaceAddress(ifaceAddr) {\n\tif (!ifaceAddr || !ifaceAddr.address) {\n\t\treturn ifaceAddr;\n\t}\n\n\tconst ip = convertIpv4Address(ifaceAddr.address.v4) || convertIpv6Address(ifaceAddr.address.v6);\n\treturn `${ip}/${ifaceAddr.prefixLength}`;\n}\n\n/**\n * Converts an IPv4 to a string\n *\n * @param {object} addr Object with the IP encoded as int32 in the address key\n * @returns {string} address in dotted-decimal format\n */\nfunction convertIpv4Address(addr) {\n\tif (!addr) {\n\t\treturn addr;\n\t}\n\n\treturn Address4.fromInteger(addr.address).address;\n}\n\n/**\n * Converts an IPv6 to a string\n *\n * @param {object} addr Object with the IP encoded as a buffer in the address key\n * @returns {string} address in colon-separated format\n */\nfunction convertIpv6Address(addr) {\n\tif (!addr) {\n\t\treturn addr;\n\t}\n\n\treturn Address6.fromByteArray(addr.address).address;\n}\n\n/**\n * Network device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst NetworkDevice = base => class extends base {\n\t/**\n\t * Get network status.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetNetworkStatus() {\n\t\treturn this.sendRequest(Request.NETWORK_GET_STATUS, {\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t}).then(rep => NetworkStatus.fromProtobuf(rep.config.state));\n\t}\n\n\t/**\n\t * Get network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Object>}\n\t */\n\tgetNetworkConfig() {\n\t\treturn this.sendRequest(Request.NETWORK_GET_CONFIGURATION, { // TODO\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t});\n\t}\n\n\t/**\n\t * Set network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} config Network configuration.\n\t * @return {Promise}\n\t */\n\tsetNetworkConfig(config) {\n\t\treturn this.sendRequest(Request.NETWORK_SET_CONFIGURATION, config); // TODO\n\t}\n\n\t/**\n\t * Gets the list of network interfaces\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Object>}\n\t */\n\tasync getNetworkInterfaceList({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst res = await this.sendRequest(Request.NETWORK_GET_INTERFACE_LIST, null, { timeout });\n\t\treturn res.interfaces.map(entry => ({\n\t\t\tindex: entry.index,\n\t\t\tname: entry.name,\n\t\t\ttype: InterfaceType.fromProtobuf(entry.type)\n\t\t}));\n\t}\n\n\t// Helper function to get active flags of a network interface\n\t_getActiveFlags(flags, flagDefinitions) {\n\t\tconst activeFlags = [];\n\t\tfor (const value of Object.values(flagDefinitions)) {\n\t\t\tif (value !== 0 && (flags & value)) {\n\t\t\t\tactiveFlags.push(value);\n\t\t\t}\n\t\t}\n\t\treturn activeFlags;\n\t}\n\n\t/**\n\t * Gets the network interface and its fields\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Object>}\n\t */\n\tasync getNetworkInterface({ index, timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst reply = await this.sendRequest(Request.NETWORK_GET_INTERFACE, { index, timeout });\n\n\t\tif (!reply.interface) {\n\t\t\tthrow new NotFoundError();\n\t\t}\n\n\t\tconst {\n\t\t\tindex: ifaceIndex,\n\t\t\tname,\n\t\t\ttype,\n\t\t\tflags,\n\t\t\textFlags,\n\t\t\tipv4Config,\n\t\t\tipv6Config,\n\t\t\thwAddress,\n\t\t\tmtu,\n\t\t\tmetric,\n\t\t\tprofile\n\t\t} = reply.interface;\n\n\t\tconst activeFlags = this._getActiveFlags(flags, proto.InterfaceFlag);\n\t\tlet flagsStrings = activeFlags.map(flag => InterfaceFlag.fromProtobuf(flag));\n\t\tflagsStrings = [...new Set(flagsStrings)];\n\n\t\tconst result = {\n\t\t\tindex: ifaceIndex,\n\t\t\tname,\n\t\t\ttype: InterfaceType.fromProtobuf(type),\n\t\t\thwAddress: convertBufferToMacAddress(hwAddress),\n\t\t\tmtu,\n\t\t\tflagsVal: flags,\n\t\t\textFlags,\n\t\t\tflagsStrings,\n\t\t\tmetric,\n\t\t\tprofile\n\t\t};\n\n\t\tif (ipv4Config) {\n\t\t\tresult.ipv4Config = {\n\t\t\t\taddresses: ipv4Config.addresses.map(convertInterfaceAddress),\n\t\t\t\tgateway: convertIpv4Address(ipv4Config.gateway),\n\t\t\t\tpeer: convertIpv4Address(ipv4Config.peer),\n\t\t\t\tdns: ipv4Config.dns.map(convertIpv4Address),\n\t\t\t\tsource: InterfaceConfigurationSource.fromProtobuf(ipv4Config.source)\n\t\t\t};\n\t\t}\n\n\t\tif (ipv6Config) {\n\t\t\tresult.ipv6Config = {\n\t\t\t\taddresses: ipv6Config.addresses.map(convertInterfaceAddress),\n\t\t\t\tgateway: convertIpv6Address(ipv6Config.gateway),\n\t\t\t\tdns: ipv6Config.dns.map(convertIpv6Address),\n\t\t\t\tsource: InterfaceConfigurationSource.fromProtobuf(ipv6Config.source)\n\t\t\t};\n\t\t}\n\n\t\treturn result;\n\t}\n};\n\nmodule.exports = {\n\tNetworkStatus,\n\tNetworkDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/network-device.js?");

/***/ }),

/***/ "./src/particle-usb.js":
/*!*****************************!*\
  !*** ./src/particle-usb.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { getDevices: getUsbDevices, openDeviceById: openUsbDeviceById, openNativeUsbDevice: openUsbNativeUsbDevice } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { PollingPolicy } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { FirmwareModule, FirmwareModuleDisplayNames } = __webpack_require__(/*! ./device */ \"./src/device.js\");\nconst { NetworkStatus } = __webpack_require__(/*! ./network-device */ \"./src/network-device.js\");\nconst { WifiAntenna, WifiCipher, EapMethod, WifiSecurityEnum } = __webpack_require__(/*! ./wifi-device */ \"./src/wifi-device.js\");\nconst { WifiSecurity } = __webpack_require__(/*! ./wifi-device-legacy */ \"./src/wifi-device-legacy.js\");\nconst { CloudConnectionStatus, ServerProtocol } = __webpack_require__(/*! ./cloud-device */ \"./src/cloud-device.js\");\nconst { Result } = __webpack_require__(/*! ./result */ \"./src/result.js\");\nconst { DeviceError, NotFoundError, NotAllowedError, StateError, TimeoutError, MemoryError, ProtocolError, UsbError, InternalError, RequestError, DeviceProtectionError, UnsupportedDfuseCommandError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { config } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { setDevicePrototype } = __webpack_require__(/*! ./set-device-prototype */ \"./src/set-device-prototype.js\");\nconst { EdlDevice } = __webpack_require__(/*! ./edl-device */ \"./src/edl-device.js\");\n\n/**\n * Enumerate Particle USB devices attached to the host.\n *\n * @param {Object} options Options.\n * @param {Array<String>} [options.types] Device types (photon, boron, tracker, etc). By default, this\n *        function enumerates devices of all platforms supported by the library.\n * @param {Boolean} [options.includeDfu=true] Whether to include devices in DFU mode.\n * @return {Promise<Array<Device>>}\n */\nfunction getDevices(options) {\n\treturn getUsbDevices(options).then(devs => devs.map(dev => setDevicePrototype(dev)));\n}\n\n/**\n * Open a Particle USB device with the specified ID.\n *\n * @param {String} id Device ID.\n * @param {Object} [options] Options (see {@link DeviceBase#open}).\n * @return {Promise<Device>}\n */\nfunction openDeviceById(id, options) {\n\treturn openUsbDeviceById(id, options).then(dev => setDevicePrototype(dev));\n}\n\n/**\n * Open a Particle USB device from a native browser or node USB device handle\n *\n * @param {Object} nativeUsbDevice A WebUSB (browser) or node-usb USB device\n * @param {Object} [options] Options (see {@link DeviceBase#open}).\n * @return {Promise<Device>}\n */\nfunction openNativeUsbDevice(nativeUsbDevice, options) {\n\treturn openUsbNativeUsbDevice(nativeUsbDevice, options).then(dev => setDevicePrototype(dev));\n}\n\n/**\n * Get devices in Qualcomm EDL mode.\n *\n * @return {Promise<Array<EdlDevice>>}\n */\nfunction getEdlDevices() {\n\treturn EdlDevice.getEdlDevices();\n}\n\nmodule.exports = {\n\tPollingPolicy,\n\tFirmwareModule,\n\tFirmwareModuleDisplayNames,\n\tNetworkStatus,\n\tWifiAntenna,\n\tWifiSecurity,\n\tWifiSecurityEnum,\n\tWifiCipher,\n\tEapMethod,\n\tCloudConnectionStatus,\n\tServerProtocol,\n\tResult,\n\tDeviceError,\n\tNotFoundError,\n\tNotAllowedError,\n\tStateError,\n\tTimeoutError,\n\tMemoryError,\n\tProtocolError,\n\tUsbError,\n\tInternalError,\n\tRequestError,\n\tDeviceProtectionError,\n\tUnsupportedDfuseCommandError,\n\tgetDevices,\n\topenDeviceById,\n\topenNativeUsbDevice,\n\tgetEdlDevices,\n\tconfig\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/particle-usb.js?");

/***/ }),

/***/ "./src/platforms.js":
/*!**************************!*\
  !*** ./src/platforms.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const deviceConstants = __webpack_require__(/*! @particle/device-constants */ \"./node_modules/@particle/device-constants/dist/js/constants.json\");\n\nconst PLATFORMS = [];\n\nfor (let p of Object.values(deviceConstants)) {\n\tif (!p.usb && !p.dfu) {\n\t\tcontinue;\n\t}\n\tp = clone(p);\n\tif (p.usb) {\n\t\tp.usb = parseUsbInfo(p.usb);\n\t}\n\tif (p.dfu) {\n\t\tp.dfu = parseUsbInfo(p.dfu);\n\t}\n\tPLATFORMS.push(p);\n}\n\n// Convert the \"0x2b04\" id strings to 0x2b04 numbers\nfunction parseUsbInfo({ vendorId, productId, quirks }) {\n\treturn {\n\t\tvendorId: Number(vendorId),\n\t\tproductId: Number(productId),\n\t\tquirks: quirks || {}\n\t};\n}\n\nfunction clone(x) {\n\treturn JSON.parse(JSON.stringify(x));\n}\n\nmodule.exports = {\n\tPLATFORMS\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/platforms.js?");

/***/ }),

/***/ "./src/protobuf-util.js":
/*!******************************!*\
  !*** ./src/protobuf-util.js ***!
  \******************************/
/***/ ((module) => {

eval("/**\n * Get an object that maps values from a Protobuf enum value to a string value and vice versa,\n * using the provided mapping.\n *\n * @param {Object} pbEnum Protobuf enum object, imported from @particle/device-os-protobuf\n * @param {Object} map Object where the keys are application strings and values are Protobuf strings\n * @param {String} [unknownVal] Value to return when the Protobuf value is unknown. Defaults to UNKNOWN\n * @returns {Readonly<{fromProtobuf: ((function(*): (*|string))|*), toProtobuf: (function(*): *)}>}\n * Object with toProtobuf and fromProtobuf functions\n */\nfunction fromProtobufEnum(pbEnum, map, unknownVal) {\n\tconst mapToProtobuf = {};\n\tconst mapFromProtobuf = {};\n\tconst funcs = {\n\t\ttoProtobuf: (val) => {\n\t\t\tconst pbVal = mapToProtobuf[val.toLowerCase()];\n\t\t\tif (pbVal === undefined) {\n\t\t\t\tthrow new RangeError(`Invalid value: ${val}`);\n\t\t\t}\n\t\t\treturn pbVal;\n\t\t},\n\t\tfromProtobuf: (pbVal) => {\n\t\t\tconst val = mapFromProtobuf[pbVal];\n\t\t\tif (val === undefined) {\n\t\t\t\treturn (unknownVal !== undefined ? unknownVal : 'UNKNOWN');\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t};\n\tconst obj = Object.create(funcs);\n\tfor (const val in map) {\n\t\tconst pbName = map[val];\n\t\tconst pbVal = pbEnum[pbName];\n\t\tif (pbVal === undefined) {\n\t\t\tthrow new Error(`Unknown enum value: ${pbName}`);\n\t\t}\n\t\tconst v = val.toLowerCase();\n\t\tif (v in mapToProtobuf) {\n\t\t\tthrow new Error(`Duplicate value: ${val}`);\n\t\t}\n\t\tmapToProtobuf[v] = pbVal;\n\t\tmapFromProtobuf[pbVal] = val;\n\t\tobj[val] = val;\n\t}\n\treturn Object.freeze(obj);\n}\n\nfunction transformMessage(msg, map) {\n\tconst obj = {};\n\tfor (let name of Object.keys(msg)) { // Ignore prototype properties\n\t\tlet val = msg[name];\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m; // Rename property\n\t\t} else if (typeof m == 'function') {\n\t\t\tval = m(val); // Convert value\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name; // Rename property\n\t\t\t}\n\t\t\tif (m.value) {\n\t\t\t\tval = m.value(val); // Convert value\n\t\t\t}\n\t\t} else if (!m) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tif (val === undefined) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tobj[name] = val;\n\t}\n\treturn obj;\n}\n\nfunction checkFromProtobufMessageMap(pbMsgProto, map) {\n\tfor (const name in map) {\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction checkToProtobufMessageMap(pbMsgProto, map) {\n\tfor (let name in map) {\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m;\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name;\n\t\t\t}\n\t\t}\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction assignMessagePropertyMaps(obj, ...maps) {\n\tfor (let map of maps) {\n\t\tif (Array.isArray(map)) {\n\t\t\tmap = map.reduce((obj, name) => {\n\t\t\t\tobj[name] = true;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\t\t}\n\t\tObject.assign(obj, map);\n\t}\n\treturn obj;\n}\n\n// Returns a function that transforms a Protobuf message to an API object according to the provided mapping\n// DEPRECATED: don't use for new code. It's clearer to write mapping code directly\nfunction fromProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckFromProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\n// Returns a function that transforms an API object to a Protobuf message according to the provided mapping\n// DEPRECATED: don't use for new code. It's clearer to write mapping code directly\nfunction toProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckToProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\n/**\n * Checks for each bit in a value and returns an array of strings for each bit that is set\n * @param value The value to check\n * @param mapping A mapping created by fromProtobufEnum\n * @returns {Array<String>} Array of strings for each bit that is set\n */\nfunction extractBits(value, mapping) {\n\tconst names = [];\n\tlet bit = 1;\n\twhile (value) {\n\t\tconst hasBit = value & 1;\n\t\tconst name = mapping.fromProtobuf(bit);\n\t\tvalue >>= 1;\n\t\tbit <<= 1;\n\t\tif (!hasBit) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (name !== 'UNKNOWN') {\n\t\t\tnames.push(name);\n\t\t}\n\t}\n\treturn names;\n}\n\nmodule.exports = {\n\tfromProtobufEnum,\n\tfromProtobufMessage,\n\ttoProtobufMessage,\n\textractBits\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/protobuf-util.js?");

/***/ }),

/***/ "./src/request.js":
/*!************************!*\
  !*** ./src/request.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { definitions: proto } = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\n\n// Mapping of request types to Protobuf messages\nconst Request = {\n\tGET_DEVICE_ID: {\n\t\tid: 20,\n\t\trequest: proto.GetDeviceIdRequest,\n\t\treply: proto.GetDeviceIdReply\n\t},\n\tGET_SERIAL_NUMBER: {\n\t\tid: 21,\n\t\trequest: proto.GetSerialNumberRequest,\n\t\treply: proto.GetSerialNumberReply\n\t},\n\tRESET: {\n\t\tid: 40\n\t},\n\tFACTORY_RESET: {\n\t\tid: 41\n\t},\n\tDFU_MODE: {\n\t\tid: 50\n\t},\n\tSAFE_MODE: {\n\t\tid: 60\n\t},\n\tSTART_LISTENING: {\n\t\tid: 70\n\t},\n\tSTOP_LISTENING: {\n\t\tid: 71\n\t},\n\tGET_DEVICE_MODE: {\n\t\tid: 72,\n\t\trequest: proto.GetDeviceModeRequest,\n\t\treply: proto.GetDeviceModeReply\n\t},\n\tSET_DEVICE_SETUP_DONE: {\n\t\tid: 73,\n\t\trequest: proto.SetDeviceSetupDoneRequest,\n\t\treply: proto.SetDeviceSetupDoneReply\n\t},\n\tLOG_CONFIG: {\n\t\tid: 80\n\t},\n\tMODULE_INFO: {\n\t\tid: 90\n\t},\n\tDIAGNOSTIC_INFO: {\n\t\tid: 100\n\t},\n\tWIFI_SET_ANTENNA: {\n\t\tid: 110,\n\t\trequest: proto.WiFiSetAntennaRequest,\n\t\treply: proto.WiFiSetAntennaReply\n\t},\n\tWIFI_GET_ANTENNA: {\n\t\tid: 111,\n\t\trequest: proto.WiFiGetAntennaRequest,\n\t\treply: proto.WiFiGetAntennaReply\n\t},\n\tWIFI_SCAN: {\n\t\tid: 112,\n\t\trequest: proto.WiFiScanRequest,\n\t\treply: proto.WiFiScanReply\n\t},\n\tWIFI_SET_CREDENTIALS: {\n\t\tid: 113,\n\t\trequest: proto.WiFiSetCredentialsRequest,\n\t\treply: proto.WiFiSetCredentialsReply\n\t},\n\tWIFI_GET_CREDENTIALS: {\n\t\tid: 114,\n\t\trequest: proto.WiFiGetCredentialsRequest,\n\t\treply: proto.WiFiGetCredentialsReply\n\t},\n\tWIFI_CLEAR_CREDENTIALS: {\n\t\tid: 115,\n\t\trequest: proto.WiFiClearCredentialsRequest,\n\t\treply: proto.WiFiClearCredentialsReply\n\t},\n\tNETWORK_SET_CONFIGURATION: {\n\t\tid: 120,\n\t\trequest: proto.NetworkSetConfigurationRequest,\n\t\treply: proto.NetworkSetConfigurationReply\n\t},\n\tNETWORK_GET_CONFIGURATION: {\n\t\tid: 121,\n\t\trequest: proto.NetworkGetConfigurationRequest,\n\t\treply: proto.NetworkGetConfigurationReply\n\t},\n\tNETWORK_GET_STATUS: {\n\t\tid: 122,\n\t\trequest: proto.NetworkGetStatusRequest,\n\t\treply: proto.NetworkGetStatusReply\n\t},\n\tSET_CLAIM_CODE: {\n\t\tid: 200,\n\t\trequest: proto.SetClaimCodeRequest,\n\t\treply: proto.SetClaimCodeReply\n\t},\n\tIS_CLAIMED: {\n\t\tid: 201,\n\t\trequest: proto.IsClaimedRequest,\n\t\treply: proto.IsClaimedReply\n\t},\n\tSET_SECURITY_KEY: {\n\t\tid: 210,\n\t\trequest: proto.SetSecurityKeyRequest,\n\t\treply: proto.SetSecurityKeyReply\n\t},\n\tGET_SECURITY_KEY: {\n\t\tid: 211,\n\t\trequest: proto.GetSecurityKeyRequest,\n\t\treply: proto.GetSecurityKeyReply\n\t},\n\tSET_SERVER_ADDRESS: {\n\t\tid: 220,\n\t\trequest: proto.SetServerAddressRequest,\n\t\treply: proto.SetServerAddressReply\n\t},\n\tGET_SERVER_ADDRESS: {\n\t\tid: 221,\n\t\trequest: proto.GetServerAddressRequest,\n\t\treply: proto.GetServerAddressReply\n\t},\n\tSET_SERVER_PROTOCOL: {\n\t\tid: 222,\n\t\trequest: proto.SetServerProtocolRequest,\n\t\treply: proto.SetServerProtocolReply\n\t},\n\tGET_SERVER_PROTOCOL: {\n\t\tid: 223,\n\t\trequest: proto.GetServerProtocolRequest,\n\t\treply: proto.GetServerProtocolReply\n\t},\n\tSTART_NYAN_SIGNAL: {\n\t\tid: 230\n\t},\n\tSTOP_NYAN_SIGNAL: {\n\t\tid: 231\n\t},\n\tSET_SOFTAP_SSID: {\n\t\tid: 240,\n\t\trequest: proto.SetSoftApSsidRequest,\n\t\treply: proto.SetSoftApSsidReply\n\t},\n\tSTART_FIRMWARE_UPDATE: {\n\t\tid: 250,\n\t\trequest: proto.StartFirmwareUpdateRequest,\n\t\treply: proto.StartFirmwareUpdateReply\n\t},\n\tFINISH_FIRMWARE_UPDATE: {\n\t\tid: 251,\n\t\trequest: proto.FinishFirmwareUpdateRequest,\n\t\treply: proto.FinishFirmwareUpdateReply\n\t},\n\tCANCEL_FIRMWARE_UPDATE: {\n\t\tid: 252,\n\t\trequest: proto.CancelFirmwareUpdateRequest,\n\t\treply: proto.CancelFirmwareUpdateReply\n\t},\n\tFIRMWARE_UPDATE_DATA: {\n\t\tid: 253,\n\t\trequest: proto.FirmwareUpdateDataRequest,\n\t\treply: proto.FirmwareUpdateDataReply\n\t},\n\tDESCRIBE_STORAGE: {\n\t\tid: 260,\n\t\trequest: proto.DescribeStorageRequest,\n\t\treply: proto.DescribeStorageReply\n\t},\n\tREAD_SECTION_DATA: {\n\t\tid: 261,\n\t\trequest: proto.ReadSectionDataRequest,\n\t\treply: proto.ReadSectionDataReply\n\t},\n\tWRITE_SECTION_DATA: {\n\t\tid: 262,\n\t\trequest: proto.WriteSectionDataRequest,\n\t\treply: proto.WriteSectionDataReply\n\t},\n\tCLEAR_SECTION_DATA: {\n\t\tid: 263,\n\t\trequest: proto.ClearSectionDataRequest,\n\t\treply: proto.ClearSectionDataReply\n\t},\n\tGET_SECTION_DATA_SIZE: {\n\t\tid: 264,\n\t\trequest: proto.GetSectionDataSizeRequest,\n\t\treply: proto.GetSectionDataSizeReply\n\t},\n\t// Cloud connectivity\n\tCLOUD_STATUS: {\n\t\tid: 300,\n\t\trequest: proto.cloud.GetConnectionStatusRequest,\n\t\treply: proto.cloud.GetConnectionStatusReply\n\t},\n\tCLOUD_CONNECT: {\n\t\tid: 301,\n\t\trequest: proto.cloud.ConnectRequest,\n\t\treply: proto.cloud.ConnectReply\n\t},\n\tCLOUD_DISCONNECT: {\n\t\tid: 302,\n\t\trequest: proto.cloud.DisconnectRequest,\n\t\treply: proto.cloud.DisconnectReply\n\t},\n\t// Cellular-specific requests\n\tCELLULAR_GET_ICCID: {\n\t\tid: 554,\n\t\trequest: proto.cellular.GetIccidRequest,\n\t\treply: proto.cellular.GetIccidReply\n\t},\n\t// Logging configuration\n\tADD_LOG_HANDLER: {\n\t\tid: 1100,\n\t\trequest: proto.logging.AddLogHandlerRequest,\n\t\treply: proto.logging.AddLogHandlerReply\n\t},\n\tREMOVE_LOG_HANDLER: {\n\t\tid: 1101,\n\t\trequest: proto.logging.RemoveLogHandlerRequest,\n\t\treply: proto.logging.RemoveLogHandlerReply\n\t},\n\tGET_LOG_HANDLERS: {\n\t\tid: 1102,\n\t\trequest: proto.logging.GetLogHandlersRequest,\n\t\treply: proto.logging.GetLogHandlersReply\n\t},\n\tNETWORK_GET_INTERFACE_LIST: {\n\t\tid: 400,\n\t\trequest: proto.GetInterfaceListRequest,\n\t\treply: proto.GetInterfaceListReply\n\t},\n\tNETWORK_GET_INTERFACE: {\n\t\tid: 401,\n\t\trequest: proto.GetInterfaceRequest,\n\t\treply: proto.GetInterfaceReply\n\t}\n};\n\nmodule.exports = {\n\tRequest\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/request.js?");

/***/ }),

/***/ "./src/result.js":
/*!***********************!*\
  !*** ./src/result.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { RequestError, DeviceProtectionError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n// Result codes as defined by the firmware's system_error_t enum\nconst RESULT_CODES = [\n\t{\n\t\tid: 'OK',\n\t\tvalue: 0,\n\t\tmessage: 'Operation succeeded'\n\t},\n\t{\n\t\tid: 'ERROR',\n\t\tvalue: -100,\n\t\tmessage: 'Unknown error'\n\t},\n\t{\n\t\tid: 'BUSY',\n\t\tvalue: -110,\n\t\tmessage: 'Resource is busy'\n\t},\n\t{\n\t\tid: 'NOT_SUPPORTED',\n\t\tvalue: -120,\n\t\tmessage: 'Not supported'\n\t},\n\t{\n\t\tid: 'NOT_ALLOWED',\n\t\tvalue: -130,\n\t\tmessage: 'Not allowed'\n\t},\n\t{\n\t\tid: 'CANCELLED',\n\t\tvalue: -140,\n\t\tmessage: 'Operation cancelled'\n\t},\n\t{\n\t\tid: 'ABORTED',\n\t\tvalue: -150,\n\t\tmessage: 'Operation aborted'\n\t},\n\t{\n\t\tid: 'TIMEOUT_ERROR',\n\t\tvalue: -160,\n\t\tmessage: 'Timeout error'\n\t},\n\t{\n\t\tid: 'NOT_FOUND',\n\t\tvalue: -170,\n\t\tmessage: 'Not found'\n\t},\n\t{\n\t\tid: 'ALREADY_EXISTS',\n\t\tvalue: -180,\n\t\tmessage: 'Already exists'\n\t},\n\t{\n\t\tid: 'TOO_LARGE',\n\t\tvalue: -190,\n\t\tmessage: 'Data is too large'\n\t},\n\t{\n\t\tid: 'LIMIT_EXCEEDED',\n\t\tvalue: -200,\n\t\tmessage: 'Limit exceeded'\n\t},\n\t{\n\t\tid: 'INVALID_STATE',\n\t\tvalue: -210,\n\t\tmessage: 'Invalid state'\n\t},\n\t{\n\t\tid: 'IO_ERROR',\n\t\tvalue: -220,\n\t\tmessage: 'IO error'\n\t},\n\t{\n\t\tid: 'NETWORK_ERROR',\n\t\tvalue: -230,\n\t\tmessage: 'Network error'\n\t},\n\t{\n\t\tid: 'PROTOCOL_ERROR',\n\t\tvalue: -240,\n\t\tmessage: 'Protocol error'\n\t},\n\t{\n\t\tid: 'INTERNAL_ERROR',\n\t\tvalue: -250,\n\t\tmessage: 'Internal error'\n\t},\n\t{\n\t\tid: 'NO_MEMORY',\n\t\tvalue: -260,\n\t\tmessage: 'Memory allocation error'\n\t},\n\t{\n\t\tid: 'INVALID_ARGUMENT',\n\t\tvalue: -270,\n\t\tmessage: 'Invalid argument'\n\t},\n\t{\n\t\tid: 'BAD_DATA',\n\t\tvalue: -280,\n\t\tmessage: 'Invalid data format'\n\t},\n\t{\n\t\tid: 'OUT_OF_RANGE',\n\t\tvalue: -290,\n\t\tmessage: 'Out of range'\n\t},\n\t{\n\t\tid: 'DEVICE_PROTECTED',\n\t\tvalue: -1801,\n\t\tmessage: 'Device is protected'\n\t},\n\t{\n\t\tid: 'KEY_MISMATCH',\n\t\tvalue: -1802,\n\t\tmessage: 'Unrecognized cryptographic key'\n\t},\n\t{\n\t\tid: 'INVALID_SIGNATURE',\n\t\tvalue: -1803,\n\t\tmessage: 'Signature validation failed'\n\t}\n];\n\n// Result code messages\nconst RESULT_CODE_MESSAGES = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.value] = result.message;\n\treturn obj;\n}, {});\n\n/**\n * Request result codes.\n *\n * @enum {Number}\n */\nconst Result = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.id] = result.value;\n\treturn obj;\n}, {});\n\n/**\n * Return a message for the result code.\n *\n * @param {Number} result Result code.\n * @return {String} Error message.\n */\nfunction messageForResultCode(result) {\n\treturn (RESULT_CODE_MESSAGES[result] || 'Request error');\n}\n\nfunction errorForRequest(result) {\n\tif (result === Result.DEVICE_PROTECTED) {\n\t\treturn new DeviceProtectionError('Device is protected');\n\t} else {\n\t\treturn new RequestError(result, messageForResultCode(result));\n\t}\n}\n\nmodule.exports = {\n\tResult,\n\tmessageForResultCode,\n\terrorForRequest\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/result.js?");

/***/ }),

/***/ "./src/set-device-prototype.js":
/*!*************************************!*\
  !*** ./src/set-device-prototype.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { PLATFORMS } = __webpack_require__(/*! ./platforms */ \"./src/platforms.js\");\nconst { Device } = __webpack_require__(/*! ./device */ \"./src/device.js\");\nconst { WifiDevice } = __webpack_require__(/*! ./wifi-device */ \"./src/wifi-device.js\");\nconst { WifiDeviceLegacy } = __webpack_require__(/*! ./wifi-device-legacy */ \"./src/wifi-device-legacy.js\");\nconst { CellularDevice } = __webpack_require__(/*! ./cellular-device */ \"./src/cellular-device.js\");\nconst { CloudDevice } = __webpack_require__(/*! ./cloud-device */ \"./src/cloud-device.js\");\nconst { Gen3Device } = __webpack_require__(/*! ./gen3-device */ \"./src/gen3-device.js\");\nconst { NetworkDevice } = __webpack_require__(/*! ./network-device */ \"./src/network-device.js\");\nconst { DfuDevice } = __webpack_require__(/*! ./dfu-device */ \"./src/dfu-device.js\");\nconst { LinuxDevice } = __webpack_require__(/*! ./linux-device */ \"./src/linux-device.js\");\n\n/**\n * This constant has a structure like this:\n//   photon: klass {},\n//   electron: klass {},\n//   p2: klass {},\n//   ...\n// }\n */\nconst DEVICE_CLASSES = PLATFORMS.reduce((classes, platform) => {\n\tlet klass;\n\tif (platform.features.includes('linux')) {\n\t\tklass = LinuxDevice;\n\t} else {\n\t\tklass = class extends NetworkDevice(Device) {};\n\t\tif (platform.generation === 3) {\n\t\t\tklass = class extends Gen3Device(klass) {};\n\t\t}\n\t\tif (platform.features.includes('cellular')) {\n\t\t\tklass = class extends CellularDevice(klass) {};\n\t\t}\n\t\tif (platform.features.includes('wifi')) {\n\t\t\tif (platform.generation === 2 || platform.generation === 1) {\n\t\t\t\tklass = class extends WifiDeviceLegacy(klass) {};\n\t\t\t} else {\n\t\t\t\tklass = class extends WifiDevice(klass) {};\n\t\t\t}\n\t\t}\n\t\tklass = class extends CloudDevice(klass) {};\n\t}\n\n\tclasses[platform.name] = klass;\n\n\treturn classes;\n}, {});\n\n\n\n/**\n * Determines the the class and inheritance hierarchy\n * of a Particle USB device based on it's platform characteristics *\n * @param {*} usbDevice - An object with a .type field that is a string like \"p1\", \"argon\", \"p2\", etc\n * \t\t\t\t\t\t  representing the short name of the device platform.\n * @returns {*} an instance of a class like WifiDevice, CellularDevice with the correct inheritance hierachy\n */\nfunction setDevicePrototype(usbDevice) {\n\tlet klass = DEVICE_CLASSES[usbDevice.type];\n\tif (!klass) {\n\t\treturn usbDevice;\n\t}\n\t// if usb device is in dfu mode, we could also add the prototype for the dfu device\n\tif (usbDevice.isInDfuMode) {\n\t\tklass = class extends DfuDevice(klass){};\n\t\treturn Object.setPrototypeOf(usbDevice, klass.prototype);\n\t} else {\n\t\treturn Object.setPrototypeOf(usbDevice, klass.prototype);\n\t}\n}\n\nmodule.exports = {\n\tsetDevicePrototype\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/set-device-prototype.js?");

/***/ }),

/***/ "./src/usb-device-webusb.js":
/*!**********************************!*\
  !*** ./src/usb-device-webusb.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { UsbError, UsbStallError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n// Maximum size of a control transfer's data stage\nconst MAX_CONTROL_TRANSFER_DATA_SIZE = 4096;\n\nfunction bmRequestTypeToString(type) {\n\ttype = (type >> 5) & 0x03;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'standard';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'class';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'vendor';\n\t\t}\n\t\tdefault: {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n\nfunction bmRequestTypeToRecipientString(type) {\n\ttype = type & 0x0f;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'device';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'interface';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'endpoint';\n\t\t}\n\t\tcase 3:\n\t\tdefault: {\n\t\t\treturn 'other';\n\t\t}\n\t}\n}\n\nclass UsbDevice {\n\tconstructor(dev) {\n\t\tthis._dev = dev;\n\t\tthis._dev.timeout = 5000; // Use longer timeout for control transfers\n\t\tthis._quirks = {};\n\t}\n\n\tasync open() {\n\t\ttry {\n\t\t\tawait this._dev.open();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Unable to open USB device', { cause: err });\n\t\t}\n\t}\n\n\tasync close() {\n\t\ttry {\n\t\t\tawait this._dev.close();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Unable to close USB device', { cause: err });\n\t\t}\n\t}\n\tasync transferIn(setup) {\n\t\tlet res;\n\t\ttry {\n\t\t\tres = await this._dev.controlTransferIn({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, setup.wLength);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('IN control transfer failed', { cause: err });\n\t\t}\n\t\tif (res.status !== 'ok') {\n\t\t\tif (res.status === 'stall') {\n\t\t\t\tthrow new UsbStallError('Transfer stalled');\n\t\t\t}\n\t\t\tthrow new Error(`Status: ${res.status}`);\n\t\t}\n\t\treturn Buffer.from(res.data.buffer);\n\t}\n\n\tasync transferOut(setup, data) {\n\t\tlet res;\n\t\ttry {\n\t\t\tif (!data && this._quirks.controlOutTransfersRequireDataStage) {\n\t\t\t\tdata = Buffer.alloc(1);\n\t\t\t}\n\t\t\tres = await this._dev.controlTransferOut({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, data); // data is optional\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('OUT control transfer failed', { cause: err });\n\t\t}\n\t\tif (res.status !== 'ok') {\n\t\t\tif (res.status === 'stall') {\n\t\t\t\tthrow new UsbStallError('Transfer stalled');\n\t\t\t}\n\t\t\tthrow new Error(`Status: ${res.status}`);\n\t\t}\n\t}\n\n\tasync claimInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.claimInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to claim interface', { cause: err });\n\t\t}\n\t}\n\n\tasync releaseInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.releaseInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to release interface', { cause: err });\n\t\t}\n\t}\n\n\tasync setAltSetting(intrface, setting) {\n\t\ttry {\n\t\t\tawait this._dev.selectAlternateInterface(intrface, setting);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to set alt setting', { cause: err });\n\t\t}\n\t}\n\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\tget productName() {\n\t\treturn this._dev.productName;\n\t}\n\n\tget serialNumber() {\n\t\treturn this._dev.serialNumber;\n\t}\n\n\tget isOpen() {\n\t\treturn this._dev.opened;\n\t}\n\n\tget internalObject() {\n\t\treturn this._dev;\n\t}\n\n\tget quirks() {\n\t\treturn this._quirks;\n\t}\n\n\tset quirks(qs) {\n\t\tthis._quirks = qs;\n\t}\n}\n\nasync function getUsbDevices(filters) {\n\tif (filters) {\n\t\t// Validate filtering options\n\t\tfilters.forEach(f => {\n\t\t\tif (f.productId && !f.vendorId) {\n\t\t\t\tthrow new RangeError('Vendor ID is missing');\n\t\t\t}\n\t\t});\n\t} else {\n\t\tfilters = [];\n\t}\n\tlet devs = [];\n\ttry {\n\t\t// Fow now, always ask the user to grant access to the device, even if we already have a\n\t\t// permission to access it. The permissions API for USB is not yet implemented in Chrome,\n\t\t// and calling requestDevice() after getDevices() causes a SecurityError.\n\t\t// TODO: Implement a separate API to request a permission from the user\n\t\tlet newDev = null;\n\t\ttry {\n\t\t\tnewDev = await navigator.usb.requestDevice({ filters });\n\t\t} catch (e) {\n\t\t\t// Ignore NotFoundError which means that the user has cancelled the request\n\t\t\tif (e.name !== 'NotFoundError') {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Get the list of known devices and filter them according to the provided options\n\t\tdevs = await navigator.usb.getDevices();\n\t\tif (filters.length > 0) {\n\t\t\tdevs = devs.filter(dev => filters.some(f => ((!f.vendorId || dev.vendorId === f.vendorId) &&\n\t\t\t\t\t(!f.productId || dev.productId === f.productId) &&\n\t\t\t\t\t(!f.serialNumber || dev.serialNumber === f.serialNumber))));\n\t\t}\n\t\tif (newDev) {\n\t\t\t// Avoid listing the same device twice\n\t\t\tconst hasNewDev = devs.some(dev => dev.vendorId === newDev.vendorId && dev.productId === newDev.productId &&\n\t\t\t\t\tdev.serialNumber === newDev.serialNumber);\n\t\t\tif (!hasNewDev) {\n\t\t\t\tdevs.push(newDev);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tthrow new UsbError('Unable to enumerate USB devices', { cause: err });\n\t}\n\tdevs = devs.map(dev => new UsbDevice(dev));\n\treturn devs;\n}\n\nmodule.exports = {\n\tMAX_CONTROL_TRANSFER_DATA_SIZE,\n\tUsbDevice,\n\tgetUsbDevices\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-device-webusb.js?");

/***/ }),

/***/ "./src/usb-protocol.js":
/*!*****************************!*\
  !*** ./src/usb-protocol.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { ProtocolError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n// Service request types\nconst ServiceType = {\n\tINIT: 1,\n\tCHECK: 2,\n\tSEND: 3,\n\tRECV: 4,\n\tRESET: 5\n};\n\n// Field flags\nconst FieldFlag = {\n\tSTATUS: 0x01,\n\tID: 0x02,\n\tSIZE: 0x04,\n\tRESULT: 0x08\n};\n\n// Status codes\nconst Status = {\n\tOK: 0,\n\tERROR: 1,\n\tPENDING: 2,\n\tBUSY: 3,\n\tNO_MEMORY: 4,\n\tNOT_FOUND: 5\n};\n\n// Values of the bmRequestType field used by the protocol\nconst BmRequestType = {\n\tHOST_TO_DEVICE: 0x40, // 01000000b (direction: host-to-device; type: vendor; recipient: device)\n\tDEVICE_TO_HOST: 0xc0 // 11000000b (direction: device_to_host; type: vendor; recipient: device)\n};\n\n// Value of the bRequest field for Particle vendor requests\nconst PARTICLE_BREQUEST = 0x50; // ASCII code of the character 'P'\n\n// Minimum length of the data stage for high-speed USB devices\nconst MIN_WLENGTH = 64;\n\n// Misc. constraints defined by the protocol and the USB specification\nconst MAX_REQUEST_ID = 0xffff;\nconst MAX_REQUEST_TYPE = 0xffff;\nconst MAX_PAYLOAD_SIZE = 0xffff;\n\n// Returns the setup packet fields for the INIT service request\nfunction initRequest(reqType, dataSize = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.INIT,\n\t\twIndex: reqType, // Request type\n\t\twValue: dataSize, // Payload size\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the CHECK service request\nfunction checkRequest(reqId) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.CHECK,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the SEND service request\nfunction sendRequest(reqId, dataSize) {\n\treturn {\n\t\t// SEND is the only host-to-device service request defined by the protocol\n\t\tbmRequestType: BmRequestType.HOST_TO_DEVICE,\n\t\tbRequest: ServiceType.SEND,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RECV service request\nfunction recvRequest(reqId, dataSize) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RECV,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RESET service request\nfunction resetRequest(reqId = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RESET,\n\t\twIndex: reqId, // Request ID (can be set to 0 to reset all requests)\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Parses service reply data\nfunction parseReply(data) {\n\ttry {\n\t\tconst rep = {};\n\t\tlet offs = 0;\n\t\t// Field flags (4 bytes)\n\t\trep.flags = data.readUInt32LE(offs);\n\t\toffs += 4;\n\t\t// Status code (2 bytes)\n\t\tif (!(rep.flags & FieldFlag.STATUS)) {\n\t\t\tthrow new ProtocolError('Service reply is missing mandatory status field');\n\t\t}\n\t\trep.status = data.readUInt16LE(offs);\n\t\toffs += 2;\n\t\t// Request ID (2 bytes, optional)\n\t\tif (rep.flags & FieldFlag.ID) {\n\t\t\trep.id = data.readUInt16LE(offs);\n\t\t\toffs += 2;\n\t\t}\n\t\t// Payload size (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.SIZE) {\n\t\t\trep.size = data.readUInt32LE(offs);\n\t\t\toffs += 4;\n\t\t}\n\t\t// Result code (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.RESULT) {\n\t\t\trep.result = data.readInt32LE(offs); // Signed\n\t\t\toffs += 4;\n\t\t}\n\t\treturn rep;\n\t} catch (err) {\n\t\tif (!(err instanceof ProtocolError)) {\n\t\t\tthrow new ProtocolError('Unable to parse service reply', { cause: err });\n\t\t}\n\t\tthrow err;\n\t}\n}\n\n// Serializes service reply data\nfunction encodeReply(rep) {\n\tlet flags = FieldFlag.STATUS; // Status code is a mandatory field\n\tlet size = 6; // 4 bytes for field flags and 2 bytes for status code\n\tif ('id' in rep) {\n\t\tflags |= FieldFlag.ID;\n\t\tsize += 2;\n\t}\n\tif ('size' in rep) {\n\t\tflags |= FieldFlag.SIZE;\n\t\tsize += 4;\n\t}\n\tif ('result' in rep) {\n\t\tflags |= FieldFlag.RESULT;\n\t\tsize += 4;\n\t}\n\tconst data = Buffer.alloc(size);\n\tlet offs = 0;\n\t// Field flags (4 bytes)\n\tdata.writeUInt32LE(flags, offs);\n\toffs += 4;\n\t// Status code (2 bytes)\n\tdata.writeUInt16LE(rep.status, offs);\n\toffs += 2;\n\t// Request ID (2 bytes, optional)\n\tif (flags & FieldFlag.ID) {\n\t\tdata.writeUInt16LE(rep.id, offs);\n\t\toffs += 2;\n\t}\n\t// Payload size (4 bytes, optional)\n\tif (flags & FieldFlag.SIZE) {\n\t\tdata.writeUInt32LE(rep.size, offs);\n\t\toffs += 4;\n\t}\n\t// Result code (4 bytes, optional)\n\tif (flags & FieldFlag.RESULT) {\n\t\tdata.writeInt32LE(rep.result, offs); // Signed\n\t\toffs += 4;\n\t}\n\treturn data;\n}\n\nmodule.exports = {\n\tServiceType,\n\tFieldFlag,\n\tStatus,\n\tBmRequestType,\n\tPARTICLE_BREQUEST,\n\tMIN_WLENGTH,\n\tMAX_REQUEST_ID,\n\tMAX_REQUEST_TYPE,\n\tMAX_PAYLOAD_SIZE,\n\tinitRequest,\n\tcheckRequest,\n\tsendRequest,\n\trecvRequest,\n\tresetRequest,\n\tparseReply,\n\tencodeReply\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-protocol.js?");

/***/ }),

/***/ "./src/wifi-device-legacy.js":
/*!***********************************!*\
  !*** ./src/wifi-device-legacy.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * All of the functionality in this class is deprecated.\n * However, it can still be used on Paticle Photon devices running\n * Device OS systems firmware from 0.8.0 to pre 2.0.0.\n */\n\n// TODO: Remove the legacy behavior!\n\nconst { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum, fromProtobufMessage, toProtobufMessage } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst { definitions: proto } = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\n\n/**\n * WiFi antenna types.\n */\nconst WifiAntenna = fromProtobufEnum(proto.WiFiAntenna, {\n\tINTERNAL: 'INTERNAL',\n\tEXTERNAL: 'EXTERNAL',\n\tAUTO: 'AUTO'\n});\n\n/**\n * WiFi security types.\n */\nconst WifiSecurity = fromProtobufEnum(proto.WiFiSecurityType, {\n\tNONE: 'UNSEC',\n\tWEP: 'WEP',\n\tWPA: 'WPA',\n\tWPA2: 'WPA2',\n\tWPA_ENTERPRISE: 'WPA_ENTERPRISE',\n\tWPA2_ENTERPRISE: 'WPA2_ENTERPRISE',\n\tUNKNOWN: 'UNKNOWN'\n});\n\n/**\n * WiFi cipher types.\n */\nconst WifiCipher = fromProtobufEnum(proto.WiFiSecurityCipher, {\n\tAES: 'AES',\n\tTKIP: 'TKIP',\n\tAES_TKIP: 'AES_TKIP'\n});\n\n/**\n * EAP methods.\n */\nconst EapMethod = fromProtobufEnum(proto.EapType, {\n\tTLS: 'TLS',\n\tPEAP: 'PEAP'\n});\n\nfunction bssidFromProtobuf(bssid) {\n\treturn [...bssid].map(b => b.toString(16).padStart(2, '0')).join(':');\n}\n\nfunction bssidToProtobuf(bssid) {\n\treturn Buffer.from(bssid.replace(/:/g, ''), 'hex');\n}\n\nconst accessPointCommonProperties = ['ssid', 'channel', 'maxDataRate', 'rssi', 'password', 'innerIdentity',\n\t'outerIdentity', 'privateKey', 'clientCertificate', 'caCertificate'];\n\nconst accessPointFromProtobuf = fromProtobufMessage(proto.WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidFromProtobuf,\n\tsecurity: WifiSecurity.fromProtobuf,\n\tcipher: WifiCipher.fromProtobuf,\n\teapType: {\n\t\tname: 'eapMethod',\n\t\tvalue: EapMethod.fromProtobuf\n\t}\n});\n\nconst accessPointToProtobuf = toProtobufMessage(proto.WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidToProtobuf,\n\tsecurity: WifiSecurity.toProtobuf,\n\tcipher: WifiCipher.toProtobuf,\n\teapMethod: {\n\t\tname: 'eapType',\n\t\tvalue: EapMethod.toProtobuf\n\t}\n});\n\n/**\n * Wi-Fi device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst WifiDeviceLegacy = base => class extends base {\n\t/**\n\t * Set the WiFi antenna to use.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} antenna Antenna type.\n\t * @return {Promise}\n\t */\n\tsetWifiAntenna(antenna) {\n\t\treturn this.sendRequest(Request.WIFI_SET_ANTENNA, {\n\t\t\tantenna: WifiAntenna.toProtobuf(antenna)\n\t\t});\n\t}\n\n\t/**\n\t * Get the currently used WiFi antenna.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetWifiAntenna(/* antenna */) {\n\t\treturn this.sendRequest(Request.WIFI_GET_ANTENNA).then(rep => {\n\t\t\treturn WifiAntenna.fromProtobuf(rep.antenna);\n\t\t});\n\t}\n\n\t/**\n\t * Perform the WiFi scan.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tscanWifiNetworks() {\n\t\treturn this.sendRequest(Request.WIFI_SCAN).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Set the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} credentials Credentials.\n\t * @return {Promise}\n\t */\n\tsetWifiCredentials(credentials) {\n\t\treturn this.sendRequest(Request.WIFI_SET_CREDENTIALS, {\n\t\t\tap: accessPointToProtobuf(credentials)\n\t\t});\n\t}\n\n\t/**\n\t * Get the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tgetWifiCredentials() {\n\t\treturn this.sendRequest(Request.WIFI_GET_CREDENTIALS).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Clear the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearWifiCredentials() {\n\t\treturn this.sendRequest(Request.WIFI_CLEAR_CREDENTIALS);\n\t}\n};\n\nmodule.exports = {\n\tWifiAntenna,\n\tWifiSecurity,\n\tWifiCipher,\n\tEapMethod,\n\tWifiDeviceLegacy\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/wifi-device-legacy.js?");

/***/ }),

/***/ "./src/wifi-device.js":
/*!****************************!*\
  !*** ./src/wifi-device.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const DeviceOSProtobuf = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\nconst { definitions: proto } = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst { convertBufferToMacAddress } = __webpack_require__(/*! ./address-util */ \"./src/address-util.js\");\n\n/**\n * Wi-Fi security types.\n *\n * @enum {String}\n */\nconst WiFiSecurity = fromProtobufEnum(proto.wifi.Security, {\n\tNONE : 'NO_SECURITY',\n\tWEP : 'WEP',\n\tWPA_PSK : 'WPA_PSK',\n\tWPA2_PSK : 'WPA2_PSK',\n\tWPA_WPA2_PSK : 'WPA_WPA2_PSK',\n\tWPA3_PSK : 'WPA3_PSK',\n\tWPA2_WPA3_PSK : 'WPA2_WPA3_PSK',\n});\n\n/**\n * Wi-Fi device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst WifiDevice = base => class extends base {\n\t/**\n\t * Perform WiFi scan for Gen 3+ devices\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {Promise[Object]} - Each object in array has these properties: ssid, bssid, security, channel, rssi. See Network protobuf message from https://github.com/particle-iot/device-os-protobuf for more details.\n\t */\n\tasync scanWifiNetworks(options) {\n\t\tconst result = await this.sendProtobufRequest(\n\t\t\t'wifi.ScanNetworksRequest',\n\t\t\t{},\n\t\t\toptions\n\t\t);\n\n\t\treturn result.networks.map((network) => {\n\t\t\treturn {\n\t\t\t\tssid: network.ssid || null, // can be blank for hidden networks\n\t\t\t\tbssid: convertBufferToMacAddress(network.bssid), // convert buffer to hex string\n\t\t\t\tsecurity: WiFiSecurity.fromProtobuf(network.security),\n\t\t\t\tchannel: network.channel,\n\t\t\t\trssi: network.rssi\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Join a new WiFi network for Gen 3+ devices.\n\t *\n\t * Warning: May not work for hidden networks due to certain bugs in the device-os.\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {string} ssid - SSID of Wifi Network\n\t * @param {string} security - Security of Wifi network\n\t * @param {string} password - Password of Wifi network, if not set will not use security\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - empty response\n\t */\n\tasync joinNewWifiNetwork({ ssid, security, password = null, hidden }, options) {\n\t\tlet dataPayload;\n\t\tif (password === null) {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\tsecurity: 0 // Security.NO_SECURITY\n\t\t\t};\n\t\t} else {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\thidden: hidden === true,\n\t\t\t\tsecurity: security ? WiFiSecurity.toProtobuf(security) : null,\n\t\t\t\tcredentials: {\n\t\t\t\t\ttype: 1, // CredentialsType.PASSWORD\n\t\t\t\t\tpassword\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.JoinNewNetworkRequest',\n\t\t\tdataPayload,\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Join a known WiFi network for Gen 3+ devices.\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {string} ssid - SSID of Wifi Network\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - empty response\n\t */\n\tasync joinKnownWifiNetwork({ ssid }, options) {\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.JoinKnownNetworkRequest',\n\t\t\t{ ssid },\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Gets the list of networks for Gen 3+ devices.\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - An array of known networks (ssid, security, credentialsType). See GetKnownNetworksReply from https://github.com/particle-iot/device-os-protobuf/blob/main/control/wifi_new.proto\n\t */\n\tasync listWifiNetworks(options) {\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.GetKnownNetworksRequest',\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Removes a Wi-Fi network\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {string} ssid - SSID of Wifi Network\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - empty response\n\t */\n\tasync removeWifiNetwork({ ssid }, options) {\n\t\tconst dataPayload = {\n\t\t\tssid\n\t\t};\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.RemoveKnownNetworkRequest',\n\t\t\tdataPayload,\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Gets the currently connected Wi-Fi network for Gen 3+ devices.\n\t *\n\t * Supported platforms:\n\t * - Gen 3\n\t * - Gen 4\n\t *\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {Promise[Object]} - ssid, bssid, channel, rssi. See GetCurrentNetworkReply from https://github.com/particle-iot/device-os-protobuf/blob/main/control/wifi_new.proto\n\t */\n\tasync getCurrentWifiNetwork(options) {\n\t\tconst res = await this.sendProtobufRequest(\n\t\t\t'wifi.GetCurrentNetworkRequest',\n\t\t\t{},\n\t\t\toptions\n\t\t);\n\t\tconst bssidStr = convertBufferToMacAddress(res.bssid);\n\t\tres.bssid = bssidStr;\n\t\treturn res;\n\t}\n\n\t/**\n\t * Set a new WiFi network for Gen 3+ devices.\n\t *\n\t * Supported platforms:\n\t * - Gen 4: Supported on P2 since Device OS 5.8.2\n\t *\n\t * @param {string} ssid - SSID of Wifi Network\n\t * @param {string} security - Security of Wifi network\n\t * @param {string} password - Password of Wifi network, if not set will not use security\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - empty response\n\t */\n\tasync setWifiCredentials({ ssid, security, password = null, hidden }, options) {\n\t\tlet dataPayload;\n\t\tif (password === null) {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\tsecurity: 0 // Security.NO_SECURITY\n\t\t\t};\n\t\t} else {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\thidden: hidden === true,\n\t\t\t\tsecurity : security ? WiFiSecurity.toProtobuf(security) : null,\n\t\t\t\tcredentials: {\n\t\t\t\t\ttype: 1, // CredentialsType.PASSWORD\n\t\t\t\t\tpassword\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.SetNetworkCredentialsRequest',\n\t\t\tdataPayload,\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Clear Wifi networks for Gen 3+ devices\n\t *\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - empty response\n\t */\n\n\tasync clearWifiNetworks(options) {\n\t\treturn await this.sendProtobufRequest(\n\t\t\t'wifi.ClearKnownNetworksRequest',\n\t\t\t{},\n\t\t\toptions\n\t\t);\n\t}\n\n\n};\n\nconst WifiSecurityEnum = DeviceOSProtobuf.getDefinition('wifi.Security').message;\n\nmodule.exports = {\n\tWifiDevice,\n\tWifiSecurityEnum\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/wifi-device.js?");

/***/ }),

/***/ "./node_modules/@particle/device-constants/dist/js/constants.json":
/*!************************************************************************!*\
  !*** ./node_modules/@particle/device-constants/dist/js/constants.json ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"core\":{\"id\":0,\"name\":\"core\",\"displayName\":\"Core\",\"generation\":1,\"baseMcu\":\"stm32f1xx\",\"features\":[\"wifi\",\"tcp\"],\"aliases\":[\"c\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":true,\"usb\":{\"vendorId\":\"0x1d50\",\"productId\":\"0x607d\"},\"dfu\":{\"vendorId\":\"0x1d50\",\"productId\":\"0x607f\",\"segments\":{\"factoryReset\":{\"address\":\"0x00020000\",\"alt\":1}}}},\"gcc\":{\"id\":3,\"name\":\"gcc\",\"displayName\":\"GCC\",\"generation\":-1,\"baseMcu\":\"gcc\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"photon\":{\"id\":6,\"name\":\"photon\",\"displayName\":\"Photon\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\"],\"aliases\":[\"p\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"monoFirmware\",\"index\":1,\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc006\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd006\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080e0000\",\"alt\":0}}}},\"p1\":{\"id\":8,\"name\":\"p1\",\"displayName\":\"P1\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"monoFirmware\",\"index\":1,\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc008\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd008\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080e0000\",\"alt\":0}}}},\"electron\":{\"id\":10,\"name\":\"electron\",\"displayName\":\"Electron\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"cellular\",\"udp\"],\"aliases\":[\"e\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":3,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"monoFirmware\",\"index\":1,\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00a\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00a\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080a0000\",\"alt\":0},\"transport\":{\"address\":\"2977\",\"alt\":1,\"size\":1}}}},\"esp32\":{\"id\":11,\"name\":\"esp32\",\"displayName\":\"ESP32\",\"generation\":-1,\"baseMcu\":\"esp32xx\",\"features\":[\"wifi\",\"udp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"argon\":{\"id\":12,\"name\":\"argon\",\"displayName\":\"Argon\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"wifi\",\"udp\",\"mesh\",\"ble\"],\"aliases\":[\"a\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00c\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00c\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":606208,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"boron\":{\"id\":13,\"name\":\"boron\",\"displayName\":\"Boron\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"cellular\",\"udp\",\"mesh\",\"ble\"],\"aliases\":[\"b\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00d\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00d\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":606208,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"xenon\":{\"id\":14,\"name\":\"xenon\",\"displayName\":\"Xenon\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"mesh\",\"ble\"],\"aliases\":[\"x\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00e\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00e\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}}},\"esomx\":{\"id\":15,\"name\":\"esomx\",\"displayName\":\"E-SoM-X\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00f\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00f\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":512,\"maxSingleAssetSize\":1572864,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"asom\":{\"id\":22,\"name\":\"asom\",\"displayName\":\"A-SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"wifi\",\"mesh\",\"udp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc016\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd016\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}}},\"bsom\":{\"id\":23,\"name\":\"bsom\",\"displayName\":\"B-SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"mesh\",\"udp\",\"ble\",\"muonCompatible\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc017\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd017\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":606208,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"xsom\":{\"id\":24,\"name\":\"xsom\",\"displayName\":\"X-SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"mesh\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":131072},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc018\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd018\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}}},\"b5som\":{\"id\":25,\"name\":\"b5som\",\"displayName\":\"B5-SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"mesh\",\"udp\",\"ble\",\"muonCompatible\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc019\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd019\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00600000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":512,\"maxSingleAssetSize\":1572864,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"tracker\":{\"id\":26,\"name\":\"tracker\",\"displayName\":\"Asset Tracker / Monitor One\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\"],\"aliases\":[\"assettracker\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc01a\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd01a\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00600000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":512,\"maxSingleAssetSize\":1572864,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"trackerm\":{\"id\":28,\"name\":\"trackerm\",\"displayName\":\"Tracker-M\",\"generation\":3,\"baseMcu\":\"rtl872x\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"growsLeft\":true,\"maxSize\":1572864},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc01c\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd01c\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":1179648,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"raspi\":{\"id\":31,\"name\":\"raspi\",\"displayName\":\"Raspberry Pi\",\"generation\":-1,\"baseMcu\":\"raspi\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"p2\":{\"id\":32,\"name\":\"p2\",\"displayName\":\"Photon 2 / P2\",\"generation\":4,\"baseMcu\":\"rtl872x\",\"features\":[\"wifi\",\"udp\",\"ble\"],\"aliases\":[\"photon2\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"growsLeft\":true,\"maxSize\":1572864},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc020\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd020\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":1179648,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"msom\":{\"id\":35,\"name\":\"msom\",\"displayName\":\"M-SoM\",\"generation\":4,\"baseMcu\":\"rtl872x\",\"features\":[\"wifi\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\",\"muonCompatible\"],\"aliases\":[\"muon\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"growsLeft\":true,\"maxSize\":1572864},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc023\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd023\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":288,\"maxSingleAssetSize\":1179648,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"electron2\":{\"id\":37,\"name\":\"electron2\",\"displayName\":\"Electron 2\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"cellular\",\"udp\",\"ble\"],\"aliases\":[\"electron2\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\",\"maxSize\":262144},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"monoFirmware\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc025\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd025\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2},\"formerUserPart\":{\"address\":\"0xd4000\",\"alt\":0,\"size\":4096}}},\"assets\":{\"blockSize\":4096,\"storageTotalBlocks\":512,\"maxSingleAssetSize\":1572864,\"assetPerBlockOverhead\":8,\"assetOverhead\":0,\"reservedBlocks\":10}},\"tachyon\":{\"id\":42,\"name\":\"tachyon\",\"displayName\":\"Tachyon\",\"generation\":-1,\"features\":[\"linux\",\"cellular\",\"wifi\",\"gnss\"],\"productEligible\":true,\"public\":true,\"billingConnectivity\":\"cellular\",\"baseMcu\":\"qcm6490\",\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc02a\",\"quirks\":{\"controlRequestsNotSupported\":true}},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"linux\":{\"id\":43,\"name\":\"linux\",\"displayName\":\"Linux\",\"generation\":-1,\"features\":[\"linux\",\"wifi\",\"gnss\"],\"productEligible\":true,\"public\":true,\"billingConnectivity\":\"wifi\",\"baseMcu\":\"unknown\",\"machineIdTypes\":{\"BOOT\":1,\"DMI\":2,\"CPU\":3,\"DBUS\":4,\"SN\":5}},\"oak\":{\"id\":82,\"name\":\"oak\",\"displayName\":\"Oak\",\"generation\":-1,\"baseMcu\":\"esp8266\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"duo\":{\"id\":88,\"name\":\"duo\",\"displayName\":\"Duo\",\"generation\":-1,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"bluz\":{\"id\":103,\"name\":\"bluz\",\"displayName\":\"Bluz\",\"generation\":-1,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}}}');\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-constants/dist/js/constants.json?");

/***/ }),

/***/ "./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json":
/*!***************************************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl\"},\"nested\":{\"particle\":{\"nested\":{\"ctrl\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl\"},\"nested\":{\"cellular\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.cellular\"},\"nested\":{\"SimType\":{\"values\":{\"INVALID_SIM_TYPE\":0,\"INTERNAL\":1,\"EXTERNAL\":2}},\"AccessPoint\":{\"fields\":{\"apn\":{\"type\":\"string\",\"id\":1},\"user\":{\"type\":\"string\",\"id\":2},\"password\":{\"type\":\"string\",\"id\":3},\"useDefaults\":{\"type\":\"bool\",\"id\":4}}},\"SetAccessPointRequest\":{\"options\":{\"(type_id)\":550},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1},\"accessPoint\":{\"type\":\"AccessPoint\",\"id\":2}}},\"SetAccessPointReply\":{\"fields\":{}},\"GetAccessPointRequest\":{\"options\":{\"(type_id)\":551},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"GetAccessPointReply\":{\"fields\":{\"accessPoint\":{\"type\":\"AccessPoint\",\"id\":1}}},\"SetActiveSimRequest\":{\"options\":{\"(type_id)\":552},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"SetActiveSimReply\":{\"fields\":{}},\"GetActiveSimRequest\":{\"options\":{\"(type_id)\":553},\"fields\":{}},\"GetActiveSimReply\":{\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"GetIccidRequest\":{\"options\":{\"(type_id)\":554},\"fields\":{}},\"GetIccidReply\":{\"fields\":{\"iccid\":{\"type\":\"string\",\"id\":1},\"imei\":{\"type\":\"string\",\"id\":2}}}}},\"cloud\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.cloud\"},\"nested\":{\"ConnectionStatus\":{\"values\":{\"DISCONNECTED\":0,\"CONNECTING\":1,\"CONNECTED\":2,\"DISCONNECTING\":3}},\"GetConnectionStatusRequest\":{\"options\":{\"(type_id)\":300},\"fields\":{}},\"GetConnectionStatusReply\":{\"fields\":{\"status\":{\"type\":\"ConnectionStatus\",\"id\":1}}},\"ConnectRequest\":{\"options\":{\"(type_id)\":301},\"fields\":{}},\"ConnectReply\":{\"fields\":{}},\"DisconnectRequest\":{\"options\":{\"(type_id)\":302},\"fields\":{}},\"DisconnectReply\":{\"fields\":{}}}},\"ResultCode\":{\"values\":{\"OK\":0,\"NOT_ALLOWED\":1,\"TIMEOUT\":2,\"NOT_FOUND\":3,\"ALREADY_EXIST\":4,\"INVALID_STATE\":5,\"NO_MEMORY\":6,\"INVALID_PARAM\":7}},\"Ipv4Address\":{\"fields\":{\"address\":{\"type\":\"fixed32\",\"id\":1}}},\"Ipv6Address\":{\"fields\":{\"address\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":16,\"(nanopb).fixed_length\":true}}}},\"IpAddress\":{\"oneofs\":{\"address\":{\"oneof\":[\"v4\",\"v6\"]}},\"fields\":{\"v4\":{\"type\":\"Ipv4Address\",\"id\":1},\"v6\":{\"type\":\"Ipv6Address\",\"id\":2}}},\"IPAddress\":{\"fields\":{\"protocol\":{\"type\":\"Protocol\",\"id\":1},\"address\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":16}}},\"nested\":{\"Protocol\":{\"values\":{\"NONE\":0,\"IPv4\":1,\"IPv6\":2}}}},\"SecurityKeyType\":{\"values\":{\"INVALID_SECURITY_KEY\":0,\"TCP_DEVICE_PRIVATE_KEY\":1,\"TCP_DEVICE_PUBLIC_KEY\":2,\"TCP_SERVER_PUBLIC_KEY\":3,\"UDP_DEVICE_PRIVATE_KEY\":4,\"UDP_DEVICE_PUBLIC_KEY\":5,\"UDP_SERVER_PUBLIC_KEY\":6}},\"ServerProtocolType\":{\"values\":{\"INVALID_PROTOCOL\":0,\"TCP_PROTOCOL\":1,\"UDP_PROTOCOL\":2}},\"DeviceMode\":{\"values\":{\"NORMAL_MODE\":0,\"LISTENING_MODE\":1}},\"SystemCapabilityFlag\":{\"values\":{\"NO_SYSTEM_CAPABILITY_FLAGS\":0,\"COMPRESSED_OTA\":1}},\"Feature\":{\"values\":{\"INVALID_FEATURE\":0,\"ETHERNET_DETECTION\":1}},\"GetDeviceIdRequest\":{\"options\":{\"(type_id)\":20},\"fields\":{}},\"GetDeviceIdReply\":{\"fields\":{\"id\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":24}}}},\"GetSerialNumberRequest\":{\"options\":{\"(type_id)\":21},\"fields\":{}},\"GetSerialNumberReply\":{\"fields\":{\"serial\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":16}}}},\"GetSystemVersionRequest\":{\"options\":{\"(type_id)\":30},\"fields\":{}},\"GetSystemVersionReply\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1}}},\"GetNcpFirmwareVersionRequest\":{\"options\":{\"(type_id)\":31},\"fields\":{}},\"GetNcpFirmwareVersionReply\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1},\"moduleVersion\":{\"type\":\"uint32\",\"id\":2}}},\"GetSystemCapabilitiesRequest\":{\"options\":{\"(type_id)\":32},\"fields\":{}},\"GetSystemCapabilitiesReply\":{\"fields\":{\"flags\":{\"type\":\"fixed32\",\"id\":1}}},\"SetClaimCodeRequest\":{\"options\":{\"(type_id)\":200},\"fields\":{\"code\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":64}}}},\"SetClaimCodeReply\":{\"fields\":{}},\"IsClaimedRequest\":{\"options\":{\"(type_id)\":201},\"fields\":{}},\"IsClaimedReply\":{\"fields\":{\"claimed\":{\"type\":\"bool\",\"id\":1}}},\"SetSecurityKeyRequest\":{\"options\":{\"(type_id)\":210},\"fields\":{\"type\":{\"type\":\"SecurityKeyType\",\"id\":1},\"data\":{\"type\":\"bytes\",\"id\":2}}},\"SetSecurityKeyReply\":{\"fields\":{}},\"GetSecurityKeyRequest\":{\"options\":{\"(type_id)\":211},\"fields\":{\"type\":{\"type\":\"SecurityKeyType\",\"id\":1}}},\"GetSecurityKeyReply\":{\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"SetServerAddressRequest\":{\"options\":{\"(type_id)\":220},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1},\"address\":{\"type\":\"string\",\"id\":2,\"options\":{\"(nanopb).max_length\":64}},\"port\":{\"type\":\"int32\",\"id\":3}}},\"SetServerAddressReply\":{\"fields\":{}},\"GetServerAddressRequest\":{\"options\":{\"(type_id)\":221},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"GetServerAddressReply\":{\"fields\":{\"address\":{\"type\":\"string\",\"id\":1},\"port\":{\"type\":\"int32\",\"id\":2}}},\"SetServerProtocolRequest\":{\"options\":{\"(type_id)\":222},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"SetServerProtocolReply\":{\"fields\":{}},\"GetServerProtocolRequest\":{\"options\":{\"(type_id)\":223},\"fields\":{}},\"GetServerProtocolReply\":{\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"SetSoftApSsidRequest\":{\"options\":{\"(type_id)\":240},\"fields\":{\"prefix\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"suffix\":{\"type\":\"string\",\"id\":2,\"options\":{\"(nanopb).max_length\":16}}}},\"SetSoftApSsidReply\":{\"fields\":{}},\"StartListeningModeRequest\":{\"options\":{\"(type_id)\":70},\"fields\":{}},\"StartListeningModeReply\":{\"fields\":{}},\"StopListeningModeRequest\":{\"options\":{\"(type_id)\":71},\"fields\":{}},\"StopListeningModeReply\":{\"fields\":{}},\"GetDeviceModeRequest\":{\"options\":{\"(type_id)\":72},\"fields\":{}},\"GetDeviceModeReply\":{\"fields\":{\"mode\":{\"type\":\"DeviceMode\",\"id\":1}}},\"SetDeviceSetupDoneRequest\":{\"options\":{\"(type_id)\":73},\"fields\":{\"done\":{\"type\":\"bool\",\"id\":1}}},\"SetDeviceSetupDoneReply\":{\"fields\":{}},\"IsDeviceSetupDoneRequest\":{\"options\":{\"(type_id)\":74},\"fields\":{}},\"IsDeviceSetupDoneReply\":{\"fields\":{\"done\":{\"type\":\"bool\",\"id\":1}}},\"SetStartupModeRequest\":{\"options\":{\"(type_id)\":75},\"fields\":{\"mode\":{\"type\":\"DeviceMode\",\"id\":1}}},\"SetStartupModeReply\":{\"fields\":{}},\"GetProtectedStateRequest\":{\"options\":{\"(type_id)\":76},\"fields\":{}},\"GetProtectedStateReply\":{\"fields\":{\"state\":{\"type\":\"bool\",\"id\":1},\"overridden\":{\"type\":\"bool\",\"id\":2}}},\"SetProtectedStateRequest\":{\"options\":{\"(type_id)\":77,\"(nanopb_msgopt).no_unions\":true},\"oneofs\":{\"data\":{\"oneof\":[\"prepare\",\"confirm\"]}},\"fields\":{\"action\":{\"type\":\"Action\",\"id\":1},\"prepare\":{\"type\":\"Prepare\",\"id\":2},\"confirm\":{\"type\":\"Confirm\",\"id\":3}},\"nested\":{\"Action\":{\"values\":{\"RESET\":0,\"PREPARE\":1,\"CONFIRM\":2}},\"Prepare\":{\"fields\":{\"serverNonce\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":32}}}},\"Confirm\":{\"fields\":{\"serverSignature\":{\"type\":\"bytes\",\"id\":1},\"serverPublicKeyFingerprint\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":32}}}}}},\"SetProtectedStateReply\":{\"oneofs\":{\"_prepare\":{\"oneof\":[\"prepare\"]}},\"fields\":{\"prepare\":{\"type\":\"Prepare\",\"id\":1,\"options\":{\"proto3_optional\":true}}},\"nested\":{\"Prepare\":{\"fields\":{\"deviceNonce\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":32}},\"deviceSignature\":{\"type\":\"bytes\",\"id\":2},\"devicePublicKeyFingerprint\":{\"type\":\"bytes\",\"id\":3,\"options\":{\"(nanopb).max_size\":32}}}}}},\"SystemResetRequest\":{\"options\":{\"(type_id)\":40},\"fields\":{}},\"SystemResetReply\":{\"fields\":{}},\"SetFeatureRequest\":{\"options\":{\"(type_id)\":33},\"fields\":{\"feature\":{\"type\":\"Feature\",\"id\":1},\"enabled\":{\"type\":\"bool\",\"id\":2}}},\"SetFeatureReply\":{\"fields\":{}},\"GetFeatureRequest\":{\"options\":{\"(type_id)\":34},\"fields\":{\"feature\":{\"type\":\"Feature\",\"id\":1}}},\"GetFeatureReply\":{\"fields\":{\"enabled\":{\"type\":\"bool\",\"id\":1}}},\"StartNyanSignalRequest\":{\"options\":{\"(type_id)\":230},\"fields\":{}},\"StartNyanSignalReply\":{\"fields\":{}},\"StopNyanSignalRequest\":{\"options\":{\"(type_id)\":231},\"fields\":{}},\"StopNyanSignalReply\":{\"fields\":{}},\"logging\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.logging\"},\"nested\":{\"LogLevel\":{\"options\":{\"allow_alias\":true},\"values\":{\"INVALID_LOG_LEVEL\":0,\"ALL\":1,\"TRACE\":1,\"INFO\":30,\"WARN\":40,\"ERROR\":50,\"NONE\":70}},\"LogHandlerType\":{\"values\":{\"INVALID_LOG_HANDLER_TYPE\":0,\"DEFAULT_STREAM_HANDLER\":1,\"JSON_STREAM_HANDLER\":2}},\"StreamType\":{\"values\":{\"INVALID_STREAM_TYPE\":0,\"USB_SERIAL_STREAM\":1,\"HW_SERIAL_STREAM\":2}},\"LogFilter\":{\"fields\":{\"category\":{\"type\":\"string\",\"id\":1},\"level\":{\"type\":\"LogLevel\",\"id\":2}}},\"SerialStreamParams\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"baudRate\":{\"type\":\"uint32\",\"id\":2}}},\"AddLogHandlerRequest\":{\"options\":{\"(type_id)\":1100},\"oneofs\":{\"streamParams\":{\"oneof\":[\"serial\"]}},\"fields\":{\"id\":{\"type\":\"string\",\"id\":1},\"handlerType\":{\"type\":\"LogHandlerType\",\"id\":2},\"level\":{\"type\":\"LogLevel\",\"id\":3},\"filters\":{\"rule\":\"repeated\",\"type\":\"LogFilter\",\"id\":4},\"streamType\":{\"type\":\"StreamType\",\"id\":5},\"serial\":{\"type\":\"SerialStreamParams\",\"id\":6}}},\"AddLogHandlerReply\":{\"fields\":{}},\"RemoveLogHandlerRequest\":{\"options\":{\"(type_id)\":1101},\"fields\":{\"id\":{\"type\":\"string\",\"id\":1}}},\"RemoveLogHandlerReply\":{\"fields\":{}},\"GetLogHandlersRequest\":{\"options\":{\"(type_id)\":1102},\"fields\":{}},\"GetLogHandlersReply\":{\"fields\":{\"handlers\":{\"rule\":\"repeated\",\"type\":\"Handler\",\"id\":1}},\"nested\":{\"Handler\":{\"fields\":{\"id\":{\"type\":\"string\",\"id\":1}}}}}}},\"mesh\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.mesh\"},\"nested\":{\"NetworkInfo\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"extPanId\":{\"type\":\"string\",\"id\":2},\"panId\":{\"type\":\"uint32\",\"id\":3},\"channel\":{\"type\":\"uint32\",\"id\":4},\"networkId\":{\"type\":\"string\",\"id\":5}}},\"AuthRequest\":{\"options\":{\"(type_id)\":1001},\"fields\":{\"password\":{\"type\":\"string\",\"id\":1}}},\"AuthReply\":{\"fields\":{}},\"CreateNetworkRequest\":{\"options\":{\"(type_id)\":1002},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2},\"channel\":{\"type\":\"uint32\",\"id\":3},\"networkId\":{\"type\":\"string\",\"id\":4}}},\"CreateNetworkReply\":{\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"StartCommissionerRequest\":{\"options\":{\"(type_id)\":1003},\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1}}},\"StartCommissionerReply\":{\"fields\":{}},\"StopCommissionerRequest\":{\"options\":{\"(type_id)\":1004},\"fields\":{}},\"StopCommissionerReply\":{\"fields\":{}},\"PrepareJoinerRequest\":{\"options\":{\"(type_id)\":1005},\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"PrepareJoinerReply\":{\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2}}},\"AddJoinerRequest\":{\"options\":{\"(type_id)\":1006},\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2},\"timeout\":{\"type\":\"uint32\",\"id\":3}}},\"AddJoinerReply\":{\"fields\":{}},\"RemoveJoinerRequest\":{\"options\":{\"(type_id)\":1007},\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1}}},\"RemoveJoinerReply\":{\"fields\":{}},\"JoinNetworkRequest\":{\"options\":{\"(type_id)\":1008},\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1}}},\"JoinNetworkReply\":{\"fields\":{}},\"LeaveNetworkRequest\":{\"options\":{\"(type_id)\":1009},\"fields\":{}},\"LeaveNetworkReply\":{\"fields\":{}},\"GetNetworkInfoRequest\":{\"options\":{\"(type_id)\":1010},\"fields\":{}},\"GetNetworkInfoReply\":{\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"ScanNetworksRequest\":{\"options\":{\"(type_id)\":1011},\"fields\":{\"duration\":{\"type\":\"uint32\",\"id\":1}}},\"ScanNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"NetworkInfo\",\"id\":1}}},\"DiagnosticType\":{\"options\":{\"allow_alias\":true},\"values\":{\"MAC_EXTENDED_ADDRESS\":0,\"RLOC\":1,\"MAC_ADDRESS\":1,\"MODE\":2,\"TIMEOUT\":3,\"CONNECTIVITY\":4,\"ROUTE64\":5,\"LEADER_DATA\":6,\"NETWORK_DATA\":7,\"IPV6_ADDRESS_LIST\":8,\"MAC_COUNTERS\":9,\"BATTERY_LEVEL\":14,\"SUPPLY_VOLTAGE\":15,\"CHILD_TABLE\":16,\"CHANNEL_PAGES\":17,\"TYPE_LIST\":18,\"MAX_CHILD_TIMEOUT\":19}},\"DiagnosticInfo\":{\"fields\":{\"extMacAddress\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":8}},\"rloc\":{\"type\":\"uint32\",\"id\":2},\"mode\":{\"type\":\"uint32\",\"id\":3},\"timeout\":{\"type\":\"uint32\",\"id\":4},\"connectivity\":{\"type\":\"Connectivity\",\"id\":5},\"route64\":{\"type\":\"Route64\",\"id\":6},\"leaderData\":{\"type\":\"LeaderData\",\"id\":7},\"networkData\":{\"type\":\"NetworkData\",\"id\":8},\"ipv6AddressList\":{\"rule\":\"repeated\",\"type\":\"Ipv6Address\",\"id\":9},\"macCounters\":{\"type\":\"MacCounters\",\"id\":10},\"batteryLevel\":{\"type\":\"uint32\",\"id\":15},\"supplyVoltage\":{\"type\":\"uint32\",\"id\":16},\"childTable\":{\"type\":\"ChildTable\",\"id\":17},\"channelPages\":{\"type\":\"bytes\",\"id\":18,\"options\":{\"(nanopb).max_size\":3}},\"typeList\":{\"rule\":\"repeated\",\"type\":\"DiagnosticType\",\"id\":19},\"maxChildTimeout\":{\"type\":\"uint32\",\"id\":20},\"deviceId\":{\"type\":\"bytes\",\"id\":100,\"options\":{\"(nanopb).max_size\":12}}},\"nested\":{\"Mode\":{\"options\":{\"allow_alias\":true},\"values\":{\"INVALID\":0,\"RECEIVER_ON_WHEN_IDLE\":16,\"SECURE_DATA_REQUESTS\":32,\"DEVICE_TYPE\":48,\"DEVICE_TYPE_FTD\":48,\"NETWORK_DATA\":64,\"NETWORK_DATA_FULL\":64}},\"Connectivity\":{\"fields\":{\"parentPriority\":{\"type\":\"uint32\",\"id\":1},\"linkQuality_1\":{\"type\":\"uint32\",\"id\":2},\"linkQuality_2\":{\"type\":\"uint32\",\"id\":3},\"linkQuality_3\":{\"type\":\"uint32\",\"id\":4},\"leaderCost\":{\"type\":\"uint32\",\"id\":5},\"idSequence\":{\"type\":\"uint32\",\"id\":6},\"activeRouters\":{\"type\":\"uint32\",\"id\":7},\"sedBufferSize\":{\"type\":\"uint32\",\"id\":8},\"sedDatagramCount\":{\"type\":\"uint32\",\"id\":9}}},\"Route64\":{\"fields\":{\"idSequence\":{\"type\":\"uint32\",\"id\":1},\"routes\":{\"rule\":\"repeated\",\"type\":\"RouteData\",\"id\":2}},\"nested\":{\"RouteData\":{\"fields\":{\"routerRloc\":{\"type\":\"uint32\",\"id\":1},\"linkQualityOut\":{\"type\":\"uint32\",\"id\":2},\"linkQualityIn\":{\"type\":\"uint32\",\"id\":3},\"routeCost\":{\"type\":\"uint32\",\"id\":4}}}}},\"LeaderData\":{\"fields\":{\"partitionId\":{\"type\":\"uint32\",\"id\":1},\"weighting\":{\"type\":\"uint32\",\"id\":2},\"dataVersion\":{\"type\":\"uint32\",\"id\":3},\"stableDataVersion\":{\"type\":\"uint32\",\"id\":4},\"leaderRloc\":{\"type\":\"uint32\",\"id\":5}}},\"RoutePreference\":{\"values\":{\"MEDIUM\":0,\"HIGH\":1,\"LOW\":-1}},\"NetworkData\":{\"fields\":{\"stable\":{\"type\":\"Data\",\"id\":1},\"temporary\":{\"type\":\"Data\",\"id\":2}},\"nested\":{\"HasRoute\":{\"fields\":{\"entries\":{\"rule\":\"repeated\",\"type\":\"HasRouteEntry\",\"id\":1}},\"nested\":{\"HasRouteEntry\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"preference\":{\"type\":\"RoutePreference\",\"id\":2}}}}},\"BorderRouter\":{\"fields\":{\"entries\":{\"rule\":\"repeated\",\"type\":\"BorderRouterEntry\",\"id\":1}},\"nested\":{\"BorderRouterEntry\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"preference\":{\"type\":\"RoutePreference\",\"id\":2},\"flags\":{\"type\":\"uint32\",\"id\":3}},\"nested\":{\"Flags\":{\"values\":{\"NONE\":0,\"PREFERRED\":1,\"SLAAC\":2,\"DHCP\":4,\"CONFIGURE\":8,\"DEFAULT_ROUTE\":16,\"ON_MESH\":32,\"ND_DNS\":64}}}}}},\"Context\":{\"fields\":{\"cid\":{\"type\":\"uint32\",\"id\":1},\"compress\":{\"type\":\"bool\",\"id\":2},\"contextLength\":{\"type\":\"uint32\",\"id\":3}}},\"Prefix\":{\"fields\":{\"domainId\":{\"type\":\"uint32\",\"id\":1},\"prefixLength\":{\"type\":\"uint32\",\"id\":2},\"prefix\":{\"type\":\"bytes\",\"id\":3,\"options\":{\"(nanopb).max_size\":16}},\"context\":{\"rule\":\"repeated\",\"type\":\"Context\",\"id\":4},\"hasRoute\":{\"type\":\"HasRoute\",\"id\":5},\"borderRouter\":{\"type\":\"BorderRouter\",\"id\":6}}},\"Server\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"data\":{\"type\":\"bytes\",\"id\":2}}},\"Service\":{\"fields\":{\"sid\":{\"type\":\"uint32\",\"id\":1},\"enterpriseNumber\":{\"type\":\"uint32\",\"id\":2},\"data\":{\"type\":\"bytes\",\"id\":3},\"servers\":{\"rule\":\"repeated\",\"type\":\"Server\",\"id\":4}}},\"Data\":{\"fields\":{\"prefixes\":{\"rule\":\"repeated\",\"type\":\"Prefix\",\"id\":1},\"services\":{\"rule\":\"repeated\",\"type\":\"Service\",\"id\":2}}}}},\"MacCounters\":{\"fields\":{\"ifInUnknownProtos\":{\"type\":\"uint32\",\"id\":1},\"ifInErrors\":{\"type\":\"uint32\",\"id\":2},\"ifOutErrors\":{\"type\":\"uint32\",\"id\":3},\"ifInUcastPkts\":{\"type\":\"uint32\",\"id\":4},\"ifInBroadcastPkts\":{\"type\":\"uint32\",\"id\":5},\"ifInDiscards\":{\"type\":\"uint32\",\"id\":6},\"ifOutUcastPkts\":{\"type\":\"uint32\",\"id\":7},\"ifOutBroadcastPkts\":{\"type\":\"uint32\",\"id\":8},\"ifOutDiscards\":{\"type\":\"uint32\",\"id\":9}}},\"ChildTable\":{\"fields\":{\"children\":{\"rule\":\"repeated\",\"type\":\"ChildEntry\",\"id\":1}},\"nested\":{\"ChildEntry\":{\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1},\"childId\":{\"type\":\"uint32\",\"id\":2},\"mode\":{\"type\":\"uint32\",\"id\":3}}}}}}},\"GetNetworkDiagnosticsRequest\":{\"options\":{\"(type_id)\":1012},\"fields\":{\"flags\":{\"type\":\"uint32\",\"id\":1},\"diagnosticTypes\":{\"rule\":\"repeated\",\"type\":\"DiagnosticType\",\"id\":2},\"timeout\":{\"type\":\"uint32\",\"id\":3}},\"nested\":{\"Flags\":{\"values\":{\"INVALID\":0,\"QUERY_CHILDREN\":1,\"RESOLVE_DEVICE_ID\":2}}}},\"GetNetworkDiagnosticsReply\":{\"fields\":{\"nodes\":{\"rule\":\"repeated\",\"type\":\"DiagnosticInfo\",\"id\":1}}}}},\"InterfaceConfigurationSource\":{\"values\":{\"NONE\":0,\"DHCP\":1,\"STATIC\":2,\"SLAAC\":3,\"DHCPV6\":4}},\"InterfaceAddress\":{\"fields\":{\"address\":{\"type\":\"IpAddress\",\"id\":1},\"prefixLength\":{\"type\":\"uint32\",\"id\":2}}},\"Ipv4Config\":{\"fields\":{\"addresses\":{\"rule\":\"repeated\",\"type\":\"InterfaceAddress\",\"id\":1},\"peer\":{\"type\":\"Ipv4Address\",\"id\":2},\"gateway\":{\"type\":\"Ipv4Address\",\"id\":3,\"options\":{\"(nanopb).proto3\":false}},\"dns\":{\"rule\":\"repeated\",\"type\":\"Ipv4Address\",\"id\":4},\"source\":{\"type\":\"InterfaceConfigurationSource\",\"id\":5}}},\"Ipv6Config\":{\"fields\":{\"addresses\":{\"rule\":\"repeated\",\"type\":\"InterfaceAddress\",\"id\":1},\"dns\":{\"rule\":\"repeated\",\"type\":\"Ipv6Address\",\"id\":2},\"source\":{\"type\":\"InterfaceConfigurationSource\",\"id\":3},\"gateway\":{\"type\":\"Ipv6Address\",\"id\":4,\"options\":{\"(nanopb).proto3\":false}}}},\"InterfaceFlag\":{\"options\":{\"allow_alias\":true},\"values\":{\"IFF_NONE\":0,\"IFF_UP\":1,\"IFF_BROADCAST\":2,\"IFF_DEBUG\":4,\"IFF_LOOPBACK\":8,\"IFF_POINTTOPOINT\":16,\"IFF_RUNNING\":64,\"IFF_LOWER_UP\":64,\"IFF_NOARP\":128,\"IFF_PROMISC\":256,\"IFF_ALLMULTI\":512,\"IFF_MULTICAST\":32768,\"IFF_NOND6\":65536}},\"InterfaceExtFlag\":{\"values\":{\"IFXF_NONE\":0,\"IFXF_WOL\":16,\"IFXF_AUTOCONF6\":32,\"IFXF_DHCP\":65536,\"IFXF_DHCP6\":131072,\"IFXF_AUTOIP\":262144}},\"InterfaceType\":{\"values\":{\"INVALID_INTERFACE_TYPE\":0,\"LOOPBACK\":1,\"THREAD\":2,\"ETHERNET\":4,\"WIFI\":8,\"PPP\":16}},\"Interface\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"name\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"InterfaceType\",\"id\":3},\"flags\":{\"type\":\"uint32\",\"id\":4},\"extFlags\":{\"type\":\"uint32\",\"id\":5},\"ipv4Config\":{\"type\":\"Ipv4Config\",\"id\":6},\"ipv6Config\":{\"type\":\"Ipv6Config\",\"id\":7},\"hwAddress\":{\"type\":\"bytes\",\"id\":8,\"options\":{\"(nanopb).max_size\":8}},\"mtu\":{\"type\":\"uint32\",\"id\":9},\"metric\":{\"type\":\"uint32\",\"id\":10},\"profile\":{\"type\":\"bytes\",\"id\":11}}},\"InterfaceEntry\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"name\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"InterfaceType\",\"id\":3}}},\"GetInterfaceListRequest\":{\"options\":{\"(type_id)\":400},\"fields\":{}},\"GetInterfaceListReply\":{\"fields\":{\"interfaces\":{\"rule\":\"repeated\",\"type\":\"InterfaceEntry\",\"id\":1}}},\"GetInterfaceRequest\":{\"options\":{\"(type_id)\":401},\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1}}},\"GetInterfaceReply\":{\"fields\":{\"interface\":{\"type\":\"Interface\",\"id\":1}}},\"GetInterfaceStoredConfigurationRequest\":{\"options\":{\"(type_id)\":402},\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1}}},\"GetInterfaceStoredConfigurationReply\":{\"fields\":{\"config\":{\"rule\":\"repeated\",\"type\":\"Interface\",\"id\":1}}},\"SetInterfaceStoredConfigurationRequest\":{\"options\":{\"(type_id)\":403},\"fields\":{\"config\":{\"type\":\"Interface\",\"id\":1}}},\"SetInterfaceStoredConfigurationReply\":{\"fields\":{}},\"DeleteInterfaceStoredConfigurationRequest\":{\"options\":{\"(type_id)\":404},\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"profile\":{\"type\":\"bytes\",\"id\":2}}},\"DeleteInterfaceStoredConfigurationReply\":{\"fields\":{}},\"NetworkGetStatusRequest\":{\"options\":{\"(type_id)\":122},\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1}}},\"NetworkGetStatusReply\":{\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkGetConfigurationRequest\":{\"options\":{\"(type_id)\":120},\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1}}},\"NetworkGetConfigurationReply\":{\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkSetConfigurationRequest\":{\"options\":{\"(type_id)\":121},\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkSetConfigurationReply\":{\"fields\":{}},\"NetworkState\":{\"values\":{\"NETWORK_STATUS_NONE\":0,\"DOWN\":1,\"UP\":2}},\"IPConfiguration\":{\"fields\":{\"type\":{\"type\":\"Type\",\"id\":1},\"address\":{\"type\":\"IPAddress\",\"id\":2},\"netmask\":{\"type\":\"IPAddress\",\"id\":3},\"gateway\":{\"type\":\"IPAddress\",\"id\":4},\"dhcpServer\":{\"type\":\"IPAddress\",\"id\":5},\"hostname\":{\"type\":\"string\",\"id\":6}},\"nested\":{\"Type\":{\"values\":{\"NONE\":0,\"DHCP\":1,\"STATIC\":2}}}},\"DNSConfiguration\":{\"fields\":{\"servers\":{\"rule\":\"repeated\",\"type\":\"IPAddress\",\"id\":1}}},\"NetworkConfiguration\":{\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1},\"state\":{\"type\":\"NetworkState\",\"id\":2},\"name\":{\"type\":\"string\",\"id\":3},\"mac\":{\"type\":\"bytes\",\"id\":4,\"options\":{\"(nanopb).max_size\":6}},\"ipconfig\":{\"type\":\"IPConfiguration\",\"id\":5},\"dnsconfig\":{\"type\":\"DNSConfiguration\",\"id\":6}}},\"StorageType\":{\"values\":{\"INVALID_STORAGE\":0,\"INTERNAL\":1}},\"SectionType\":{\"values\":{\"INVALID_SECTION\":0,\"FIRMWARE\":1,\"OTA_BACKUP\":2,\"FACTORY_BACKUP\":3,\"CONFIG\":4,\"EEPROM\":5}},\"FirmwareModuleType\":{\"values\":{\"INVALID_FIRMWARE_MODULE\":0,\"BOOTLOADER\":1,\"SYSTEM_PART\":2,\"USER_PART\":3,\"MONO_FIRMWARE\":4,\"NCP_FIRMWARE\":5,\"RADIO_STACK\":6}},\"FirmwareModuleValidityFlag\":{\"values\":{\"NO_VALIDATION_ERRORS\":0,\"INTEGRITY_CHECK_FAILED\":1,\"DEPENDENCY_CHECK_FAILED\":2}},\"SectionFlag\":{\"values\":{\"NO_SECTION_FLAGS\":0,\"CAN_READ\":1,\"CAN_WRITE\":2,\"CAN_CLEAR\":4,\"CAN_GET_SIZE\":8,\"NEED_CLEAR\":16}},\"FileFormat\":{\"values\":{\"BIN\":0,\"MINIZ\":1}},\"StartFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":250},\"fields\":{\"size\":{\"type\":\"uint32\",\"id\":1},\"format\":{\"type\":\"FileFormat\",\"id\":2}}},\"StartFirmwareUpdateReply\":{\"fields\":{\"chunkSize\":{\"type\":\"uint32\",\"id\":1}}},\"FinishFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":251},\"fields\":{\"validateOnly\":{\"type\":\"bool\",\"id\":1}}},\"FinishFirmwareUpdateReply\":{\"fields\":{}},\"CancelFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":252},\"fields\":{}},\"CancelFirmwareUpdateReply\":{\"fields\":{}},\"FirmwareUpdateDataRequest\":{\"options\":{\"(type_id)\":253},\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"FirmwareUpdateDataReply\":{\"fields\":{}},\"DescribeStorageRequest\":{\"options\":{\"(type_id)\":260},\"fields\":{}},\"DescribeStorageReply\":{\"fields\":{\"storage\":{\"rule\":\"repeated\",\"type\":\"Storage\",\"id\":1}},\"nested\":{\"Section\":{\"fields\":{\"type\":{\"type\":\"SectionType\",\"id\":1},\"size\":{\"type\":\"uint32\",\"id\":2},\"flags\":{\"type\":\"uint32\",\"id\":3},\"firmwareModule\":{\"type\":\"FirmwareModule\",\"id\":4}},\"nested\":{\"FirmwareModule\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2}}}}},\"Storage\":{\"fields\":{\"type\":{\"type\":\"StorageType\",\"id\":1},\"flags\":{\"type\":\"uint32\",\"id\":2},\"sections\":{\"rule\":\"repeated\",\"type\":\"Section\",\"id\":3}}}}},\"ReadSectionDataRequest\":{\"options\":{\"(type_id)\":261},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2},\"offset\":{\"type\":\"uint32\",\"id\":3},\"size\":{\"type\":\"uint32\",\"id\":4}}},\"ReadSectionDataReply\":{\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"WriteSectionDataRequest\":{\"options\":{\"(type_id)\":262},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2},\"offset\":{\"type\":\"uint32\",\"id\":3},\"data\":{\"type\":\"bytes\",\"id\":4}}},\"WriteSectionDataReply\":{\"fields\":{}},\"ClearSectionDataRequest\":{\"options\":{\"(type_id)\":263},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2}}},\"ClearSectionDataReply\":{\"fields\":{}},\"GetSectionDataSizeRequest\":{\"options\":{\"(type_id)\":264},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2}}},\"GetSectionDataSizeReply\":{\"fields\":{\"size\":{\"type\":\"uint32\",\"id\":1}}},\"GetModuleInfoRequest\":{\"options\":{\"(type_id)\":90},\"fields\":{}},\"GetModuleInfoReply\":{\"fields\":{\"modulesDeprecated\":{\"rule\":\"repeated\",\"type\":\"Module\",\"id\":1},\"modules\":{\"rule\":\"repeated\",\"type\":\"particle.cloud.FirmwareModule\",\"id\":2}},\"nested\":{\"Dependency\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3}}},\"Module\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3},\"size\":{\"type\":\"uint32\",\"id\":4},\"validity\":{\"type\":\"uint32\",\"id\":5},\"dependencies\":{\"rule\":\"repeated\",\"type\":\"Dependency\",\"id\":6}}}}},\"GetAssetInfoRequest\":{\"options\":{\"(type_id)\":91},\"fields\":{}},\"GetAssetInfoReply\":{\"fields\":{\"available\":{\"rule\":\"repeated\",\"type\":\"particle.cloud.FirmwareModuleAsset\",\"id\":1},\"required\":{\"rule\":\"repeated\",\"type\":\"particle.cloud.FirmwareModuleAsset\",\"id\":2}}},\"WiFiGetAntennaRequest\":{\"options\":{\"(type_id)\":111},\"fields\":{}},\"WiFiGetAntennaReply\":{\"fields\":{\"antenna\":{\"type\":\"WiFiAntenna\",\"id\":1}}},\"WiFiSetAntennaRequest\":{\"options\":{\"(type_id)\":110},\"fields\":{\"antenna\":{\"type\":\"WiFiAntenna\",\"id\":1}}},\"WiFiSetAntennaReply\":{\"fields\":{}},\"WiFiScanRequest\":{\"options\":{\"(type_id)\":112},\"fields\":{}},\"WiFiScanReply\":{\"fields\":{\"list\":{\"type\":\"WiFiAccessPointList\",\"id\":1}}},\"WiFiGetCredentialsRequest\":{\"options\":{\"(type_id)\":114},\"fields\":{}},\"WiFiGetCredentialsReply\":{\"fields\":{\"list\":{\"type\":\"WiFiAccessPointList\",\"id\":1}}},\"WiFiSetCredentialsRequest\":{\"options\":{\"(type_id)\":113},\"fields\":{\"ap\":{\"type\":\"WiFiAccessPoint\",\"id\":1}}},\"WiFiSetCredentialsReply\":{\"fields\":{}},\"WiFiClearCredentialsRequest\":{\"options\":{\"(type_id)\":115},\"fields\":{}},\"WiFiClearCredentialsReply\":{\"fields\":{}},\"WiFiAntenna\":{\"values\":{\"ANTENNA_NONE\":0,\"INTERNAL\":1,\"EXTERNAL\":2,\"AUTO\":3}},\"WiFiSecurityType\":{\"values\":{\"UNSEC\":0,\"WEP\":1,\"WPA\":2,\"WPA2\":3,\"WPA_ENTERPRISE\":4,\"WPA2_ENTERPRISE\":5,\"UNKNOWN\":255}},\"WiFiSecurityCipher\":{\"values\":{\"CIPHER_NONE\":0,\"AES\":1,\"TKIP\":2,\"AES_TKIP\":3}},\"EapType\":{\"values\":{\"EAP_TYPE_NONE\":0,\"TLS\":13,\"PEAP\":25}},\"WiFiAccessPoint\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":33}},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6,\"(nanopb).fixed_length\":true}},\"security\":{\"type\":\"WiFiSecurityType\",\"id\":3},\"cipher\":{\"type\":\"WiFiSecurityCipher\",\"id\":4},\"channel\":{\"type\":\"uint32\",\"id\":5},\"maxDataRate\":{\"type\":\"int32\",\"id\":6},\"rssi\":{\"type\":\"int32\",\"id\":7},\"password\":{\"type\":\"string\",\"id\":8},\"eapType\":{\"type\":\"EapType\",\"id\":9},\"innerIdentity\":{\"type\":\"string\",\"id\":10},\"outerIdentity\":{\"type\":\"string\",\"id\":11},\"privateKey\":{\"type\":\"bytes\",\"id\":12},\"clientCertificate\":{\"type\":\"bytes\",\"id\":13},\"caCertificate\":{\"type\":\"bytes\",\"id\":14}}},\"WiFiAccessPointList\":{\"fields\":{\"aps\":{\"rule\":\"repeated\",\"type\":\"WiFiAccessPoint\",\"id\":1}}},\"wifi\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.wifi\"},\"nested\":{\"Security\":{\"values\":{\"NO_SECURITY\":0,\"WEP\":1,\"WPA_PSK\":2,\"WPA2_PSK\":3,\"WPA_WPA2_PSK\":4,\"WPA3_PSK\":5,\"WPA2_WPA3_PSK\":6}},\"CredentialsType\":{\"values\":{\"NO_CREDENTIALS\":0,\"PASSWORD\":1}},\"Credentials\":{\"fields\":{\"type\":{\"type\":\"CredentialsType\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2}}},\"JoinNewNetworkRequest\":{\"options\":{\"(type_id)\":500},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"Security\",\"id\":3},\"credentials\":{\"type\":\"Credentials\",\"id\":4},\"interfaceConfig\":{\"type\":\"Interface\",\"id\":5},\"hidden\":{\"type\":\"bool\",\"id\":6}}},\"JoinNewNetworkReply\":{\"fields\":{}},\"JoinKnownNetworkRequest\":{\"options\":{\"(type_id)\":501},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1}}},\"JoinKnownNetworkReply\":{\"fields\":{}},\"GetKnownNetworksRequest\":{\"options\":{\"(type_id)\":502},\"fields\":{}},\"GetKnownNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"Network\",\"id\":1}},\"nested\":{\"Network\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"security\":{\"type\":\"Security\",\"id\":2},\"credentialsType\":{\"type\":\"CredentialsType\",\"id\":3}}}}},\"RemoveKnownNetworkRequest\":{\"options\":{\"(type_id)\":503},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1}}},\"RemoveKnownNetworkReply\":{\"fields\":{}},\"ClearKnownNetworksRequest\":{\"options\":{\"(type_id)\":504},\"fields\":{}},\"ClearKnownNetworksReply\":{\"fields\":{}},\"GetCurrentNetworkRequest\":{\"options\":{\"(type_id)\":505},\"fields\":{}},\"GetCurrentNetworkReply\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"channel\":{\"type\":\"int32\",\"id\":3},\"rssi\":{\"type\":\"int32\",\"id\":4}}},\"ScanNetworksRequest\":{\"options\":{\"(type_id)\":506},\"fields\":{}},\"ScanNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"Network\",\"id\":1}},\"nested\":{\"Network\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"Security\",\"id\":3},\"channel\":{\"type\":\"int32\",\"id\":4},\"rssi\":{\"type\":\"int32\",\"id\":5}}}}},\"SetNetworkCredentialsRequest\":{\"options\":{\"(type_id)\":507},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"Security\",\"id\":3},\"credentials\":{\"type\":\"Credentials\",\"id\":4},\"interfaceConfig\":{\"type\":\"Interface\",\"id\":5},\"hidden\":{\"type\":\"bool\",\"id\":6}}},\"SetNetworkCredentialsReply\":{\"fields\":{}}}}}},\"cloud\":{\"nested\":{\"Request\":{\"oneofs\":{\"data\":{\"oneof\":[\"ledgerGetInfo\",\"ledgerSetData\",\"ledgerGetData\",\"ledgerSubscribe\",\"ledgerNotifyUpdate\",\"ledgerResetInfo\"]}},\"fields\":{\"type\":{\"type\":\"Type\",\"id\":1},\"ledgerGetInfo\":{\"type\":\"ledger.GetInfoRequest\",\"id\":2},\"ledgerSetData\":{\"type\":\"ledger.SetDataRequest\",\"id\":3},\"ledgerGetData\":{\"type\":\"ledger.GetDataRequest\",\"id\":4},\"ledgerSubscribe\":{\"type\":\"ledger.SubscribeRequest\",\"id\":5},\"ledgerNotifyUpdate\":{\"type\":\"ledger.NotifyUpdateRequest\",\"id\":6},\"ledgerResetInfo\":{\"type\":\"ledger.ResetInfoRequest\",\"id\":7}},\"nested\":{\"Type\":{\"values\":{\"INVALID\":0,\"LEDGER_GET_INFO\":1,\"LEDGER_SET_DATA\":2,\"LEDGER_GET_DATA\":3,\"LEDGER_SUBSCRIBE\":4,\"LEDGER_NOTIFY_UPDATE\":5,\"LEDGER_RESET_INFO\":6}}}},\"Response\":{\"oneofs\":{\"_message\":{\"oneof\":[\"message\"]},\"data\":{\"oneof\":[\"ledgerGetInfo\",\"ledgerSetData\",\"ledgerGetData\",\"ledgerSubscribe\",\"ledgerNotifyUpdate\",\"ledgerResetInfo\"]}},\"fields\":{\"result\":{\"type\":\"sint32\",\"id\":1},\"message\":{\"type\":\"string\",\"id\":2,\"options\":{\"proto3_optional\":true}},\"ledgerGetInfo\":{\"type\":\"ledger.GetInfoResponse\",\"id\":3},\"ledgerSetData\":{\"type\":\"ledger.SetDataResponse\",\"id\":4},\"ledgerGetData\":{\"type\":\"ledger.GetDataResponse\",\"id\":5},\"ledgerSubscribe\":{\"type\":\"ledger.SubscribeResponse\",\"id\":6},\"ledgerNotifyUpdate\":{\"type\":\"ledger.NotifyUpdateResponse\",\"id\":7},\"ledgerResetInfo\":{\"type\":\"ledger.ResetInfoResponse\",\"id\":8}},\"nested\":{\"Result\":{\"values\":{\"OK\":0,\"ERROR\":1,\"LEDGER_NOT_FOUND\":2,\"LEDGER_INVALID_SYNC_DIRECTION\":3,\"LEDGER_SCOPE_CHANGED\":4,\"LEDGER_INVALID_DATA\":5,\"LEDGER_TOO_LARGE_DATA\":6}}}},\"ServerMovedPermanentlyRequest\":{\"fields\":{\"serverAddr\":{\"type\":\"string\",\"id\":1},\"serverPort\":{\"type\":\"uint32\",\"id\":2},\"serverPubKey\":{\"type\":\"bytes\",\"id\":3},\"sign\":{\"type\":\"bytes\",\"id\":4}}},\"ServerMovedPermanentlyResponse\":{\"fields\":{}},\"ledger\":{\"nested\":{\"ScopeType\":{\"values\":{\"SCOPE_TYPE_UNKNOWN\":0,\"SCOPE_TYPE_DEVICE\":1,\"SCOPE_TYPE_PRODUCT\":2,\"SCOPE_TYPE_OWNER\":3}},\"SyncDirection\":{\"values\":{\"SYNC_DIRECTION_UNKNOWN\":0,\"SYNC_DIRECTION_DEVICE_TO_CLOUD\":1,\"SYNC_DIRECTION_CLOUD_TO_DEVICE\":2}},\"GetInfoRequest\":{\"fields\":{\"ledgers\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":1}}},\"GetInfoResponse\":{\"fields\":{\"ledgers\":{\"rule\":\"repeated\",\"type\":\"Ledger\",\"id\":1}},\"nested\":{\"Ledger\":{\"oneofs\":{\"_lastUpdated\":{\"oneof\":[\"lastUpdated\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"scopeId\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":32}},\"scopeType\":{\"type\":\"ScopeType\",\"id\":3},\"syncDirection\":{\"type\":\"SyncDirection\",\"id\":4},\"lastUpdated\":{\"type\":\"fixed64\",\"id\":5,\"options\":{\"proto3_optional\":true}}}}}},\"SetDataRequest\":{\"oneofs\":{\"_lastUpdated\":{\"oneof\":[\"lastUpdated\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"scopeId\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":32}},\"lastUpdated\":{\"type\":\"fixed64\",\"id\":3,\"options\":{\"proto3_optional\":true}},\"data\":{\"type\":\"bytes\",\"id\":10}}},\"SetDataResponse\":{\"fields\":{}},\"GetDataRequest\":{\"oneofs\":{\"_lastUpdated\":{\"oneof\":[\"lastUpdated\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"scopeId\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":32}},\"lastUpdated\":{\"type\":\"fixed64\",\"id\":3,\"options\":{\"proto3_optional\":true}}}},\"GetDataResponse\":{\"oneofs\":{\"_lastUpdated\":{\"oneof\":[\"lastUpdated\"]},\"_data\":{\"oneof\":[\"data\"]}},\"fields\":{\"lastUpdated\":{\"type\":\"fixed64\",\"id\":1,\"options\":{\"proto3_optional\":true}},\"data\":{\"type\":\"bytes\",\"id\":10,\"options\":{\"proto3_optional\":true}}}},\"SubscribeRequest\":{\"fields\":{\"ledgers\":{\"rule\":\"repeated\",\"type\":\"Ledger\",\"id\":1}},\"nested\":{\"Ledger\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"scopeId\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":32}}}}}},\"SubscribeResponse\":{\"fields\":{\"ledgers\":{\"rule\":\"repeated\",\"type\":\"Ledger\",\"id\":1}},\"nested\":{\"Ledger\":{\"oneofs\":{\"_lastUpdated\":{\"oneof\":[\"lastUpdated\"]}},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"lastUpdated\":{\"type\":\"fixed64\",\"id\":2,\"options\":{\"proto3_optional\":true}}}}}},\"NotifyUpdateRequest\":{\"fields\":{\"ledgers\":{\"rule\":\"repeated\",\"type\":\"Ledger\",\"id\":1}},\"nested\":{\"Ledger\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_length\":32}},\"lastUpdated\":{\"type\":\"fixed64\",\"id\":2}}}}},\"NotifyUpdateResponse\":{\"fields\":{}},\"ResetInfoRequest\":{\"fields\":{}},\"ResetInfoResponse\":{\"fields\":{}}}},\"FirmwareModuleType\":{\"values\":{\"INVALID_MODULE\":0,\"RESOURCE_MODULE\":1,\"BOOTLOADER_MODULE\":2,\"MONO_FIRMWARE_MODULE\":3,\"SYSTEM_PART_MODULE\":4,\"USER_PART_MODULE\":5,\"SETTINGS_MODULE\":6,\"NCP_FIRMWARE_MODULE\":7,\"RADIO_STACK_MODULE\":8,\"ASSET_MODULE\":9}},\"FirmwareModuleStore\":{\"values\":{\"MAIN_MODULE_STORE\":0,\"FACTORY_MODULE_STORE\":1,\"BACKUP_MODULE_STORE\":2,\"SCRATCHPAD_MODULE_STORE\":3}},\"FirmwareModuleValidityFlag\":{\"values\":{\"MODULE_NO_VALID_FLAGS\":0,\"MODULE_INTEGRITY_VALID_FLAG\":2,\"MODULE_DEPENDENCIES_VALID_FLAG\":4,\"MODULE_RANGE_VALID_FLAG\":8,\"MODULE_PLATFORM_VALID_FLAG\":16}},\"FirmwareModuleSecurityMode\":{\"values\":{\"NONE\":0,\"PROTECTED\":1}},\"FirmwareModuleSecurity\":{\"fields\":{\"mode\":{\"type\":\"FirmwareModuleSecurityMode\",\"id\":1},\"certificateFingerprint\":{\"type\":\"bytes\",\"id\":2}}},\"FirmwareModuleDependency\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3}}},\"FirmwareModuleAsset\":{\"fields\":{\"hash\":{\"type\":\"bytes\",\"id\":1},\"name\":{\"type\":\"string\",\"id\":2},\"size\":{\"type\":\"uint32\",\"id\":3},\"storageSize\":{\"type\":\"uint32\",\"id\":4}}},\"FirmwareModule\":{\"oneofs\":{\"_hash\":{\"oneof\":[\"hash\"]}},\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3},\"store\":{\"type\":\"FirmwareModuleStore\",\"id\":4},\"maxSize\":{\"type\":\"uint32\",\"id\":5},\"checkedFlags\":{\"type\":\"fixed32\",\"id\":6},\"passedFlags\":{\"type\":\"fixed32\",\"id\":7},\"hash\":{\"type\":\"bytes\",\"id\":8,\"options\":{\"proto3_optional\":true}},\"dependencies\":{\"rule\":\"repeated\",\"type\":\"FirmwareModuleDependency\",\"id\":9},\"assetDependencies\":{\"rule\":\"repeated\",\"type\":\"FirmwareModuleAsset\",\"id\":10},\"size\":{\"type\":\"uint32\",\"id\":11},\"security\":{\"type\":\"FirmwareModuleSecurity\",\"id\":12}}},\"SystemDescribe\":{\"oneofs\":{\"_imei\":{\"oneof\":[\"imei\"]},\"_iccid\":{\"oneof\":[\"iccid\"]},\"_modemFirmwareVersion\":{\"oneof\":[\"modemFirmwareVersion\"]}},\"fields\":{\"firmwareModules\":{\"rule\":\"repeated\",\"type\":\"FirmwareModule\",\"id\":1},\"imei\":{\"type\":\"string\",\"id\":2,\"options\":{\"proto3_optional\":true}},\"iccid\":{\"type\":\"string\",\"id\":3,\"options\":{\"proto3_optional\":true}},\"modemFirmwareVersion\":{\"type\":\"string\",\"id\":4,\"options\":{\"proto3_optional\":true}},\"assets\":{\"rule\":\"repeated\",\"type\":\"FirmwareModuleAsset\",\"id\":5},\"protectedState\":{\"type\":\"bool\",\"id\":6}}}}}}},\"typeId\":{\"type\":\"int32\",\"id\":50001,\"extend\":\"google.protobuf.MessageOptions\"},\"intValue\":{\"type\":\"int32\",\"id\":50002,\"extend\":\"google.protobuf.EnumValueOptions\"},\"google\":{\"nested\":{\"protobuf\":{\"nested\":{\"FileDescriptorSet\":{\"fields\":{\"file\":{\"rule\":\"repeated\",\"type\":\"FileDescriptorProto\",\"id\":1}}},\"FileDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"package\":{\"type\":\"string\",\"id\":2},\"dependency\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":3},\"publicDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":10,\"options\":{\"packed\":false}},\"weakDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":11,\"options\":{\"packed\":false}},\"messageType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":4},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":5},\"service\":{\"rule\":\"repeated\",\"type\":\"ServiceDescriptorProto\",\"id\":6},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":7},\"options\":{\"type\":\"FileOptions\",\"id\":8},\"sourceCodeInfo\":{\"type\":\"SourceCodeInfo\",\"id\":9},\"syntax\":{\"type\":\"string\",\"id\":12}}},\"DescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"field\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":2},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":6},\"nestedType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":3},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":4},\"extensionRange\":{\"rule\":\"repeated\",\"type\":\"ExtensionRange\",\"id\":5},\"oneofDecl\":{\"rule\":\"repeated\",\"type\":\"OneofDescriptorProto\",\"id\":8},\"options\":{\"type\":\"MessageOptions\",\"id\":7},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"ReservedRange\",\"id\":9},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":10}},\"nested\":{\"ExtensionRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}},\"ReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"FieldDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":3},\"label\":{\"type\":\"Label\",\"id\":4},\"type\":{\"type\":\"Type\",\"id\":5},\"typeName\":{\"type\":\"string\",\"id\":6},\"extendee\":{\"type\":\"string\",\"id\":2},\"defaultValue\":{\"type\":\"string\",\"id\":7},\"oneofIndex\":{\"type\":\"int32\",\"id\":9},\"jsonName\":{\"type\":\"string\",\"id\":10},\"options\":{\"type\":\"FieldOptions\",\"id\":8}},\"nested\":{\"Type\":{\"values\":{\"TYPE_DOUBLE\":1,\"TYPE_FLOAT\":2,\"TYPE_INT64\":3,\"TYPE_UINT64\":4,\"TYPE_INT32\":5,\"TYPE_FIXED64\":6,\"TYPE_FIXED32\":7,\"TYPE_BOOL\":8,\"TYPE_STRING\":9,\"TYPE_GROUP\":10,\"TYPE_MESSAGE\":11,\"TYPE_BYTES\":12,\"TYPE_UINT32\":13,\"TYPE_ENUM\":14,\"TYPE_SFIXED32\":15,\"TYPE_SFIXED64\":16,\"TYPE_SINT32\":17,\"TYPE_SINT64\":18}},\"Label\":{\"values\":{\"LABEL_OPTIONAL\":1,\"LABEL_REQUIRED\":2,\"LABEL_REPEATED\":3}}}},\"OneofDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"options\":{\"type\":\"OneofOptions\",\"id\":2}}},\"EnumDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"value\":{\"rule\":\"repeated\",\"type\":\"EnumValueDescriptorProto\",\"id\":2},\"options\":{\"type\":\"EnumOptions\",\"id\":3}}},\"EnumValueDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"EnumValueOptions\",\"id\":3}}},\"ServiceDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"method\":{\"rule\":\"repeated\",\"type\":\"MethodDescriptorProto\",\"id\":2},\"options\":{\"type\":\"ServiceOptions\",\"id\":3}}},\"MethodDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"inputType\":{\"type\":\"string\",\"id\":2},\"outputType\":{\"type\":\"string\",\"id\":3},\"options\":{\"type\":\"MethodOptions\",\"id\":4},\"clientStreaming\":{\"type\":\"bool\",\"id\":5},\"serverStreaming\":{\"type\":\"bool\",\"id\":6}}},\"FileOptions\":{\"fields\":{\"javaPackage\":{\"type\":\"string\",\"id\":1},\"javaOuterClassname\":{\"type\":\"string\",\"id\":8},\"javaMultipleFiles\":{\"type\":\"bool\",\"id\":10},\"javaGenerateEqualsAndHash\":{\"type\":\"bool\",\"id\":20,\"options\":{\"deprecated\":true}},\"javaStringCheckUtf8\":{\"type\":\"bool\",\"id\":27},\"optimizeFor\":{\"type\":\"OptimizeMode\",\"id\":9,\"options\":{\"default\":\"SPEED\"}},\"goPackage\":{\"type\":\"string\",\"id\":11},\"ccGenericServices\":{\"type\":\"bool\",\"id\":16},\"javaGenericServices\":{\"type\":\"bool\",\"id\":17},\"pyGenericServices\":{\"type\":\"bool\",\"id\":18},\"deprecated\":{\"type\":\"bool\",\"id\":23},\"ccEnableArenas\":{\"type\":\"bool\",\"id\":31},\"objcClassPrefix\":{\"type\":\"string\",\"id\":36},\"csharpNamespace\":{\"type\":\"string\",\"id\":37},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[38,38]],\"nested\":{\"OptimizeMode\":{\"values\":{\"SPEED\":1,\"CODE_SIZE\":2,\"LITE_RUNTIME\":3}}}},\"MessageOptions\":{\"fields\":{\"messageSetWireFormat\":{\"type\":\"bool\",\"id\":1},\"noStandardDescriptorAccessor\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"mapEntry\":{\"type\":\"bool\",\"id\":7},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[8,8]]},\"FieldOptions\":{\"fields\":{\"ctype\":{\"type\":\"CType\",\"id\":1,\"options\":{\"default\":\"STRING\"}},\"packed\":{\"type\":\"bool\",\"id\":2},\"jstype\":{\"type\":\"JSType\",\"id\":6,\"options\":{\"default\":\"JS_NORMAL\"}},\"lazy\":{\"type\":\"bool\",\"id\":5},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"weak\":{\"type\":\"bool\",\"id\":10},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[4,4]],\"nested\":{\"CType\":{\"values\":{\"STRING\":0,\"CORD\":1,\"STRING_PIECE\":2}},\"JSType\":{\"values\":{\"JS_NORMAL\":0,\"JS_STRING\":1,\"JS_NUMBER\":2}}}},\"OneofOptions\":{\"fields\":{\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumOptions\":{\"fields\":{\"allowAlias\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumValueOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":1},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"ServiceOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"MethodOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"UninterpretedOption\":{\"fields\":{\"name\":{\"rule\":\"repeated\",\"type\":\"NamePart\",\"id\":2},\"identifierValue\":{\"type\":\"string\",\"id\":3},\"positiveIntValue\":{\"type\":\"uint64\",\"id\":4},\"negativeIntValue\":{\"type\":\"int64\",\"id\":5},\"doubleValue\":{\"type\":\"double\",\"id\":6},\"stringValue\":{\"type\":\"bytes\",\"id\":7},\"aggregateValue\":{\"type\":\"string\",\"id\":8}},\"nested\":{\"NamePart\":{\"fields\":{\"namePart\":{\"rule\":\"required\",\"type\":\"string\",\"id\":1},\"isExtension\":{\"rule\":\"required\",\"type\":\"bool\",\"id\":2}}}}},\"SourceCodeInfo\":{\"fields\":{\"location\":{\"rule\":\"repeated\",\"type\":\"Location\",\"id\":1}},\"nested\":{\"Location\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"span\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"leadingComments\":{\"type\":\"string\",\"id\":3},\"trailingComments\":{\"type\":\"string\",\"id\":4},\"leadingDetachedComments\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6}}}}},\"GeneratedCodeInfo\":{\"fields\":{\"annotation\":{\"rule\":\"repeated\",\"type\":\"Annotation\",\"id\":1}},\"nested\":{\"Annotation\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"sourceFile\":{\"type\":\"string\",\"id\":2},\"begin\":{\"type\":\"int32\",\"id\":3},\"end\":{\"type\":\"int32\",\"id\":4}}}}}}}}}}}');\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/particle-usb.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});