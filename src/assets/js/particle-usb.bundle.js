(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("ParticleUsb", [], factory);
	else if(typeof exports === 'object')
		exports["ParticleUsb"] = factory();
	else
		root["ParticleUsb"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/particle-usb.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/pb-message.js":
/*!***************************!*\
  !*** ./lib/pb-message.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (true)\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /* CommonJS */ else {}\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.particle = (function() {\n    \n        var particle = {};\n    \n        particle.ctrl = (function() {\n    \n            var ctrl = {};\n    \n            ctrl.cellular = (function() {\n    \n                var cellular = {};\n    \n                cellular.SimType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_SIM_TYPE\"] = 0;\n                    values[valuesById[1] = \"INTERNAL\"] = 1;\n                    values[valuesById[2] = \"EXTERNAL\"] = 2;\n                    return values;\n                })();\n    \n                cellular.AccessPoint = (function() {\n    \n                    function AccessPoint(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AccessPoint.prototype.apn = \"\";\n                    AccessPoint.prototype.user = \"\";\n                    AccessPoint.prototype.password = \"\";\n                    AccessPoint.prototype.useDefaults = false;\n    \n                    AccessPoint.create = function create(properties) {\n                        return new AccessPoint(properties);\n                    };\n    \n                    AccessPoint.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.apn != null && m.hasOwnProperty(\"apn\"))\n                            w.uint32(10).string(m.apn);\n                        if (m.user != null && m.hasOwnProperty(\"user\"))\n                            w.uint32(18).string(m.user);\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(26).string(m.password);\n                        if (m.useDefaults != null && m.hasOwnProperty(\"useDefaults\"))\n                            w.uint32(32).bool(m.useDefaults);\n                        return w;\n                    };\n    \n                    AccessPoint.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.AccessPoint();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.apn = r.string();\n                                break;\n                            case 2:\n                                m.user = r.string();\n                                break;\n                            case 3:\n                                m.password = r.string();\n                                break;\n                            case 4:\n                                m.useDefaults = r.bool();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AccessPoint;\n                })();\n    \n                cellular.SetAccessPointRequest = (function() {\n    \n                    function SetAccessPointRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetAccessPointRequest.prototype.simType = 0;\n                    SetAccessPointRequest.prototype.accessPoint = null;\n    \n                    SetAccessPointRequest.create = function create(properties) {\n                        return new SetAccessPointRequest(properties);\n                    };\n    \n                    SetAccessPointRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && m.hasOwnProperty(\"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        if (m.accessPoint != null && m.hasOwnProperty(\"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(m.accessPoint, w.uint32(18).fork()).ldelim();\n                        return w;\n                    };\n    \n                    SetAccessPointRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetAccessPointRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            case 2:\n                                m.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetAccessPointRequest;\n                })();\n    \n                cellular.SetAccessPointReply = (function() {\n    \n                    function SetAccessPointReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetAccessPointReply.create = function create(properties) {\n                        return new SetAccessPointReply(properties);\n                    };\n    \n                    SetAccessPointReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    SetAccessPointReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetAccessPointReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetAccessPointReply;\n                })();\n    \n                cellular.GetAccessPointRequest = (function() {\n    \n                    function GetAccessPointRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetAccessPointRequest.prototype.simType = 0;\n    \n                    GetAccessPointRequest.create = function create(properties) {\n                        return new GetAccessPointRequest(properties);\n                    };\n    \n                    GetAccessPointRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && m.hasOwnProperty(\"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    GetAccessPointRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetAccessPointRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetAccessPointRequest;\n                })();\n    \n                cellular.GetAccessPointReply = (function() {\n    \n                    function GetAccessPointReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetAccessPointReply.prototype.accessPoint = null;\n    \n                    GetAccessPointReply.create = function create(properties) {\n                        return new GetAccessPointReply(properties);\n                    };\n    \n                    GetAccessPointReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.accessPoint != null && m.hasOwnProperty(\"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(m.accessPoint, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    GetAccessPointReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetAccessPointReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetAccessPointReply;\n                })();\n    \n                cellular.SetActiveSimRequest = (function() {\n    \n                    function SetActiveSimRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetActiveSimRequest.prototype.simType = 0;\n    \n                    SetActiveSimRequest.create = function create(properties) {\n                        return new SetActiveSimRequest(properties);\n                    };\n    \n                    SetActiveSimRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && m.hasOwnProperty(\"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    SetActiveSimRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetActiveSimRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetActiveSimRequest;\n                })();\n    \n                cellular.SetActiveSimReply = (function() {\n    \n                    function SetActiveSimReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetActiveSimReply.create = function create(properties) {\n                        return new SetActiveSimReply(properties);\n                    };\n    \n                    SetActiveSimReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    SetActiveSimReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetActiveSimReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetActiveSimReply;\n                })();\n    \n                cellular.GetActiveSimRequest = (function() {\n    \n                    function GetActiveSimRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetActiveSimRequest.create = function create(properties) {\n                        return new GetActiveSimRequest(properties);\n                    };\n    \n                    GetActiveSimRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetActiveSimRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetActiveSimRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetActiveSimRequest;\n                })();\n    \n                cellular.GetActiveSimReply = (function() {\n    \n                    function GetActiveSimReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetActiveSimReply.prototype.simType = 0;\n    \n                    GetActiveSimReply.create = function create(properties) {\n                        return new GetActiveSimReply(properties);\n                    };\n    \n                    GetActiveSimReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && m.hasOwnProperty(\"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    GetActiveSimReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetActiveSimReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetActiveSimReply;\n                })();\n    \n                cellular.GetIccidRequest = (function() {\n    \n                    function GetIccidRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetIccidRequest.create = function create(properties) {\n                        return new GetIccidRequest(properties);\n                    };\n    \n                    GetIccidRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetIccidRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetIccidRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetIccidRequest;\n                })();\n    \n                cellular.GetIccidReply = (function() {\n    \n                    function GetIccidReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetIccidReply.prototype.iccid = \"\";\n    \n                    GetIccidReply.create = function create(properties) {\n                        return new GetIccidReply(properties);\n                    };\n    \n                    GetIccidReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.iccid != null && m.hasOwnProperty(\"iccid\"))\n                            w.uint32(10).string(m.iccid);\n                        return w;\n                    };\n    \n                    GetIccidReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetIccidReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.iccid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetIccidReply;\n                })();\n    \n                return cellular;\n            })();\n    \n            ctrl.ResultCode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"OK\"] = 0;\n                values[valuesById[1] = \"NOT_ALLOWED\"] = 1;\n                values[valuesById[2] = \"TIMEOUT\"] = 2;\n                values[valuesById[3] = \"NOT_FOUND\"] = 3;\n                values[valuesById[4] = \"ALREADY_EXIST\"] = 4;\n                values[valuesById[5] = \"INVALID_STATE\"] = 5;\n                values[valuesById[6] = \"NO_MEMORY\"] = 6;\n                values[valuesById[7] = \"INVALID_PARAM\"] = 7;\n                return values;\n            })();\n    \n            ctrl.Ipv4Address = (function() {\n    \n                function Ipv4Address(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv4Address.prototype.address = 0;\n    \n                Ipv4Address.create = function create(properties) {\n                    return new Ipv4Address(properties);\n                };\n    \n                Ipv4Address.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        w.uint32(13).fixed32(m.address);\n                    return w;\n                };\n    \n                Ipv4Address.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv4Address();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.fixed32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv4Address;\n            })();\n    \n            ctrl.Ipv6Address = (function() {\n    \n                function Ipv6Address(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv6Address.prototype.address = $util.newBuffer([]);\n    \n                Ipv6Address.create = function create(properties) {\n                    return new Ipv6Address(properties);\n                };\n    \n                Ipv6Address.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        w.uint32(10).bytes(m.address);\n                    return w;\n                };\n    \n                Ipv6Address.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv6Address();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv6Address;\n            })();\n    \n            ctrl.IpAddress = (function() {\n    \n                function IpAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IpAddress.prototype.v4 = null;\n                IpAddress.prototype.v6 = null;\n    \n                var $oneOfFields;\n    \n                Object.defineProperty(IpAddress.prototype, \"address\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"v4\", \"v6\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                IpAddress.create = function create(properties) {\n                    return new IpAddress(properties);\n                };\n    \n                IpAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.v4 != null && m.hasOwnProperty(\"v4\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.v4, w.uint32(10).fork()).ldelim();\n                    if (m.v6 != null && m.hasOwnProperty(\"v6\"))\n                        $root.particle.ctrl.Ipv6Address.encode(m.v6, w.uint32(18).fork()).ldelim();\n                    return w;\n                };\n    \n                IpAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IpAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.v4 = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.v6 = $root.particle.ctrl.Ipv6Address.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IpAddress;\n            })();\n    \n            ctrl.IPAddress = (function() {\n    \n                function IPAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IPAddress.prototype.protocol = 0;\n                IPAddress.prototype.address = $util.newBuffer([]);\n    \n                IPAddress.create = function create(properties) {\n                    return new IPAddress(properties);\n                };\n    \n                IPAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && m.hasOwnProperty(\"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        w.uint32(18).bytes(m.address);\n                    return w;\n                };\n    \n                IPAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IPAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        case 2:\n                            m.address = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                IPAddress.Protocol = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"IPv4\"] = 1;\n                    values[valuesById[2] = \"IPv6\"] = 2;\n                    return values;\n                })();\n    \n                return IPAddress;\n            })();\n    \n            ctrl.cloud = (function() {\n    \n                var cloud = {};\n    \n                cloud.ConnectionStatus = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DISCONNECTED\"] = 0;\n                    values[valuesById[1] = \"CONNECTING\"] = 1;\n                    values[valuesById[2] = \"CONNECTED\"] = 2;\n                    values[valuesById[3] = \"DISCONNECTING\"] = 3;\n                    return values;\n                })();\n    \n                cloud.GetConnectionStatusRequest = (function() {\n    \n                    function GetConnectionStatusRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetConnectionStatusRequest.create = function create(properties) {\n                        return new GetConnectionStatusRequest(properties);\n                    };\n    \n                    GetConnectionStatusRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetConnectionStatusRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.GetConnectionStatusRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetConnectionStatusRequest;\n                })();\n    \n                cloud.GetConnectionStatusReply = (function() {\n    \n                    function GetConnectionStatusReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetConnectionStatusReply.prototype.status = 0;\n    \n                    GetConnectionStatusReply.create = function create(properties) {\n                        return new GetConnectionStatusReply(properties);\n                    };\n    \n                    GetConnectionStatusReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.status != null && m.hasOwnProperty(\"status\"))\n                            w.uint32(8).int32(m.status);\n                        return w;\n                    };\n    \n                    GetConnectionStatusReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.GetConnectionStatusReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.status = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetConnectionStatusReply;\n                })();\n    \n                cloud.ConnectRequest = (function() {\n    \n                    function ConnectRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ConnectRequest.create = function create(properties) {\n                        return new ConnectRequest(properties);\n                    };\n    \n                    ConnectRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ConnectRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.ConnectRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ConnectRequest;\n                })();\n    \n                cloud.ConnectReply = (function() {\n    \n                    function ConnectReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ConnectReply.create = function create(properties) {\n                        return new ConnectReply(properties);\n                    };\n    \n                    ConnectReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ConnectReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.ConnectReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ConnectReply;\n                })();\n    \n                cloud.DisconnectRequest = (function() {\n    \n                    function DisconnectRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DisconnectRequest.create = function create(properties) {\n                        return new DisconnectRequest(properties);\n                    };\n    \n                    DisconnectRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    DisconnectRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.DisconnectRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return DisconnectRequest;\n                })();\n    \n                cloud.DisconnectReply = (function() {\n    \n                    function DisconnectReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DisconnectReply.create = function create(properties) {\n                        return new DisconnectReply(properties);\n                    };\n    \n                    DisconnectReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    DisconnectReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.DisconnectReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return DisconnectReply;\n                })();\n    \n                return cloud;\n            })();\n    \n            ctrl.SecurityKeyType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECURITY_KEY\"] = 0;\n                values[valuesById[1] = \"TCP_DEVICE_PRIVATE_KEY\"] = 1;\n                values[valuesById[2] = \"TCP_DEVICE_PUBLIC_KEY\"] = 2;\n                values[valuesById[3] = \"TCP_SERVER_PUBLIC_KEY\"] = 3;\n                values[valuesById[4] = \"UDP_DEVICE_PRIVATE_KEY\"] = 4;\n                values[valuesById[5] = \"UDP_DEVICE_PUBLIC_KEY\"] = 5;\n                values[valuesById[6] = \"UDP_SERVER_PUBLIC_KEY\"] = 6;\n                return values;\n            })();\n    \n            ctrl.ServerProtocolType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_PROTOCOL\"] = 0;\n                values[valuesById[1] = \"TCP_PROTOCOL\"] = 1;\n                values[valuesById[2] = \"UDP_PROTOCOL\"] = 2;\n                return values;\n            })();\n    \n            ctrl.DeviceMode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NORMAL_MODE\"] = 0;\n                values[valuesById[1] = \"LISTENING_MODE\"] = 1;\n                return values;\n            })();\n    \n            ctrl.SystemCapabilityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SYSTEM_CAPABILITY_FLAGS\"] = 0;\n                values[valuesById[1] = \"COMPRESSED_OTA\"] = 1;\n                return values;\n            })();\n    \n            ctrl.Feature = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FEATURE\"] = 0;\n                values[valuesById[1] = \"ETHERNET_DETECTION\"] = 1;\n                return values;\n            })();\n    \n            ctrl.GetDeviceIdRequest = (function() {\n    \n                function GetDeviceIdRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceIdRequest.create = function create(properties) {\n                    return new GetDeviceIdRequest(properties);\n                };\n    \n                GetDeviceIdRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetDeviceIdRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceIdRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceIdRequest;\n            })();\n    \n            ctrl.GetDeviceIdReply = (function() {\n    \n                function GetDeviceIdReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceIdReply.prototype.id = \"\";\n    \n                GetDeviceIdReply.create = function create(properties) {\n                    return new GetDeviceIdReply(properties);\n                };\n    \n                GetDeviceIdReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.id != null && m.hasOwnProperty(\"id\"))\n                        w.uint32(10).string(m.id);\n                    return w;\n                };\n    \n                GetDeviceIdReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceIdReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.id = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceIdReply;\n            })();\n    \n            ctrl.GetSerialNumberRequest = (function() {\n    \n                function GetSerialNumberRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSerialNumberRequest.create = function create(properties) {\n                    return new GetSerialNumberRequest(properties);\n                };\n    \n                GetSerialNumberRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSerialNumberRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSerialNumberRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSerialNumberRequest;\n            })();\n    \n            ctrl.GetSerialNumberReply = (function() {\n    \n                function GetSerialNumberReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSerialNumberReply.prototype.serial = \"\";\n    \n                GetSerialNumberReply.create = function create(properties) {\n                    return new GetSerialNumberReply(properties);\n                };\n    \n                GetSerialNumberReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.serial != null && m.hasOwnProperty(\"serial\"))\n                        w.uint32(10).string(m.serial);\n                    return w;\n                };\n    \n                GetSerialNumberReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSerialNumberReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.serial = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSerialNumberReply;\n            })();\n    \n            ctrl.GetSystemVersionRequest = (function() {\n    \n                function GetSystemVersionRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemVersionRequest.create = function create(properties) {\n                    return new GetSystemVersionRequest(properties);\n                };\n    \n                GetSystemVersionRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSystemVersionRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemVersionRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemVersionRequest;\n            })();\n    \n            ctrl.GetSystemVersionReply = (function() {\n    \n                function GetSystemVersionReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemVersionReply.prototype.version = \"\";\n    \n                GetSystemVersionReply.create = function create(properties) {\n                    return new GetSystemVersionReply(properties);\n                };\n    \n                GetSystemVersionReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.version != null && m.hasOwnProperty(\"version\"))\n                        w.uint32(10).string(m.version);\n                    return w;\n                };\n    \n                GetSystemVersionReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemVersionReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.version = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemVersionReply;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionRequest = (function() {\n    \n                function GetNcpFirmwareVersionRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetNcpFirmwareVersionRequest.create = function create(properties) {\n                    return new GetNcpFirmwareVersionRequest(properties);\n                };\n    \n                GetNcpFirmwareVersionRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetNcpFirmwareVersionRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetNcpFirmwareVersionRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetNcpFirmwareVersionRequest;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionReply = (function() {\n    \n                function GetNcpFirmwareVersionReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetNcpFirmwareVersionReply.prototype.version = \"\";\n                GetNcpFirmwareVersionReply.prototype.moduleVersion = 0;\n    \n                GetNcpFirmwareVersionReply.create = function create(properties) {\n                    return new GetNcpFirmwareVersionReply(properties);\n                };\n    \n                GetNcpFirmwareVersionReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.version != null && m.hasOwnProperty(\"version\"))\n                        w.uint32(10).string(m.version);\n                    if (m.moduleVersion != null && m.hasOwnProperty(\"moduleVersion\"))\n                        w.uint32(16).uint32(m.moduleVersion);\n                    return w;\n                };\n    \n                GetNcpFirmwareVersionReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetNcpFirmwareVersionReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.version = r.string();\n                            break;\n                        case 2:\n                            m.moduleVersion = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetNcpFirmwareVersionReply;\n            })();\n    \n            ctrl.GetSystemCapabilitiesRequest = (function() {\n    \n                function GetSystemCapabilitiesRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemCapabilitiesRequest.create = function create(properties) {\n                    return new GetSystemCapabilitiesRequest(properties);\n                };\n    \n                GetSystemCapabilitiesRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSystemCapabilitiesRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemCapabilitiesRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemCapabilitiesRequest;\n            })();\n    \n            ctrl.GetSystemCapabilitiesReply = (function() {\n    \n                function GetSystemCapabilitiesReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemCapabilitiesReply.prototype.flags = 0;\n    \n                GetSystemCapabilitiesReply.create = function create(properties) {\n                    return new GetSystemCapabilitiesReply(properties);\n                };\n    \n                GetSystemCapabilitiesReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                        w.uint32(13).fixed32(m.flags);\n                    return w;\n                };\n    \n                GetSystemCapabilitiesReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemCapabilitiesReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.flags = r.fixed32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemCapabilitiesReply;\n            })();\n    \n            ctrl.SetClaimCodeRequest = (function() {\n    \n                function SetClaimCodeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetClaimCodeRequest.prototype.code = \"\";\n    \n                SetClaimCodeRequest.create = function create(properties) {\n                    return new SetClaimCodeRequest(properties);\n                };\n    \n                SetClaimCodeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.code != null && m.hasOwnProperty(\"code\"))\n                        w.uint32(10).string(m.code);\n                    return w;\n                };\n    \n                SetClaimCodeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetClaimCodeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.code = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetClaimCodeRequest;\n            })();\n    \n            ctrl.SetClaimCodeReply = (function() {\n    \n                function SetClaimCodeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetClaimCodeReply.create = function create(properties) {\n                    return new SetClaimCodeReply(properties);\n                };\n    \n                SetClaimCodeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetClaimCodeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetClaimCodeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetClaimCodeReply;\n            })();\n    \n            ctrl.IsClaimedRequest = (function() {\n    \n                function IsClaimedRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsClaimedRequest.create = function create(properties) {\n                    return new IsClaimedRequest(properties);\n                };\n    \n                IsClaimedRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                IsClaimedRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsClaimedRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsClaimedRequest;\n            })();\n    \n            ctrl.IsClaimedReply = (function() {\n    \n                function IsClaimedReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsClaimedReply.prototype.claimed = false;\n    \n                IsClaimedReply.create = function create(properties) {\n                    return new IsClaimedReply(properties);\n                };\n    \n                IsClaimedReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.claimed != null && m.hasOwnProperty(\"claimed\"))\n                        w.uint32(8).bool(m.claimed);\n                    return w;\n                };\n    \n                IsClaimedReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsClaimedReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.claimed = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsClaimedReply;\n            })();\n    \n            ctrl.SetSecurityKeyRequest = (function() {\n    \n                function SetSecurityKeyRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSecurityKeyRequest.prototype.type = 0;\n                SetSecurityKeyRequest.prototype.data = $util.newBuffer([]);\n    \n                SetSecurityKeyRequest.create = function create(properties) {\n                    return new SetSecurityKeyRequest(properties);\n                };\n    \n                SetSecurityKeyRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(8).int32(m.type);\n                    if (m.data != null && m.hasOwnProperty(\"data\"))\n                        w.uint32(18).bytes(m.data);\n                    return w;\n                };\n    \n                SetSecurityKeyRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSecurityKeyRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        case 2:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSecurityKeyRequest;\n            })();\n    \n            ctrl.SetSecurityKeyReply = (function() {\n    \n                function SetSecurityKeyReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSecurityKeyReply.create = function create(properties) {\n                    return new SetSecurityKeyReply(properties);\n                };\n    \n                SetSecurityKeyReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetSecurityKeyReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSecurityKeyReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSecurityKeyReply;\n            })();\n    \n            ctrl.GetSecurityKeyRequest = (function() {\n    \n                function GetSecurityKeyRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSecurityKeyRequest.prototype.type = 0;\n    \n                GetSecurityKeyRequest.create = function create(properties) {\n                    return new GetSecurityKeyRequest(properties);\n                };\n    \n                GetSecurityKeyRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(8).int32(m.type);\n                    return w;\n                };\n    \n                GetSecurityKeyRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSecurityKeyRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSecurityKeyRequest;\n            })();\n    \n            ctrl.GetSecurityKeyReply = (function() {\n    \n                function GetSecurityKeyReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSecurityKeyReply.prototype.data = $util.newBuffer([]);\n    \n                GetSecurityKeyReply.create = function create(properties) {\n                    return new GetSecurityKeyReply(properties);\n                };\n    \n                GetSecurityKeyReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && m.hasOwnProperty(\"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                GetSecurityKeyReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSecurityKeyReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSecurityKeyReply;\n            })();\n    \n            ctrl.SetServerAddressRequest = (function() {\n    \n                function SetServerAddressRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerAddressRequest.prototype.protocol = 0;\n                SetServerAddressRequest.prototype.address = \"\";\n                SetServerAddressRequest.prototype.port = 0;\n    \n                SetServerAddressRequest.create = function create(properties) {\n                    return new SetServerAddressRequest(properties);\n                };\n    \n                SetServerAddressRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && m.hasOwnProperty(\"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        w.uint32(18).string(m.address);\n                    if (m.port != null && m.hasOwnProperty(\"port\"))\n                        w.uint32(24).int32(m.port);\n                    return w;\n                };\n    \n                SetServerAddressRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerAddressRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        case 2:\n                            m.address = r.string();\n                            break;\n                        case 3:\n                            m.port = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerAddressRequest;\n            })();\n    \n            ctrl.SetServerAddressReply = (function() {\n    \n                function SetServerAddressReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerAddressReply.create = function create(properties) {\n                    return new SetServerAddressReply(properties);\n                };\n    \n                SetServerAddressReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetServerAddressReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerAddressReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerAddressReply;\n            })();\n    \n            ctrl.GetServerAddressRequest = (function() {\n    \n                function GetServerAddressRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerAddressRequest.prototype.protocol = 0;\n    \n                GetServerAddressRequest.create = function create(properties) {\n                    return new GetServerAddressRequest(properties);\n                };\n    \n                GetServerAddressRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && m.hasOwnProperty(\"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                GetServerAddressRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerAddressRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerAddressRequest;\n            })();\n    \n            ctrl.GetServerAddressReply = (function() {\n    \n                function GetServerAddressReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerAddressReply.prototype.address = \"\";\n                GetServerAddressReply.prototype.port = 0;\n    \n                GetServerAddressReply.create = function create(properties) {\n                    return new GetServerAddressReply(properties);\n                };\n    \n                GetServerAddressReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        w.uint32(10).string(m.address);\n                    if (m.port != null && m.hasOwnProperty(\"port\"))\n                        w.uint32(16).int32(m.port);\n                    return w;\n                };\n    \n                GetServerAddressReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerAddressReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.string();\n                            break;\n                        case 2:\n                            m.port = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerAddressReply;\n            })();\n    \n            ctrl.SetServerProtocolRequest = (function() {\n    \n                function SetServerProtocolRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerProtocolRequest.prototype.protocol = 0;\n    \n                SetServerProtocolRequest.create = function create(properties) {\n                    return new SetServerProtocolRequest(properties);\n                };\n    \n                SetServerProtocolRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && m.hasOwnProperty(\"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                SetServerProtocolRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerProtocolRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerProtocolRequest;\n            })();\n    \n            ctrl.SetServerProtocolReply = (function() {\n    \n                function SetServerProtocolReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerProtocolReply.create = function create(properties) {\n                    return new SetServerProtocolReply(properties);\n                };\n    \n                SetServerProtocolReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetServerProtocolReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerProtocolReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerProtocolReply;\n            })();\n    \n            ctrl.GetServerProtocolRequest = (function() {\n    \n                function GetServerProtocolRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerProtocolRequest.create = function create(properties) {\n                    return new GetServerProtocolRequest(properties);\n                };\n    \n                GetServerProtocolRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetServerProtocolRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerProtocolRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerProtocolRequest;\n            })();\n    \n            ctrl.GetServerProtocolReply = (function() {\n    \n                function GetServerProtocolReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerProtocolReply.prototype.protocol = 0;\n    \n                GetServerProtocolReply.create = function create(properties) {\n                    return new GetServerProtocolReply(properties);\n                };\n    \n                GetServerProtocolReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && m.hasOwnProperty(\"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                GetServerProtocolReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerProtocolReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerProtocolReply;\n            })();\n    \n            ctrl.SetSoftApSsidRequest = (function() {\n    \n                function SetSoftApSsidRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSoftApSsidRequest.prototype.prefix = \"\";\n                SetSoftApSsidRequest.prototype.suffix = \"\";\n    \n                SetSoftApSsidRequest.create = function create(properties) {\n                    return new SetSoftApSsidRequest(properties);\n                };\n    \n                SetSoftApSsidRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.prefix != null && m.hasOwnProperty(\"prefix\"))\n                        w.uint32(10).string(m.prefix);\n                    if (m.suffix != null && m.hasOwnProperty(\"suffix\"))\n                        w.uint32(18).string(m.suffix);\n                    return w;\n                };\n    \n                SetSoftApSsidRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSoftApSsidRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.prefix = r.string();\n                            break;\n                        case 2:\n                            m.suffix = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSoftApSsidRequest;\n            })();\n    \n            ctrl.SetSoftApSsidReply = (function() {\n    \n                function SetSoftApSsidReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSoftApSsidReply.create = function create(properties) {\n                    return new SetSoftApSsidReply(properties);\n                };\n    \n                SetSoftApSsidReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetSoftApSsidReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSoftApSsidReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSoftApSsidReply;\n            })();\n    \n            ctrl.StartListeningModeRequest = (function() {\n    \n                function StartListeningModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartListeningModeRequest.create = function create(properties) {\n                    return new StartListeningModeRequest(properties);\n                };\n    \n                StartListeningModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StartListeningModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartListeningModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartListeningModeRequest;\n            })();\n    \n            ctrl.StartListeningModeReply = (function() {\n    \n                function StartListeningModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartListeningModeReply.create = function create(properties) {\n                    return new StartListeningModeReply(properties);\n                };\n    \n                StartListeningModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StartListeningModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartListeningModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartListeningModeReply;\n            })();\n    \n            ctrl.StopListeningModeRequest = (function() {\n    \n                function StopListeningModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StopListeningModeRequest.create = function create(properties) {\n                    return new StopListeningModeRequest(properties);\n                };\n    \n                StopListeningModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StopListeningModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StopListeningModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StopListeningModeRequest;\n            })();\n    \n            ctrl.StopListeningModeReply = (function() {\n    \n                function StopListeningModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StopListeningModeReply.create = function create(properties) {\n                    return new StopListeningModeReply(properties);\n                };\n    \n                StopListeningModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StopListeningModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StopListeningModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StopListeningModeReply;\n            })();\n    \n            ctrl.GetDeviceModeRequest = (function() {\n    \n                function GetDeviceModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceModeRequest.create = function create(properties) {\n                    return new GetDeviceModeRequest(properties);\n                };\n    \n                GetDeviceModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetDeviceModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceModeRequest;\n            })();\n    \n            ctrl.GetDeviceModeReply = (function() {\n    \n                function GetDeviceModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceModeReply.prototype.mode = 0;\n    \n                GetDeviceModeReply.create = function create(properties) {\n                    return new GetDeviceModeReply(properties);\n                };\n    \n                GetDeviceModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.mode != null && m.hasOwnProperty(\"mode\"))\n                        w.uint32(8).int32(m.mode);\n                    return w;\n                };\n    \n                GetDeviceModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.mode = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceModeReply;\n            })();\n    \n            ctrl.SetDeviceSetupDoneRequest = (function() {\n    \n                function SetDeviceSetupDoneRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetDeviceSetupDoneRequest.prototype.done = false;\n    \n                SetDeviceSetupDoneRequest.create = function create(properties) {\n                    return new SetDeviceSetupDoneRequest(properties);\n                };\n    \n                SetDeviceSetupDoneRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.done != null && m.hasOwnProperty(\"done\"))\n                        w.uint32(8).bool(m.done);\n                    return w;\n                };\n    \n                SetDeviceSetupDoneRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetDeviceSetupDoneRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.done = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.SetDeviceSetupDoneReply = (function() {\n    \n                function SetDeviceSetupDoneReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetDeviceSetupDoneReply.create = function create(properties) {\n                    return new SetDeviceSetupDoneReply(properties);\n                };\n    \n                SetDeviceSetupDoneReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetDeviceSetupDoneReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetDeviceSetupDoneReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetDeviceSetupDoneReply;\n            })();\n    \n            ctrl.IsDeviceSetupDoneRequest = (function() {\n    \n                function IsDeviceSetupDoneRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsDeviceSetupDoneRequest.create = function create(properties) {\n                    return new IsDeviceSetupDoneRequest(properties);\n                };\n    \n                IsDeviceSetupDoneRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                IsDeviceSetupDoneRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsDeviceSetupDoneRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.IsDeviceSetupDoneReply = (function() {\n    \n                function IsDeviceSetupDoneReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsDeviceSetupDoneReply.prototype.done = false;\n    \n                IsDeviceSetupDoneReply.create = function create(properties) {\n                    return new IsDeviceSetupDoneReply(properties);\n                };\n    \n                IsDeviceSetupDoneReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.done != null && m.hasOwnProperty(\"done\"))\n                        w.uint32(8).bool(m.done);\n                    return w;\n                };\n    \n                IsDeviceSetupDoneReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsDeviceSetupDoneReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.done = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsDeviceSetupDoneReply;\n            })();\n    \n            ctrl.SetStartupModeRequest = (function() {\n    \n                function SetStartupModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetStartupModeRequest.prototype.mode = 0;\n    \n                SetStartupModeRequest.create = function create(properties) {\n                    return new SetStartupModeRequest(properties);\n                };\n    \n                SetStartupModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.mode != null && m.hasOwnProperty(\"mode\"))\n                        w.uint32(8).int32(m.mode);\n                    return w;\n                };\n    \n                SetStartupModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetStartupModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.mode = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetStartupModeRequest;\n            })();\n    \n            ctrl.SetStartupModeReply = (function() {\n    \n                function SetStartupModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetStartupModeReply.create = function create(properties) {\n                    return new SetStartupModeReply(properties);\n                };\n    \n                SetStartupModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetStartupModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetStartupModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetStartupModeReply;\n            })();\n    \n            ctrl.SystemResetRequest = (function() {\n    \n                function SystemResetRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SystemResetRequest.create = function create(properties) {\n                    return new SystemResetRequest(properties);\n                };\n    \n                SystemResetRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SystemResetRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SystemResetRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SystemResetRequest;\n            })();\n    \n            ctrl.SystemResetReply = (function() {\n    \n                function SystemResetReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SystemResetReply.create = function create(properties) {\n                    return new SystemResetReply(properties);\n                };\n    \n                SystemResetReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SystemResetReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SystemResetReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SystemResetReply;\n            })();\n    \n            ctrl.SetFeatureRequest = (function() {\n    \n                function SetFeatureRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetFeatureRequest.prototype.feature = 0;\n                SetFeatureRequest.prototype.enabled = false;\n    \n                SetFeatureRequest.create = function create(properties) {\n                    return new SetFeatureRequest(properties);\n                };\n    \n                SetFeatureRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.feature != null && m.hasOwnProperty(\"feature\"))\n                        w.uint32(8).int32(m.feature);\n                    if (m.enabled != null && m.hasOwnProperty(\"enabled\"))\n                        w.uint32(16).bool(m.enabled);\n                    return w;\n                };\n    \n                SetFeatureRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetFeatureRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.feature = r.int32();\n                            break;\n                        case 2:\n                            m.enabled = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetFeatureRequest;\n            })();\n    \n            ctrl.SetFeatureReply = (function() {\n    \n                function SetFeatureReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetFeatureReply.create = function create(properties) {\n                    return new SetFeatureReply(properties);\n                };\n    \n                SetFeatureReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetFeatureReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetFeatureReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetFeatureReply;\n            })();\n    \n            ctrl.GetFeatureRequest = (function() {\n    \n                function GetFeatureRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetFeatureRequest.prototype.feature = 0;\n    \n                GetFeatureRequest.create = function create(properties) {\n                    return new GetFeatureRequest(properties);\n                };\n    \n                GetFeatureRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.feature != null && m.hasOwnProperty(\"feature\"))\n                        w.uint32(8).int32(m.feature);\n                    return w;\n                };\n    \n                GetFeatureRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetFeatureRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.feature = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetFeatureRequest;\n            })();\n    \n            ctrl.GetFeatureReply = (function() {\n    \n                function GetFeatureReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetFeatureReply.prototype.enabled = false;\n    \n                GetFeatureReply.create = function create(properties) {\n                    return new GetFeatureReply(properties);\n                };\n    \n                GetFeatureReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.enabled != null && m.hasOwnProperty(\"enabled\"))\n                        w.uint32(8).bool(m.enabled);\n                    return w;\n                };\n    \n                GetFeatureReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetFeatureReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.enabled = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetFeatureReply;\n            })();\n    \n            ctrl.WiFiGetAntennaRequest = (function() {\n    \n                function WiFiGetAntennaRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetAntennaRequest.create = function create(properties) {\n                    return new WiFiGetAntennaRequest(properties);\n                };\n    \n                WiFiGetAntennaRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiGetAntennaRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetAntennaRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetAntennaRequest;\n            })();\n    \n            ctrl.WiFiGetAntennaReply = (function() {\n    \n                function WiFiGetAntennaReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetAntennaReply.prototype.antenna = 0;\n    \n                WiFiGetAntennaReply.create = function create(properties) {\n                    return new WiFiGetAntennaReply(properties);\n                };\n    \n                WiFiGetAntennaReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.antenna != null && m.hasOwnProperty(\"antenna\"))\n                        w.uint32(8).int32(m.antenna);\n                    return w;\n                };\n    \n                WiFiGetAntennaReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetAntennaReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.antenna = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetAntennaReply;\n            })();\n    \n            ctrl.WiFiSetAntennaRequest = (function() {\n    \n                function WiFiSetAntennaRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetAntennaRequest.prototype.antenna = 0;\n    \n                WiFiSetAntennaRequest.create = function create(properties) {\n                    return new WiFiSetAntennaRequest(properties);\n                };\n    \n                WiFiSetAntennaRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.antenna != null && m.hasOwnProperty(\"antenna\"))\n                        w.uint32(8).int32(m.antenna);\n                    return w;\n                };\n    \n                WiFiSetAntennaRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetAntennaRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.antenna = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetAntennaRequest;\n            })();\n    \n            ctrl.WiFiSetAntennaReply = (function() {\n    \n                function WiFiSetAntennaReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetAntennaReply.create = function create(properties) {\n                    return new WiFiSetAntennaReply(properties);\n                };\n    \n                WiFiSetAntennaReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiSetAntennaReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetAntennaReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetAntennaReply;\n            })();\n    \n            ctrl.WiFiScanRequest = (function() {\n    \n                function WiFiScanRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiScanRequest.create = function create(properties) {\n                    return new WiFiScanRequest(properties);\n                };\n    \n                WiFiScanRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiScanRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiScanRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiScanRequest;\n            })();\n    \n            ctrl.WiFiScanReply = (function() {\n    \n                function WiFiScanReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiScanReply.prototype.list = null;\n    \n                WiFiScanReply.create = function create(properties) {\n                    return new WiFiScanReply(properties);\n                };\n    \n                WiFiScanReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.list != null && m.hasOwnProperty(\"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(m.list, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiScanReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiScanReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.list = $root.particle.ctrl.WiFiAccessPointList.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiScanReply;\n            })();\n    \n            ctrl.WiFiGetCredentialsRequest = (function() {\n    \n                function WiFiGetCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetCredentialsRequest.create = function create(properties) {\n                    return new WiFiGetCredentialsRequest(properties);\n                };\n    \n                WiFiGetCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiGetCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiGetCredentialsReply = (function() {\n    \n                function WiFiGetCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetCredentialsReply.prototype.list = null;\n    \n                WiFiGetCredentialsReply.create = function create(properties) {\n                    return new WiFiGetCredentialsReply(properties);\n                };\n    \n                WiFiGetCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.list != null && m.hasOwnProperty(\"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(m.list, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiGetCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.list = $root.particle.ctrl.WiFiAccessPointList.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetCredentialsReply;\n            })();\n    \n            ctrl.WiFiSetCredentialsRequest = (function() {\n    \n                function WiFiSetCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetCredentialsRequest.prototype.ap = null;\n    \n                WiFiSetCredentialsRequest.create = function create(properties) {\n                    return new WiFiSetCredentialsRequest(properties);\n                };\n    \n                WiFiSetCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ap != null && m.hasOwnProperty(\"ap\"))\n                        $root.particle.ctrl.WiFiAccessPoint.encode(m.ap, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiSetCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ap = $root.particle.ctrl.WiFiAccessPoint.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiSetCredentialsReply = (function() {\n    \n                function WiFiSetCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetCredentialsReply.create = function create(properties) {\n                    return new WiFiSetCredentialsReply(properties);\n                };\n    \n                WiFiSetCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiSetCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetCredentialsReply;\n            })();\n    \n            ctrl.WiFiClearCredentialsRequest = (function() {\n    \n                function WiFiClearCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiClearCredentialsRequest.create = function create(properties) {\n                    return new WiFiClearCredentialsRequest(properties);\n                };\n    \n                WiFiClearCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiClearCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiClearCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiClearCredentialsRequest;\n            })();\n    \n            ctrl.WiFiClearCredentialsReply = (function() {\n    \n                function WiFiClearCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiClearCredentialsReply.create = function create(properties) {\n                    return new WiFiClearCredentialsReply(properties);\n                };\n    \n                WiFiClearCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiClearCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiClearCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiClearCredentialsReply;\n            })();\n    \n            ctrl.WiFiAntenna = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"ANTENNA_NONE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                values[valuesById[2] = \"EXTERNAL\"] = 2;\n                values[valuesById[3] = \"AUTO\"] = 3;\n                return values;\n            })();\n    \n            ctrl.WiFiSecurityType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"UNSEC\"] = 0;\n                values[valuesById[1] = \"WEP\"] = 1;\n                values[valuesById[2] = \"WPA\"] = 2;\n                values[valuesById[3] = \"WPA2\"] = 3;\n                values[valuesById[4] = \"WPA_ENTERPRISE\"] = 4;\n                values[valuesById[5] = \"WPA2_ENTERPRISE\"] = 5;\n                values[valuesById[255] = \"UNKNOWN\"] = 255;\n                return values;\n            })();\n    \n            ctrl.WiFiSecurityCipher = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"CIPHER_NONE\"] = 0;\n                values[valuesById[1] = \"AES\"] = 1;\n                values[valuesById[2] = \"TKIP\"] = 2;\n                values[valuesById[3] = \"AES_TKIP\"] = 3;\n                return values;\n            })();\n    \n            ctrl.EapType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"EAP_TYPE_NONE\"] = 0;\n                values[valuesById[13] = \"TLS\"] = 13;\n                values[valuesById[25] = \"PEAP\"] = 25;\n                return values;\n            })();\n    \n            ctrl.WiFiAccessPoint = (function() {\n    \n                function WiFiAccessPoint(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiAccessPoint.prototype.ssid = \"\";\n                WiFiAccessPoint.prototype.bssid = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.security = 0;\n                WiFiAccessPoint.prototype.cipher = 0;\n                WiFiAccessPoint.prototype.channel = 0;\n                WiFiAccessPoint.prototype.maxDataRate = 0;\n                WiFiAccessPoint.prototype.rssi = 0;\n                WiFiAccessPoint.prototype.password = \"\";\n                WiFiAccessPoint.prototype.eapType = 0;\n                WiFiAccessPoint.prototype.innerIdentity = \"\";\n                WiFiAccessPoint.prototype.outerIdentity = \"\";\n                WiFiAccessPoint.prototype.privateKey = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.clientCertificate = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.caCertificate = $util.newBuffer([]);\n    \n                WiFiAccessPoint.create = function create(properties) {\n                    return new WiFiAccessPoint(properties);\n                };\n    \n                WiFiAccessPoint.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                        w.uint32(10).string(m.ssid);\n                    if (m.bssid != null && m.hasOwnProperty(\"bssid\"))\n                        w.uint32(18).bytes(m.bssid);\n                    if (m.security != null && m.hasOwnProperty(\"security\"))\n                        w.uint32(24).int32(m.security);\n                    if (m.cipher != null && m.hasOwnProperty(\"cipher\"))\n                        w.uint32(32).int32(m.cipher);\n                    if (m.channel != null && m.hasOwnProperty(\"channel\"))\n                        w.uint32(40).uint32(m.channel);\n                    if (m.maxDataRate != null && m.hasOwnProperty(\"maxDataRate\"))\n                        w.uint32(48).int32(m.maxDataRate);\n                    if (m.rssi != null && m.hasOwnProperty(\"rssi\"))\n                        w.uint32(56).int32(m.rssi);\n                    if (m.password != null && m.hasOwnProperty(\"password\"))\n                        w.uint32(66).string(m.password);\n                    if (m.eapType != null && m.hasOwnProperty(\"eapType\"))\n                        w.uint32(72).int32(m.eapType);\n                    if (m.innerIdentity != null && m.hasOwnProperty(\"innerIdentity\"))\n                        w.uint32(82).string(m.innerIdentity);\n                    if (m.outerIdentity != null && m.hasOwnProperty(\"outerIdentity\"))\n                        w.uint32(90).string(m.outerIdentity);\n                    if (m.privateKey != null && m.hasOwnProperty(\"privateKey\"))\n                        w.uint32(98).bytes(m.privateKey);\n                    if (m.clientCertificate != null && m.hasOwnProperty(\"clientCertificate\"))\n                        w.uint32(106).bytes(m.clientCertificate);\n                    if (m.caCertificate != null && m.hasOwnProperty(\"caCertificate\"))\n                        w.uint32(114).bytes(m.caCertificate);\n                    return w;\n                };\n    \n                WiFiAccessPoint.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiAccessPoint();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ssid = r.string();\n                            break;\n                        case 2:\n                            m.bssid = r.bytes();\n                            break;\n                        case 3:\n                            m.security = r.int32();\n                            break;\n                        case 4:\n                            m.cipher = r.int32();\n                            break;\n                        case 5:\n                            m.channel = r.uint32();\n                            break;\n                        case 6:\n                            m.maxDataRate = r.int32();\n                            break;\n                        case 7:\n                            m.rssi = r.int32();\n                            break;\n                        case 8:\n                            m.password = r.string();\n                            break;\n                        case 9:\n                            m.eapType = r.int32();\n                            break;\n                        case 10:\n                            m.innerIdentity = r.string();\n                            break;\n                        case 11:\n                            m.outerIdentity = r.string();\n                            break;\n                        case 12:\n                            m.privateKey = r.bytes();\n                            break;\n                        case 13:\n                            m.clientCertificate = r.bytes();\n                            break;\n                        case 14:\n                            m.caCertificate = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiAccessPoint;\n            })();\n    \n            ctrl.WiFiAccessPointList = (function() {\n    \n                function WiFiAccessPointList(p) {\n                    this.aps = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiAccessPointList.prototype.aps = $util.emptyArray;\n    \n                WiFiAccessPointList.create = function create(properties) {\n                    return new WiFiAccessPointList(properties);\n                };\n    \n                WiFiAccessPointList.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.aps != null && m.aps.length) {\n                        for (var i = 0; i < m.aps.length; ++i)\n                            $root.particle.ctrl.WiFiAccessPoint.encode(m.aps[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                WiFiAccessPointList.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiAccessPointList();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.aps && m.aps.length))\n                                m.aps = [];\n                            m.aps.push($root.particle.ctrl.WiFiAccessPoint.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiAccessPointList;\n            })();\n    \n            ctrl.NetworkGetStatusRequest = (function() {\n    \n                function NetworkGetStatusRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetStatusRequest.prototype[\"interface\"] = 0;\n    \n                NetworkGetStatusRequest.create = function create(properties) {\n                    return new NetworkGetStatusRequest(properties);\n                };\n    \n                NetworkGetStatusRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && m.hasOwnProperty(\"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    return w;\n                };\n    \n                NetworkGetStatusRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetStatusRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetStatusRequest;\n            })();\n    \n            ctrl.NetworkGetStatusReply = (function() {\n    \n                function NetworkGetStatusReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetStatusReply.prototype.config = null;\n    \n                NetworkGetStatusReply.create = function create(properties) {\n                    return new NetworkGetStatusReply(properties);\n                };\n    \n                NetworkGetStatusReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && m.hasOwnProperty(\"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkGetStatusReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetStatusReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetStatusReply;\n            })();\n    \n            ctrl.NetworkGetConfigurationRequest = (function() {\n    \n                function NetworkGetConfigurationRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetConfigurationRequest.prototype[\"interface\"] = 0;\n    \n                NetworkGetConfigurationRequest.create = function create(properties) {\n                    return new NetworkGetConfigurationRequest(properties);\n                };\n    \n                NetworkGetConfigurationRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && m.hasOwnProperty(\"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    return w;\n                };\n    \n                NetworkGetConfigurationRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetConfigurationRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkGetConfigurationReply = (function() {\n    \n                function NetworkGetConfigurationReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetConfigurationReply.prototype.config = null;\n    \n                NetworkGetConfigurationReply.create = function create(properties) {\n                    return new NetworkGetConfigurationReply(properties);\n                };\n    \n                NetworkGetConfigurationReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && m.hasOwnProperty(\"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkGetConfigurationReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetConfigurationReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetConfigurationReply;\n            })();\n    \n            ctrl.NetworkSetConfigurationRequest = (function() {\n    \n                function NetworkSetConfigurationRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkSetConfigurationRequest.prototype.config = null;\n    \n                NetworkSetConfigurationRequest.create = function create(properties) {\n                    return new NetworkSetConfigurationRequest(properties);\n                };\n    \n                NetworkSetConfigurationRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && m.hasOwnProperty(\"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkSetConfigurationRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkSetConfigurationRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkSetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkSetConfigurationReply = (function() {\n    \n                function NetworkSetConfigurationReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkSetConfigurationReply.create = function create(properties) {\n                    return new NetworkSetConfigurationReply(properties);\n                };\n    \n                NetworkSetConfigurationReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                NetworkSetConfigurationReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkSetConfigurationReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkSetConfigurationReply;\n            })();\n    \n            ctrl.NetworkState = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NETWORK_STATUS_NONE\"] = 0;\n                values[valuesById[1] = \"DOWN\"] = 1;\n                values[valuesById[2] = \"UP\"] = 2;\n                return values;\n            })();\n    \n            ctrl.IPConfiguration = (function() {\n    \n                function IPConfiguration(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IPConfiguration.prototype.type = 0;\n                IPConfiguration.prototype.address = null;\n                IPConfiguration.prototype.netmask = null;\n                IPConfiguration.prototype.gateway = null;\n                IPConfiguration.prototype.dhcpServer = null;\n                IPConfiguration.prototype.hostname = \"\";\n    \n                IPConfiguration.create = function create(properties) {\n                    return new IPConfiguration(properties);\n                };\n    \n                IPConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(8).int32(m.type);\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        $root.particle.ctrl.IPAddress.encode(m.address, w.uint32(18).fork()).ldelim();\n                    if (m.netmask != null && m.hasOwnProperty(\"netmask\"))\n                        $root.particle.ctrl.IPAddress.encode(m.netmask, w.uint32(26).fork()).ldelim();\n                    if (m.gateway != null && m.hasOwnProperty(\"gateway\"))\n                        $root.particle.ctrl.IPAddress.encode(m.gateway, w.uint32(34).fork()).ldelim();\n                    if (m.dhcpServer != null && m.hasOwnProperty(\"dhcpServer\"))\n                        $root.particle.ctrl.IPAddress.encode(m.dhcpServer, w.uint32(42).fork()).ldelim();\n                    if (m.hostname != null && m.hasOwnProperty(\"hostname\"))\n                        w.uint32(50).string(m.hostname);\n                    return w;\n                };\n    \n                IPConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IPConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        case 2:\n                            m.address = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.netmask = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 4:\n                            m.gateway = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 5:\n                            m.dhcpServer = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 6:\n                            m.hostname = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                IPConfiguration.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"DHCP\"] = 1;\n                    values[valuesById[2] = \"STATIC\"] = 2;\n                    return values;\n                })();\n    \n                return IPConfiguration;\n            })();\n    \n            ctrl.DNSConfiguration = (function() {\n    \n                function DNSConfiguration(p) {\n                    this.servers = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DNSConfiguration.prototype.servers = $util.emptyArray;\n    \n                DNSConfiguration.create = function create(properties) {\n                    return new DNSConfiguration(properties);\n                };\n    \n                DNSConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.servers != null && m.servers.length) {\n                        for (var i = 0; i < m.servers.length; ++i)\n                            $root.particle.ctrl.IPAddress.encode(m.servers[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                DNSConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DNSConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.servers && m.servers.length))\n                                m.servers = [];\n                            m.servers.push($root.particle.ctrl.IPAddress.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return DNSConfiguration;\n            })();\n    \n            ctrl.NetworkConfiguration = (function() {\n    \n                function NetworkConfiguration(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkConfiguration.prototype[\"interface\"] = 0;\n                NetworkConfiguration.prototype.state = 0;\n                NetworkConfiguration.prototype.name = \"\";\n                NetworkConfiguration.prototype.mac = $util.newBuffer([]);\n                NetworkConfiguration.prototype.ipconfig = null;\n                NetworkConfiguration.prototype.dnsconfig = null;\n    \n                NetworkConfiguration.create = function create(properties) {\n                    return new NetworkConfiguration(properties);\n                };\n    \n                NetworkConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && m.hasOwnProperty(\"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    if (m.state != null && m.hasOwnProperty(\"state\"))\n                        w.uint32(16).int32(m.state);\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(26).string(m.name);\n                    if (m.mac != null && m.hasOwnProperty(\"mac\"))\n                        w.uint32(34).bytes(m.mac);\n                    if (m.ipconfig != null && m.hasOwnProperty(\"ipconfig\"))\n                        $root.particle.ctrl.IPConfiguration.encode(m.ipconfig, w.uint32(42).fork()).ldelim();\n                    if (m.dnsconfig != null && m.hasOwnProperty(\"dnsconfig\"))\n                        $root.particle.ctrl.DNSConfiguration.encode(m.dnsconfig, w.uint32(50).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        case 2:\n                            m.state = r.int32();\n                            break;\n                        case 3:\n                            m.name = r.string();\n                            break;\n                        case 4:\n                            m.mac = r.bytes();\n                            break;\n                        case 5:\n                            m.ipconfig = $root.particle.ctrl.IPConfiguration.decode(r, r.uint32());\n                            break;\n                        case 6:\n                            m.dnsconfig = $root.particle.ctrl.DNSConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkConfiguration;\n            })();\n    \n            ctrl.InterfaceAddress = (function() {\n    \n                function InterfaceAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                InterfaceAddress.prototype.address = null;\n                InterfaceAddress.prototype.prefixLength = 0;\n    \n                InterfaceAddress.create = function create(properties) {\n                    return new InterfaceAddress(properties);\n                };\n    \n                InterfaceAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && m.hasOwnProperty(\"address\"))\n                        $root.particle.ctrl.IpAddress.encode(m.address, w.uint32(10).fork()).ldelim();\n                    if (m.prefixLength != null && m.hasOwnProperty(\"prefixLength\"))\n                        w.uint32(16).uint32(m.prefixLength);\n                    return w;\n                };\n    \n                InterfaceAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.InterfaceAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = $root.particle.ctrl.IpAddress.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.prefixLength = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return InterfaceAddress;\n            })();\n    \n            ctrl.Ipv4Config = (function() {\n    \n                function Ipv4Config(p) {\n                    this.addresses = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv4Config.prototype.addresses = $util.emptyArray;\n                Ipv4Config.prototype.peer = null;\n                Ipv4Config.prototype.gateway = null;\n    \n                Ipv4Config.create = function create(properties) {\n                    return new Ipv4Config(properties);\n                };\n    \n                Ipv4Config.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.addresses != null && m.addresses.length) {\n                        for (var i = 0; i < m.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(m.addresses[i], w.uint32(10).fork()).ldelim();\n                    }\n                    if (m.peer != null && m.hasOwnProperty(\"peer\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.peer, w.uint32(18).fork()).ldelim();\n                    if (m.gateway != null && m.hasOwnProperty(\"gateway\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.gateway, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                Ipv4Config.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv4Config();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.addresses && m.addresses.length))\n                                m.addresses = [];\n                            m.addresses.push($root.particle.ctrl.InterfaceAddress.decode(r, r.uint32()));\n                            break;\n                        case 2:\n                            m.peer = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.gateway = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv4Config;\n            })();\n    \n            ctrl.Ipv6Config = (function() {\n    \n                function Ipv6Config(p) {\n                    this.addresses = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv6Config.prototype.addresses = $util.emptyArray;\n    \n                Ipv6Config.create = function create(properties) {\n                    return new Ipv6Config(properties);\n                };\n    \n                Ipv6Config.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.addresses != null && m.addresses.length) {\n                        for (var i = 0; i < m.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(m.addresses[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                Ipv6Config.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv6Config();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.addresses && m.addresses.length))\n                                m.addresses = [];\n                            m.addresses.push($root.particle.ctrl.InterfaceAddress.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv6Config;\n            })();\n    \n            ctrl.InterfaceFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFF_NONE\"] = 0;\n                values[valuesById[1] = \"IFF_UP\"] = 1;\n                values[valuesById[2] = \"IFF_BROADCAST\"] = 2;\n                values[valuesById[4] = \"IFF_DEBUG\"] = 4;\n                values[valuesById[8] = \"IFF_LOOPBACK\"] = 8;\n                values[valuesById[16] = \"IFF_POINTTOPOINT\"] = 16;\n                values[valuesById[64] = \"IFF_RUNNING\"] = 64;\n                values[\"IFF_LOWER_UP\"] = 64;\n                values[valuesById[128] = \"IFF_NOARP\"] = 128;\n                values[valuesById[256] = \"IFF_PROMISC\"] = 256;\n                values[valuesById[512] = \"IFF_ALLMULTI\"] = 512;\n                values[valuesById[32768] = \"IFF_MULTICAST\"] = 32768;\n                values[valuesById[65536] = \"IFF_NOND6\"] = 65536;\n                return values;\n            })();\n    \n            ctrl.InterfaceExtFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFXF_NONE\"] = 0;\n                values[valuesById[16] = \"IFXF_WOL\"] = 16;\n                values[valuesById[32] = \"IFXF_AUTOCONF6\"] = 32;\n                values[valuesById[65536] = \"IFXF_DHCP\"] = 65536;\n                values[valuesById[131072] = \"IFXF_DHCP6\"] = 131072;\n                values[valuesById[262144] = \"IFXF_AUTOIP\"] = 262144;\n                return values;\n            })();\n    \n            ctrl.InterfaceType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_INTERFACE_TYPE\"] = 0;\n                values[valuesById[1] = \"LOOPBACK\"] = 1;\n                values[valuesById[2] = \"THREAD\"] = 2;\n                values[valuesById[4] = \"ETHERNET\"] = 4;\n                values[valuesById[8] = \"WIFI\"] = 8;\n                values[valuesById[16] = \"PPP\"] = 16;\n                return values;\n            })();\n    \n            ctrl.Interface = (function() {\n    \n                function Interface(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Interface.prototype.index = 0;\n                Interface.prototype.name = \"\";\n                Interface.prototype.type = 0;\n                Interface.prototype.flags = 0;\n                Interface.prototype.extFlags = 0;\n                Interface.prototype.ipv4Config = null;\n                Interface.prototype.ipv6Config = null;\n                Interface.prototype.hwAddress = $util.newBuffer([]);\n                Interface.prototype.mtu = 0;\n                Interface.prototype.metric = 0;\n    \n                Interface.create = function create(properties) {\n                    return new Interface(properties);\n                };\n    \n                Interface.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && m.hasOwnProperty(\"index\"))\n                        w.uint32(8).uint32(m.index);\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(18).string(m.name);\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(24).int32(m.type);\n                    if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                        w.uint32(32).uint32(m.flags);\n                    if (m.extFlags != null && m.hasOwnProperty(\"extFlags\"))\n                        w.uint32(40).uint32(m.extFlags);\n                    if (m.ipv4Config != null && m.hasOwnProperty(\"ipv4Config\"))\n                        $root.particle.ctrl.Ipv4Config.encode(m.ipv4Config, w.uint32(50).fork()).ldelim();\n                    if (m.ipv6Config != null && m.hasOwnProperty(\"ipv6Config\"))\n                        $root.particle.ctrl.Ipv6Config.encode(m.ipv6Config, w.uint32(58).fork()).ldelim();\n                    if (m.hwAddress != null && m.hasOwnProperty(\"hwAddress\"))\n                        w.uint32(66).bytes(m.hwAddress);\n                    if (m.mtu != null && m.hasOwnProperty(\"mtu\"))\n                        w.uint32(72).uint32(m.mtu);\n                    if (m.metric != null && m.hasOwnProperty(\"metric\"))\n                        w.uint32(80).uint32(m.metric);\n                    return w;\n                };\n    \n                Interface.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Interface();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        case 2:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.type = r.int32();\n                            break;\n                        case 4:\n                            m.flags = r.uint32();\n                            break;\n                        case 5:\n                            m.extFlags = r.uint32();\n                            break;\n                        case 6:\n                            m.ipv4Config = $root.particle.ctrl.Ipv4Config.decode(r, r.uint32());\n                            break;\n                        case 7:\n                            m.ipv6Config = $root.particle.ctrl.Ipv6Config.decode(r, r.uint32());\n                            break;\n                        case 8:\n                            m.hwAddress = r.bytes();\n                            break;\n                        case 9:\n                            m.mtu = r.uint32();\n                            break;\n                        case 10:\n                            m.metric = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Interface;\n            })();\n    \n            ctrl.InterfaceEntry = (function() {\n    \n                function InterfaceEntry(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                InterfaceEntry.prototype.index = 0;\n                InterfaceEntry.prototype.name = \"\";\n                InterfaceEntry.prototype.type = 0;\n    \n                InterfaceEntry.create = function create(properties) {\n                    return new InterfaceEntry(properties);\n                };\n    \n                InterfaceEntry.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && m.hasOwnProperty(\"index\"))\n                        w.uint32(8).uint32(m.index);\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(18).string(m.name);\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(24).int32(m.type);\n                    return w;\n                };\n    \n                InterfaceEntry.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.InterfaceEntry();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        case 2:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.type = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return InterfaceEntry;\n            })();\n    \n            ctrl.GetInterfaceListRequest = (function() {\n    \n                function GetInterfaceListRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceListRequest.create = function create(properties) {\n                    return new GetInterfaceListRequest(properties);\n                };\n    \n                GetInterfaceListRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetInterfaceListRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceListRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceListRequest;\n            })();\n    \n            ctrl.GetInterfaceListReply = (function() {\n    \n                function GetInterfaceListReply(p) {\n                    this.interfaces = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceListReply.prototype.interfaces = $util.emptyArray;\n    \n                GetInterfaceListReply.create = function create(properties) {\n                    return new GetInterfaceListReply(properties);\n                };\n    \n                GetInterfaceListReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.interfaces != null && m.interfaces.length) {\n                        for (var i = 0; i < m.interfaces.length; ++i)\n                            $root.particle.ctrl.InterfaceEntry.encode(m.interfaces[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GetInterfaceListReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceListReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.interfaces && m.interfaces.length))\n                                m.interfaces = [];\n                            m.interfaces.push($root.particle.ctrl.InterfaceEntry.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceListReply;\n            })();\n    \n            ctrl.GetInterfaceRequest = (function() {\n    \n                function GetInterfaceRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceRequest.prototype.index = 0;\n    \n                GetInterfaceRequest.create = function create(properties) {\n                    return new GetInterfaceRequest(properties);\n                };\n    \n                GetInterfaceRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && m.hasOwnProperty(\"index\"))\n                        w.uint32(8).uint32(m.index);\n                    return w;\n                };\n    \n                GetInterfaceRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceRequest;\n            })();\n    \n            ctrl.GetInterfaceReply = (function() {\n    \n                function GetInterfaceReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceReply.prototype[\"interface\"] = null;\n    \n                GetInterfaceReply.create = function create(properties) {\n                    return new GetInterfaceReply(properties);\n                };\n    \n                GetInterfaceReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && m.hasOwnProperty(\"interface\"))\n                        $root.particle.ctrl.Interface.encode(m[\"interface\"], w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                GetInterfaceReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = $root.particle.ctrl.Interface.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceReply;\n            })();\n    \n            ctrl.wifi = (function() {\n    \n                var wifi = {};\n    \n                wifi.Security = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_SECURITY\"] = 0;\n                    values[valuesById[1] = \"WEP\"] = 1;\n                    values[valuesById[2] = \"WPA_PSK\"] = 2;\n                    values[valuesById[3] = \"WPA2_PSK\"] = 3;\n                    values[valuesById[4] = \"WPA_WPA2_PSK\"] = 4;\n                    return values;\n                })();\n    \n                wifi.CredentialsType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_CREDENTIALS\"] = 0;\n                    values[valuesById[1] = \"PASSWORD\"] = 1;\n                    return values;\n                })();\n    \n                wifi.Credentials = (function() {\n    \n                    function Credentials(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Credentials.prototype.type = 0;\n                    Credentials.prototype.password = \"\";\n    \n                    Credentials.create = function create(properties) {\n                        return new Credentials(properties);\n                    };\n    \n                    Credentials.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && m.hasOwnProperty(\"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(18).string(m.password);\n                        return w;\n                    };\n    \n                    Credentials.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.Credentials();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Credentials;\n                })();\n    \n                wifi.JoinNewNetworkRequest = (function() {\n    \n                    function JoinNewNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNewNetworkRequest.prototype.ssid = \"\";\n                    JoinNewNetworkRequest.prototype.bssid = $util.newBuffer([]);\n                    JoinNewNetworkRequest.prototype.security = 0;\n                    JoinNewNetworkRequest.prototype.credentials = null;\n    \n                    JoinNewNetworkRequest.create = function create(properties) {\n                        return new JoinNewNetworkRequest(properties);\n                    };\n    \n                    JoinNewNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && m.hasOwnProperty(\"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.security != null && m.hasOwnProperty(\"security\"))\n                            w.uint32(24).int32(m.security);\n                        if (m.credentials != null && m.hasOwnProperty(\"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(m.credentials, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    JoinNewNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinNewNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.security = r.int32();\n                                break;\n                            case 4:\n                                m.credentials = $root.particle.ctrl.wifi.Credentials.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNewNetworkRequest;\n                })();\n    \n                wifi.JoinNewNetworkReply = (function() {\n    \n                    function JoinNewNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNewNetworkReply.create = function create(properties) {\n                        return new JoinNewNetworkReply(properties);\n                    };\n    \n                    JoinNewNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinNewNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinNewNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNewNetworkReply;\n                })();\n    \n                wifi.JoinKnownNetworkRequest = (function() {\n    \n                    function JoinKnownNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    JoinKnownNetworkRequest.create = function create(properties) {\n                        return new JoinKnownNetworkRequest(properties);\n                    };\n    \n                    JoinKnownNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        return w;\n                    };\n    \n                    JoinKnownNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinKnownNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinKnownNetworkRequest;\n                })();\n    \n                wifi.JoinKnownNetworkReply = (function() {\n    \n                    function JoinKnownNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinKnownNetworkReply.create = function create(properties) {\n                        return new JoinKnownNetworkReply(properties);\n                    };\n    \n                    JoinKnownNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinKnownNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinKnownNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinKnownNetworkReply;\n                })();\n    \n                wifi.GetKnownNetworksRequest = (function() {\n    \n                    function GetKnownNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetKnownNetworksRequest.create = function create(properties) {\n                        return new GetKnownNetworksRequest(properties);\n                    };\n    \n                    GetKnownNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetKnownNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetKnownNetworksRequest;\n                })();\n    \n                wifi.GetKnownNetworksReply = (function() {\n    \n                    function GetKnownNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetKnownNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    GetKnownNetworksReply.create = function create(properties) {\n                        return new GetKnownNetworksReply(properties);\n                    };\n    \n                    GetKnownNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.wifi.GetKnownNetworksReply.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetKnownNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.wifi.GetKnownNetworksReply.Network.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetKnownNetworksReply.Network = (function() {\n    \n                        function Network(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Network.prototype.ssid = \"\";\n                        Network.prototype.security = 0;\n                        Network.prototype.credentialsType = 0;\n    \n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        Network.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                                w.uint32(10).string(m.ssid);\n                            if (m.security != null && m.hasOwnProperty(\"security\"))\n                                w.uint32(16).int32(m.security);\n                            if (m.credentialsType != null && m.hasOwnProperty(\"credentialsType\"))\n                                w.uint32(24).int32(m.credentialsType);\n                            return w;\n                        };\n    \n                        Network.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksReply.Network();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ssid = r.string();\n                                    break;\n                                case 2:\n                                    m.security = r.int32();\n                                    break;\n                                case 3:\n                                    m.credentialsType = r.int32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return GetKnownNetworksReply;\n                })();\n    \n                wifi.RemoveKnownNetworkRequest = (function() {\n    \n                    function RemoveKnownNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    RemoveKnownNetworkRequest.create = function create(properties) {\n                        return new RemoveKnownNetworkRequest(properties);\n                    };\n    \n                    RemoveKnownNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        return w;\n                    };\n    \n                    RemoveKnownNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.RemoveKnownNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveKnownNetworkRequest;\n                })();\n    \n                wifi.RemoveKnownNetworkReply = (function() {\n    \n                    function RemoveKnownNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveKnownNetworkReply.create = function create(properties) {\n                        return new RemoveKnownNetworkReply(properties);\n                    };\n    \n                    RemoveKnownNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveKnownNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.RemoveKnownNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveKnownNetworkReply;\n                })();\n    \n                wifi.ClearKnownNetworksRequest = (function() {\n    \n                    function ClearKnownNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ClearKnownNetworksRequest.create = function create(properties) {\n                        return new ClearKnownNetworksRequest(properties);\n                    };\n    \n                    ClearKnownNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ClearKnownNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ClearKnownNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ClearKnownNetworksRequest;\n                })();\n    \n                wifi.ClearKnownNetworksReply = (function() {\n    \n                    function ClearKnownNetworksReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ClearKnownNetworksReply.create = function create(properties) {\n                        return new ClearKnownNetworksReply(properties);\n                    };\n    \n                    ClearKnownNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ClearKnownNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ClearKnownNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ClearKnownNetworksReply;\n                })();\n    \n                wifi.GetCurrentNetworkRequest = (function() {\n    \n                    function GetCurrentNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetCurrentNetworkRequest.create = function create(properties) {\n                        return new GetCurrentNetworkRequest(properties);\n                    };\n    \n                    GetCurrentNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetCurrentNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetCurrentNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetCurrentNetworkRequest;\n                })();\n    \n                wifi.GetCurrentNetworkReply = (function() {\n    \n                    function GetCurrentNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetCurrentNetworkReply.prototype.ssid = \"\";\n                    GetCurrentNetworkReply.prototype.bssid = $util.newBuffer([]);\n                    GetCurrentNetworkReply.prototype.channel = 0;\n                    GetCurrentNetworkReply.prototype.rssi = 0;\n    \n                    GetCurrentNetworkReply.create = function create(properties) {\n                        return new GetCurrentNetworkReply(properties);\n                    };\n    \n                    GetCurrentNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && m.hasOwnProperty(\"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.channel != null && m.hasOwnProperty(\"channel\"))\n                            w.uint32(24).int32(m.channel);\n                        if (m.rssi != null && m.hasOwnProperty(\"rssi\"))\n                            w.uint32(32).int32(m.rssi);\n                        return w;\n                    };\n    \n                    GetCurrentNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetCurrentNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.channel = r.int32();\n                                break;\n                            case 4:\n                                m.rssi = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetCurrentNetworkReply;\n                })();\n    \n                wifi.ScanNetworksRequest = (function() {\n    \n                    function ScanNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    ScanNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ScanNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                wifi.ScanNetworksReply = (function() {\n    \n                    function ScanNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    ScanNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.wifi.ScanNetworksReply.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    ScanNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.wifi.ScanNetworksReply.Network.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    ScanNetworksReply.Network = (function() {\n    \n                        function Network(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Network.prototype.ssid = \"\";\n                        Network.prototype.bssid = $util.newBuffer([]);\n                        Network.prototype.security = 0;\n                        Network.prototype.channel = 0;\n                        Network.prototype.rssi = 0;\n    \n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        Network.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                                w.uint32(10).string(m.ssid);\n                            if (m.bssid != null && m.hasOwnProperty(\"bssid\"))\n                                w.uint32(18).bytes(m.bssid);\n                            if (m.security != null && m.hasOwnProperty(\"security\"))\n                                w.uint32(24).int32(m.security);\n                            if (m.channel != null && m.hasOwnProperty(\"channel\"))\n                                w.uint32(32).int32(m.channel);\n                            if (m.rssi != null && m.hasOwnProperty(\"rssi\"))\n                                w.uint32(40).int32(m.rssi);\n                            return w;\n                        };\n    \n                        Network.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksReply.Network();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ssid = r.string();\n                                    break;\n                                case 2:\n                                    m.bssid = r.bytes();\n                                    break;\n                                case 3:\n                                    m.security = r.int32();\n                                    break;\n                                case 4:\n                                    m.channel = r.int32();\n                                    break;\n                                case 5:\n                                    m.rssi = r.int32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return ScanNetworksReply;\n                })();\n    \n                return wifi;\n            })();\n    \n            ctrl.logging = (function() {\n    \n                var logging = {};\n    \n                logging.LogLevel = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_LEVEL\"] = 0;\n                    values[valuesById[1] = \"ALL\"] = 1;\n                    values[\"TRACE\"] = 1;\n                    values[valuesById[30] = \"INFO\"] = 30;\n                    values[valuesById[40] = \"WARN\"] = 40;\n                    values[valuesById[50] = \"ERROR\"] = 50;\n                    values[valuesById[70] = \"NONE\"] = 70;\n                    return values;\n                })();\n    \n                logging.LogHandlerType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_HANDLER_TYPE\"] = 0;\n                    values[valuesById[1] = \"DEFAULT_STREAM_HANDLER\"] = 1;\n                    values[valuesById[2] = \"JSON_STREAM_HANDLER\"] = 2;\n                    return values;\n                })();\n    \n                logging.StreamType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_STREAM_TYPE\"] = 0;\n                    values[valuesById[1] = \"USB_SERIAL_STREAM\"] = 1;\n                    values[valuesById[2] = \"HW_SERIAL_STREAM\"] = 2;\n                    return values;\n                })();\n    \n                logging.LogFilter = (function() {\n    \n                    function LogFilter(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LogFilter.prototype.category = \"\";\n                    LogFilter.prototype.level = 0;\n    \n                    LogFilter.create = function create(properties) {\n                        return new LogFilter(properties);\n                    };\n    \n                    LogFilter.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.category != null && m.hasOwnProperty(\"category\"))\n                            w.uint32(10).string(m.category);\n                        if (m.level != null && m.hasOwnProperty(\"level\"))\n                            w.uint32(16).int32(m.level);\n                        return w;\n                    };\n    \n                    LogFilter.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.LogFilter();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.category = r.string();\n                                break;\n                            case 2:\n                                m.level = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LogFilter;\n                })();\n    \n                logging.SerialStreamParams = (function() {\n    \n                    function SerialStreamParams(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SerialStreamParams.prototype.index = 0;\n                    SerialStreamParams.prototype.baudRate = 0;\n    \n                    SerialStreamParams.create = function create(properties) {\n                        return new SerialStreamParams(properties);\n                    };\n    \n                    SerialStreamParams.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.index != null && m.hasOwnProperty(\"index\"))\n                            w.uint32(8).uint32(m.index);\n                        if (m.baudRate != null && m.hasOwnProperty(\"baudRate\"))\n                            w.uint32(16).uint32(m.baudRate);\n                        return w;\n                    };\n    \n                    SerialStreamParams.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.SerialStreamParams();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.index = r.uint32();\n                                break;\n                            case 2:\n                                m.baudRate = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SerialStreamParams;\n                })();\n    \n                logging.AddLogHandlerRequest = (function() {\n    \n                    function AddLogHandlerRequest(p) {\n                        this.filters = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddLogHandlerRequest.prototype.id = \"\";\n                    AddLogHandlerRequest.prototype.handlerType = 0;\n                    AddLogHandlerRequest.prototype.level = 0;\n                    AddLogHandlerRequest.prototype.filters = $util.emptyArray;\n                    AddLogHandlerRequest.prototype.streamType = 0;\n                    AddLogHandlerRequest.prototype.serial = null;\n    \n                    var $oneOfFields;\n    \n                    Object.defineProperty(AddLogHandlerRequest.prototype, \"streamParams\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"serial\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    AddLogHandlerRequest.create = function create(properties) {\n                        return new AddLogHandlerRequest(properties);\n                    };\n    \n                    AddLogHandlerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.id != null && m.hasOwnProperty(\"id\"))\n                            w.uint32(10).string(m.id);\n                        if (m.handlerType != null && m.hasOwnProperty(\"handlerType\"))\n                            w.uint32(16).int32(m.handlerType);\n                        if (m.level != null && m.hasOwnProperty(\"level\"))\n                            w.uint32(24).int32(m.level);\n                        if (m.filters != null && m.filters.length) {\n                            for (var i = 0; i < m.filters.length; ++i)\n                                $root.particle.ctrl.logging.LogFilter.encode(m.filters[i], w.uint32(34).fork()).ldelim();\n                        }\n                        if (m.streamType != null && m.hasOwnProperty(\"streamType\"))\n                            w.uint32(40).int32(m.streamType);\n                        if (m.serial != null && m.hasOwnProperty(\"serial\"))\n                            $root.particle.ctrl.logging.SerialStreamParams.encode(m.serial, w.uint32(50).fork()).ldelim();\n                        return w;\n                    };\n    \n                    AddLogHandlerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.AddLogHandlerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.id = r.string();\n                                break;\n                            case 2:\n                                m.handlerType = r.int32();\n                                break;\n                            case 3:\n                                m.level = r.int32();\n                                break;\n                            case 4:\n                                if (!(m.filters && m.filters.length))\n                                    m.filters = [];\n                                m.filters.push($root.particle.ctrl.logging.LogFilter.decode(r, r.uint32()));\n                                break;\n                            case 5:\n                                m.streamType = r.int32();\n                                break;\n                            case 6:\n                                m.serial = $root.particle.ctrl.logging.SerialStreamParams.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddLogHandlerRequest;\n                })();\n    \n                logging.AddLogHandlerReply = (function() {\n    \n                    function AddLogHandlerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddLogHandlerReply.create = function create(properties) {\n                        return new AddLogHandlerReply(properties);\n                    };\n    \n                    AddLogHandlerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AddLogHandlerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.AddLogHandlerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddLogHandlerReply;\n                })();\n    \n                logging.RemoveLogHandlerRequest = (function() {\n    \n                    function RemoveLogHandlerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveLogHandlerRequest.prototype.id = \"\";\n    \n                    RemoveLogHandlerRequest.create = function create(properties) {\n                        return new RemoveLogHandlerRequest(properties);\n                    };\n    \n                    RemoveLogHandlerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.id != null && m.hasOwnProperty(\"id\"))\n                            w.uint32(10).string(m.id);\n                        return w;\n                    };\n    \n                    RemoveLogHandlerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.RemoveLogHandlerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.id = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveLogHandlerRequest;\n                })();\n    \n                logging.RemoveLogHandlerReply = (function() {\n    \n                    function RemoveLogHandlerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveLogHandlerReply.create = function create(properties) {\n                        return new RemoveLogHandlerReply(properties);\n                    };\n    \n                    RemoveLogHandlerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveLogHandlerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.RemoveLogHandlerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveLogHandlerReply;\n                })();\n    \n                logging.GetLogHandlersRequest = (function() {\n    \n                    function GetLogHandlersRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetLogHandlersRequest.create = function create(properties) {\n                        return new GetLogHandlersRequest(properties);\n                    };\n    \n                    GetLogHandlersRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetLogHandlersRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetLogHandlersRequest;\n                })();\n    \n                logging.GetLogHandlersReply = (function() {\n    \n                    function GetLogHandlersReply(p) {\n                        this.handlers = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetLogHandlersReply.prototype.handlers = $util.emptyArray;\n    \n                    GetLogHandlersReply.create = function create(properties) {\n                        return new GetLogHandlersReply(properties);\n                    };\n    \n                    GetLogHandlersReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.handlers != null && m.handlers.length) {\n                            for (var i = 0; i < m.handlers.length; ++i)\n                                $root.particle.ctrl.logging.GetLogHandlersReply.Handler.encode(m.handlers[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetLogHandlersReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.handlers && m.handlers.length))\n                                    m.handlers = [];\n                                m.handlers.push($root.particle.ctrl.logging.GetLogHandlersReply.Handler.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetLogHandlersReply.Handler = (function() {\n    \n                        function Handler(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Handler.prototype.id = \"\";\n    \n                        Handler.create = function create(properties) {\n                            return new Handler(properties);\n                        };\n    \n                        Handler.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.id != null && m.hasOwnProperty(\"id\"))\n                                w.uint32(10).string(m.id);\n                            return w;\n                        };\n    \n                        Handler.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersReply.Handler();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.id = r.string();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Handler;\n                    })();\n    \n                    return GetLogHandlersReply;\n                })();\n    \n                return logging;\n            })();\n    \n            ctrl.mesh = (function() {\n    \n                var mesh = {};\n    \n                mesh.NetworkInfo = (function() {\n    \n                    function NetworkInfo(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    NetworkInfo.prototype.name = \"\";\n                    NetworkInfo.prototype.extPanId = \"\";\n                    NetworkInfo.prototype.panId = 0;\n                    NetworkInfo.prototype.channel = 0;\n                    NetworkInfo.prototype.networkId = \"\";\n    \n                    NetworkInfo.create = function create(properties) {\n                        return new NetworkInfo(properties);\n                    };\n    \n                    NetworkInfo.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.name != null && m.hasOwnProperty(\"name\"))\n                            w.uint32(10).string(m.name);\n                        if (m.extPanId != null && m.hasOwnProperty(\"extPanId\"))\n                            w.uint32(18).string(m.extPanId);\n                        if (m.panId != null && m.hasOwnProperty(\"panId\"))\n                            w.uint32(24).uint32(m.panId);\n                        if (m.channel != null && m.hasOwnProperty(\"channel\"))\n                            w.uint32(32).uint32(m.channel);\n                        if (m.networkId != null && m.hasOwnProperty(\"networkId\"))\n                            w.uint32(42).string(m.networkId);\n                        return w;\n                    };\n    \n                    NetworkInfo.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.NetworkInfo();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.name = r.string();\n                                break;\n                            case 2:\n                                m.extPanId = r.string();\n                                break;\n                            case 3:\n                                m.panId = r.uint32();\n                                break;\n                            case 4:\n                                m.channel = r.uint32();\n                                break;\n                            case 5:\n                                m.networkId = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return NetworkInfo;\n                })();\n    \n                mesh.AuthRequest = (function() {\n    \n                    function AuthRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AuthRequest.prototype.password = \"\";\n    \n                    AuthRequest.create = function create(properties) {\n                        return new AuthRequest(properties);\n                    };\n    \n                    AuthRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(10).string(m.password);\n                        return w;\n                    };\n    \n                    AuthRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AuthRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AuthRequest;\n                })();\n    \n                mesh.AuthReply = (function() {\n    \n                    function AuthReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AuthReply.create = function create(properties) {\n                        return new AuthReply(properties);\n                    };\n    \n                    AuthReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AuthReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AuthReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AuthReply;\n                })();\n    \n                mesh.CreateNetworkRequest = (function() {\n    \n                    function CreateNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    CreateNetworkRequest.prototype.name = \"\";\n                    CreateNetworkRequest.prototype.password = \"\";\n                    CreateNetworkRequest.prototype.channel = 0;\n                    CreateNetworkRequest.prototype.networkId = \"\";\n    \n                    CreateNetworkRequest.create = function create(properties) {\n                        return new CreateNetworkRequest(properties);\n                    };\n    \n                    CreateNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.name != null && m.hasOwnProperty(\"name\"))\n                            w.uint32(10).string(m.name);\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(18).string(m.password);\n                        if (m.channel != null && m.hasOwnProperty(\"channel\"))\n                            w.uint32(24).uint32(m.channel);\n                        if (m.networkId != null && m.hasOwnProperty(\"networkId\"))\n                            w.uint32(34).string(m.networkId);\n                        return w;\n                    };\n    \n                    CreateNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.CreateNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.name = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            case 3:\n                                m.channel = r.uint32();\n                                break;\n                            case 4:\n                                m.networkId = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return CreateNetworkRequest;\n                })();\n    \n                mesh.CreateNetworkReply = (function() {\n    \n                    function CreateNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    CreateNetworkReply.prototype.network = null;\n    \n                    CreateNetworkReply.create = function create(properties) {\n                        return new CreateNetworkReply(properties);\n                    };\n    \n                    CreateNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && m.hasOwnProperty(\"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    CreateNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.CreateNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return CreateNetworkReply;\n                })();\n    \n                mesh.StartCommissionerRequest = (function() {\n    \n                    function StartCommissionerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StartCommissionerRequest.prototype.timeout = 0;\n    \n                    StartCommissionerRequest.create = function create(properties) {\n                        return new StartCommissionerRequest(properties);\n                    };\n    \n                    StartCommissionerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                            w.uint32(8).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    StartCommissionerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StartCommissionerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StartCommissionerRequest;\n                })();\n    \n                mesh.StartCommissionerReply = (function() {\n    \n                    function StartCommissionerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StartCommissionerReply.create = function create(properties) {\n                        return new StartCommissionerReply(properties);\n                    };\n    \n                    StartCommissionerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StartCommissionerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StartCommissionerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StartCommissionerReply;\n                })();\n    \n                mesh.StopCommissionerRequest = (function() {\n    \n                    function StopCommissionerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StopCommissionerRequest.create = function create(properties) {\n                        return new StopCommissionerRequest(properties);\n                    };\n    \n                    StopCommissionerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StopCommissionerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StopCommissionerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StopCommissionerRequest;\n                })();\n    \n                mesh.StopCommissionerReply = (function() {\n    \n                    function StopCommissionerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StopCommissionerReply.create = function create(properties) {\n                        return new StopCommissionerReply(properties);\n                    };\n    \n                    StopCommissionerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StopCommissionerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StopCommissionerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StopCommissionerReply;\n                })();\n    \n                mesh.PrepareJoinerRequest = (function() {\n    \n                    function PrepareJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    PrepareJoinerRequest.prototype.network = null;\n    \n                    PrepareJoinerRequest.create = function create(properties) {\n                        return new PrepareJoinerRequest(properties);\n                    };\n    \n                    PrepareJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && m.hasOwnProperty(\"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    PrepareJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.PrepareJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return PrepareJoinerRequest;\n                })();\n    \n                mesh.PrepareJoinerReply = (function() {\n    \n                    function PrepareJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    PrepareJoinerReply.prototype.eui64 = \"\";\n                    PrepareJoinerReply.prototype.password = \"\";\n    \n                    PrepareJoinerReply.create = function create(properties) {\n                        return new PrepareJoinerReply(properties);\n                    };\n    \n                    PrepareJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && m.hasOwnProperty(\"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(18).string(m.password);\n                        return w;\n                    };\n    \n                    PrepareJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.PrepareJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return PrepareJoinerReply;\n                })();\n    \n                mesh.AddJoinerRequest = (function() {\n    \n                    function AddJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddJoinerRequest.prototype.eui64 = \"\";\n                    AddJoinerRequest.prototype.password = \"\";\n                    AddJoinerRequest.prototype.timeout = 0;\n    \n                    AddJoinerRequest.create = function create(properties) {\n                        return new AddJoinerRequest(properties);\n                    };\n    \n                    AddJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && m.hasOwnProperty(\"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        if (m.password != null && m.hasOwnProperty(\"password\"))\n                            w.uint32(18).string(m.password);\n                        if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                            w.uint32(24).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    AddJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AddJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            case 3:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddJoinerRequest;\n                })();\n    \n                mesh.AddJoinerReply = (function() {\n    \n                    function AddJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddJoinerReply.create = function create(properties) {\n                        return new AddJoinerReply(properties);\n                    };\n    \n                    AddJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AddJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AddJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddJoinerReply;\n                })();\n    \n                mesh.RemoveJoinerRequest = (function() {\n    \n                    function RemoveJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveJoinerRequest.prototype.eui64 = \"\";\n    \n                    RemoveJoinerRequest.create = function create(properties) {\n                        return new RemoveJoinerRequest(properties);\n                    };\n    \n                    RemoveJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && m.hasOwnProperty(\"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        return w;\n                    };\n    \n                    RemoveJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.RemoveJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveJoinerRequest;\n                })();\n    \n                mesh.RemoveJoinerReply = (function() {\n    \n                    function RemoveJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveJoinerReply.create = function create(properties) {\n                        return new RemoveJoinerReply(properties);\n                    };\n    \n                    RemoveJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.RemoveJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveJoinerReply;\n                })();\n    \n                mesh.JoinNetworkRequest = (function() {\n    \n                    function JoinNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNetworkRequest.prototype.timeout = 0;\n    \n                    JoinNetworkRequest.create = function create(properties) {\n                        return new JoinNetworkRequest(properties);\n                    };\n    \n                    JoinNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                            w.uint32(8).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    JoinNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.JoinNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNetworkRequest;\n                })();\n    \n                mesh.JoinNetworkReply = (function() {\n    \n                    function JoinNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNetworkReply.create = function create(properties) {\n                        return new JoinNetworkReply(properties);\n                    };\n    \n                    JoinNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.JoinNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNetworkReply;\n                })();\n    \n                mesh.LeaveNetworkRequest = (function() {\n    \n                    function LeaveNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LeaveNetworkRequest.create = function create(properties) {\n                        return new LeaveNetworkRequest(properties);\n                    };\n    \n                    LeaveNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    LeaveNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.LeaveNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LeaveNetworkRequest;\n                })();\n    \n                mesh.LeaveNetworkReply = (function() {\n    \n                    function LeaveNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LeaveNetworkReply.create = function create(properties) {\n                        return new LeaveNetworkReply(properties);\n                    };\n    \n                    LeaveNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    LeaveNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.LeaveNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LeaveNetworkReply;\n                })();\n    \n                mesh.GetNetworkInfoRequest = (function() {\n    \n                    function GetNetworkInfoRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkInfoRequest.create = function create(properties) {\n                        return new GetNetworkInfoRequest(properties);\n                    };\n    \n                    GetNetworkInfoRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetNetworkInfoRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkInfoRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkInfoRequest;\n                })();\n    \n                mesh.GetNetworkInfoReply = (function() {\n    \n                    function GetNetworkInfoReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkInfoReply.prototype.network = null;\n    \n                    GetNetworkInfoReply.create = function create(properties) {\n                        return new GetNetworkInfoReply(properties);\n                    };\n    \n                    GetNetworkInfoReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && m.hasOwnProperty(\"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    GetNetworkInfoReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkInfoReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkInfoReply;\n                })();\n    \n                mesh.ScanNetworksRequest = (function() {\n    \n                    function ScanNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksRequest.prototype.duration = 0;\n    \n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    ScanNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.duration != null && m.hasOwnProperty(\"duration\"))\n                            w.uint32(8).uint32(m.duration);\n                        return w;\n                    };\n    \n                    ScanNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.ScanNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.duration = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                mesh.ScanNetworksReply = (function() {\n    \n                    function ScanNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    ScanNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.mesh.NetworkInfo.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    ScanNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.ScanNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksReply;\n                })();\n    \n                mesh.DiagnosticType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"MAC_EXTENDED_ADDRESS\"] = 0;\n                    values[valuesById[1] = \"RLOC\"] = 1;\n                    values[\"MAC_ADDRESS\"] = 1;\n                    values[valuesById[2] = \"MODE\"] = 2;\n                    values[valuesById[3] = \"TIMEOUT\"] = 3;\n                    values[valuesById[4] = \"CONNECTIVITY\"] = 4;\n                    values[valuesById[5] = \"ROUTE64\"] = 5;\n                    values[valuesById[6] = \"LEADER_DATA\"] = 6;\n                    values[valuesById[7] = \"NETWORK_DATA\"] = 7;\n                    values[valuesById[8] = \"IPV6_ADDRESS_LIST\"] = 8;\n                    values[valuesById[9] = \"MAC_COUNTERS\"] = 9;\n                    values[valuesById[14] = \"BATTERY_LEVEL\"] = 14;\n                    values[valuesById[15] = \"SUPPLY_VOLTAGE\"] = 15;\n                    values[valuesById[16] = \"CHILD_TABLE\"] = 16;\n                    values[valuesById[17] = \"CHANNEL_PAGES\"] = 17;\n                    values[valuesById[18] = \"TYPE_LIST\"] = 18;\n                    values[valuesById[19] = \"MAX_CHILD_TIMEOUT\"] = 19;\n                    return values;\n                })();\n    \n                mesh.DiagnosticInfo = (function() {\n    \n                    function DiagnosticInfo(p) {\n                        this.ipv6AddressList = [];\n                        this.typeList = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DiagnosticInfo.prototype.extMacAddress = $util.newBuffer([]);\n                    DiagnosticInfo.prototype.rloc = 0;\n                    DiagnosticInfo.prototype.mode = 0;\n                    DiagnosticInfo.prototype.timeout = 0;\n                    DiagnosticInfo.prototype.connectivity = null;\n                    DiagnosticInfo.prototype.route64 = null;\n                    DiagnosticInfo.prototype.leaderData = null;\n                    DiagnosticInfo.prototype.networkData = null;\n                    DiagnosticInfo.prototype.ipv6AddressList = $util.emptyArray;\n                    DiagnosticInfo.prototype.macCounters = null;\n                    DiagnosticInfo.prototype.batteryLevel = 0;\n                    DiagnosticInfo.prototype.supplyVoltage = 0;\n                    DiagnosticInfo.prototype.childTable = null;\n                    DiagnosticInfo.prototype.channelPages = $util.newBuffer([]);\n                    DiagnosticInfo.prototype.typeList = $util.emptyArray;\n                    DiagnosticInfo.prototype.maxChildTimeout = 0;\n                    DiagnosticInfo.prototype.deviceId = $util.newBuffer([]);\n    \n                    DiagnosticInfo.create = function create(properties) {\n                        return new DiagnosticInfo(properties);\n                    };\n    \n                    DiagnosticInfo.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.extMacAddress != null && m.hasOwnProperty(\"extMacAddress\"))\n                            w.uint32(10).bytes(m.extMacAddress);\n                        if (m.rloc != null && m.hasOwnProperty(\"rloc\"))\n                            w.uint32(16).uint32(m.rloc);\n                        if (m.mode != null && m.hasOwnProperty(\"mode\"))\n                            w.uint32(24).uint32(m.mode);\n                        if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                            w.uint32(32).uint32(m.timeout);\n                        if (m.connectivity != null && m.hasOwnProperty(\"connectivity\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.encode(m.connectivity, w.uint32(42).fork()).ldelim();\n                        if (m.route64 != null && m.hasOwnProperty(\"route64\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Route64.encode(m.route64, w.uint32(50).fork()).ldelim();\n                        if (m.leaderData != null && m.hasOwnProperty(\"leaderData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.encode(m.leaderData, w.uint32(58).fork()).ldelim();\n                        if (m.networkData != null && m.hasOwnProperty(\"networkData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.encode(m.networkData, w.uint32(66).fork()).ldelim();\n                        if (m.ipv6AddressList != null && m.ipv6AddressList.length) {\n                            for (var i = 0; i < m.ipv6AddressList.length; ++i)\n                                $root.particle.ctrl.Ipv6Address.encode(m.ipv6AddressList[i], w.uint32(74).fork()).ldelim();\n                        }\n                        if (m.macCounters != null && m.hasOwnProperty(\"macCounters\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.encode(m.macCounters, w.uint32(82).fork()).ldelim();\n                        if (m.batteryLevel != null && m.hasOwnProperty(\"batteryLevel\"))\n                            w.uint32(120).uint32(m.batteryLevel);\n                        if (m.supplyVoltage != null && m.hasOwnProperty(\"supplyVoltage\"))\n                            w.uint32(128).uint32(m.supplyVoltage);\n                        if (m.childTable != null && m.hasOwnProperty(\"childTable\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.encode(m.childTable, w.uint32(138).fork()).ldelim();\n                        if (m.channelPages != null && m.hasOwnProperty(\"channelPages\"))\n                            w.uint32(146).bytes(m.channelPages);\n                        if (m.typeList != null && m.typeList.length) {\n                            w.uint32(154).fork();\n                            for (var i = 0; i < m.typeList.length; ++i)\n                                w.int32(m.typeList[i]);\n                            w.ldelim();\n                        }\n                        if (m.maxChildTimeout != null && m.hasOwnProperty(\"maxChildTimeout\"))\n                            w.uint32(160).uint32(m.maxChildTimeout);\n                        if (m.deviceId != null && m.hasOwnProperty(\"deviceId\"))\n                            w.uint32(802).bytes(m.deviceId);\n                        return w;\n                    };\n    \n                    DiagnosticInfo.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.extMacAddress = r.bytes();\n                                break;\n                            case 2:\n                                m.rloc = r.uint32();\n                                break;\n                            case 3:\n                                m.mode = r.uint32();\n                                break;\n                            case 4:\n                                m.timeout = r.uint32();\n                                break;\n                            case 5:\n                                m.connectivity = $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.decode(r, r.uint32());\n                                break;\n                            case 6:\n                                m.route64 = $root.particle.ctrl.mesh.DiagnosticInfo.Route64.decode(r, r.uint32());\n                                break;\n                            case 7:\n                                m.leaderData = $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.decode(r, r.uint32());\n                                break;\n                            case 8:\n                                m.networkData = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.decode(r, r.uint32());\n                                break;\n                            case 9:\n                                if (!(m.ipv6AddressList && m.ipv6AddressList.length))\n                                    m.ipv6AddressList = [];\n                                m.ipv6AddressList.push($root.particle.ctrl.Ipv6Address.decode(r, r.uint32()));\n                                break;\n                            case 10:\n                                m.macCounters = $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.decode(r, r.uint32());\n                                break;\n                            case 15:\n                                m.batteryLevel = r.uint32();\n                                break;\n                            case 16:\n                                m.supplyVoltage = r.uint32();\n                                break;\n                            case 17:\n                                m.childTable = $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.decode(r, r.uint32());\n                                break;\n                            case 18:\n                                m.channelPages = r.bytes();\n                                break;\n                            case 19:\n                                if (!(m.typeList && m.typeList.length))\n                                    m.typeList = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.typeList.push(r.int32());\n                                } else\n                                    m.typeList.push(r.int32());\n                                break;\n                            case 20:\n                                m.maxChildTimeout = r.uint32();\n                                break;\n                            case 100:\n                                m.deviceId = r.bytes();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    DiagnosticInfo.Mode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[16] = \"RECEIVER_ON_WHEN_IDLE\"] = 16;\n                        values[valuesById[32] = \"SECURE_DATA_REQUESTS\"] = 32;\n                        values[valuesById[48] = \"DEVICE_TYPE\"] = 48;\n                        values[\"DEVICE_TYPE_FTD\"] = 48;\n                        values[valuesById[64] = \"NETWORK_DATA\"] = 64;\n                        values[\"NETWORK_DATA_FULL\"] = 64;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.Connectivity = (function() {\n    \n                        function Connectivity(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Connectivity.prototype.parentPriority = 0;\n                        Connectivity.prototype.linkQuality_1 = 0;\n                        Connectivity.prototype.linkQuality_2 = 0;\n                        Connectivity.prototype.linkQuality_3 = 0;\n                        Connectivity.prototype.leaderCost = 0;\n                        Connectivity.prototype.idSequence = 0;\n                        Connectivity.prototype.activeRouters = 0;\n                        Connectivity.prototype.sedBufferSize = 0;\n                        Connectivity.prototype.sedDatagramCount = 0;\n    \n                        Connectivity.create = function create(properties) {\n                            return new Connectivity(properties);\n                        };\n    \n                        Connectivity.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.parentPriority != null && m.hasOwnProperty(\"parentPriority\"))\n                                w.uint32(8).uint32(m.parentPriority);\n                            if (m.linkQuality_1 != null && m.hasOwnProperty(\"linkQuality_1\"))\n                                w.uint32(16).uint32(m.linkQuality_1);\n                            if (m.linkQuality_2 != null && m.hasOwnProperty(\"linkQuality_2\"))\n                                w.uint32(24).uint32(m.linkQuality_2);\n                            if (m.linkQuality_3 != null && m.hasOwnProperty(\"linkQuality_3\"))\n                                w.uint32(32).uint32(m.linkQuality_3);\n                            if (m.leaderCost != null && m.hasOwnProperty(\"leaderCost\"))\n                                w.uint32(40).uint32(m.leaderCost);\n                            if (m.idSequence != null && m.hasOwnProperty(\"idSequence\"))\n                                w.uint32(48).uint32(m.idSequence);\n                            if (m.activeRouters != null && m.hasOwnProperty(\"activeRouters\"))\n                                w.uint32(56).uint32(m.activeRouters);\n                            if (m.sedBufferSize != null && m.hasOwnProperty(\"sedBufferSize\"))\n                                w.uint32(64).uint32(m.sedBufferSize);\n                            if (m.sedDatagramCount != null && m.hasOwnProperty(\"sedDatagramCount\"))\n                                w.uint32(72).uint32(m.sedDatagramCount);\n                            return w;\n                        };\n    \n                        Connectivity.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.parentPriority = r.uint32();\n                                    break;\n                                case 2:\n                                    m.linkQuality_1 = r.uint32();\n                                    break;\n                                case 3:\n                                    m.linkQuality_2 = r.uint32();\n                                    break;\n                                case 4:\n                                    m.linkQuality_3 = r.uint32();\n                                    break;\n                                case 5:\n                                    m.leaderCost = r.uint32();\n                                    break;\n                                case 6:\n                                    m.idSequence = r.uint32();\n                                    break;\n                                case 7:\n                                    m.activeRouters = r.uint32();\n                                    break;\n                                case 8:\n                                    m.sedBufferSize = r.uint32();\n                                    break;\n                                case 9:\n                                    m.sedDatagramCount = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Connectivity;\n                    })();\n    \n                    DiagnosticInfo.Route64 = (function() {\n    \n                        function Route64(p) {\n                            this.routes = [];\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Route64.prototype.idSequence = 0;\n                        Route64.prototype.routes = $util.emptyArray;\n    \n                        Route64.create = function create(properties) {\n                            return new Route64(properties);\n                        };\n    \n                        Route64.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.idSequence != null && m.hasOwnProperty(\"idSequence\"))\n                                w.uint32(8).uint32(m.idSequence);\n                            if (m.routes != null && m.routes.length) {\n                                for (var i = 0; i < m.routes.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.encode(m.routes[i], w.uint32(18).fork()).ldelim();\n                            }\n                            return w;\n                        };\n    \n                        Route64.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.idSequence = r.uint32();\n                                    break;\n                                case 2:\n                                    if (!(m.routes && m.routes.length))\n                                        m.routes = [];\n                                    m.routes.push($root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.decode(r, r.uint32()));\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        Route64.RouteData = (function() {\n    \n                            function RouteData(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            RouteData.prototype.routerRloc = 0;\n                            RouteData.prototype.linkQualityOut = 0;\n                            RouteData.prototype.linkQualityIn = 0;\n                            RouteData.prototype.routeCost = 0;\n    \n                            RouteData.create = function create(properties) {\n                                return new RouteData(properties);\n                            };\n    \n                            RouteData.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.routerRloc != null && m.hasOwnProperty(\"routerRloc\"))\n                                    w.uint32(8).uint32(m.routerRloc);\n                                if (m.linkQualityOut != null && m.hasOwnProperty(\"linkQualityOut\"))\n                                    w.uint32(16).uint32(m.linkQualityOut);\n                                if (m.linkQualityIn != null && m.hasOwnProperty(\"linkQualityIn\"))\n                                    w.uint32(24).uint32(m.linkQualityIn);\n                                if (m.routeCost != null && m.hasOwnProperty(\"routeCost\"))\n                                    w.uint32(32).uint32(m.routeCost);\n                                return w;\n                            };\n    \n                            RouteData.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.routerRloc = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.linkQualityOut = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.linkQualityIn = r.uint32();\n                                        break;\n                                    case 4:\n                                        m.routeCost = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return RouteData;\n                        })();\n    \n                        return Route64;\n                    })();\n    \n                    DiagnosticInfo.LeaderData = (function() {\n    \n                        function LeaderData(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        LeaderData.prototype.partitionId = 0;\n                        LeaderData.prototype.weighting = 0;\n                        LeaderData.prototype.dataVersion = 0;\n                        LeaderData.prototype.stableDataVersion = 0;\n                        LeaderData.prototype.leaderRloc = 0;\n    \n                        LeaderData.create = function create(properties) {\n                            return new LeaderData(properties);\n                        };\n    \n                        LeaderData.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.partitionId != null && m.hasOwnProperty(\"partitionId\"))\n                                w.uint32(8).uint32(m.partitionId);\n                            if (m.weighting != null && m.hasOwnProperty(\"weighting\"))\n                                w.uint32(16).uint32(m.weighting);\n                            if (m.dataVersion != null && m.hasOwnProperty(\"dataVersion\"))\n                                w.uint32(24).uint32(m.dataVersion);\n                            if (m.stableDataVersion != null && m.hasOwnProperty(\"stableDataVersion\"))\n                                w.uint32(32).uint32(m.stableDataVersion);\n                            if (m.leaderRloc != null && m.hasOwnProperty(\"leaderRloc\"))\n                                w.uint32(40).uint32(m.leaderRloc);\n                            return w;\n                        };\n    \n                        LeaderData.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.partitionId = r.uint32();\n                                    break;\n                                case 2:\n                                    m.weighting = r.uint32();\n                                    break;\n                                case 3:\n                                    m.dataVersion = r.uint32();\n                                    break;\n                                case 4:\n                                    m.stableDataVersion = r.uint32();\n                                    break;\n                                case 5:\n                                    m.leaderRloc = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return LeaderData;\n                    })();\n    \n                    DiagnosticInfo.RoutePreference = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"MEDIUM\"] = 0;\n                        values[valuesById[1] = \"HIGH\"] = 1;\n                        values[valuesById[-1] = \"LOW\"] = -1;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.NetworkData = (function() {\n    \n                        function NetworkData(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        NetworkData.prototype.stable = null;\n                        NetworkData.prototype.temporary = null;\n    \n                        NetworkData.create = function create(properties) {\n                            return new NetworkData(properties);\n                        };\n    \n                        NetworkData.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.stable != null && m.hasOwnProperty(\"stable\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(m.stable, w.uint32(10).fork()).ldelim();\n                            if (m.temporary != null && m.hasOwnProperty(\"temporary\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(m.temporary, w.uint32(18).fork()).ldelim();\n                            return w;\n                        };\n    \n                        NetworkData.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.stable = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(r, r.uint32());\n                                    break;\n                                case 2:\n                                    m.temporary = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(r, r.uint32());\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        NetworkData.HasRoute = (function() {\n    \n                            function HasRoute(p) {\n                                this.entries = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            HasRoute.prototype.entries = $util.emptyArray;\n    \n                            HasRoute.create = function create(properties) {\n                                return new HasRoute(properties);\n                            };\n    \n                            HasRoute.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.entries != null && m.entries.length) {\n                                    for (var i = 0; i < m.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.encode(m.entries[i], w.uint32(10).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            HasRoute.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.entries && m.entries.length))\n                                            m.entries = [];\n                                        m.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            HasRoute.HasRouteEntry = (function() {\n    \n                                function HasRouteEntry(p) {\n                                    if (p)\n                                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                            if (p[ks[i]] != null)\n                                                this[ks[i]] = p[ks[i]];\n                                }\n    \n                                HasRouteEntry.prototype.rloc = 0;\n                                HasRouteEntry.prototype.preference = 0;\n    \n                                HasRouteEntry.create = function create(properties) {\n                                    return new HasRouteEntry(properties);\n                                };\n    \n                                HasRouteEntry.encode = function encode(m, w) {\n                                    if (!w)\n                                        w = $Writer.create();\n                                    if (m.rloc != null && m.hasOwnProperty(\"rloc\"))\n                                        w.uint32(8).uint32(m.rloc);\n                                    if (m.preference != null && m.hasOwnProperty(\"preference\"))\n                                        w.uint32(16).int32(m.preference);\n                                    return w;\n                                };\n    \n                                HasRouteEntry.decode = function decode(r, l) {\n                                    if (!(r instanceof $Reader))\n                                        r = $Reader.create(r);\n                                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry();\n                                    while (r.pos < c) {\n                                        var t = r.uint32();\n                                        switch (t >>> 3) {\n                                        case 1:\n                                            m.rloc = r.uint32();\n                                            break;\n                                        case 2:\n                                            m.preference = r.int32();\n                                            break;\n                                        default:\n                                            r.skipType(t & 7);\n                                            break;\n                                        }\n                                    }\n                                    return m;\n                                };\n    \n                                return HasRouteEntry;\n                            })();\n    \n                            return HasRoute;\n                        })();\n    \n                        NetworkData.BorderRouter = (function() {\n    \n                            function BorderRouter(p) {\n                                this.entries = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            BorderRouter.prototype.entries = $util.emptyArray;\n    \n                            BorderRouter.create = function create(properties) {\n                                return new BorderRouter(properties);\n                            };\n    \n                            BorderRouter.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.entries != null && m.entries.length) {\n                                    for (var i = 0; i < m.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.encode(m.entries[i], w.uint32(10).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            BorderRouter.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.entries && m.entries.length))\n                                            m.entries = [];\n                                        m.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            BorderRouter.BorderRouterEntry = (function() {\n    \n                                function BorderRouterEntry(p) {\n                                    if (p)\n                                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                            if (p[ks[i]] != null)\n                                                this[ks[i]] = p[ks[i]];\n                                }\n    \n                                BorderRouterEntry.prototype.rloc = 0;\n                                BorderRouterEntry.prototype.preference = 0;\n                                BorderRouterEntry.prototype.flags = 0;\n    \n                                BorderRouterEntry.create = function create(properties) {\n                                    return new BorderRouterEntry(properties);\n                                };\n    \n                                BorderRouterEntry.encode = function encode(m, w) {\n                                    if (!w)\n                                        w = $Writer.create();\n                                    if (m.rloc != null && m.hasOwnProperty(\"rloc\"))\n                                        w.uint32(8).uint32(m.rloc);\n                                    if (m.preference != null && m.hasOwnProperty(\"preference\"))\n                                        w.uint32(16).int32(m.preference);\n                                    if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                                        w.uint32(24).uint32(m.flags);\n                                    return w;\n                                };\n    \n                                BorderRouterEntry.decode = function decode(r, l) {\n                                    if (!(r instanceof $Reader))\n                                        r = $Reader.create(r);\n                                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry();\n                                    while (r.pos < c) {\n                                        var t = r.uint32();\n                                        switch (t >>> 3) {\n                                        case 1:\n                                            m.rloc = r.uint32();\n                                            break;\n                                        case 2:\n                                            m.preference = r.int32();\n                                            break;\n                                        case 3:\n                                            m.flags = r.uint32();\n                                            break;\n                                        default:\n                                            r.skipType(t & 7);\n                                            break;\n                                        }\n                                    }\n                                    return m;\n                                };\n    \n                                BorderRouterEntry.Flags = (function() {\n                                    var valuesById = {}, values = Object.create(valuesById);\n                                    values[valuesById[0] = \"NONE\"] = 0;\n                                    values[valuesById[1] = \"PREFERRED\"] = 1;\n                                    values[valuesById[2] = \"SLAAC\"] = 2;\n                                    values[valuesById[4] = \"DHCP\"] = 4;\n                                    values[valuesById[8] = \"CONFIGURE\"] = 8;\n                                    values[valuesById[16] = \"DEFAULT_ROUTE\"] = 16;\n                                    values[valuesById[32] = \"ON_MESH\"] = 32;\n                                    values[valuesById[64] = \"ND_DNS\"] = 64;\n                                    return values;\n                                })();\n    \n                                return BorderRouterEntry;\n                            })();\n    \n                            return BorderRouter;\n                        })();\n    \n                        NetworkData.Context = (function() {\n    \n                            function Context(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Context.prototype.cid = 0;\n                            Context.prototype.compress = false;\n                            Context.prototype.contextLength = 0;\n    \n                            Context.create = function create(properties) {\n                                return new Context(properties);\n                            };\n    \n                            Context.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.cid != null && m.hasOwnProperty(\"cid\"))\n                                    w.uint32(8).uint32(m.cid);\n                                if (m.compress != null && m.hasOwnProperty(\"compress\"))\n                                    w.uint32(16).bool(m.compress);\n                                if (m.contextLength != null && m.hasOwnProperty(\"contextLength\"))\n                                    w.uint32(24).uint32(m.contextLength);\n                                return w;\n                            };\n    \n                            Context.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.cid = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.compress = r.bool();\n                                        break;\n                                    case 3:\n                                        m.contextLength = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Context;\n                        })();\n    \n                        NetworkData.Prefix = (function() {\n    \n                            function Prefix(p) {\n                                this.context = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Prefix.prototype.domainId = 0;\n                            Prefix.prototype.prefixLength = 0;\n                            Prefix.prototype.prefix = $util.newBuffer([]);\n                            Prefix.prototype.context = $util.emptyArray;\n                            Prefix.prototype.hasRoute = null;\n                            Prefix.prototype.borderRouter = null;\n    \n                            Prefix.create = function create(properties) {\n                                return new Prefix(properties);\n                            };\n    \n                            Prefix.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.domainId != null && m.hasOwnProperty(\"domainId\"))\n                                    w.uint32(8).uint32(m.domainId);\n                                if (m.prefixLength != null && m.hasOwnProperty(\"prefixLength\"))\n                                    w.uint32(16).uint32(m.prefixLength);\n                                if (m.prefix != null && m.hasOwnProperty(\"prefix\"))\n                                    w.uint32(26).bytes(m.prefix);\n                                if (m.context != null && m.context.length) {\n                                    for (var i = 0; i < m.context.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.encode(m.context[i], w.uint32(34).fork()).ldelim();\n                                }\n                                if (m.hasRoute != null && m.hasOwnProperty(\"hasRoute\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.encode(m.hasRoute, w.uint32(42).fork()).ldelim();\n                                if (m.borderRouter != null && m.hasOwnProperty(\"borderRouter\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.encode(m.borderRouter, w.uint32(50).fork()).ldelim();\n                                return w;\n                            };\n    \n                            Prefix.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.domainId = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.prefixLength = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.prefix = r.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(m.context && m.context.length))\n                                            m.context = [];\n                                        m.context.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.decode(r, r.uint32()));\n                                        break;\n                                    case 5:\n                                        m.hasRoute = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.decode(r, r.uint32());\n                                        break;\n                                    case 6:\n                                        m.borderRouter = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.decode(r, r.uint32());\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Prefix;\n                        })();\n    \n                        NetworkData.Server = (function() {\n    \n                            function Server(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Server.prototype.rloc = 0;\n                            Server.prototype.data = $util.newBuffer([]);\n    \n                            Server.create = function create(properties) {\n                                return new Server(properties);\n                            };\n    \n                            Server.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.rloc != null && m.hasOwnProperty(\"rloc\"))\n                                    w.uint32(8).uint32(m.rloc);\n                                if (m.data != null && m.hasOwnProperty(\"data\"))\n                                    w.uint32(18).bytes(m.data);\n                                return w;\n                            };\n    \n                            Server.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.rloc = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.data = r.bytes();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Server;\n                        })();\n    \n                        NetworkData.Service = (function() {\n    \n                            function Service(p) {\n                                this.servers = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Service.prototype.sid = 0;\n                            Service.prototype.enterpriseNumber = 0;\n                            Service.prototype.data = $util.newBuffer([]);\n                            Service.prototype.servers = $util.emptyArray;\n    \n                            Service.create = function create(properties) {\n                                return new Service(properties);\n                            };\n    \n                            Service.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.sid != null && m.hasOwnProperty(\"sid\"))\n                                    w.uint32(8).uint32(m.sid);\n                                if (m.enterpriseNumber != null && m.hasOwnProperty(\"enterpriseNumber\"))\n                                    w.uint32(16).uint32(m.enterpriseNumber);\n                                if (m.data != null && m.hasOwnProperty(\"data\"))\n                                    w.uint32(26).bytes(m.data);\n                                if (m.servers != null && m.servers.length) {\n                                    for (var i = 0; i < m.servers.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.encode(m.servers[i], w.uint32(34).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            Service.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.sid = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.enterpriseNumber = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.data = r.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(m.servers && m.servers.length))\n                                            m.servers = [];\n                                        m.servers.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Service;\n                        })();\n    \n                        NetworkData.Data = (function() {\n    \n                            function Data(p) {\n                                this.prefixes = [];\n                                this.services = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Data.prototype.prefixes = $util.emptyArray;\n                            Data.prototype.services = $util.emptyArray;\n    \n                            Data.create = function create(properties) {\n                                return new Data(properties);\n                            };\n    \n                            Data.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.prefixes != null && m.prefixes.length) {\n                                    for (var i = 0; i < m.prefixes.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.encode(m.prefixes[i], w.uint32(10).fork()).ldelim();\n                                }\n                                if (m.services != null && m.services.length) {\n                                    for (var i = 0; i < m.services.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.encode(m.services[i], w.uint32(18).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            Data.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.prefixes && m.prefixes.length))\n                                            m.prefixes = [];\n                                        m.prefixes.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.decode(r, r.uint32()));\n                                        break;\n                                    case 2:\n                                        if (!(m.services && m.services.length))\n                                            m.services = [];\n                                        m.services.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Data;\n                        })();\n    \n                        return NetworkData;\n                    })();\n    \n                    DiagnosticInfo.MacCounters = (function() {\n    \n                        function MacCounters(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        MacCounters.prototype.ifInUnknownProtos = 0;\n                        MacCounters.prototype.ifInErrors = 0;\n                        MacCounters.prototype.ifOutErrors = 0;\n                        MacCounters.prototype.ifInUcastPkts = 0;\n                        MacCounters.prototype.ifInBroadcastPkts = 0;\n                        MacCounters.prototype.ifInDiscards = 0;\n                        MacCounters.prototype.ifOutUcastPkts = 0;\n                        MacCounters.prototype.ifOutBroadcastPkts = 0;\n                        MacCounters.prototype.ifOutDiscards = 0;\n    \n                        MacCounters.create = function create(properties) {\n                            return new MacCounters(properties);\n                        };\n    \n                        MacCounters.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ifInUnknownProtos != null && m.hasOwnProperty(\"ifInUnknownProtos\"))\n                                w.uint32(8).uint32(m.ifInUnknownProtos);\n                            if (m.ifInErrors != null && m.hasOwnProperty(\"ifInErrors\"))\n                                w.uint32(16).uint32(m.ifInErrors);\n                            if (m.ifOutErrors != null && m.hasOwnProperty(\"ifOutErrors\"))\n                                w.uint32(24).uint32(m.ifOutErrors);\n                            if (m.ifInUcastPkts != null && m.hasOwnProperty(\"ifInUcastPkts\"))\n                                w.uint32(32).uint32(m.ifInUcastPkts);\n                            if (m.ifInBroadcastPkts != null && m.hasOwnProperty(\"ifInBroadcastPkts\"))\n                                w.uint32(40).uint32(m.ifInBroadcastPkts);\n                            if (m.ifInDiscards != null && m.hasOwnProperty(\"ifInDiscards\"))\n                                w.uint32(48).uint32(m.ifInDiscards);\n                            if (m.ifOutUcastPkts != null && m.hasOwnProperty(\"ifOutUcastPkts\"))\n                                w.uint32(56).uint32(m.ifOutUcastPkts);\n                            if (m.ifOutBroadcastPkts != null && m.hasOwnProperty(\"ifOutBroadcastPkts\"))\n                                w.uint32(64).uint32(m.ifOutBroadcastPkts);\n                            if (m.ifOutDiscards != null && m.hasOwnProperty(\"ifOutDiscards\"))\n                                w.uint32(72).uint32(m.ifOutDiscards);\n                            return w;\n                        };\n    \n                        MacCounters.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ifInUnknownProtos = r.uint32();\n                                    break;\n                                case 2:\n                                    m.ifInErrors = r.uint32();\n                                    break;\n                                case 3:\n                                    m.ifOutErrors = r.uint32();\n                                    break;\n                                case 4:\n                                    m.ifInUcastPkts = r.uint32();\n                                    break;\n                                case 5:\n                                    m.ifInBroadcastPkts = r.uint32();\n                                    break;\n                                case 6:\n                                    m.ifInDiscards = r.uint32();\n                                    break;\n                                case 7:\n                                    m.ifOutUcastPkts = r.uint32();\n                                    break;\n                                case 8:\n                                    m.ifOutBroadcastPkts = r.uint32();\n                                    break;\n                                case 9:\n                                    m.ifOutDiscards = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return MacCounters;\n                    })();\n    \n                    DiagnosticInfo.ChildTable = (function() {\n    \n                        function ChildTable(p) {\n                            this.children = [];\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        ChildTable.prototype.children = $util.emptyArray;\n    \n                        ChildTable.create = function create(properties) {\n                            return new ChildTable(properties);\n                        };\n    \n                        ChildTable.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.children != null && m.children.length) {\n                                for (var i = 0; i < m.children.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.encode(m.children[i], w.uint32(10).fork()).ldelim();\n                            }\n                            return w;\n                        };\n    \n                        ChildTable.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    if (!(m.children && m.children.length))\n                                        m.children = [];\n                                    m.children.push($root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.decode(r, r.uint32()));\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        ChildTable.ChildEntry = (function() {\n    \n                            function ChildEntry(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            ChildEntry.prototype.timeout = 0;\n                            ChildEntry.prototype.childId = 0;\n                            ChildEntry.prototype.mode = 0;\n    \n                            ChildEntry.create = function create(properties) {\n                                return new ChildEntry(properties);\n                            };\n    \n                            ChildEntry.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                                    w.uint32(8).uint32(m.timeout);\n                                if (m.childId != null && m.hasOwnProperty(\"childId\"))\n                                    w.uint32(16).uint32(m.childId);\n                                if (m.mode != null && m.hasOwnProperty(\"mode\"))\n                                    w.uint32(24).uint32(m.mode);\n                                return w;\n                            };\n    \n                            ChildEntry.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.timeout = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.childId = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.mode = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return ChildEntry;\n                        })();\n    \n                        return ChildTable;\n                    })();\n    \n                    return DiagnosticInfo;\n                })();\n    \n                mesh.GetNetworkDiagnosticsRequest = (function() {\n    \n                    function GetNetworkDiagnosticsRequest(p) {\n                        this.diagnosticTypes = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkDiagnosticsRequest.prototype.flags = 0;\n                    GetNetworkDiagnosticsRequest.prototype.diagnosticTypes = $util.emptyArray;\n                    GetNetworkDiagnosticsRequest.prototype.timeout = 0;\n    \n                    GetNetworkDiagnosticsRequest.create = function create(properties) {\n                        return new GetNetworkDiagnosticsRequest(properties);\n                    };\n    \n                    GetNetworkDiagnosticsRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                            w.uint32(8).uint32(m.flags);\n                        if (m.diagnosticTypes != null && m.diagnosticTypes.length) {\n                            w.uint32(18).fork();\n                            for (var i = 0; i < m.diagnosticTypes.length; ++i)\n                                w.int32(m.diagnosticTypes[i]);\n                            w.ldelim();\n                        }\n                        if (m.timeout != null && m.hasOwnProperty(\"timeout\"))\n                            w.uint32(24).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    GetNetworkDiagnosticsRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.flags = r.uint32();\n                                break;\n                            case 2:\n                                if (!(m.diagnosticTypes && m.diagnosticTypes.length))\n                                    m.diagnosticTypes = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.diagnosticTypes.push(r.int32());\n                                } else\n                                    m.diagnosticTypes.push(r.int32());\n                                break;\n                            case 3:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetNetworkDiagnosticsRequest.Flags = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[1] = \"QUERY_CHILDREN\"] = 1;\n                        values[valuesById[2] = \"RESOLVE_DEVICE_ID\"] = 2;\n                        return values;\n                    })();\n    \n                    return GetNetworkDiagnosticsRequest;\n                })();\n    \n                mesh.GetNetworkDiagnosticsReply = (function() {\n    \n                    function GetNetworkDiagnosticsReply(p) {\n                        this.nodes = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkDiagnosticsReply.prototype.nodes = $util.emptyArray;\n    \n                    GetNetworkDiagnosticsReply.create = function create(properties) {\n                        return new GetNetworkDiagnosticsReply(properties);\n                    };\n    \n                    GetNetworkDiagnosticsReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.nodes != null && m.nodes.length) {\n                            for (var i = 0; i < m.nodes.length; ++i)\n                                $root.particle.ctrl.mesh.DiagnosticInfo.encode(m.nodes[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetNetworkDiagnosticsReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.nodes && m.nodes.length))\n                                    m.nodes = [];\n                                m.nodes.push($root.particle.ctrl.mesh.DiagnosticInfo.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkDiagnosticsReply;\n                })();\n    \n                return mesh;\n            })();\n    \n            ctrl.StorageType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_STORAGE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                return values;\n            })();\n    \n            ctrl.SectionType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECTION\"] = 0;\n                values[valuesById[1] = \"FIRMWARE\"] = 1;\n                values[valuesById[2] = \"OTA_BACKUP\"] = 2;\n                values[valuesById[3] = \"FACTORY_BACKUP\"] = 3;\n                values[valuesById[4] = \"CONFIG\"] = 4;\n                values[valuesById[5] = \"EEPROM\"] = 5;\n                return values;\n            })();\n    \n            ctrl.FirmwareModuleType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FIRMWARE_MODULE\"] = 0;\n                values[valuesById[1] = \"BOOTLOADER\"] = 1;\n                values[valuesById[2] = \"SYSTEM_PART\"] = 2;\n                values[valuesById[3] = \"USER_PART\"] = 3;\n                values[valuesById[4] = \"MONO_FIRMWARE\"] = 4;\n                values[valuesById[5] = \"NCP_FIRMWARE\"] = 5;\n                return values;\n            })();\n    \n            ctrl.FirmwareModuleValidityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_VALIDATION_ERRORS\"] = 0;\n                values[valuesById[1] = \"INTEGRITY_CHECK_FAILED\"] = 1;\n                values[valuesById[2] = \"DEPENDENCY_CHECK_FAILED\"] = 2;\n                return values;\n            })();\n    \n            ctrl.SectionFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SECTION_FLAGS\"] = 0;\n                values[valuesById[1] = \"CAN_READ\"] = 1;\n                values[valuesById[2] = \"CAN_WRITE\"] = 2;\n                values[valuesById[4] = \"CAN_CLEAR\"] = 4;\n                values[valuesById[8] = \"CAN_GET_SIZE\"] = 8;\n                values[valuesById[16] = \"NEED_CLEAR\"] = 16;\n                return values;\n            })();\n    \n            ctrl.FileFormat = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"BIN\"] = 0;\n                values[valuesById[1] = \"MINIZ\"] = 1;\n                return values;\n            })();\n    \n            ctrl.StartFirmwareUpdateRequest = (function() {\n    \n                function StartFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartFirmwareUpdateRequest.prototype.size = 0;\n                StartFirmwareUpdateRequest.prototype.format = 0;\n    \n                StartFirmwareUpdateRequest.create = function create(properties) {\n                    return new StartFirmwareUpdateRequest(properties);\n                };\n    \n                StartFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.size != null && m.hasOwnProperty(\"size\"))\n                        w.uint32(8).uint32(m.size);\n                    if (m.format != null && m.hasOwnProperty(\"format\"))\n                        w.uint32(16).int32(m.format);\n                    return w;\n                };\n    \n                StartFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.size = r.uint32();\n                            break;\n                        case 2:\n                            m.format = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartFirmwareUpdateRequest;\n            })();\n    \n            ctrl.StartFirmwareUpdateReply = (function() {\n    \n                function StartFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartFirmwareUpdateReply.prototype.chunkSize = 0;\n    \n                StartFirmwareUpdateReply.create = function create(properties) {\n                    return new StartFirmwareUpdateReply(properties);\n                };\n    \n                StartFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.chunkSize != null && m.hasOwnProperty(\"chunkSize\"))\n                        w.uint32(8).uint32(m.chunkSize);\n                    return w;\n                };\n    \n                StartFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.chunkSize = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartFirmwareUpdateReply;\n            })();\n    \n            ctrl.FinishFirmwareUpdateRequest = (function() {\n    \n                function FinishFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FinishFirmwareUpdateRequest.prototype.validateOnly = false;\n    \n                FinishFirmwareUpdateRequest.create = function create(properties) {\n                    return new FinishFirmwareUpdateRequest(properties);\n                };\n    \n                FinishFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.validateOnly != null && m.hasOwnProperty(\"validateOnly\"))\n                        w.uint32(8).bool(m.validateOnly);\n                    return w;\n                };\n    \n                FinishFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FinishFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.validateOnly = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FinishFirmwareUpdateRequest;\n            })();\n    \n            ctrl.FinishFirmwareUpdateReply = (function() {\n    \n                function FinishFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FinishFirmwareUpdateReply.create = function create(properties) {\n                    return new FinishFirmwareUpdateReply(properties);\n                };\n    \n                FinishFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                FinishFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FinishFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FinishFirmwareUpdateReply;\n            })();\n    \n            ctrl.CancelFirmwareUpdateRequest = (function() {\n    \n                function CancelFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CancelFirmwareUpdateRequest.create = function create(properties) {\n                    return new CancelFirmwareUpdateRequest(properties);\n                };\n    \n                CancelFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                CancelFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.CancelFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CancelFirmwareUpdateRequest;\n            })();\n    \n            ctrl.CancelFirmwareUpdateReply = (function() {\n    \n                function CancelFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CancelFirmwareUpdateReply.create = function create(properties) {\n                    return new CancelFirmwareUpdateReply(properties);\n                };\n    \n                CancelFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                CancelFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.CancelFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CancelFirmwareUpdateReply;\n            })();\n    \n            ctrl.FirmwareUpdateDataRequest = (function() {\n    \n                function FirmwareUpdateDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FirmwareUpdateDataRequest.prototype.data = $util.newBuffer([]);\n    \n                FirmwareUpdateDataRequest.create = function create(properties) {\n                    return new FirmwareUpdateDataRequest(properties);\n                };\n    \n                FirmwareUpdateDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && m.hasOwnProperty(\"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                FirmwareUpdateDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FirmwareUpdateDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FirmwareUpdateDataRequest;\n            })();\n    \n            ctrl.FirmwareUpdateDataReply = (function() {\n    \n                function FirmwareUpdateDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FirmwareUpdateDataReply.create = function create(properties) {\n                    return new FirmwareUpdateDataReply(properties);\n                };\n    \n                FirmwareUpdateDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                FirmwareUpdateDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FirmwareUpdateDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FirmwareUpdateDataReply;\n            })();\n    \n            ctrl.DescribeStorageRequest = (function() {\n    \n                function DescribeStorageRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescribeStorageRequest.create = function create(properties) {\n                    return new DescribeStorageRequest(properties);\n                };\n    \n                DescribeStorageRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                DescribeStorageRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return DescribeStorageRequest;\n            })();\n    \n            ctrl.DescribeStorageReply = (function() {\n    \n                function DescribeStorageReply(p) {\n                    this.storage = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescribeStorageReply.prototype.storage = $util.emptyArray;\n    \n                DescribeStorageReply.create = function create(properties) {\n                    return new DescribeStorageReply(properties);\n                };\n    \n                DescribeStorageReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.storage.length) {\n                        for (var i = 0; i < m.storage.length; ++i)\n                            $root.particle.ctrl.DescribeStorageReply.Storage.encode(m.storage[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                DescribeStorageReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.storage && m.storage.length))\n                                m.storage = [];\n                            m.storage.push($root.particle.ctrl.DescribeStorageReply.Storage.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                DescribeStorageReply.Section = (function() {\n    \n                    function Section(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Section.prototype.type = 0;\n                    Section.prototype.size = 0;\n                    Section.prototype.flags = 0;\n                    Section.prototype.firmwareModule = null;\n    \n                    Section.create = function create(properties) {\n                        return new Section(properties);\n                    };\n    \n                    Section.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && m.hasOwnProperty(\"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.size != null && m.hasOwnProperty(\"size\"))\n                            w.uint32(16).uint32(m.size);\n                        if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                            w.uint32(24).uint32(m.flags);\n                        if (m.firmwareModule != null && m.hasOwnProperty(\"firmwareModule\"))\n                            $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.encode(m.firmwareModule, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    Section.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Section();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.size = r.uint32();\n                                break;\n                            case 3:\n                                m.flags = r.uint32();\n                                break;\n                            case 4:\n                                m.firmwareModule = $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    Section.FirmwareModule = (function() {\n    \n                        function FirmwareModule(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        FirmwareModule.prototype.type = 0;\n                        FirmwareModule.prototype.index = 0;\n    \n                        FirmwareModule.create = function create(properties) {\n                            return new FirmwareModule(properties);\n                        };\n    \n                        FirmwareModule.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.type != null && m.hasOwnProperty(\"type\"))\n                                w.uint32(8).int32(m.type);\n                            if (m.index != null && m.hasOwnProperty(\"index\"))\n                                w.uint32(16).uint32(m.index);\n                            return w;\n                        };\n    \n                        FirmwareModule.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.type = r.int32();\n                                    break;\n                                case 2:\n                                    m.index = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return FirmwareModule;\n                    })();\n    \n                    return Section;\n                })();\n    \n                DescribeStorageReply.Storage = (function() {\n    \n                    function Storage(p) {\n                        this.sections = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Storage.prototype.type = 0;\n                    Storage.prototype.flags = 0;\n                    Storage.prototype.sections = $util.emptyArray;\n    \n                    Storage.create = function create(properties) {\n                        return new Storage(properties);\n                    };\n    \n                    Storage.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && m.hasOwnProperty(\"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.flags != null && m.hasOwnProperty(\"flags\"))\n                            w.uint32(16).uint32(m.flags);\n                        if (m.sections != null && m.sections.length) {\n                            for (var i = 0; i < m.sections.length; ++i)\n                                $root.particle.ctrl.DescribeStorageReply.Section.encode(m.sections[i], w.uint32(26).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    Storage.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Storage();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.flags = r.uint32();\n                                break;\n                            case 3:\n                                if (!(m.sections && m.sections.length))\n                                    m.sections = [];\n                                m.sections.push($root.particle.ctrl.DescribeStorageReply.Section.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Storage;\n                })();\n    \n                return DescribeStorageReply;\n            })();\n    \n            ctrl.ReadSectionDataRequest = (function() {\n    \n                function ReadSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ReadSectionDataRequest.prototype.storage = 0;\n                ReadSectionDataRequest.prototype.section = 0;\n                ReadSectionDataRequest.prototype.offset = 0;\n                ReadSectionDataRequest.prototype.size = 0;\n    \n                ReadSectionDataRequest.create = function create(properties) {\n                    return new ReadSectionDataRequest(properties);\n                };\n    \n                ReadSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.hasOwnProperty(\"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && m.hasOwnProperty(\"section\"))\n                        w.uint32(16).uint32(m.section);\n                    if (m.offset != null && m.hasOwnProperty(\"offset\"))\n                        w.uint32(24).uint32(m.offset);\n                    if (m.size != null && m.hasOwnProperty(\"size\"))\n                        w.uint32(32).uint32(m.size);\n                    return w;\n                };\n    \n                ReadSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ReadSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        case 3:\n                            m.offset = r.uint32();\n                            break;\n                        case 4:\n                            m.size = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ReadSectionDataRequest;\n            })();\n    \n            ctrl.ReadSectionDataReply = (function() {\n    \n                function ReadSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ReadSectionDataReply.prototype.data = $util.newBuffer([]);\n    \n                ReadSectionDataReply.create = function create(properties) {\n                    return new ReadSectionDataReply(properties);\n                };\n    \n                ReadSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && m.hasOwnProperty(\"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                ReadSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ReadSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ReadSectionDataReply;\n            })();\n    \n            ctrl.WriteSectionDataRequest = (function() {\n    \n                function WriteSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WriteSectionDataRequest.prototype.storage = 0;\n                WriteSectionDataRequest.prototype.section = 0;\n                WriteSectionDataRequest.prototype.offset = 0;\n                WriteSectionDataRequest.prototype.data = $util.newBuffer([]);\n    \n                WriteSectionDataRequest.create = function create(properties) {\n                    return new WriteSectionDataRequest(properties);\n                };\n    \n                WriteSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.hasOwnProperty(\"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && m.hasOwnProperty(\"section\"))\n                        w.uint32(16).uint32(m.section);\n                    if (m.offset != null && m.hasOwnProperty(\"offset\"))\n                        w.uint32(24).uint32(m.offset);\n                    if (m.data != null && m.hasOwnProperty(\"data\"))\n                        w.uint32(34).bytes(m.data);\n                    return w;\n                };\n    \n                WriteSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WriteSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        case 3:\n                            m.offset = r.uint32();\n                            break;\n                        case 4:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WriteSectionDataRequest;\n            })();\n    \n            ctrl.WriteSectionDataReply = (function() {\n    \n                function WriteSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WriteSectionDataReply.create = function create(properties) {\n                    return new WriteSectionDataReply(properties);\n                };\n    \n                WriteSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WriteSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WriteSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WriteSectionDataReply;\n            })();\n    \n            ctrl.ClearSectionDataRequest = (function() {\n    \n                function ClearSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ClearSectionDataRequest.prototype.storage = 0;\n                ClearSectionDataRequest.prototype.section = 0;\n    \n                ClearSectionDataRequest.create = function create(properties) {\n                    return new ClearSectionDataRequest(properties);\n                };\n    \n                ClearSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.hasOwnProperty(\"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && m.hasOwnProperty(\"section\"))\n                        w.uint32(16).uint32(m.section);\n                    return w;\n                };\n    \n                ClearSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ClearSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ClearSectionDataRequest;\n            })();\n    \n            ctrl.ClearSectionDataReply = (function() {\n    \n                function ClearSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ClearSectionDataReply.create = function create(properties) {\n                    return new ClearSectionDataReply(properties);\n                };\n    \n                ClearSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                ClearSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ClearSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ClearSectionDataReply;\n            })();\n    \n            ctrl.GetSectionDataSizeRequest = (function() {\n    \n                function GetSectionDataSizeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSectionDataSizeRequest.prototype.storage = 0;\n                GetSectionDataSizeRequest.prototype.section = 0;\n    \n                GetSectionDataSizeRequest.create = function create(properties) {\n                    return new GetSectionDataSizeRequest(properties);\n                };\n    \n                GetSectionDataSizeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.hasOwnProperty(\"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && m.hasOwnProperty(\"section\"))\n                        w.uint32(16).uint32(m.section);\n                    return w;\n                };\n    \n                GetSectionDataSizeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSectionDataSizeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSectionDataSizeRequest;\n            })();\n    \n            ctrl.GetSectionDataSizeReply = (function() {\n    \n                function GetSectionDataSizeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSectionDataSizeReply.prototype.size = 0;\n    \n                GetSectionDataSizeReply.create = function create(properties) {\n                    return new GetSectionDataSizeReply(properties);\n                };\n    \n                GetSectionDataSizeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.size != null && m.hasOwnProperty(\"size\"))\n                        w.uint32(8).uint32(m.size);\n                    return w;\n                };\n    \n                GetSectionDataSizeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSectionDataSizeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.size = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSectionDataSizeReply;\n            })();\n    \n            ctrl.GetModuleInfoRequest = (function() {\n    \n                function GetModuleInfoRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetModuleInfoRequest.create = function create(properties) {\n                    return new GetModuleInfoRequest(properties);\n                };\n    \n                GetModuleInfoRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetModuleInfoRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetModuleInfoRequest;\n            })();\n    \n            ctrl.GetModuleInfoReply = (function() {\n    \n                function GetModuleInfoReply(p) {\n                    this.modules = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetModuleInfoReply.prototype.modules = $util.emptyArray;\n    \n                GetModuleInfoReply.create = function create(properties) {\n                    return new GetModuleInfoReply(properties);\n                };\n    \n                GetModuleInfoReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.modules != null && m.modules.length) {\n                        for (var i = 0; i < m.modules.length; ++i)\n                            $root.particle.ctrl.GetModuleInfoReply.Module.encode(m.modules[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GetModuleInfoReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.modules && m.modules.length))\n                                m.modules = [];\n                            m.modules.push($root.particle.ctrl.GetModuleInfoReply.Module.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                GetModuleInfoReply.Dependency = (function() {\n    \n                    function Dependency(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Dependency.prototype.type = 0;\n                    Dependency.prototype.index = 0;\n                    Dependency.prototype.version = 0;\n    \n                    Dependency.create = function create(properties) {\n                        return new Dependency(properties);\n                    };\n    \n                    Dependency.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && m.hasOwnProperty(\"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.index != null && m.hasOwnProperty(\"index\"))\n                            w.uint32(16).uint32(m.index);\n                        if (m.version != null && m.hasOwnProperty(\"version\"))\n                            w.uint32(24).uint32(m.version);\n                        return w;\n                    };\n    \n                    Dependency.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply.Dependency();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.index = r.uint32();\n                                break;\n                            case 3:\n                                m.version = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Dependency;\n                })();\n    \n                GetModuleInfoReply.Module = (function() {\n    \n                    function Module(p) {\n                        this.dependencies = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Module.prototype.type = 0;\n                    Module.prototype.index = 0;\n                    Module.prototype.version = 0;\n                    Module.prototype.size = 0;\n                    Module.prototype.validity = 0;\n                    Module.prototype.dependencies = $util.emptyArray;\n    \n                    Module.create = function create(properties) {\n                        return new Module(properties);\n                    };\n    \n                    Module.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && m.hasOwnProperty(\"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.index != null && m.hasOwnProperty(\"index\"))\n                            w.uint32(16).uint32(m.index);\n                        if (m.version != null && m.hasOwnProperty(\"version\"))\n                            w.uint32(24).uint32(m.version);\n                        if (m.size != null && m.hasOwnProperty(\"size\"))\n                            w.uint32(32).uint32(m.size);\n                        if (m.validity != null && m.hasOwnProperty(\"validity\"))\n                            w.uint32(40).uint32(m.validity);\n                        if (m.dependencies != null && m.dependencies.length) {\n                            for (var i = 0; i < m.dependencies.length; ++i)\n                                $root.particle.ctrl.GetModuleInfoReply.Dependency.encode(m.dependencies[i], w.uint32(50).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    Module.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply.Module();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.index = r.uint32();\n                                break;\n                            case 3:\n                                m.version = r.uint32();\n                                break;\n                            case 4:\n                                m.size = r.uint32();\n                                break;\n                            case 5:\n                                m.validity = r.uint32();\n                                break;\n                            case 6:\n                                if (!(m.dependencies && m.dependencies.length))\n                                    m.dependencies = [];\n                                m.dependencies.push($root.particle.ctrl.GetModuleInfoReply.Dependency.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Module;\n                })();\n    \n                return GetModuleInfoReply;\n            })();\n    \n            return ctrl;\n        })();\n    \n        particle.firmware = (function() {\n    \n            var firmware = {};\n    \n            firmware.WifiConfig = (function() {\n    \n                function WifiConfig(p) {\n                    this.networks = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WifiConfig.prototype.networks = $util.emptyArray;\n    \n                WifiConfig.create = function create(properties) {\n                    return new WifiConfig(properties);\n                };\n    \n                WifiConfig.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.networks != null && m.networks.length) {\n                        for (var i = 0; i < m.networks.length; ++i)\n                            $root.particle.firmware.WifiConfig.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                WifiConfig.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.WifiConfig();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.networks && m.networks.length))\n                                m.networks = [];\n                            m.networks.push($root.particle.firmware.WifiConfig.Network.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                WifiConfig.Network = (function() {\n    \n                    function Network(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Network.prototype.ssid = \"\";\n                    Network.prototype.bssid = $util.newBuffer([]);\n                    Network.prototype.security = 0;\n                    Network.prototype.credentials = null;\n    \n                    Network.create = function create(properties) {\n                        return new Network(properties);\n                    };\n    \n                    Network.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && m.hasOwnProperty(\"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && m.hasOwnProperty(\"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.security != null && m.hasOwnProperty(\"security\"))\n                            w.uint32(24).int32(m.security);\n                        if (m.credentials != null && m.hasOwnProperty(\"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(m.credentials, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    Network.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.WifiConfig.Network();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.security = r.int32();\n                                break;\n                            case 4:\n                                m.credentials = $root.particle.ctrl.wifi.Credentials.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Network;\n                })();\n    \n                return WifiConfig;\n            })();\n    \n            firmware.CellularConfig = (function() {\n    \n                function CellularConfig(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CellularConfig.prototype.internalSim = null;\n                CellularConfig.prototype.externalSim = null;\n                CellularConfig.prototype.activeSim = 0;\n    \n                CellularConfig.create = function create(properties) {\n                    return new CellularConfig(properties);\n                };\n    \n                CellularConfig.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.internalSim != null && m.hasOwnProperty(\"internalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(m.internalSim, w.uint32(10).fork()).ldelim();\n                    if (m.externalSim != null && m.hasOwnProperty(\"externalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(m.externalSim, w.uint32(18).fork()).ldelim();\n                    if (m.activeSim != null && m.hasOwnProperty(\"activeSim\"))\n                        w.uint32(24).int32(m.activeSim);\n                    return w;\n                };\n    \n                CellularConfig.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.CellularConfig();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.internalSim = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.externalSim = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.activeSim = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CellularConfig;\n            })();\n    \n            return firmware;\n        })();\n    \n        return particle;\n    })();\n    \n    $root.google = (function() {\n    \n        var google = {};\n    \n        google.protobuf = (function() {\n    \n            var protobuf = {};\n    \n            protobuf.FileDescriptorSet = (function() {\n    \n                function FileDescriptorSet(p) {\n                    this.file = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileDescriptorSet.prototype.file = $util.emptyArray;\n    \n                FileDescriptorSet.create = function create(properties) {\n                    return new FileDescriptorSet(properties);\n                };\n    \n                FileDescriptorSet.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.file != null && m.file.length) {\n                        for (var i = 0; i < m.file.length; ++i)\n                            $root.google.protobuf.FileDescriptorProto.encode(m.file[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                FileDescriptorSet.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileDescriptorSet();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.file && m.file.length))\n                                m.file = [];\n                            m.file.push($root.google.protobuf.FileDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FileDescriptorSet;\n            })();\n    \n            protobuf.FileDescriptorProto = (function() {\n    \n                function FileDescriptorProto(p) {\n                    this.dependency = [];\n                    this.publicDependency = [];\n                    this.weakDependency = [];\n                    this.messageType = [];\n                    this.enumType = [];\n                    this.service = [];\n                    this.extension = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileDescriptorProto.prototype.name = \"\";\n                FileDescriptorProto.prototype[\"package\"] = \"\";\n                FileDescriptorProto.prototype.dependency = $util.emptyArray;\n                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n                FileDescriptorProto.prototype.messageType = $util.emptyArray;\n                FileDescriptorProto.prototype.enumType = $util.emptyArray;\n                FileDescriptorProto.prototype.service = $util.emptyArray;\n                FileDescriptorProto.prototype.extension = $util.emptyArray;\n                FileDescriptorProto.prototype.options = null;\n                FileDescriptorProto.prototype.sourceCodeInfo = null;\n                FileDescriptorProto.prototype.syntax = \"\";\n    \n                FileDescriptorProto.create = function create(properties) {\n                    return new FileDescriptorProto(properties);\n                };\n    \n                FileDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m[\"package\"] != null && m.hasOwnProperty(\"package\"))\n                        w.uint32(18).string(m[\"package\"]);\n                    if (m.dependency != null && m.dependency.length) {\n                        for (var i = 0; i < m.dependency.length; ++i)\n                            w.uint32(26).string(m.dependency[i]);\n                    }\n                    if (m.messageType != null && m.messageType.length) {\n                        for (var i = 0; i < m.messageType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(m.messageType[i], w.uint32(34).fork()).ldelim();\n                    }\n                    if (m.enumType != null && m.enumType.length) {\n                        for (var i = 0; i < m.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(m.enumType[i], w.uint32(42).fork()).ldelim();\n                    }\n                    if (m.service != null && m.service.length) {\n                        for (var i = 0; i < m.service.length; ++i)\n                            $root.google.protobuf.ServiceDescriptorProto.encode(m.service[i], w.uint32(50).fork()).ldelim();\n                    }\n                    if (m.extension != null && m.extension.length) {\n                        for (var i = 0; i < m.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.extension[i], w.uint32(58).fork()).ldelim();\n                    }\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.FileOptions.encode(m.options, w.uint32(66).fork()).ldelim();\n                    if (m.sourceCodeInfo != null && m.hasOwnProperty(\"sourceCodeInfo\"))\n                        $root.google.protobuf.SourceCodeInfo.encode(m.sourceCodeInfo, w.uint32(74).fork()).ldelim();\n                    if (m.publicDependency != null && m.publicDependency.length) {\n                        for (var i = 0; i < m.publicDependency.length; ++i)\n                            w.uint32(80).int32(m.publicDependency[i]);\n                    }\n                    if (m.weakDependency != null && m.weakDependency.length) {\n                        for (var i = 0; i < m.weakDependency.length; ++i)\n                            w.uint32(88).int32(m.weakDependency[i]);\n                    }\n                    if (m.syntax != null && m.hasOwnProperty(\"syntax\"))\n                        w.uint32(98).string(m.syntax);\n                    return w;\n                };\n    \n                FileDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m[\"package\"] = r.string();\n                            break;\n                        case 3:\n                            if (!(m.dependency && m.dependency.length))\n                                m.dependency = [];\n                            m.dependency.push(r.string());\n                            break;\n                        case 10:\n                            if (!(m.publicDependency && m.publicDependency.length))\n                                m.publicDependency = [];\n                            if ((t & 7) === 2) {\n                                var c2 = r.uint32() + r.pos;\n                                while (r.pos < c2)\n                                    m.publicDependency.push(r.int32());\n                            } else\n                                m.publicDependency.push(r.int32());\n                            break;\n                        case 11:\n                            if (!(m.weakDependency && m.weakDependency.length))\n                                m.weakDependency = [];\n                            if ((t & 7) === 2) {\n                                var c2 = r.uint32() + r.pos;\n                                while (r.pos < c2)\n                                    m.weakDependency.push(r.int32());\n                            } else\n                                m.weakDependency.push(r.int32());\n                            break;\n                        case 4:\n                            if (!(m.messageType && m.messageType.length))\n                                m.messageType = [];\n                            m.messageType.push($root.google.protobuf.DescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 5:\n                            if (!(m.enumType && m.enumType.length))\n                                m.enumType = [];\n                            m.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 6:\n                            if (!(m.service && m.service.length))\n                                m.service = [];\n                            m.service.push($root.google.protobuf.ServiceDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 7:\n                            if (!(m.extension && m.extension.length))\n                                m.extension = [];\n                            m.extension.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 8:\n                            m.options = $root.google.protobuf.FileOptions.decode(r, r.uint32());\n                            break;\n                        case 9:\n                            m.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(r, r.uint32());\n                            break;\n                        case 12:\n                            m.syntax = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FileDescriptorProto;\n            })();\n    \n            protobuf.DescriptorProto = (function() {\n    \n                function DescriptorProto(p) {\n                    this.field = [];\n                    this.extension = [];\n                    this.nestedType = [];\n                    this.enumType = [];\n                    this.extensionRange = [];\n                    this.oneofDecl = [];\n                    this.reservedRange = [];\n                    this.reservedName = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescriptorProto.prototype.name = \"\";\n                DescriptorProto.prototype.field = $util.emptyArray;\n                DescriptorProto.prototype.extension = $util.emptyArray;\n                DescriptorProto.prototype.nestedType = $util.emptyArray;\n                DescriptorProto.prototype.enumType = $util.emptyArray;\n                DescriptorProto.prototype.extensionRange = $util.emptyArray;\n                DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n                DescriptorProto.prototype.options = null;\n                DescriptorProto.prototype.reservedRange = $util.emptyArray;\n                DescriptorProto.prototype.reservedName = $util.emptyArray;\n    \n                DescriptorProto.create = function create(properties) {\n                    return new DescriptorProto(properties);\n                };\n    \n                DescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.field != null && m.field.length) {\n                        for (var i = 0; i < m.field.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.field[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.nestedType != null && m.nestedType.length) {\n                        for (var i = 0; i < m.nestedType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(m.nestedType[i], w.uint32(26).fork()).ldelim();\n                    }\n                    if (m.enumType != null && m.enumType.length) {\n                        for (var i = 0; i < m.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(m.enumType[i], w.uint32(34).fork()).ldelim();\n                    }\n                    if (m.extensionRange != null && m.extensionRange.length) {\n                        for (var i = 0; i < m.extensionRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(m.extensionRange[i], w.uint32(42).fork()).ldelim();\n                    }\n                    if (m.extension != null && m.extension.length) {\n                        for (var i = 0; i < m.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.extension[i], w.uint32(50).fork()).ldelim();\n                    }\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.MessageOptions.encode(m.options, w.uint32(58).fork()).ldelim();\n                    if (m.oneofDecl != null && m.oneofDecl.length) {\n                        for (var i = 0; i < m.oneofDecl.length; ++i)\n                            $root.google.protobuf.OneofDescriptorProto.encode(m.oneofDecl[i], w.uint32(66).fork()).ldelim();\n                    }\n                    if (m.reservedRange != null && m.reservedRange.length) {\n                        for (var i = 0; i < m.reservedRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(m.reservedRange[i], w.uint32(74).fork()).ldelim();\n                    }\n                    if (m.reservedName != null && m.reservedName.length) {\n                        for (var i = 0; i < m.reservedName.length; ++i)\n                            w.uint32(82).string(m.reservedName[i]);\n                    }\n                    return w;\n                };\n    \n                DescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.field && m.field.length))\n                                m.field = [];\n                            m.field.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 6:\n                            if (!(m.extension && m.extension.length))\n                                m.extension = [];\n                            m.extension.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            if (!(m.nestedType && m.nestedType.length))\n                                m.nestedType = [];\n                            m.nestedType.push($root.google.protobuf.DescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 4:\n                            if (!(m.enumType && m.enumType.length))\n                                m.enumType = [];\n                            m.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 5:\n                            if (!(m.extensionRange && m.extensionRange.length))\n                                m.extensionRange = [];\n                            m.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(r, r.uint32()));\n                            break;\n                        case 8:\n                            if (!(m.oneofDecl && m.oneofDecl.length))\n                                m.oneofDecl = [];\n                            m.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 7:\n                            m.options = $root.google.protobuf.MessageOptions.decode(r, r.uint32());\n                            break;\n                        case 9:\n                            if (!(m.reservedRange && m.reservedRange.length))\n                                m.reservedRange = [];\n                            m.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(r, r.uint32()));\n                            break;\n                        case 10:\n                            if (!(m.reservedName && m.reservedName.length))\n                                m.reservedName = [];\n                            m.reservedName.push(r.string());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                DescriptorProto.ExtensionRange = (function() {\n    \n                    function ExtensionRange(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ExtensionRange.prototype.start = 0;\n                    ExtensionRange.prototype.end = 0;\n    \n                    ExtensionRange.create = function create(properties) {\n                        return new ExtensionRange(properties);\n                    };\n    \n                    ExtensionRange.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.start != null && m.hasOwnProperty(\"start\"))\n                            w.uint32(8).int32(m.start);\n                        if (m.end != null && m.hasOwnProperty(\"end\"))\n                            w.uint32(16).int32(m.end);\n                        return w;\n                    };\n    \n                    ExtensionRange.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.start = r.int32();\n                                break;\n                            case 2:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ExtensionRange;\n                })();\n    \n                DescriptorProto.ReservedRange = (function() {\n    \n                    function ReservedRange(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ReservedRange.prototype.start = 0;\n                    ReservedRange.prototype.end = 0;\n    \n                    ReservedRange.create = function create(properties) {\n                        return new ReservedRange(properties);\n                    };\n    \n                    ReservedRange.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.start != null && m.hasOwnProperty(\"start\"))\n                            w.uint32(8).int32(m.start);\n                        if (m.end != null && m.hasOwnProperty(\"end\"))\n                            w.uint32(16).int32(m.end);\n                        return w;\n                    };\n    \n                    ReservedRange.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto.ReservedRange();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.start = r.int32();\n                                break;\n                            case 2:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ReservedRange;\n                })();\n    \n                return DescriptorProto;\n            })();\n    \n            protobuf.FieldDescriptorProto = (function() {\n    \n                function FieldDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FieldDescriptorProto.prototype.name = \"\";\n                FieldDescriptorProto.prototype.number = 0;\n                FieldDescriptorProto.prototype.label = 1;\n                FieldDescriptorProto.prototype.type = 1;\n                FieldDescriptorProto.prototype.typeName = \"\";\n                FieldDescriptorProto.prototype.extendee = \"\";\n                FieldDescriptorProto.prototype.defaultValue = \"\";\n                FieldDescriptorProto.prototype.oneofIndex = 0;\n                FieldDescriptorProto.prototype.jsonName = \"\";\n                FieldDescriptorProto.prototype.options = null;\n    \n                FieldDescriptorProto.create = function create(properties) {\n                    return new FieldDescriptorProto(properties);\n                };\n    \n                FieldDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.extendee != null && m.hasOwnProperty(\"extendee\"))\n                        w.uint32(18).string(m.extendee);\n                    if (m.number != null && m.hasOwnProperty(\"number\"))\n                        w.uint32(24).int32(m.number);\n                    if (m.label != null && m.hasOwnProperty(\"label\"))\n                        w.uint32(32).int32(m.label);\n                    if (m.type != null && m.hasOwnProperty(\"type\"))\n                        w.uint32(40).int32(m.type);\n                    if (m.typeName != null && m.hasOwnProperty(\"typeName\"))\n                        w.uint32(50).string(m.typeName);\n                    if (m.defaultValue != null && m.hasOwnProperty(\"defaultValue\"))\n                        w.uint32(58).string(m.defaultValue);\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.FieldOptions.encode(m.options, w.uint32(66).fork()).ldelim();\n                    if (m.oneofIndex != null && m.hasOwnProperty(\"oneofIndex\"))\n                        w.uint32(72).int32(m.oneofIndex);\n                    if (m.jsonName != null && m.hasOwnProperty(\"jsonName\"))\n                        w.uint32(82).string(m.jsonName);\n                    return w;\n                };\n    \n                FieldDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FieldDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.number = r.int32();\n                            break;\n                        case 4:\n                            m.label = r.int32();\n                            break;\n                        case 5:\n                            m.type = r.int32();\n                            break;\n                        case 6:\n                            m.typeName = r.string();\n                            break;\n                        case 2:\n                            m.extendee = r.string();\n                            break;\n                        case 7:\n                            m.defaultValue = r.string();\n                            break;\n                        case 9:\n                            m.oneofIndex = r.int32();\n                            break;\n                        case 10:\n                            m.jsonName = r.string();\n                            break;\n                        case 8:\n                            m.options = $root.google.protobuf.FieldOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FieldDescriptorProto.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n                    values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n                    values[valuesById[3] = \"TYPE_INT64\"] = 3;\n                    values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n                    values[valuesById[5] = \"TYPE_INT32\"] = 5;\n                    values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n                    values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n                    values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n                    values[valuesById[9] = \"TYPE_STRING\"] = 9;\n                    values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n                    values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n                    values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n                    values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n                    values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n                    values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n                    values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n                    values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n                    values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n                    return values;\n                })();\n    \n                FieldDescriptorProto.Label = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n                    values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n                    values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n                    return values;\n                })();\n    \n                return FieldDescriptorProto;\n            })();\n    \n            protobuf.OneofDescriptorProto = (function() {\n    \n                function OneofDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                OneofDescriptorProto.prototype.name = \"\";\n                OneofDescriptorProto.prototype.options = null;\n    \n                OneofDescriptorProto.create = function create(properties) {\n                    return new OneofDescriptorProto(properties);\n                };\n    \n                OneofDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.OneofOptions.encode(m.options, w.uint32(18).fork()).ldelim();\n                    return w;\n                };\n    \n                OneofDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.OneofDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.options = $root.google.protobuf.OneofOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return OneofDescriptorProto;\n            })();\n    \n            protobuf.EnumDescriptorProto = (function() {\n    \n                function EnumDescriptorProto(p) {\n                    this.value = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumDescriptorProto.prototype.name = \"\";\n                EnumDescriptorProto.prototype.value = $util.emptyArray;\n                EnumDescriptorProto.prototype.options = null;\n    \n                EnumDescriptorProto.create = function create(properties) {\n                    return new EnumDescriptorProto(properties);\n                };\n    \n                EnumDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.value != null && m.value.length) {\n                        for (var i = 0; i < m.value.length; ++i)\n                            $root.google.protobuf.EnumValueDescriptorProto.encode(m.value[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.EnumOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.value && m.value.length))\n                                m.value = [];\n                            m.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.EnumOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumDescriptorProto;\n            })();\n    \n            protobuf.EnumValueDescriptorProto = (function() {\n    \n                function EnumValueDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumValueDescriptorProto.prototype.name = \"\";\n                EnumValueDescriptorProto.prototype.number = 0;\n                EnumValueDescriptorProto.prototype.options = null;\n    \n                EnumValueDescriptorProto.create = function create(properties) {\n                    return new EnumValueDescriptorProto(properties);\n                };\n    \n                EnumValueDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.number != null && m.hasOwnProperty(\"number\"))\n                        w.uint32(16).int32(m.number);\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.EnumValueOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumValueDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumValueDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.number = r.int32();\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.EnumValueOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumValueDescriptorProto;\n            })();\n    \n            protobuf.ServiceDescriptorProto = (function() {\n    \n                function ServiceDescriptorProto(p) {\n                    this.method = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ServiceDescriptorProto.prototype.name = \"\";\n                ServiceDescriptorProto.prototype.method = $util.emptyArray;\n                ServiceDescriptorProto.prototype.options = null;\n    \n                ServiceDescriptorProto.create = function create(properties) {\n                    return new ServiceDescriptorProto(properties);\n                };\n    \n                ServiceDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.method != null && m.method.length) {\n                        for (var i = 0; i < m.method.length; ++i)\n                            $root.google.protobuf.MethodDescriptorProto.encode(m.method[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.ServiceOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                ServiceDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.ServiceDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.method && m.method.length))\n                                m.method = [];\n                            m.method.push($root.google.protobuf.MethodDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.ServiceOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ServiceDescriptorProto;\n            })();\n    \n            protobuf.MethodDescriptorProto = (function() {\n    \n                function MethodDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MethodDescriptorProto.prototype.name = \"\";\n                MethodDescriptorProto.prototype.inputType = \"\";\n                MethodDescriptorProto.prototype.outputType = \"\";\n                MethodDescriptorProto.prototype.options = null;\n                MethodDescriptorProto.prototype.clientStreaming = false;\n                MethodDescriptorProto.prototype.serverStreaming = false;\n    \n                MethodDescriptorProto.create = function create(properties) {\n                    return new MethodDescriptorProto(properties);\n                };\n    \n                MethodDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.hasOwnProperty(\"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.inputType != null && m.hasOwnProperty(\"inputType\"))\n                        w.uint32(18).string(m.inputType);\n                    if (m.outputType != null && m.hasOwnProperty(\"outputType\"))\n                        w.uint32(26).string(m.outputType);\n                    if (m.options != null && m.hasOwnProperty(\"options\"))\n                        $root.google.protobuf.MethodOptions.encode(m.options, w.uint32(34).fork()).ldelim();\n                    if (m.clientStreaming != null && m.hasOwnProperty(\"clientStreaming\"))\n                        w.uint32(40).bool(m.clientStreaming);\n                    if (m.serverStreaming != null && m.hasOwnProperty(\"serverStreaming\"))\n                        w.uint32(48).bool(m.serverStreaming);\n                    return w;\n                };\n    \n                MethodDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MethodDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.inputType = r.string();\n                            break;\n                        case 3:\n                            m.outputType = r.string();\n                            break;\n                        case 4:\n                            m.options = $root.google.protobuf.MethodOptions.decode(r, r.uint32());\n                            break;\n                        case 5:\n                            m.clientStreaming = r.bool();\n                            break;\n                        case 6:\n                            m.serverStreaming = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MethodDescriptorProto;\n            })();\n    \n            protobuf.FileOptions = (function() {\n    \n                function FileOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileOptions.prototype.javaPackage = \"\";\n                FileOptions.prototype.javaOuterClassname = \"\";\n                FileOptions.prototype.javaMultipleFiles = false;\n                FileOptions.prototype.javaGenerateEqualsAndHash = false;\n                FileOptions.prototype.javaStringCheckUtf8 = false;\n                FileOptions.prototype.optimizeFor = 1;\n                FileOptions.prototype.goPackage = \"\";\n                FileOptions.prototype.ccGenericServices = false;\n                FileOptions.prototype.javaGenericServices = false;\n                FileOptions.prototype.pyGenericServices = false;\n                FileOptions.prototype.deprecated = false;\n                FileOptions.prototype.ccEnableArenas = false;\n                FileOptions.prototype.objcClassPrefix = \"\";\n                FileOptions.prototype.csharpNamespace = \"\";\n                FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n                FileOptions.prototype[\".nanopbFileopt\"] = null;\n    \n                FileOptions.create = function create(properties) {\n                    return new FileOptions(properties);\n                };\n    \n                FileOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.javaPackage != null && m.hasOwnProperty(\"javaPackage\"))\n                        w.uint32(10).string(m.javaPackage);\n                    if (m.javaOuterClassname != null && m.hasOwnProperty(\"javaOuterClassname\"))\n                        w.uint32(66).string(m.javaOuterClassname);\n                    if (m.optimizeFor != null && m.hasOwnProperty(\"optimizeFor\"))\n                        w.uint32(72).int32(m.optimizeFor);\n                    if (m.javaMultipleFiles != null && m.hasOwnProperty(\"javaMultipleFiles\"))\n                        w.uint32(80).bool(m.javaMultipleFiles);\n                    if (m.goPackage != null && m.hasOwnProperty(\"goPackage\"))\n                        w.uint32(90).string(m.goPackage);\n                    if (m.ccGenericServices != null && m.hasOwnProperty(\"ccGenericServices\"))\n                        w.uint32(128).bool(m.ccGenericServices);\n                    if (m.javaGenericServices != null && m.hasOwnProperty(\"javaGenericServices\"))\n                        w.uint32(136).bool(m.javaGenericServices);\n                    if (m.pyGenericServices != null && m.hasOwnProperty(\"pyGenericServices\"))\n                        w.uint32(144).bool(m.pyGenericServices);\n                    if (m.javaGenerateEqualsAndHash != null && m.hasOwnProperty(\"javaGenerateEqualsAndHash\"))\n                        w.uint32(160).bool(m.javaGenerateEqualsAndHash);\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(184).bool(m.deprecated);\n                    if (m.javaStringCheckUtf8 != null && m.hasOwnProperty(\"javaStringCheckUtf8\"))\n                        w.uint32(216).bool(m.javaStringCheckUtf8);\n                    if (m.ccEnableArenas != null && m.hasOwnProperty(\"ccEnableArenas\"))\n                        w.uint32(248).bool(m.ccEnableArenas);\n                    if (m.objcClassPrefix != null && m.hasOwnProperty(\"objcClassPrefix\"))\n                        w.uint32(290).string(m.objcClassPrefix);\n                    if (m.csharpNamespace != null && m.hasOwnProperty(\"csharpNamespace\"))\n                        w.uint32(298).string(m.csharpNamespace);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbFileopt\"] != null && m.hasOwnProperty(\".nanopbFileopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbFileopt\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                FileOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.javaPackage = r.string();\n                            break;\n                        case 8:\n                            m.javaOuterClassname = r.string();\n                            break;\n                        case 10:\n                            m.javaMultipleFiles = r.bool();\n                            break;\n                        case 20:\n                            m.javaGenerateEqualsAndHash = r.bool();\n                            break;\n                        case 27:\n                            m.javaStringCheckUtf8 = r.bool();\n                            break;\n                        case 9:\n                            m.optimizeFor = r.int32();\n                            break;\n                        case 11:\n                            m.goPackage = r.string();\n                            break;\n                        case 16:\n                            m.ccGenericServices = r.bool();\n                            break;\n                        case 17:\n                            m.javaGenericServices = r.bool();\n                            break;\n                        case 18:\n                            m.pyGenericServices = r.bool();\n                            break;\n                        case 23:\n                            m.deprecated = r.bool();\n                            break;\n                        case 31:\n                            m.ccEnableArenas = r.bool();\n                            break;\n                        case 36:\n                            m.objcClassPrefix = r.string();\n                            break;\n                        case 37:\n                            m.csharpNamespace = r.string();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopbFileopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FileOptions.OptimizeMode = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"SPEED\"] = 1;\n                    values[valuesById[2] = \"CODE_SIZE\"] = 2;\n                    values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n                    return values;\n                })();\n    \n                return FileOptions;\n            })();\n    \n            protobuf.MessageOptions = (function() {\n    \n                function MessageOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MessageOptions.prototype.messageSetWireFormat = false;\n                MessageOptions.prototype.noStandardDescriptorAccessor = false;\n                MessageOptions.prototype.deprecated = false;\n                MessageOptions.prototype.mapEntry = false;\n                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n                MessageOptions.prototype[\".typeId\"] = 0;\n                MessageOptions.prototype[\".nanopbMsgopt\"] = null;\n    \n                MessageOptions.create = function create(properties) {\n                    return new MessageOptions(properties);\n                };\n    \n                MessageOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.messageSetWireFormat != null && m.hasOwnProperty(\"messageSetWireFormat\"))\n                        w.uint32(8).bool(m.messageSetWireFormat);\n                    if (m.noStandardDescriptorAccessor != null && m.hasOwnProperty(\"noStandardDescriptorAccessor\"))\n                        w.uint32(16).bool(m.noStandardDescriptorAccessor);\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.mapEntry != null && m.hasOwnProperty(\"mapEntry\"))\n                        w.uint32(56).bool(m.mapEntry);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbMsgopt\"] != null && m.hasOwnProperty(\".nanopbMsgopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbMsgopt\"], w.uint32(8082).fork()).ldelim();\n                    if (m[\".typeId\"] != null && m.hasOwnProperty(\".typeId\"))\n                        w.uint32(400008).int32(m[\".typeId\"]);\n                    return w;\n                };\n    \n                MessageOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MessageOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.messageSetWireFormat = r.bool();\n                            break;\n                        case 2:\n                            m.noStandardDescriptorAccessor = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 7:\n                            m.mapEntry = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 50001:\n                            m[\".typeId\"] = r.int32();\n                            break;\n                        case 1010:\n                            m[\".nanopbMsgopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MessageOptions;\n            })();\n    \n            protobuf.FieldOptions = (function() {\n    \n                function FieldOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FieldOptions.prototype.ctype = 0;\n                FieldOptions.prototype.packed = false;\n                FieldOptions.prototype.jstype = 0;\n                FieldOptions.prototype.lazy = false;\n                FieldOptions.prototype.deprecated = false;\n                FieldOptions.prototype.weak = false;\n                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n                FieldOptions.prototype[\".nanopb\"] = null;\n    \n                FieldOptions.create = function create(properties) {\n                    return new FieldOptions(properties);\n                };\n    \n                FieldOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ctype != null && m.hasOwnProperty(\"ctype\"))\n                        w.uint32(8).int32(m.ctype);\n                    if (m.packed != null && m.hasOwnProperty(\"packed\"))\n                        w.uint32(16).bool(m.packed);\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.lazy != null && m.hasOwnProperty(\"lazy\"))\n                        w.uint32(40).bool(m.lazy);\n                    if (m.jstype != null && m.hasOwnProperty(\"jstype\"))\n                        w.uint32(48).int32(m.jstype);\n                    if (m.weak != null && m.hasOwnProperty(\"weak\"))\n                        w.uint32(80).bool(m.weak);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopb\"] != null && m.hasOwnProperty(\".nanopb\"))\n                        $root.NanoPBOptions.encode(m[\".nanopb\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                FieldOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FieldOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ctype = r.int32();\n                            break;\n                        case 2:\n                            m.packed = r.bool();\n                            break;\n                        case 6:\n                            m.jstype = r.int32();\n                            break;\n                        case 5:\n                            m.lazy = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 10:\n                            m.weak = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopb\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FieldOptions.CType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"STRING\"] = 0;\n                    values[valuesById[1] = \"CORD\"] = 1;\n                    values[valuesById[2] = \"STRING_PIECE\"] = 2;\n                    return values;\n                })();\n    \n                FieldOptions.JSType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"JS_NORMAL\"] = 0;\n                    values[valuesById[1] = \"JS_STRING\"] = 1;\n                    values[valuesById[2] = \"JS_NUMBER\"] = 2;\n                    return values;\n                })();\n    \n                return FieldOptions;\n            })();\n    \n            protobuf.OneofOptions = (function() {\n    \n                function OneofOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                OneofOptions.create = function create(properties) {\n                    return new OneofOptions(properties);\n                };\n    \n                OneofOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                OneofOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.OneofOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return OneofOptions;\n            })();\n    \n            protobuf.EnumOptions = (function() {\n    \n                function EnumOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumOptions.prototype.allowAlias = false;\n                EnumOptions.prototype.deprecated = false;\n                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n                EnumOptions.prototype[\".nanopbEnumopt\"] = null;\n    \n                EnumOptions.create = function create(properties) {\n                    return new EnumOptions(properties);\n                };\n    \n                EnumOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.allowAlias != null && m.hasOwnProperty(\"allowAlias\"))\n                        w.uint32(16).bool(m.allowAlias);\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbEnumopt\"] != null && m.hasOwnProperty(\".nanopbEnumopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbEnumopt\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 2:\n                            m.allowAlias = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopbEnumopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumOptions;\n            })();\n    \n            protobuf.EnumValueOptions = (function() {\n    \n                function EnumValueOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumValueOptions.prototype.deprecated = false;\n                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n                EnumValueOptions.prototype[\".intValue\"] = 0;\n    \n                EnumValueOptions.create = function create(properties) {\n                    return new EnumValueOptions(properties);\n                };\n    \n                EnumValueOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(8).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".intValue\"] != null && m.hasOwnProperty(\".intValue\"))\n                        w.uint32(400016).int32(m[\".intValue\"]);\n                    return w;\n                };\n    \n                EnumValueOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumValueOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 50002:\n                            m[\".intValue\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumValueOptions;\n            })();\n    \n            protobuf.ServiceOptions = (function() {\n    \n                function ServiceOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ServiceOptions.prototype.deprecated = false;\n                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                ServiceOptions.create = function create(properties) {\n                    return new ServiceOptions(properties);\n                };\n    \n                ServiceOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(264).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                ServiceOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.ServiceOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 33:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ServiceOptions;\n            })();\n    \n            protobuf.MethodOptions = (function() {\n    \n                function MethodOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MethodOptions.prototype.deprecated = false;\n                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                MethodOptions.create = function create(properties) {\n                    return new MethodOptions(properties);\n                };\n    \n                MethodOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && m.hasOwnProperty(\"deprecated\"))\n                        w.uint32(264).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                MethodOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MethodOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 33:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MethodOptions;\n            })();\n    \n            protobuf.UninterpretedOption = (function() {\n    \n                function UninterpretedOption(p) {\n                    this.name = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                UninterpretedOption.prototype.name = $util.emptyArray;\n                UninterpretedOption.prototype.identifierValue = \"\";\n                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n                UninterpretedOption.prototype.doubleValue = 0;\n                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n                UninterpretedOption.prototype.aggregateValue = \"\";\n    \n                UninterpretedOption.create = function create(properties) {\n                    return new UninterpretedOption(properties);\n                };\n    \n                UninterpretedOption.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.name.length) {\n                        for (var i = 0; i < m.name.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.NamePart.encode(m.name[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.identifierValue != null && m.hasOwnProperty(\"identifierValue\"))\n                        w.uint32(26).string(m.identifierValue);\n                    if (m.positiveIntValue != null && m.hasOwnProperty(\"positiveIntValue\"))\n                        w.uint32(32).uint64(m.positiveIntValue);\n                    if (m.negativeIntValue != null && m.hasOwnProperty(\"negativeIntValue\"))\n                        w.uint32(40).int64(m.negativeIntValue);\n                    if (m.doubleValue != null && m.hasOwnProperty(\"doubleValue\"))\n                        w.uint32(49).double(m.doubleValue);\n                    if (m.stringValue != null && m.hasOwnProperty(\"stringValue\"))\n                        w.uint32(58).bytes(m.stringValue);\n                    if (m.aggregateValue != null && m.hasOwnProperty(\"aggregateValue\"))\n                        w.uint32(66).string(m.aggregateValue);\n                    return w;\n                };\n    \n                UninterpretedOption.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UninterpretedOption();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 2:\n                            if (!(m.name && m.name.length))\n                                m.name = [];\n                            m.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.identifierValue = r.string();\n                            break;\n                        case 4:\n                            m.positiveIntValue = r.uint64();\n                            break;\n                        case 5:\n                            m.negativeIntValue = r.int64();\n                            break;\n                        case 6:\n                            m.doubleValue = r.double();\n                            break;\n                        case 7:\n                            m.stringValue = r.bytes();\n                            break;\n                        case 8:\n                            m.aggregateValue = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                UninterpretedOption.NamePart = (function() {\n    \n                    function NamePart(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    NamePart.prototype.namePart = \"\";\n                    NamePart.prototype.isExtension = false;\n    \n                    NamePart.create = function create(properties) {\n                        return new NamePart(properties);\n                    };\n    \n                    NamePart.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        w.uint32(10).string(m.namePart);\n                        w.uint32(16).bool(m.isExtension);\n                        return w;\n                    };\n    \n                    NamePart.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UninterpretedOption.NamePart();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.namePart = r.string();\n                                break;\n                            case 2:\n                                m.isExtension = r.bool();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        if (!m.hasOwnProperty(\"namePart\"))\n                            throw $util.ProtocolError(\"missing required 'namePart'\", { instance: m });\n                        if (!m.hasOwnProperty(\"isExtension\"))\n                            throw $util.ProtocolError(\"missing required 'isExtension'\", { instance: m });\n                        return m;\n                    };\n    \n                    return NamePart;\n                })();\n    \n                return UninterpretedOption;\n            })();\n    \n            protobuf.SourceCodeInfo = (function() {\n    \n                function SourceCodeInfo(p) {\n                    this.location = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SourceCodeInfo.prototype.location = $util.emptyArray;\n    \n                SourceCodeInfo.create = function create(properties) {\n                    return new SourceCodeInfo(properties);\n                };\n    \n                SourceCodeInfo.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.location != null && m.location.length) {\n                        for (var i = 0; i < m.location.length; ++i)\n                            $root.google.protobuf.SourceCodeInfo.Location.encode(m.location[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                SourceCodeInfo.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.SourceCodeInfo();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.location && m.location.length))\n                                m.location = [];\n                            m.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                SourceCodeInfo.Location = (function() {\n    \n                    function Location(p) {\n                        this.path = [];\n                        this.span = [];\n                        this.leadingDetachedComments = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Location.prototype.path = $util.emptyArray;\n                    Location.prototype.span = $util.emptyArray;\n                    Location.prototype.leadingComments = \"\";\n                    Location.prototype.trailingComments = \"\";\n                    Location.prototype.leadingDetachedComments = $util.emptyArray;\n    \n                    Location.create = function create(properties) {\n                        return new Location(properties);\n                    };\n    \n                    Location.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.path != null && m.path.length) {\n                            w.uint32(10).fork();\n                            for (var i = 0; i < m.path.length; ++i)\n                                w.int32(m.path[i]);\n                            w.ldelim();\n                        }\n                        if (m.span != null && m.span.length) {\n                            w.uint32(18).fork();\n                            for (var i = 0; i < m.span.length; ++i)\n                                w.int32(m.span[i]);\n                            w.ldelim();\n                        }\n                        if (m.leadingComments != null && m.hasOwnProperty(\"leadingComments\"))\n                            w.uint32(26).string(m.leadingComments);\n                        if (m.trailingComments != null && m.hasOwnProperty(\"trailingComments\"))\n                            w.uint32(34).string(m.trailingComments);\n                        if (m.leadingDetachedComments != null && m.leadingDetachedComments.length) {\n                            for (var i = 0; i < m.leadingDetachedComments.length; ++i)\n                                w.uint32(50).string(m.leadingDetachedComments[i]);\n                        }\n                        return w;\n                    };\n    \n                    Location.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.SourceCodeInfo.Location();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.path && m.path.length))\n                                    m.path = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.path.push(r.int32());\n                                } else\n                                    m.path.push(r.int32());\n                                break;\n                            case 2:\n                                if (!(m.span && m.span.length))\n                                    m.span = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.span.push(r.int32());\n                                } else\n                                    m.span.push(r.int32());\n                                break;\n                            case 3:\n                                m.leadingComments = r.string();\n                                break;\n                            case 4:\n                                m.trailingComments = r.string();\n                                break;\n                            case 6:\n                                if (!(m.leadingDetachedComments && m.leadingDetachedComments.length))\n                                    m.leadingDetachedComments = [];\n                                m.leadingDetachedComments.push(r.string());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Location;\n                })();\n    \n                return SourceCodeInfo;\n            })();\n    \n            protobuf.GeneratedCodeInfo = (function() {\n    \n                function GeneratedCodeInfo(p) {\n                    this.annotation = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n    \n                GeneratedCodeInfo.create = function create(properties) {\n                    return new GeneratedCodeInfo(properties);\n                };\n    \n                GeneratedCodeInfo.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.annotation != null && m.annotation.length) {\n                        for (var i = 0; i < m.annotation.length; ++i)\n                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(m.annotation[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GeneratedCodeInfo.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.GeneratedCodeInfo();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.annotation && m.annotation.length))\n                                m.annotation = [];\n                            m.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                GeneratedCodeInfo.Annotation = (function() {\n    \n                    function Annotation(p) {\n                        this.path = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Annotation.prototype.path = $util.emptyArray;\n                    Annotation.prototype.sourceFile = \"\";\n                    Annotation.prototype.begin = 0;\n                    Annotation.prototype.end = 0;\n    \n                    Annotation.create = function create(properties) {\n                        return new Annotation(properties);\n                    };\n    \n                    Annotation.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.path != null && m.path.length) {\n                            w.uint32(10).fork();\n                            for (var i = 0; i < m.path.length; ++i)\n                                w.int32(m.path[i]);\n                            w.ldelim();\n                        }\n                        if (m.sourceFile != null && m.hasOwnProperty(\"sourceFile\"))\n                            w.uint32(18).string(m.sourceFile);\n                        if (m.begin != null && m.hasOwnProperty(\"begin\"))\n                            w.uint32(24).int32(m.begin);\n                        if (m.end != null && m.hasOwnProperty(\"end\"))\n                            w.uint32(32).int32(m.end);\n                        return w;\n                    };\n    \n                    Annotation.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.path && m.path.length))\n                                    m.path = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.path.push(r.int32());\n                                } else\n                                    m.path.push(r.int32());\n                                break;\n                            case 2:\n                                m.sourceFile = r.string();\n                                break;\n                            case 3:\n                                m.begin = r.int32();\n                                break;\n                            case 4:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Annotation;\n                })();\n    \n                return GeneratedCodeInfo;\n            })();\n    \n            return protobuf;\n        })();\n    \n        return google;\n    })();\n    \n    $root.FieldType = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"FT_DEFAULT\"] = 0;\n        values[valuesById[1] = \"FT_CALLBACK\"] = 1;\n        values[valuesById[4] = \"FT_POINTER\"] = 4;\n        values[valuesById[2] = \"FT_STATIC\"] = 2;\n        values[valuesById[3] = \"FT_IGNORE\"] = 3;\n        values[valuesById[5] = \"FT_INLINE\"] = 5;\n        return values;\n    })();\n    \n    $root.IntSize = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"IS_DEFAULT\"] = 0;\n        values[valuesById[8] = \"IS_8\"] = 8;\n        values[valuesById[16] = \"IS_16\"] = 16;\n        values[valuesById[32] = \"IS_32\"] = 32;\n        values[valuesById[64] = \"IS_64\"] = 64;\n        return values;\n    })();\n    \n    $root.NanoPBOptions = (function() {\n    \n        function NanoPBOptions(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n    \n        NanoPBOptions.prototype.maxSize = 0;\n        NanoPBOptions.prototype.maxLength = 0;\n        NanoPBOptions.prototype.maxCount = 0;\n        NanoPBOptions.prototype.intSize = 0;\n        NanoPBOptions.prototype.type = 0;\n        NanoPBOptions.prototype.longNames = true;\n        NanoPBOptions.prototype.packedStruct = false;\n        NanoPBOptions.prototype.packedEnum = false;\n        NanoPBOptions.prototype.skipMessage = false;\n        NanoPBOptions.prototype.noUnions = false;\n        NanoPBOptions.prototype.msgid = 0;\n        NanoPBOptions.prototype.anonymousOneof = false;\n        NanoPBOptions.prototype.proto3 = false;\n        NanoPBOptions.prototype.enumToString = false;\n        NanoPBOptions.prototype.fixedLength = false;\n        NanoPBOptions.prototype.fixedCount = false;\n    \n        NanoPBOptions.create = function create(properties) {\n            return new NanoPBOptions(properties);\n        };\n    \n        NanoPBOptions.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.maxSize != null && m.hasOwnProperty(\"maxSize\"))\n                w.uint32(8).int32(m.maxSize);\n            if (m.maxCount != null && m.hasOwnProperty(\"maxCount\"))\n                w.uint32(16).int32(m.maxCount);\n            if (m.type != null && m.hasOwnProperty(\"type\"))\n                w.uint32(24).int32(m.type);\n            if (m.longNames != null && m.hasOwnProperty(\"longNames\"))\n                w.uint32(32).bool(m.longNames);\n            if (m.packedStruct != null && m.hasOwnProperty(\"packedStruct\"))\n                w.uint32(40).bool(m.packedStruct);\n            if (m.skipMessage != null && m.hasOwnProperty(\"skipMessage\"))\n                w.uint32(48).bool(m.skipMessage);\n            if (m.intSize != null && m.hasOwnProperty(\"intSize\"))\n                w.uint32(56).int32(m.intSize);\n            if (m.noUnions != null && m.hasOwnProperty(\"noUnions\"))\n                w.uint32(64).bool(m.noUnions);\n            if (m.msgid != null && m.hasOwnProperty(\"msgid\"))\n                w.uint32(72).uint32(m.msgid);\n            if (m.packedEnum != null && m.hasOwnProperty(\"packedEnum\"))\n                w.uint32(80).bool(m.packedEnum);\n            if (m.anonymousOneof != null && m.hasOwnProperty(\"anonymousOneof\"))\n                w.uint32(88).bool(m.anonymousOneof);\n            if (m.proto3 != null && m.hasOwnProperty(\"proto3\"))\n                w.uint32(96).bool(m.proto3);\n            if (m.enumToString != null && m.hasOwnProperty(\"enumToString\"))\n                w.uint32(104).bool(m.enumToString);\n            if (m.maxLength != null && m.hasOwnProperty(\"maxLength\"))\n                w.uint32(112).int32(m.maxLength);\n            if (m.fixedLength != null && m.hasOwnProperty(\"fixedLength\"))\n                w.uint32(120).bool(m.fixedLength);\n            if (m.fixedCount != null && m.hasOwnProperty(\"fixedCount\"))\n                w.uint32(128).bool(m.fixedCount);\n            return w;\n        };\n    \n        NanoPBOptions.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.NanoPBOptions();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.maxSize = r.int32();\n                    break;\n                case 14:\n                    m.maxLength = r.int32();\n                    break;\n                case 2:\n                    m.maxCount = r.int32();\n                    break;\n                case 7:\n                    m.intSize = r.int32();\n                    break;\n                case 3:\n                    m.type = r.int32();\n                    break;\n                case 4:\n                    m.longNames = r.bool();\n                    break;\n                case 5:\n                    m.packedStruct = r.bool();\n                    break;\n                case 10:\n                    m.packedEnum = r.bool();\n                    break;\n                case 6:\n                    m.skipMessage = r.bool();\n                    break;\n                case 8:\n                    m.noUnions = r.bool();\n                    break;\n                case 9:\n                    m.msgid = r.uint32();\n                    break;\n                case 11:\n                    m.anonymousOneof = r.bool();\n                    break;\n                case 12:\n                    m.proto3 = r.bool();\n                    break;\n                case 13:\n                    m.enumToString = r.bool();\n                    break;\n                case 15:\n                    m.fixedLength = r.bool();\n                    break;\n                case 16:\n                    m.fixedCount = r.bool();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n    \n        return NanoPBOptions;\n    })();\n\n    return $root;\n});\n\n\n//# sourceURL=webpack://ParticleUsb/./lib/pb-message.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/assert-plus/assert.js":
/*!********************************************!*\
  !*** ./node_modules/assert-plus/assert.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer, process) {// Copyright (c) 2012, Mark Cavage. All rights reserved.\n// Copyright 2015 Joyent, Inc.\n\nvar assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\nvar Stream = __webpack_require__(/*! stream */ \"./node_modules/stream-browserify/index.js\").Stream;\nvar util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n\n///--- Globals\n\n/* JSSTYLED */\nvar UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;\n\n\n///--- Internal\n\nfunction _capitalize(str) {\n    return (str.charAt(0).toUpperCase() + str.slice(1));\n}\n\nfunction _toss(name, expected, oper, arg, actual) {\n    throw new assert.AssertionError({\n        message: util.format('%s (%s) is required', name, expected),\n        actual: (actual === undefined) ? typeof (arg) : actual(arg),\n        expected: expected,\n        operator: oper || '===',\n        stackStartFunction: _toss.caller\n    });\n}\n\nfunction _getClass(arg) {\n    return (Object.prototype.toString.call(arg).slice(8, -1));\n}\n\nfunction noop() {\n    // Why even bother with asserts?\n}\n\n\n///--- Exports\n\nvar types = {\n    bool: {\n        check: function (arg) { return typeof (arg) === 'boolean'; }\n    },\n    func: {\n        check: function (arg) { return typeof (arg) === 'function'; }\n    },\n    string: {\n        check: function (arg) { return typeof (arg) === 'string'; }\n    },\n    object: {\n        check: function (arg) {\n            return typeof (arg) === 'object' && arg !== null;\n        }\n    },\n    number: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg);\n        }\n    },\n    finite: {\n        check: function (arg) {\n            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);\n        }\n    },\n    buffer: {\n        check: function (arg) { return Buffer.isBuffer(arg); },\n        operator: 'Buffer.isBuffer'\n    },\n    array: {\n        check: function (arg) { return Array.isArray(arg); },\n        operator: 'Array.isArray'\n    },\n    stream: {\n        check: function (arg) { return arg instanceof Stream; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    date: {\n        check: function (arg) { return arg instanceof Date; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    regexp: {\n        check: function (arg) { return arg instanceof RegExp; },\n        operator: 'instanceof',\n        actual: _getClass\n    },\n    uuid: {\n        check: function (arg) {\n            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);\n        },\n        operator: 'isUUID'\n    }\n};\n\nfunction _setExports(ndebug) {\n    var keys = Object.keys(types);\n    var out;\n\n    /* re-export standard assert */\n    if (process.env.NODE_NDEBUG) {\n        out = noop;\n    } else {\n        out = function (arg, msg) {\n            if (!arg) {\n                _toss(msg, 'true', arg);\n            }\n        };\n    }\n\n    /* standard checks */\n    keys.forEach(function (k) {\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        var type = types[k];\n        out[k] = function (arg, msg) {\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* optional checks */\n    keys.forEach(function (k) {\n        var name = 'optional' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!type.check(arg)) {\n                _toss(msg, k, type.operator, arg, type.actual);\n            }\n        };\n    });\n\n    /* arrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'arrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* optionalArrayOf checks */\n    keys.forEach(function (k) {\n        var name = 'optionalArrayOf' + _capitalize(k);\n        if (ndebug) {\n            out[name] = noop;\n            return;\n        }\n        var type = types[k];\n        var expected = '[' + k + ']';\n        out[name] = function (arg, msg) {\n            if (arg === undefined || arg === null) {\n                return;\n            }\n            if (!Array.isArray(arg)) {\n                _toss(msg, expected, type.operator, arg, type.actual);\n            }\n            var i;\n            for (i = 0; i < arg.length; i++) {\n                if (!type.check(arg[i])) {\n                    _toss(msg, expected, type.operator, arg, type.actual);\n                }\n            }\n        };\n    });\n\n    /* re-export built-in assertions */\n    Object.keys(assert).forEach(function (k) {\n        if (k === 'AssertionError') {\n            out[k] = assert[k];\n            return;\n        }\n        if (ndebug) {\n            out[k] = noop;\n            return;\n        }\n        out[k] = assert[k];\n    });\n\n    /* export ourselves (for unit tests _only_) */\n    out._setExports = _setExports;\n\n    return out;\n}\n\nmodule.exports = _setExports(process.env.NODE_NDEBUG);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/assert-plus/assert.js?");

/***/ }),

/***/ "./node_modules/assert/assert.js":
/*!***************************************!*\
  !*** ./node_modules/assert/assert.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(/*! util/ */ \"./node_modules/util/util.js\");\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/assert/assert.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/core-util-is/lib/util.js":
/*!***********************************************!*\
  !*** ./node_modules/core-util-is/lib/util.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/core-util-is/lib/util.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/extsprintf/lib/extsprintf.js":
/*!***************************************************!*\
  !*** ./node_modules/extsprintf/lib/extsprintf.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {/*\n * extsprintf.js: extended POSIX-style sprintf\n */\n\nvar mod_assert = __webpack_require__(/*! assert */ \"./node_modules/assert/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\n/*\n * Public interface\n */\nexports.sprintf = jsSprintf;\nexports.printf = jsPrintf;\nexports.fprintf = jsFprintf;\n\n/*\n * Stripped down version of s[n]printf(3c).  We make a best effort to throw an\n * exception when given a format string we don't understand, rather than\n * ignoring it, so that we won't break existing programs if/when we go implement\n * the rest of this.\n *\n * This implementation currently supports specifying\n *\t- field alignment ('-' flag),\n * \t- zero-pad ('0' flag)\n *\t- always show numeric sign ('+' flag),\n *\t- field width\n *\t- conversions for strings, decimal integers, and floats (numbers).\n *\t- argument size specifiers.  These are all accepted but ignored, since\n *\t  Javascript has no notion of the physical size of an argument.\n *\n * Everything else is currently unsupported, most notably precision, unsigned\n * numbers, non-decimal numbers, and characters.\n */\nfunction jsSprintf(ofmt)\n{\n\tvar regex = [\n\t    '([^%]*)',\t\t\t\t/* normal text */\n\t    '%',\t\t\t\t/* start of format */\n\t    '([\\'\\\\-+ #0]*?)',\t\t\t/* flags (optional) */\n\t    '([1-9]\\\\d*)?',\t\t\t/* width (optional) */\n\t    '(\\\\.([1-9]\\\\d*))?',\t\t/* precision (optional) */\n\t    '[lhjztL]*?',\t\t\t/* length mods (ignored) */\n\t    '([diouxXfFeEgGaAcCsSp%jr])'\t/* conversion */\n\t].join('');\n\n\tvar re = new RegExp(regex);\n\n\t/* variadic arguments used to fill in conversion specifiers */\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\t/* remaining format string */\n\tvar fmt = ofmt;\n\n\t/* components of the current conversion specifier */\n\tvar flags, width, precision, conversion;\n\tvar left, pad, sign, arg, match;\n\n\t/* return value */\n\tvar ret = '';\n\n\t/* current variadic argument (1-based) */\n\tvar argn = 1;\n\t/* 0-based position in the format string that we've read */\n\tvar posn = 0;\n\t/* 1-based position in the format string of the current conversion */\n\tvar convposn;\n\t/* current conversion specifier */\n\tvar curconv;\n\n\tmod_assert.equal('string', typeof (fmt),\n\t    'first argument must be a format string');\n\n\twhile ((match = re.exec(fmt)) !== null) {\n\t\tret += match[1];\n\t\tfmt = fmt.substring(match[0].length);\n\n\t\t/*\n\t\t * Update flags related to the current conversion specifier's\n\t\t * position so that we can report clear error messages.\n\t\t */\n\t\tcurconv = match[0].substring(match[1].length);\n\t\tconvposn = posn + match[1].length + 1;\n\t\tposn += match[0].length;\n\n\t\tflags = match[2] || '';\n\t\twidth = match[3] || 0;\n\t\tprecision = match[4] || '';\n\t\tconversion = match[6];\n\t\tleft = false;\n\t\tsign = false;\n\t\tpad = ' ';\n\n\t\tif (conversion == '%') {\n\t\t\tret += '%';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (args.length === 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'has no matching argument ' +\n\t\t\t    '(too few arguments passed)'));\n\t\t}\n\n\t\targ = args.shift();\n\t\targn++;\n\n\t\tif (flags.match(/[\\' #]/)) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses unsupported flags'));\n\t\t}\n\n\t\tif (precision.length > 0) {\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'uses non-zero precision (not supported)'));\n\t\t}\n\n\t\tif (flags.match(/-/))\n\t\t\tleft = true;\n\n\t\tif (flags.match(/0/))\n\t\t\tpad = '0';\n\n\t\tif (flags.match(/\\+/))\n\t\t\tsign = true;\n\n\t\tswitch (conversion) {\n\t\tcase 's':\n\t\t\tif (arg === undefined || arg === null) {\n\t\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t\t    'attempted to print undefined or null ' +\n\t\t\t\t    'as a string (argument ' + argn + ' to ' +\n\t\t\t\t    'sprintf)'));\n\t\t\t}\n\t\t\tret += doPad(pad, width, left, arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'd':\n\t\t\targ = Math.floor(arg);\n\t\t\t/*jsl:fallthru*/\n\t\tcase 'f':\n\t\t\tsign = sign && arg > 0 ? '+' : '';\n\t\t\tret += sign + doPad(pad, width, left,\n\t\t\t    arg.toString());\n\t\t\tbreak;\n\n\t\tcase 'x':\n\t\t\tret += doPad(pad, width, left, arg.toString(16));\n\t\t\tbreak;\n\n\t\tcase 'j': /* non-standard */\n\t\t\tif (width === 0)\n\t\t\t\twidth = 10;\n\t\t\tret += mod_util.inspect(arg, false, width);\n\t\t\tbreak;\n\n\t\tcase 'r': /* non-standard */\n\t\t\tret += dumpException(arg);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow (jsError(ofmt, convposn, curconv,\n\t\t\t    'is not supported'));\n\t\t}\n\t}\n\n\tret += fmt;\n\treturn (ret);\n}\n\nfunction jsError(fmtstr, convposn, curconv, reason) {\n\tmod_assert.equal(typeof (fmtstr), 'string');\n\tmod_assert.equal(typeof (curconv), 'string');\n\tmod_assert.equal(typeof (convposn), 'number');\n\tmod_assert.equal(typeof (reason), 'string');\n\treturn (new Error('format string \"' + fmtstr +\n\t    '\": conversion specifier \"' + curconv + '\" at character ' +\n\t    convposn + ' ' + reason));\n}\n\nfunction jsPrintf() {\n\tvar args = Array.prototype.slice.call(arguments);\n\targs.unshift(process.stdout);\n\tjsFprintf.apply(null, args);\n}\n\nfunction jsFprintf(stream) {\n\tvar args = Array.prototype.slice.call(arguments, 1);\n\treturn (stream.write(jsSprintf.apply(this, args)));\n}\n\nfunction doPad(chr, width, left, str)\n{\n\tvar ret = str;\n\n\twhile (ret.length < width) {\n\t\tif (left)\n\t\t\tret += chr;\n\t\telse\n\t\t\tret = chr + ret;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * This function dumps long stack traces for exceptions having a cause() method.\n * See node-verror for an example.\n */\nfunction dumpException(ex)\n{\n\tvar ret;\n\n\tif (!(ex instanceof Error))\n\t\tthrow (new Error(jsSprintf('invalid type for %%r: %j', ex)));\n\n\t/* Note that V8 prepends \"ex.stack\" with ex.toString(). */\n\tret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;\n\n\tif (ex.cause && typeof (ex.cause) === 'function') {\n\t\tvar cex = ex.cause();\n\t\tif (cex) {\n\t\t\tret += '\\nCaused by: ' + dumpException(cex);\n\t\t}\n\t}\n\n\treturn (ret);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/extsprintf/lib/extsprintf.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/ip/lib/ip.js":
/*!***********************************!*\
  !*** ./node_modules/ip/lib/ip.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ip = exports;\nvar Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\").Buffer;\nvar os = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\");\n\nip.toBuffer = function(ip, buff, offset) {\n  offset = ~~offset;\n\n  var result;\n\n  if (this.isV4Format(ip)) {\n    result = buff || new Buffer(offset + 4);\n    ip.split(/\\./g).map(function(byte) {\n      result[offset++] = parseInt(byte, 10) & 0xff;\n    });\n  } else if (this.isV6Format(ip)) {\n    var sections = ip.split(':', 8);\n\n    var i;\n    for (i = 0; i < sections.length; i++) {\n      var isv4 = this.isV4Format(sections[i]);\n      var v4Buffer;\n\n      if (isv4) {\n        v4Buffer = this.toBuffer(sections[i]);\n        sections[i] = v4Buffer.slice(0, 2).toString('hex');\n      }\n\n      if (v4Buffer && ++i < 8) {\n        sections.splice(i, 0, v4Buffer.slice(2, 4).toString('hex'));\n      }\n    }\n\n    if (sections[0] === '') {\n      while (sections.length < 8) sections.unshift('0');\n    } else if (sections[sections.length - 1] === '') {\n      while (sections.length < 8) sections.push('0');\n    } else if (sections.length < 8) {\n      for (i = 0; i < sections.length && sections[i] !== ''; i++);\n      var argv = [ i, 1 ];\n      for (i = 9 - sections.length; i > 0; i--) {\n        argv.push('0');\n      }\n      sections.splice.apply(sections, argv);\n    }\n\n    result = buff || new Buffer(offset + 16);\n    for (i = 0; i < sections.length; i++) {\n      var word = parseInt(sections[i], 16);\n      result[offset++] = (word >> 8) & 0xff;\n      result[offset++] = word & 0xff;\n    }\n  }\n\n  if (!result) {\n    throw Error('Invalid ip address: ' + ip);\n  }\n\n  return result;\n};\n\nip.toString = function(buff, offset, length) {\n  offset = ~~offset;\n  length = length || (buff.length - offset);\n\n  var result = [];\n  if (length === 4) {\n    // IPv4\n    for (var i = 0; i < length; i++) {\n      result.push(buff[offset + i]);\n    }\n    result = result.join('.');\n  } else if (length === 16) {\n    // IPv6\n    for (var i = 0; i < length; i += 2) {\n      result.push(buff.readUInt16BE(offset + i).toString(16));\n    }\n    result = result.join(':');\n    result = result.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3');\n    result = result.replace(/:{3,4}/, '::');\n  }\n\n  return result;\n};\n\nvar ipv4Regex = /^(\\d{1,3}\\.){3,3}\\d{1,3}$/;\nvar ipv6Regex =\n    /^(::)?(((\\d{1,3}\\.){3}(\\d{1,3}){1})?([0-9a-f]){0,4}:{0,2}){1,8}(::)?$/i;\n\nip.isV4Format = function(ip) {\n  return ipv4Regex.test(ip);\n};\n\nip.isV6Format = function(ip) {\n  return ipv6Regex.test(ip);\n};\nfunction _normalizeFamily(family) {\n  return family ? family.toLowerCase() : 'ipv4';\n}\n\nip.fromPrefixLen = function(prefixlen, family) {\n  if (prefixlen > 32) {\n    family = 'ipv6';\n  } else {\n    family = _normalizeFamily(family);\n  }\n\n  var len = 4;\n  if (family === 'ipv6') {\n    len = 16;\n  }\n  var buff = new Buffer(len);\n\n  for (var i = 0, n = buff.length; i < n; ++i) {\n    var bits = 8;\n    if (prefixlen < 8) {\n      bits = prefixlen;\n    }\n    prefixlen -= bits;\n\n    buff[i] = ~(0xff >> bits) & 0xff;\n  }\n\n  return ip.toString(buff);\n};\n\nip.mask = function(addr, mask) {\n  addr = ip.toBuffer(addr);\n  mask = ip.toBuffer(mask);\n\n  var result = new Buffer(Math.max(addr.length, mask.length));\n\n  var i = 0;\n  // Same protocol - do bitwise and\n  if (addr.length === mask.length) {\n    for (i = 0; i < addr.length; i++) {\n      result[i] = addr[i] & mask[i];\n    }\n  } else if (mask.length === 4) {\n    // IPv6 address and IPv4 mask\n    // (Mask low bits)\n    for (i = 0; i < mask.length; i++) {\n      result[i] = addr[addr.length - 4  + i] & mask[i];\n    }\n  } else {\n    // IPv6 mask and IPv4 addr\n    for (var i = 0; i < result.length - 6; i++) {\n      result[i] = 0;\n    }\n\n    // ::ffff:ipv4\n    result[10] = 0xff;\n    result[11] = 0xff;\n    for (i = 0; i < addr.length; i++) {\n      result[i + 12] = addr[i] & mask[i + 12];\n    }\n    i = i + 12;\n  }\n  for (; i < result.length; i++)\n    result[i] = 0;\n\n  return ip.toString(result);\n};\n\nip.cidr = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.mask(addr, mask);\n};\n\nip.subnet = function(addr, mask) {\n  var networkAddress = ip.toLong(ip.mask(addr, mask));\n\n  // Calculate the mask's length.\n  var maskBuffer = ip.toBuffer(mask);\n  var maskLength = 0;\n\n  for (var i = 0; i < maskBuffer.length; i++) {\n    if (maskBuffer[i] === 0xff) {\n      maskLength += 8;\n    } else {\n      var octet = maskBuffer[i] & 0xff;\n      while (octet) {\n        octet = (octet << 1) & 0xff;\n        maskLength++;\n      }\n    }\n  }\n\n  var numberOfAddresses = Math.pow(2, 32 - maskLength);\n\n  return {\n    networkAddress: ip.fromLong(networkAddress),\n    firstAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress) :\n                    ip.fromLong(networkAddress + 1),\n    lastAddress: numberOfAddresses <= 2 ?\n                    ip.fromLong(networkAddress + numberOfAddresses - 1) :\n                    ip.fromLong(networkAddress + numberOfAddresses - 2),\n    broadcastAddress: ip.fromLong(networkAddress + numberOfAddresses - 1),\n    subnetMask: mask,\n    subnetMaskLength: maskLength,\n    numHosts: numberOfAddresses <= 2 ?\n                numberOfAddresses : numberOfAddresses - 2,\n    length: numberOfAddresses,\n    contains: function(other) {\n      return networkAddress === ip.toLong(ip.mask(other, mask));\n    }\n  };\n};\n\nip.cidrSubnet = function(cidrString) {\n  var cidrParts = cidrString.split('/');\n\n  var addr = cidrParts[0];\n  if (cidrParts.length !== 2)\n    throw new Error('invalid CIDR subnet: ' + addr);\n\n  var mask = ip.fromPrefixLen(parseInt(cidrParts[1], 10));\n\n  return ip.subnet(addr, mask);\n};\n\nip.not = function(addr) {\n  var buff = ip.toBuffer(addr);\n  for (var i = 0; i < buff.length; i++) {\n    buff[i] = 0xff ^ buff[i];\n  }\n  return ip.toString(buff);\n};\n\nip.or = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; ++i) {\n      a[i] |= b[i];\n    }\n    return ip.toString(a);\n\n  // mixed protocols\n  } else {\n    var buff = a;\n    var other = b;\n    if (b.length > a.length) {\n      buff = b;\n      other = a;\n    }\n\n    var offset = buff.length - other.length;\n    for (var i = offset; i < buff.length; ++i) {\n      buff[i] |= other[i - offset];\n    }\n\n    return ip.toString(buff);\n  }\n};\n\nip.isEqual = function(a, b) {\n  a = ip.toBuffer(a);\n  b = ip.toBuffer(b);\n\n  // Same protocol\n  if (a.length === b.length) {\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  // Swap\n  if (b.length === 4) {\n    var t = b;\n    b = a;\n    a = t;\n  }\n\n  // a - IPv4, b - IPv6\n  for (var i = 0; i < 10; i++) {\n    if (b[i] !== 0) return false;\n  }\n\n  var word = b.readUInt16BE(10);\n  if (word !== 0 && word !== 0xffff) return false;\n\n  for (var i = 0; i < 4; i++) {\n    if (a[i] !== b[i + 12]) return false;\n  }\n\n  return true;\n};\n\nip.isPrivate = function(addr) {\n  return /^(::f{4}:)?10\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?192\\.168\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?172\\.(1[6-9]|2\\d|30|31)\\.([0-9]{1,3})\\.([0-9]{1,3})$/i\n      .test(addr) ||\n    /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^(::f{4}:)?169\\.254\\.([0-9]{1,3})\\.([0-9]{1,3})$/i.test(addr) ||\n    /^f[cd][0-9a-f]{2}:/i.test(addr) ||\n    /^fe80:/i.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.isPublic = function(addr) {\n  return !ip.isPrivate(addr);\n};\n\nip.isLoopback = function(addr) {\n  return /^(::f{4}:)?127\\.([0-9]{1,3})\\.([0-9]{1,3})\\.([0-9]{1,3})/\n      .test(addr) ||\n    /^fe80::1$/.test(addr) ||\n    /^::1$/.test(addr) ||\n    /^::$/.test(addr);\n};\n\nip.loopback = function(family) {\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  if (family !== 'ipv4' && family !== 'ipv6') {\n    throw new Error('family must be ipv4 or ipv6');\n  }\n\n  return family === 'ipv4' ? '127.0.0.1' : 'fe80::1';\n};\n\n//\n// ### function address (name, family)\n// #### @name {string|'public'|'private'} **Optional** Name or security\n//      of the network interface.\n// #### @family {ipv4|ipv6} **Optional** IP family of the address (defaults\n//      to ipv4).\n//\n// Returns the address for the network interface on the current system with\n// the specified `name`:\n//   * String: First `family` address of the interface.\n//             If not found see `undefined`.\n//   * 'public': the first public ip address of family.\n//   * 'private': the first private ip address of family.\n//   * undefined: First address with `ipv4` or loopback address `127.0.0.1`.\n//\nip.address = function(name, family) {\n  var interfaces = os.networkInterfaces();\n  var all;\n\n  //\n  // Default to `ipv4`\n  //\n  family = _normalizeFamily(family);\n\n  //\n  // If a specific network interface has been named,\n  // return the address.\n  //\n  if (name && name !== 'private' && name !== 'public') {\n    var res = interfaces[name].filter(function(details) {\n      var itemFamily = details.family.toLowerCase();\n      return itemFamily === family;\n    });\n    if (res.length === 0)\n      return undefined;\n    return res[0].address;\n  }\n\n  var all = Object.keys(interfaces).map(function (nic) {\n    //\n    // Note: name will only be `public` or `private`\n    // when this is called.\n    //\n    var addresses = interfaces[nic].filter(function (details) {\n      details.family = details.family.toLowerCase();\n      if (details.family !== family || ip.isLoopback(details.address)) {\n        return false;\n      } else if (!name) {\n        return true;\n      }\n\n      return name === 'public' ? ip.isPrivate(details.address) :\n          ip.isPublic(details.address);\n    });\n\n    return addresses.length ? addresses[0].address : undefined;\n  }).filter(Boolean);\n\n  return !all.length ? ip.loopback(family) : all[0];\n};\n\nip.toLong = function(ip) {\n  var ipl = 0;\n  ip.split('.').forEach(function(octet) {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return(ipl >>> 0);\n};\n\nip.fromLong = function(ipl) {\n  return ((ipl >>> 24) + '.' +\n      (ipl >> 16 & 255) + '.' +\n      (ipl >> 8 & 255) + '.' +\n      (ipl & 255) );\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ip/lib/ip.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/object-assign/index.js?");

/***/ }),

/***/ "./node_modules/os-browserify/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/os-browserify/browser.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/os-browserify/browser.js?");

/***/ }),

/***/ "./node_modules/process-nextick-args/index.js":
/*!****************************************************!*\
  !*** ./node_modules/process-nextick-args/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/process-nextick-args/index.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.Reader._configure(protobuf.BufferReader);\n    protobuf.util._configure();\n}\n\n// Set up buffer utility according to the environment\nprotobuf.Writer._configure(protobuf.BufferWriter);\nconfigure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = util.Buffer\n    ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer)\n                ? new BufferReader(buffer)\n                /* istanbul ignore next */\n                : create_array(buffer);\n        })(buffer);\n    }\n    /* istanbul ignore next */\n    : create_array;\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\n/* istanbul ignore else */\nif (util.Buffer)\n    BufferReader.prototype._slice = util.Buffer.prototype.slice;\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n// global object reference\nutil.global = typeof window !== \"undefined\" && window\n           || typeof global !== \"undefined\" && global\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n * @const\n */\nutil.isNode = Boolean(util.global.process && util.global.process.versions && util.global.process.versions.node);\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: (new Error()).stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = util.Buffer\n    ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    }\n    /* istanbul ignore next */\n    : function create_array() {\n        return new Writer();\n    };\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar Buffer = util.Buffer;\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Buffer} Buffer\n */\nBufferWriter.alloc = function alloc_buffer(size) {\n    return (BufferWriter.alloc = util._Buffer_allocUnsafe)(size);\n};\n\nvar writeBytesBuffer = Buffer && Buffer.prototype instanceof Uint8Array && Buffer.prototype.set.name === \"set\"\n    ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n                           // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n        else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n    };\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else\n        buf.utf8Write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./node_modules/readable-stream/duplex-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/duplex-browser.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/duplex-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nvar Readable = __webpack_require__(/*! ./_stream_readable */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nvar Writable = __webpack_require__(/*! ./_stream_writable */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/_stream_duplex.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(/*! ./_stream_transform */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/_stream_passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(/*! util */ 0);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ \"./node_modules/readable-stream/lib/internal/streams/BufferList.js\");\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ \"./node_modules/string_decoder/lib/string_decoder.js\").StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/_stream_readable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/_stream_transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\");\nutil.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(/*! util-deprecate */ \"./node_modules/util-deprecate/browser.js\")\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(/*! ./internal/streams/stream */ \"./node_modules/readable-stream/lib/internal/streams/stream-browser.js\");\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ \"./node_modules/readable-stream/lib/internal/streams/destroy.js\");\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"./node_modules/process/browser.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/_stream_writable.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!*************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\nvar util = __webpack_require__(/*! util */ 1);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/internal/streams/BufferList.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(/*! process-nextick-args */ \"./node_modules/process-nextick-args/index.js\");\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/internal/streams/destroy.js?");

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/lib/internal/streams/stream-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/passthrough.js":
/*!*****************************************************!*\
  !*** ./node_modules/readable-stream/passthrough.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").PassThrough\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/passthrough.js?");

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ \"./node_modules/readable-stream/lib/_stream_readable.js\");\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\nexports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ \"./node_modules/readable-stream/lib/_stream_duplex.js\");\nexports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ \"./node_modules/readable-stream/lib/_stream_transform.js\");\nexports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ \"./node_modules/readable-stream/lib/_stream_passthrough.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/readable-browser.js?");

/***/ }),

/***/ "./node_modules/readable-stream/transform.js":
/*!***************************************************!*\
  !*** ./node_modules/readable-stream/transform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./readable */ \"./node_modules/readable-stream/readable-browser.js\").Transform\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/transform.js?");

/***/ }),

/***/ "./node_modules/readable-stream/writable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/writable-browser.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/_stream_writable.js */ \"./node_modules/readable-stream/lib/_stream_writable.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/readable-stream/writable-browser.js?");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/safe-buffer/index.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/stream-browserify/index.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-browserify/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter;\nvar inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(/*! readable-stream/readable.js */ \"./node_modules/readable-stream/readable-browser.js\");\nStream.Writable = __webpack_require__(/*! readable-stream/writable.js */ \"./node_modules/readable-stream/writable-browser.js\");\nStream.Duplex = __webpack_require__(/*! readable-stream/duplex.js */ \"./node_modules/readable-stream/duplex-browser.js\");\nStream.Transform = __webpack_require__(/*! readable-stream/transform.js */ \"./node_modules/readable-stream/transform.js\");\nStream.PassThrough = __webpack_require__(/*! readable-stream/passthrough.js */ \"./node_modules/readable-stream/passthrough.js\");\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/stream-browserify/index.js?");

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/string_decoder/lib/string_decoder.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/util-deprecate/browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/verror/lib/verror.js":
/*!*******************************************!*\
  !*** ./node_modules/verror/lib/verror.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n * verror.js: richer JavaScript errors\n */\n\nvar mod_assertplus = __webpack_require__(/*! assert-plus */ \"./node_modules/assert-plus/assert.js\");\nvar mod_util = __webpack_require__(/*! util */ \"./node_modules/util/util.js\");\n\nvar mod_extsprintf = __webpack_require__(/*! extsprintf */ \"./node_modules/extsprintf/lib/extsprintf.js\");\nvar mod_isError = __webpack_require__(/*! core-util-is */ \"./node_modules/core-util-is/lib/util.js\").isError;\nvar sprintf = mod_extsprintf.sprintf;\n\n/*\n * Public interface\n */\n\n/* So you can 'var VError = require('verror')' */\nmodule.exports = VError;\n/* For compatibility */\nVError.VError = VError;\n/* Other exported classes */\nVError.SError = SError;\nVError.WError = WError;\nVError.MultiError = MultiError;\n\n/*\n * Common function used to parse constructor arguments for VError, WError, and\n * SError.  Named arguments to this function:\n *\n *     strict\t\tforce strict interpretation of sprintf arguments, even\n *     \t\t\tif the options in \"argv\" don't say so\n *\n *     argv\t\terror's constructor arguments, which are to be\n *     \t\t\tinterpreted as described in README.md.  For quick\n *     \t\t\treference, \"argv\" has one of the following forms:\n *\n *          [ sprintf_args... ]           (argv[0] is a string)\n *          [ cause, sprintf_args... ]    (argv[0] is an Error)\n *          [ options, sprintf_args... ]  (argv[0] is an object)\n *\n * This function normalizes these forms, producing an object with the following\n * properties:\n *\n *    options           equivalent to \"options\" in third form.  This will never\n *    \t\t\tbe a direct reference to what the caller passed in\n *    \t\t\t(i.e., it may be a shallow copy), so it can be freely\n *    \t\t\tmodified.\n *\n *    shortmessage      result of sprintf(sprintf_args), taking options.strict\n *    \t\t\tinto account as described in README.md.\n */\nfunction parseConstructorArguments(args)\n{\n\tvar argv, options, sprintf_args, shortmessage, k;\n\n\tmod_assertplus.object(args, 'args');\n\tmod_assertplus.bool(args.strict, 'args.strict');\n\tmod_assertplus.array(args.argv, 'args.argv');\n\targv = args.argv;\n\n\t/*\n\t * First, figure out which form of invocation we've been given.\n\t */\n\tif (argv.length === 0) {\n\t\toptions = {};\n\t\tsprintf_args = [];\n\t} else if (mod_isError(argv[0])) {\n\t\toptions = { 'cause': argv[0] };\n\t\tsprintf_args = argv.slice(1);\n\t} else if (typeof (argv[0]) === 'object') {\n\t\toptions = {};\n\t\tfor (k in argv[0]) {\n\t\t\toptions[k] = argv[0][k];\n\t\t}\n\t\tsprintf_args = argv.slice(1);\n\t} else {\n\t\tmod_assertplus.string(argv[0],\n\t\t    'first argument to VError, SError, or WError ' +\n\t\t    'constructor must be a string, object, or Error');\n\t\toptions = {};\n\t\tsprintf_args = argv;\n\t}\n\n\t/*\n\t * Now construct the error's message.\n\t *\n\t * extsprintf (which we invoke here with our caller's arguments in order\n\t * to construct this Error's message) is strict in its interpretation of\n\t * values to be processed by the \"%s\" specifier.  The value passed to\n\t * extsprintf must actually be a string or something convertible to a\n\t * String using .toString().  Passing other values (notably \"null\" and\n\t * \"undefined\") is considered a programmer error.  The assumption is\n\t * that if you actually want to print the string \"null\" or \"undefined\",\n\t * then that's easy to do that when you're calling extsprintf; on the\n\t * other hand, if you did NOT want that (i.e., there's actually a bug\n\t * where the program assumes some variable is non-null and tries to\n\t * print it, which might happen when constructing a packet or file in\n\t * some specific format), then it's better to stop immediately than\n\t * produce bogus output.\n\t *\n\t * However, sometimes the bug is only in the code calling VError, and a\n\t * programmer might prefer to have the error message contain \"null\" or\n\t * \"undefined\" rather than have the bug in the error path crash the\n\t * program (making the first bug harder to identify).  For that reason,\n\t * by default VError converts \"null\" or \"undefined\" arguments to their\n\t * string representations and passes those to extsprintf.  Programmers\n\t * desiring the strict behavior can use the SError class or pass the\n\t * \"strict\" option to the VError constructor.\n\t */\n\tmod_assertplus.object(options);\n\tif (!options.strict && !args.strict) {\n\t\tsprintf_args = sprintf_args.map(function (a) {\n\t\t\treturn (a === null ? 'null' :\n\t\t\t    a === undefined ? 'undefined' : a);\n\t\t});\n\t}\n\n\tif (sprintf_args.length === 0) {\n\t\tshortmessage = '';\n\t} else {\n\t\tshortmessage = sprintf.apply(null, sprintf_args);\n\t}\n\n\treturn ({\n\t    'options': options,\n\t    'shortmessage': shortmessage\n\t});\n}\n\n/*\n * See README.md for reference documentation.\n */\nfunction VError()\n{\n\tvar args, obj, parsed, cause, ctor, message, k;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\n\t/*\n\t * This is a regrettable pattern, but JavaScript's built-in Error class\n\t * is defined to work this way, so we allow the constructor to be called\n\t * without \"new\".\n\t */\n\tif (!(this instanceof VError)) {\n\t\tobj = Object.create(VError.prototype);\n\t\tVError.apply(obj, arguments);\n\t\treturn (obj);\n\t}\n\n\t/*\n\t * For convenience and backwards compatibility, we support several\n\t * different calling forms.  Normalize them here.\n\t */\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': false\n\t});\n\n\t/*\n\t * If we've been given a name, apply it now.\n\t */\n\tif (parsed.options.name) {\n\t\tmod_assertplus.string(parsed.options.name,\n\t\t    'error\\'s \"name\" must be a string');\n\t\tthis.name = parsed.options.name;\n\t}\n\n\t/*\n\t * For debugging, we keep track of the original short message (attached\n\t * this Error particularly) separately from the complete message (which\n\t * includes the messages of our cause chain).\n\t */\n\tthis.jse_shortmsg = parsed.shortmessage;\n\tmessage = parsed.shortmessage;\n\n\t/*\n\t * If we've been given a cause, record a reference to it and update our\n\t * message appropriately.\n\t */\n\tcause = parsed.options.cause;\n\tif (cause) {\n\t\tmod_assertplus.ok(mod_isError(cause), 'cause is not an Error');\n\t\tthis.jse_cause = cause;\n\n\t\tif (!parsed.options.skipCauseMessage) {\n\t\t\tmessage += ': ' + cause.message;\n\t\t}\n\t}\n\n\t/*\n\t * If we've been given an object with properties, shallow-copy that\n\t * here.  We don't want to use a deep copy in case there are non-plain\n\t * objects here, but we don't want to use the original object in case\n\t * the caller modifies it later.\n\t */\n\tthis.jse_info = {};\n\tif (parsed.options.info) {\n\t\tfor (k in parsed.options.info) {\n\t\t\tthis.jse_info[k] = parsed.options.info[k];\n\t\t}\n\t}\n\n\tthis.message = message;\n\tError.call(this, message);\n\n\tif (Error.captureStackTrace) {\n\t\tctor = parsed.options.constructorOpt || this.constructor;\n\t\tError.captureStackTrace(this, ctor);\n\t}\n\n\treturn (this);\n}\n\nmod_util.inherits(VError, Error);\nVError.prototype.name = 'VError';\n\nVError.prototype.toString = function ve_toString()\n{\n\tvar str = (this.hasOwnProperty('name') && this.name ||\n\t\tthis.constructor.name || this.constructor.prototype.name);\n\tif (this.message)\n\t\tstr += ': ' + this.message;\n\n\treturn (str);\n};\n\n/*\n * This method is provided for compatibility.  New callers should use\n * VError.cause() instead.  That method also uses the saner `null` return value\n * when there is no cause.\n */\nVError.prototype.cause = function ve_cause()\n{\n\tvar cause = VError.cause(this);\n\treturn (cause === null ? undefined : cause);\n};\n\n/*\n * Static methods\n *\n * These class-level methods are provided so that callers can use them on\n * instances of Errors that are not VErrors.  New interfaces should be provided\n * only using static methods to eliminate the class of programming mistake where\n * people fail to check whether the Error object has the corresponding methods.\n */\n\nVError.cause = function (err)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\treturn (mod_isError(err.jse_cause) ? err.jse_cause : null);\n};\n\nVError.info = function (err)\n{\n\tvar rv, cause, k;\n\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tcause = VError.cause(err);\n\tif (cause !== null) {\n\t\trv = VError.info(cause);\n\t} else {\n\t\trv = {};\n\t}\n\n\tif (typeof (err.jse_info) == 'object' && err.jse_info !== null) {\n\t\tfor (k in err.jse_info) {\n\t\t\trv[k] = err.jse_info[k];\n\t\t}\n\t}\n\n\treturn (rv);\n};\n\nVError.findCauseByName = function (err, name)\n{\n\tvar cause;\n\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tmod_assertplus.string(name, 'name');\n\tmod_assertplus.ok(name.length > 0, 'name cannot be empty');\n\n\tfor (cause = err; cause !== null; cause = VError.cause(cause)) {\n\t\tmod_assertplus.ok(mod_isError(cause));\n\t\tif (cause.name == name) {\n\t\t\treturn (cause);\n\t\t}\n\t}\n\n\treturn (null);\n};\n\nVError.hasCauseWithName = function (err, name)\n{\n\treturn (VError.findCauseByName(err, name) !== null);\n};\n\nVError.fullStack = function (err)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\n\tvar cause = VError.cause(err);\n\n\tif (cause) {\n\t\treturn (err.stack + '\\ncaused by: ' + VError.fullStack(cause));\n\t}\n\n\treturn (err.stack);\n};\n\nVError.errorFromList = function (errors)\n{\n\tmod_assertplus.arrayOfObject(errors, 'errors');\n\n\tif (errors.length === 0) {\n\t\treturn (null);\n\t}\n\n\terrors.forEach(function (e) {\n\t\tmod_assertplus.ok(mod_isError(e));\n\t});\n\n\tif (errors.length == 1) {\n\t\treturn (errors[0]);\n\t}\n\n\treturn (new MultiError(errors));\n};\n\nVError.errorForEach = function (err, func)\n{\n\tmod_assertplus.ok(mod_isError(err), 'err must be an Error');\n\tmod_assertplus.func(func, 'func');\n\n\tif (err instanceof MultiError) {\n\t\terr.errors().forEach(function iterError(e) { func(e); });\n\t} else {\n\t\tfunc(err);\n\t}\n};\n\n\n/*\n * SError is like VError, but stricter about types.  You cannot pass \"null\" or\n * \"undefined\" as string arguments to the formatter.\n */\nfunction SError()\n{\n\tvar args, obj, parsed, options;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\tif (!(this instanceof SError)) {\n\t\tobj = Object.create(SError.prototype);\n\t\tSError.apply(obj, arguments);\n\t\treturn (obj);\n\t}\n\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': true\n\t});\n\n\toptions = parsed.options;\n\tVError.call(this, options, '%s', parsed.shortmessage);\n\n\treturn (this);\n}\n\n/*\n * We don't bother setting SError.prototype.name because once constructed,\n * SErrors are just like VErrors.\n */\nmod_util.inherits(SError, VError);\n\n\n/*\n * Represents a collection of errors for the purpose of consumers that generally\n * only deal with one error.  Callers can extract the individual errors\n * contained in this object, but may also just treat it as a normal single\n * error, in which case a summary message will be printed.\n */\nfunction MultiError(errors)\n{\n\tmod_assertplus.array(errors, 'list of errors');\n\tmod_assertplus.ok(errors.length > 0, 'must be at least one error');\n\tthis.ase_errors = errors;\n\n\tVError.call(this, {\n\t    'cause': errors[0]\n\t}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');\n}\n\nmod_util.inherits(MultiError, VError);\nMultiError.prototype.name = 'MultiError';\n\nMultiError.prototype.errors = function me_errors()\n{\n\treturn (this.ase_errors.slice(0));\n};\n\n\n/*\n * See README.md for reference details.\n */\nfunction WError()\n{\n\tvar args, obj, parsed, options;\n\n\targs = Array.prototype.slice.call(arguments, 0);\n\tif (!(this instanceof WError)) {\n\t\tobj = Object.create(WError.prototype);\n\t\tWError.apply(obj, args);\n\t\treturn (obj);\n\t}\n\n\tparsed = parseConstructorArguments({\n\t    'argv': args,\n\t    'strict': false\n\t});\n\n\toptions = parsed.options;\n\toptions['skipCauseMessage'] = true;\n\tVError.call(this, options, '%s', parsed.shortmessage);\n\n\treturn (this);\n}\n\nmod_util.inherits(WError, VError);\nWError.prototype.name = 'WError';\n\nWError.prototype.toString = function we_toString()\n{\n\tvar str = (this.hasOwnProperty('name') && this.name ||\n\t\tthis.constructor.name || this.constructor.prototype.name);\n\tif (this.message)\n\t\tstr += ': ' + this.message;\n\tif (this.jse_cause && this.jse_cause.message)\n\t\tstr += '; caused by ' + this.jse_cause.toString();\n\n\treturn (str);\n};\n\n/*\n * For purely historical reasons, WError's cause() function allows you to set\n * the cause.\n */\nWError.prototype.cause = function we_cause(c)\n{\n\tif (mod_isError(c))\n\t\tthis.jse_cause = c;\n\n\treturn (this.jse_cause);\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/verror/lib/verror.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://ParticleUsb/(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/cellular-device.js":
/*!********************************!*\
  !*** ./src/cellular-device.js ***!
  \********************************/
/*! exports provided: CellularDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CellularDevice\", function() { return CellularDevice; });\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\n\n\n/**\n * Cellular device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CellularDevice = base => class extends base {\n\t/**\n\t * Get ICCID of the active SIM card.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getIccid({ timeout = _config__WEBPACK_IMPORTED_MODULE_1__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CELLULAR_GET_ICCID, null /* msg */, { timeout });\n\t\treturn r.iccid;\n\t}\n\n\t/**\n\t * Set to `true` if this is a cellular device.\n\t */\n\tget isCellularDevice() {\n\t\treturn true;\n\t}\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cellular-device.js?");

/***/ }),

/***/ "./src/cloud-device.js":
/*!*****************************!*\
  !*** ./src/cloud-device.js ***!
  \*****************************/
/*! exports provided: CloudConnectionStatus, ServerProtocol, CloudDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloudConnectionStatus\", function() { return CloudConnectionStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ServerProtocol\", function() { return ServerProtocol; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CloudDevice\", function() { return CloudDevice; });\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _protobuf_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n/* harmony import */ var _usb_protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./config */ \"./src/config.js\");\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n\n\n\n\n\n/**\n * Cloud connection status.\n *\n * @enum {String}\n */\nconst CloudConnectionStatus = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].cloud.ConnectionStatus, {\n\t/** Disconnected. */\n\tDISCONNECTED: 'DISCONNECTED',\n\t/** Connecting. */\n\tCONNECTING: 'CONNECTING',\n\t/** Connected. */\n\tCONNECTED: 'CONNECTED',\n\t/** Disconnecting. */\n\tDISCONNECTING: 'DISCONNECTING'\n});\n\n/**\n * Server protocol types.\n *\n * @enum {String}\n */\nconst ServerProtocol = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType, {\n\t/** TCP. */\n\tTCP: 'TCP_PROTOCOL',\n\t/** UDP. */\n\tUDP: 'UDP_PROTOCOL'\n});\n\n/**\n * Cloud-enabled device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CloudDevice = base => class extends base {\n\t/**\n\t * Connect to the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually connect to the cloud and\n\t *        return immediately.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync connectToCloud({ dontWait = false, timeout = _config__WEBPACK_IMPORTED_MODULE_3__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_CONNECT);\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_STATUS);\n\t\t\t\t\tif (r.status === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].cloud.ConnectionStatus.CONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Disconnect from the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually disconnect from the cloud\n\t *        and return immediately.\n\t * @param {Boolean} [options.force] Disconnect immediately, even if the device is busy performing\n\t *        some operation with the cloud.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync disconnectFromCloud({ dontWait = false, force = false, timeout = _config__WEBPACK_IMPORTED_MODULE_3__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tif (force) {\n\t\t\tconst setup = {\n\t\t\t\tbmRequestType: _usb_protocol__WEBPACK_IMPORTED_MODULE_2__[\"BmRequestType\"].HOST_TO_DEVICE,\n\t\t\t\tbRequest: _usb_protocol__WEBPACK_IMPORTED_MODULE_2__[\"PARTICLE_BREQUEST\"],\n\t\t\t\twIndex: _request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_DISCONNECT.id,\n\t\t\t\twValue: 0\n\t\t\t};\n\t\t\tawait this.usbDevice.transferOut(setup);\n\t\t\tif (dontWait) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tif (!force) {\n\t\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_DISCONNECT);\n\t\t\t}\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_STATUS);\n\t\t\t\t\tif (r.status === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].cloud.ConnectionStatus.DISCONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the cloud connection status.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<CloudConnectionStatus>}\n\t */\n\tasync getCloudConnectionStatus({ timeout = _config__WEBPACK_IMPORTED_MODULE_3__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].CLOUD_STATUS, null /* msg */, { timeout });\n\t\treturn CloudConnectionStatus.fromProtobuf(r.status);\n\t}\n\n\t/**\n\t * Set the claim code.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {String} code Claim code.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tsetClaimCode(code, { timeout = _config__WEBPACK_IMPORTED_MODULE_3__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].SET_CLAIM_CODE, { code }, { timeout });\n\t}\n\n\t/**\n\t * Check if the device is claimed.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Boolean>}\n\t */\n\tisClaimed({ timeout = _config__WEBPACK_IMPORTED_MODULE_3__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].IS_CLAIMED, null /* msg */, { timeout }).then(rep => rep.claimed);\n\t}\n\n\t/**\n\t * Set the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePrivateKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_DEVICE_PRIVATE_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePrivateKey(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_DEVICE_PRIVATE_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_DEVICE_PUBLIC_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_DEVICE_PUBLIC_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_SERVER_PUBLIC_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].ServerProtocolType.UDP_PROTOCOL ? _protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.UDP_SERVER_PUBLIC_KEY :\n\t\t\t\t_protocol__WEBPACK_IMPORTED_MODULE_4__[\"default\"].SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} data Host address.\n\t * @param {Number} port Port number.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerAddress(address, port, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].SET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol,\n\t\t\t\taddress: address,\n\t\t\t\tport: port // TODO: Make port number optional\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Object>}\n\t */\n\tgetServerAddress(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].GET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} protocol Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerProtocol(protocol) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].SET_SERVER_PROTOCOL, {\n\t\t\tprotocol: ServerProtocol.toProtobuf(protocol)\n\t\t});\n\t}\n\n\t/**\n\t * Get the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetServerProtocol() {\n\t\treturn this._getServerProtocol().then(protocol => ServerProtocol.fromProtobuf(protocol));\n\t}\n\n\t_setSecurityKey(type, data) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].SET_SECURITY_KEY, { type: type, data: data });\n\t}\n\n\t_getSecurityKey(type) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].GET_SECURITY_KEY, { type: type }).then(rep => rep.data);\n\t}\n\n\t_getServerProtocol(protocol) {\n\t\tif (protocol) {\n\t\t\treturn Promise.resolve(ServerProtocol.toProtobuf(protocol));\n\t\t}\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].GET_SERVER_PROTOCOL).then(rep => rep.protocol);\n\t}\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cloud-device.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/*! exports provided: globalOptions, config */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globalOptions\", function() { return globalOptions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return config; });\n// Global configuration\nlet globalOptions = {\n\t// Request timeout\n\trequestTimeout: 60000,\n\t// Logger instance\n\tlog: {\n\t\ttrace: () => {},\n\t\tinfo: () => {},\n\t\twarn: () => {},\n\t\terror: () => {}\n\t}\n};\n\n/**\n * Set global options.\n *\n * @param {Object} [options] Options.\n * @param {Number} [options.requestTimeout=60000] Default request timeout (milliseconds).\n * @param {Object} [options.log] Logger instance. The logger is expected to have the following methods:\n *                 `trace(String)`, `info(String)`, `warn(String)`, `error(String)`.\n * @return {Object} Current options.\n */\nfunction config(options) {\n\treturn Object.assign(globalOptions, options);\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./src/config.js?");

/***/ }),

/***/ "./src/device-base.js":
/*!****************************!*\
  !*** ./src/device-base.js ***!
  \****************************/
/*! exports provided: PollingPolicy, DeviceBase, getDevices, openDeviceById */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PollingPolicy\", function() { return PollingPolicy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeviceBase\", function() { return DeviceBase; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDevices\", function() { return getDevices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openDeviceById\", function() { return openDeviceById; });\n/* harmony import */ var _usb_device_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./usb-device-node */ \"./src/usb-device-webusb.js\");\n/* harmony import */ var _usb_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\n/* harmony import */ var _device_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./device-type */ \"./src/device-type.js\");\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./config */ \"./src/config.js\");\n/* harmony import */ var _dfu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dfu */ \"./src/dfu.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\n\n\n// Device descriptions arranged by vendor/product IDs\nconst DEVICE_INFO = _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DEVICES\"].reduce((obj, dev) => {\n\tdev = Object.assign({}, dev);\n\tconst ids = dev.usbIds;\n\tdelete dev.usbIds;\n\tconst dfuIds = dev.dfuUsbIds;\n\tdelete dev.dfuUsbIds;\n\tif (!(ids.vendorId in obj)) {\n\t\tobj[ids.vendorId] = {};\n\t}\n\tobj[ids.vendorId][ids.productId] = Object.assign({ dfu: false }, dev);\n\tif (!(dfuIds.vendorId in obj)) {\n\t\tobj[dfuIds.vendorId] = {};\n\t}\n\tobj[dfuIds.vendorId][dfuIds.productId] = Object.assign({ dfu: true }, dev);\n\treturn obj;\n}, {});\n\nfunction deviceInfoForUsbIds(vendorId, productId) {\n\tlet info = DEVICE_INFO[vendorId];\n\tif (info) {\n\t\tinfo = info[productId];\n\t}\n\treturn info;\n}\n\n// Default backoff intervals for the CHECK service request\nconst DEFAULT_CHECK_INTERVALS = [50, 50, 100, 100, 250, 250, 500, 500, 1000];\n\nfunction checkInterval(attempts, intervals) {\n\tif (attempts < intervals.length) {\n\t\treturn intervals[attempts];\n\t}\n\treturn intervals[intervals.length - 1];\n}\n\n/**\n * Predefined polling policies.\n *\n * @enum {Function}\n */\nconst PollingPolicy = {\n\t/** Default polling policy. */\n\tDEFAULT: n => checkInterval(n, DEFAULT_CHECK_INTERVALS)\n};\n\n// Device state\nconst DeviceState = {\n\tCLOSED: 0,\n\tOPENING: 1,\n\tOPEN: 2,\n\tCLOSING: 3\n};\n\n// Low-level vendor requests as defined by the firmware's ctrl_request_type enum\nconst VendorRequest = {\n\tSYSTEM_VERSION: 30 // Get system version\n};\n\n// Dummy callback function\nfunction ignore() {\n}\n\n/**\n * Base class for a Particle USB device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass DeviceBase extends events__WEBPACK_IMPORTED_MODULE_6___default.a {\n\tconstructor(dev, info) {\n\t\tsuper();\n\t\tthis._dev = dev; // USB device handle\n\t\tthis._info = info; // Device info\n\t\tthis._log = _config__WEBPACK_IMPORTED_MODULE_4__[\"globalOptions\"].log; // Logger instance\n\t\tthis._state = DeviceState.CLOSED; // Device state\n\t\tthis._reqs = new Map(); // All known requests\n\t\tthis._reqQueue = []; // Unprocessed requests\n\t\tthis._checkQueue = []; // Active requests that need to be checked\n\t\tthis._resetQueue = []; // Active requests that need to be reset\n\t\tthis._activeReqs = 0; // Number of active requests\n\t\tthis._maxActiveReqs = null; // Maximum number of active requests\n\t\tthis._lastReqId = 0; // Last used request ID\n\t\tthis._closeTimer = null; // Timer for the closing operation\n\t\tthis._wantClose = false; // Set to true if the device needs to be closed\n\t\tthis._resetAllReqs = false; // Set to true if all requests need to be reset\n\t\tthis._busy = false; // Set to true if there's an activity on the USB connection\n\t\tthis._fwVer = null; // Firmware version\n\t\tthis._id = null; // Device ID\n\t\tthis._dfu = null; // DFU class implementation\n\t}\n\n\t/**\n\t * Open the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.concurrentRequests] Maximum number of requests that can be sent to the\n\t *        device concurrently. Requests that exceed this limit are queued. By default, this parameter\n\t *        is set to the maximum number of concurrent requests supported by the device.\n\t * @return {Promise}\n\t */\n\topen(options) {\n\t\toptions = Object.assign({\n\t\t\tconcurrentRequests: null // The maximum number of concurrent requests is limited by the device\n\t\t}, options);\n\t\tif (this._state !== DeviceState.CLOSED) {\n\t\t\treturn Promise.reject(new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device is already open'));\n\t\t}\n\t\t// Open USB device\n\t\tthis._log.trace('Opening device');\n\t\tthis._state = DeviceState.OPENING;\n\t\treturn this._dev.open().then(() => {\n\t\t\t// Normalize the device ID string\n\t\t\tthis._id = this._dev.serialNumber.replace(/[^\\x20-\\x7e]/g, '').toLowerCase();\n\t\t\tthis._log.trace(`Device ID: ${this._id}`);\n\n\t\t\t// Get firmware version\n\t\t\treturn this._getFirmwareVersion().then(ver => {\n\t\t\t\tthis._fwVer = ver;\n\t\t\t\tthis._log.trace(`Firmware version: ${this._fwVer}`);\n\t\t\t}).catch(err => {\n\t\t\t\t// Pre-0.6.0 firmwares and devices in DFU mode don't support the firmware version request\n\t\t\t\tif (!this._info.dfu) {\n\t\t\t\t\tthis._log.trace(`Unable to get firmware version: ${err.message}`);\n\t\t\t\t}\n\t\t\t});\n\t\t}).then(() => {\n\t\t\tif (this._info.dfu) {\n\t\t\t\tthis._dfu = new _dfu__WEBPACK_IMPORTED_MODULE_5__[\"Dfu\"](this._dev, this._log);\n\t\t\t\treturn this._dfu.open(options);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tthis._log.trace('Device is open');\n\t\t\tthis._maxActiveReqs = options.concurrentRequests;\n\t\t\tthis._resetAllReqs = true; // Reset all requests remaining from a previous session\n\t\t\tthis._state = DeviceState.OPEN;\n\t\t\tthis.emit('open');\n\t\t\tthis._process();\n\t\t}).catch(err => {\n\t\t\treturn this._close(err).catch(ignore).then(() => {\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Close the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.processPendingRequests=true] Whether to complete processing of the\n\t *        pending requests before closing the device.\n\t * @param {Number} [options.timeout] Timeout for processing pending requests (milliseconds).\n\t *        By default, the device is kept open until all requests are processed.\n\t * @return {Promise}\n\t */\n\tclose(options) {\n\t\toptions = Object.assign({\n\t\t\tprocessPendingRequests: true, // Process pending requests before closing the device\n\t\t\ttimeout: null // Wait until all requests are processed\n\t\t}, options);\n\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\t// Check if pending requests need to be processed before closing the device\n\t\tif (!options.processPendingRequests) {\n\t\t\tthis._rejectAllRequests(new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device is being closed'));\n\t\t\tif (this._closeTimer) {\n\t\t\t\tclearTimeout(this._closeTimer);\n\t\t\t\tthis._closeTimer = null;\n\t\t\t}\n\t\t} else if (options.timeout && !this._wantClose) { // Timeout cannot be overriden\n\t\t\tthis._closeTimer = setTimeout(() => {\n\t\t\t\tthis._rejectAllRequests(new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device is being closed'));\n\t\t\t\tthis._process();\n\t\t\t}, options.timeout);\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\t// Use EventEmitter's queue to resolve the promise\n\t\t\tthis.once('closed', () => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t\tthis._wantClose = true;\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Send a control request to the device.\n\t *\n\t * @param {Number} type Request type.\n\t * @param {Buffer|String} data Request data.\n\t * @param {Object} [options] Request options.\n\t * @param {Function|Number} [options.pollingPolicy=PollingPolicy.DEFAULT] Request polling policy.\n\t *        This parameter specifies how frequently the device will be polled to determine the result\n\t *        of the request. The argument can either be a function that returns the number of milliseconds\n\t *        to wait before polling the device again or a number that specifies a fixed interval.\n\t * @param {Number} [options.timeout] Request timeout. The default timeout can be configured via\n\t *        {@link config}.\n\t * @return {Promise<Object>} Response object.\n\t */\n\tsendControlRequest(type, data, options) {\n\t\toptions = Object.assign({\n\t\t\tpollingPolicy: PollingPolicy.DEFAULT, // Polling policy\n\t\t\ttimeout: _config__WEBPACK_IMPORTED_MODULE_4__[\"globalOptions\"].requestTimeout // Request timeout\n\t\t}, options);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device is not open');\n\t\t\t}\n\t\t\tif (this._state === DeviceState.CLOSING || this._wantClose) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device is being closed');\n\t\t\t}\n\t\t\tif (type < 0 || type > _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"MAX_REQUEST_TYPE\"]) {\n\t\t\t\tthrow new RangeError('Invalid request type');\n\t\t\t}\n\t\t\tconst dataIsStr = (typeof data === 'string');\n\t\t\tif (dataIsStr) {\n\t\t\t\tdata = Buffer.from(data);\n\t\t\t}\n\t\t\tif (data && data.length > _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"MAX_PAYLOAD_SIZE\"]) {\n\t\t\t\tthrow new RangeError('Request data is too large');\n\t\t\t}\n\t\t\tconst req = {\n\t\t\t\tid: ++this._lastReqId, // Internal request ID\n\t\t\t\ttype: type,\n\t\t\t\tdata: data,\n\t\t\t\tdataIsStr: dataIsStr,\n\t\t\t\tdataSent: false,\n\t\t\t\tprotoId: null, // Protocol request ID\n\t\t\t\tcheckInterval: options.pollingPolicy,\n\t\t\t\tcheckIntervalIsFunc: (typeof options.pollingPolicy === 'function'),\n\t\t\t\tcheckTimer: null,\n\t\t\t\tcheckCount: 0,\n\t\t\t\treqTimer: null,\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t\tif (options.timeout) {\n\t\t\t\t// Start request timer\n\t\t\t\treq.reqTimer = setTimeout(() => {\n\t\t\t\t\tthis._rejectRequest(req, new _error__WEBPACK_IMPORTED_MODULE_3__[\"TimeoutError\"]('Request timeout'));\n\t\t\t\t\tthis._process();\n\t\t\t\t}, options.timeout);\n\t\t\t}\n\t\t\tthis._reqs.set(req.id, req);\n\t\t\tthis._reqQueue.push(req);\n\t\t\tthis._log.trace(`Request ${req.id}: Enqueued`);\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * This method only works in DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync reset() {\n\t\tif (this._dfu) {\n\t\t\treturn this._dfu.leave();\n\t\t}\n\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]();\n\t}\n\n\t/**\n\t * Set to `true` if the device is open.\n\t */\n\tget isOpen() {\n\t\treturn (this._state !== DeviceState.CLOSED);\n\t}\n\n\t/**\n\t * Device ID.\n\t *\n\t * This property is set to `null` if the device is closed.\n\t */\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Device OS system version.\n\t *\n\t * This property is set to `null` if the device is closed or the version could not be determined.\n\t */\n\tget firmwareVersion() {\n\t\treturn this._fwVer;\n\t}\n\n\t/**\n\t * Device type (see {@link DeviceType}).\n\t */\n\tget type() {\n\t\treturn this._info.type;\n\t}\n\n\t/**\n\t * Platform ID.\n\t */\n\tget platformId() {\n\t\treturn this._info.platformId;\n\t}\n\n\t/**\n\t * Set to `true` if this is a Core device.\n\t */\n\tget isCore() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].CORE);\n\t}\n\n\t/**\n\t * Set to `true` if this is a Photon device.\n\t */\n\tget isPhoton() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].PHOTON);\n\t}\n\n\t/**\n\t * Set to `true` if this is a P1 device.\n\t */\n\tget isP1() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].P1);\n\t}\n\n\t/**\n\t * Set to `true` if this is an Electron device.\n\t */\n\tget isElectron() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].ELECTRON);\n\t}\n\n\t/**\n\t * Set to `true` if this is a RedBear Duo device.\n\t */\n\tget isDuo() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].DUO);\n\t}\n\n\t/**\n\t * Set to `true` if this is a Xenon device.\n\t */\n\tget isXenon() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].XENON);\n\t}\n\n\t/**\n\t * Set to `true` if this is an Argon device.\n\t */\n\tget isArgon() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].ARGON);\n\t}\n\n\t/**\n\t * Set to `true` if this is a Boron device.\n\t */\n\tget isBoron() {\n\t\treturn (this.type === _device_type__WEBPACK_IMPORTED_MODULE_2__[\"DeviceType\"].BORON);\n\t}\n\n\t/**\n\t * USB vendor ID.\n\t */\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\t/**\n\t * USB product ID.\n\t */\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\t/**\n\t * Set to `true` if this device is in the DFU mode.\n\t */\n\tget isInDfuMode() {\n\t\treturn this._info.dfu;\n\t}\n\n\t/**\n\t * Internal USB device handle.\n\t */\n\tget usbDevice() {\n\t\treturn this._dev;\n\t}\n\n\t_process() {\n\t\tif (this._state === DeviceState.CLOSED || this._state === DeviceState.OPENING || this._busy) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._wantClose && this._state !== DeviceState.CLOSING) {\n\t\t\tthis._log.trace('Closing device');\n\t\t\tthis._state = DeviceState.CLOSING;\n\t\t}\n\t\tif (this._resetAllRequests()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._resetNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._checkNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._sendNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._state === DeviceState.CLOSING && this._activeReqs === 0) {\n\t\t\tthis._close();\n\t\t}\n\t}\n\n\t_resetAllRequests() {\n\t\tif (!this._resetAllReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace('Sending RESET');\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"resetRequest\"]();\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tthis._resetAllReqs = false;\n\t\t\tthis._activeReqs = 0;\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_resetNextRequest() {\n\t\tif (this._resetQueue.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst req = this._resetQueue.shift();\n\t\tthis._log.trace(`Request ${req.id}: Sending RESET`);\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"resetRequest\"](req.protoId);\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(--this._activeReqs >= 0);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_checkNextRequest() {\n\t\tlet req = null;\n\t\twhile (this._checkQueue.length !== 0) {\n\t\t\tconst r = this._checkQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending CHECK (${req.checkCount})`);\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"checkRequest\"](req.protoId);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].OK: {\n\t\t\t\t\tif (req.dataSent) {\n\t\t\t\t\t\t// Request processing is completed\n\t\t\t\t\t\tconst rep = {\n\t\t\t\t\t\t\tresult: srep.result\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (srep.size) {\n\t\t\t\t\t\t\t// Receive payload data\n\t\t\t\t\t\t\treturn this._recvReplyData(req, srep.size).then(data => {\n\t\t\t\t\t\t\t\trep.data = req.dataIsStr ? data.toString() : data;\n\t\t\t\t\t\t\t\tthis._resolveRequest(req, rep);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveRequest(req, rep); // No reply data\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Buffer allocation is completed, send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\treq.checkCount = 0; // Reset check counter\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].PENDING: {\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].NO_MEMORY: {\n\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"MemoryError\"]('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].NOT_FOUND: {\n\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"DeviceError\"]('Request was cancelled');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"ProtocolError\"](`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendNextRequest() {\n\t\tif (this._maxActiveReqs && this._activeReqs >= this._maxActiveReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tlet req = null;\n\t\twhile (this._reqQueue.length !== 0) {\n\t\t\tconst r = this._reqQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending INIT`);\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"initRequest\"](req.type, req.data ? req.data.length : 0);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tif (srep.status === _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].OK || srep.status === _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].PENDING) {\n\t\t\t\treq.protoId = srep.id;\n\t\t\t\t++this._activeReqs;\n\t\t\t\tthis._log.trace(`Request ${req.id}: Protocol ID: ${req.protoId}`);\n\t\t\t}\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].OK: {\n\t\t\t\t\tif (req.data && req.data.length > 0) {\n\t\t\t\t\t\t// Send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.dataSent = true; // No payload data\n\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].PENDING: {\n\t\t\t\t\tif (!req.data || req.data.length === 0) {\n\t\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"ProtocolError\"](`Unexpected status code: ${srep.status}`);\n\t\t\t\t\t}\n\t\t\t\t\t// Buffer allocation is pending\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].BUSY: {\n\t\t\t\t\t// Update maximum number of active requests\n\t\t\t\t\tthis._maxActiveReqs = this._activeReqs;\n\t\t\t\t\t// Return the request back to queue\n\t\t\t\t\tthis._reqQueue.unshift(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"Status\"].NO_MEMORY: {\n\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"MemoryError\"]('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"ProtocolError\"](`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendRequestData(req) {\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(req.data && req.data.length > 0);\n\t\tlet offs = 0;\n\t\tconst sendNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(_usb_device_node__WEBPACK_IMPORTED_MODULE_0__[\"MAX_CONTROL_TRANSFER_DATA_SIZE\"], req.data.length - offs);\n\t\t\tconst chunk = req.data.slice(offs, offs + chunkSize);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending SEND`);\n\t\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"sendRequest\"](req.protoId, chunkSize);\n\t\t\treturn this._dev.transferOut(setup, chunk).then(() => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Sent ${chunkSize} bytes`);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < req.data.length) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn sendNextChunk();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\treturn sendNextChunk();\n\t}\n\n\t_recvReplyData(req, size) {\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(size > 0);\n\t\tconst buf = Buffer.alloc(size);\n\t\tlet offs = 0;\n\t\tconst recvNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(_usb_device_node__WEBPACK_IMPORTED_MODULE_0__[\"MAX_CONTROL_TRANSFER_DATA_SIZE\"], size - offs);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending RECV`);\n\t\t\tconst setup = _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"recvRequest\"](req.protoId, chunkSize);\n\t\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Received ${data.length} bytes`);\n\t\t\t\tif (data.length !== chunkSize) {\n\t\t\t\t\tthrow new Error('Unexpected size of the control transfer');\n\t\t\t\t}\n\t\t\t\tdata.copy(buf, offs);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < size) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn recvNextChunk();\n\t\t\t\t}\n\t\t\t\treturn buf;\n\t\t\t});\n\t\t};\n\t\treturn recvNextChunk();\n\t}\n\n\t_close(err = null) {\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(!this._busy);\n\t\t// Cancel all requests\n\t\tif (this._reqs.size !== 0) {\n\t\t\tif (!err) {\n\t\t\t\terr = new _error__WEBPACK_IMPORTED_MODULE_3__[\"StateError\"]('Device has been closed');\n\t\t\t}\n\t\t\tthis._rejectAllRequests(err);\n\t\t}\n\t\tthis._activeReqs = 0;\n\t\tthis._resetAllReqs = false;\n\t\t// Cancel timers\n\t\tif (this._closeTimer) {\n\t\t\tclearTimeout(this._closeTimer);\n\t\t\tthis._closeTimer = null;\n\t\t}\n\n\t\tlet p = Promise.resolve();\n\t\tif (this._dfu) {\n\t\t\tp = p.then(() => this._dfu.close()).catch(err => {\n\t\t\t\tthis._log.warn(`Unable to close DFU interface: ${err.message}`);\n\t\t\t});\n\t\t}\n\t\t// Close USB device\n\t\treturn p.then(() => this._dev.close()).catch(err => {\n\t\t\tthis._log.warn(`Unable to close USB device: ${err.message}`);\n\t\t}).then(() => {\n\t\t\t// Reset device state\n\t\t\tconst emitEvent = (this._state === DeviceState.CLOSING);\n\t\t\tthis._state = DeviceState.CLOSED;\n\t\t\tthis._wantClose = false;\n\t\t\tthis._maxActiveReqs = null;\n\t\t\tthis._fwVer = null;\n\t\t\tthis._id = null;\n\t\t\tif (emitEvent) {\n\t\t\t\tthis.emit('closed');\n\t\t\t}\n\t\t});\n\t}\n\n\t_rejectAllRequests(err) {\n\t\tthis._reqs.forEach(req => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t});\n\t\tthis._reqQueue = [];\n\t\tthis._checkQueue = [];\n\t\tthis._resetQueue = [];\n\t\tif (this._activeReqs > 0) {\n\t\t\tthis._resetAllReqs = true;\n\t\t}\n\t}\n\n\t_rejectRequest(req, err) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Failed: ${err.message}`);\n\t\tthis._clearRequest(req);\n\t\tif (req.protoId) {\n\t\t\tthis._resetQueue.push(req);\n\t\t}\n\t\treq.reject(err);\n\t}\n\n\t_resolveRequest(req, rep) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Completed`);\n\t\tthis._clearRequest(req);\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(--this._activeReqs >= 0);\n\t\treq.resolve(rep);\n\t}\n\n\t_clearRequest(req) {\n\t\tif (req.checkTimer) {\n\t\t\tclearTimeout(req.checkTimer);\n\t\t\treq.checkTimer = null;\n\t\t}\n\t\tif (req.reqTimer) {\n\t\t\tclearTimeout(req.reqTimer);\n\t\t\treq.reqTimer = null;\n\t\t}\n\t\tthis._reqs.delete(req.id);\n\t\treq.done = true;\n\t}\n\n\t_startCheckTimer(req) {\n\t\tlet timeout = req.checkInterval;\n\t\tif (req.checkIntervalIsFunc) {\n\t\t\ttimeout = timeout(req.checkCount);\n\t\t}\n\t\t++req.checkCount;\n\t\tsetTimeout(() => {\n\t\t\tthis._checkQueue.push(req);\n\t\t\tthis._process();\n\t\t}, timeout);\n\t}\n\n\t_getFirmwareVersion() {\n\t\tconst setup = {\n\t\t\tbmRequestType: _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"BmRequestType\"].DEVICE_TO_HOST,\n\t\t\tbRequest: _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"PARTICLE_BREQUEST\"],\n\t\t\twIndex: VendorRequest.SYSTEM_VERSION,\n\t\t\twValue: 0,\n\t\t\twLength: _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"MIN_WLENGTH\"]\n\t\t};\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\treturn data.toString();\n\t\t});\n\t}\n\n\t// Sends a service request and parses the reply data\n\t_sendServiceRequest(setup) {\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\treturn _usb_protocol__WEBPACK_IMPORTED_MODULE_1__[\"parseReply\"](data);\n\t\t});\n\t}\n}\n\nasync function getDevices({ types = [], includeDfu = true } = {}) {\n\ttypes = types.map(type => type.toLowerCase());\n\tconst filters = [];\n\t_device_type__WEBPACK_IMPORTED_MODULE_2__[\"DEVICES\"].forEach(dev => {\n\t\tif (types.length === 0 || types.includes(dev.type.toLowerCase())) {\n\t\t\tfilters.push(dev.usbIds);\n\t\t\tif (includeDfu) {\n\t\t\t\tfilters.push(dev.dfuUsbIds);\n\t\t\t}\n\t\t}\n\t});\n\tif (filters.length === 0) {\n\t\treturn [];\n\t}\n\tconst devs = await Object(_usb_device_node__WEBPACK_IMPORTED_MODULE_0__[\"getUsbDevices\"])(filters);\n\treturn devs.map(dev => {\n\t\tconst info = deviceInfoForUsbIds(dev.vendorId, dev.productId);\n\t\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(info);\n\t\treturn new DeviceBase(dev, info);\n\t});\n}\n\nasync function openDeviceById(id, options = null) {\n\tconst log = _config__WEBPACK_IMPORTED_MODULE_4__[\"globalOptions\"].log;\n\tconst filters = [];\n\t_device_type__WEBPACK_IMPORTED_MODULE_2__[\"DEVICES\"].forEach(dev => {\n\t\tfilters.push(Object.assign({ serialNumber: id }, dev.usbIds));\n\t\tfilters.push(Object.assign({ serialNumber: id }, dev.dfuUsbIds));\n\t});\n\tconst devs = await Object(_usb_device_node__WEBPACK_IMPORTED_MODULE_0__[\"getUsbDevices\"])(filters);\n\tif (devs.length === 0) {\n\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_3__[\"NotFoundError\"]('Device is not found');\n\t}\n\tif (devs.length !== 1) {\n\t\tlog.warn(`Found multiple devices with the same ID: ${id}`); // lol\n\t}\n\tlet dev = devs[0];\n\tconst info = deviceInfoForUsbIds(dev.vendorId, dev.productId);\n\tObject(_error__WEBPACK_IMPORTED_MODULE_3__[\"assert\"])(info);\n\tdev = new DeviceBase(dev, info);\n\tawait dev.open(options);\n\treturn dev;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/device-base.js?");

/***/ }),

/***/ "./src/device-type.js":
/*!****************************!*\
  !*** ./src/device-type.js ***!
  \****************************/
/*! exports provided: DeviceType, DEVICES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeviceType\", function() { return DeviceType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEVICES\", function() { return DEVICES; });\n/**\n * Device types.\n *\n * @enum {String}\n */\nconst DeviceType = {\n\t/** Core. */\n\tCORE: 'Core',\n\t/** Photon. */\n\tPHOTON: 'Photon',\n\t/** P1. */\n\tP1: 'P1',\n\t/** Electron. */\n\tELECTRON: 'Electron',\n\t/** Argon. */\n\tARGON: 'Argon',\n\t/** Boron. */\n\tBORON: 'Boron',\n\t/** Xenon. */\n\tXENON: 'Xenon',\n\t/** A SoM. */\n\tARGON_SOM: 'Argon-SoM',\n\t/** B SoM. */\n\tBORON_SOM: 'Boron-SoM',\n\t/** X SoM. */\n\tXENON_SOM: 'Xenon-SoM',\n\t/** B5 SoM. */\n\tB5_SOM: 'B5-SoM',\n\t/** Tracker. */\n\tASSET_TRACKER: 'Asset-Tracker'\n};\n\n// Descriptions of all devices supported by the library\nconst DEVICES = [\n\t{\n\t\ttype: DeviceType.CORE,\n\t\tplatformId: 0,\n\t\tusbIds: {\n\t\t\tvendorId: 0x1d50,\n\t\t\tproductId: 0x607d\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x1d50,\n\t\t\tproductId: 0x607f\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.PHOTON,\n\t\tplatformId: 6,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc006\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd006\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.P1,\n\t\tplatformId: 8,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc008\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd008\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.ELECTRON,\n\t\tplatformId: 10,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc00a\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd00a\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.ARGON,\n\t\tplatformId: 12,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc00c\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd00c\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.BORON,\n\t\tplatformId: 13,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc00d\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd00d\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.XENON,\n\t\tplatformId: 14,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc00e\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd00e\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.ARGON_SOM,\n\t\tplatformId: 22,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc016\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd016\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.BORON_SOM,\n\t\tplatformId: 23,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc017\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd017\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.XENON_SOM,\n\t\tplatformId: 24,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc018\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd018\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.B5_SOM,\n\t\tplatformId: 25,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc019\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd019\n\t\t}\n\t},\n\t{\n\t\ttype: DeviceType.ASSET_TRACKER,\n\t\tplatformId: 26,\n\t\tusbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xc01a\n\t\t},\n\t\tdfuUsbIds: {\n\t\t\tvendorId: 0x2b04,\n\t\t\tproductId: 0xd01a\n\t\t}\n\t}\n];\n\n\n//# sourceURL=webpack://ParticleUsb/./src/device-type.js?");

/***/ }),

/***/ "./src/device.js":
/*!***********************!*\
  !*** ./src/device.js ***!
  \***********************/
/*! exports provided: FirmwareModule, DeviceMode, LogLevel, Device */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FirmwareModule\", function() { return FirmwareModule; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeviceMode\", function() { return DeviceMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LogLevel\", function() { return LogLevel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Device\", function() { return Device; });\n/* harmony import */ var _device_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./result */ \"./src/result.js\");\n/* harmony import */ var _protobuf_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n/* harmony import */ var _usb_protocol__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./config */ \"./src/config.js\");\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Firmware module types.\n *\n * @enum {String}\n */\nconst FirmwareModule = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_3__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].FirmwareModuleType, {\n\t/** Bootloader module. */\n\tBOOTLOADER: 'BOOTLOADER',\n\t/** System part module. */\n\tSYSTEM_PART: 'SYSTEM_PART',\n\t/** User part module. */\n\tUSER_PART: 'USER_PART',\n\t/** Monolithic firmware module. */\n\tMONO_FIRMWARE: 'MONO_FIRMWARE'\n});\n\n/**\n * Device modes.\n *\n * @enum {String}\n */\nconst DeviceMode = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_3__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].DeviceMode, {\n\t/** Device is in normal mode. */\n\tNORMAL: 'NORMAL_MODE',\n\t/** Device is in listening mode. */\n\tLISTENING: 'LISTENING_MODE'\n});\n\n/**\n * Logging levels.\n *\n * @enum {String}\n */\nconst LogLevel = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_3__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.LogLevel, {\n\t/** Enables logging of all messages. */\n\tALL: 'ALL',\n\t/** Enables logging of trace messages. */\n\tTRACE: 'TRACE',\n\t/** Enables logging of info messages. */\n\tINFO: 'INFO',\n\t/** Enables logging of warning messages. */\n\tWARN: 'WARN',\n\t/** Enables logging of error messages. */\n\tERROR: 'ERROR',\n\t/** Disables logging of any messages. */\n\tNONE: 'NONE'\n});\n\nconst DEFAULT_FIRMWARE_UPDATE_TIMEOUT = 120000;\n\n// Helper class used by Device.timeout()\nclass RequestSender {\n\tconstructor(device, timeout) {\n\t\tthis.id = device.id;\n\t\tthis.device = device;\n\t\tthis._timeoutTime = Date.now() + timeout;\n\t}\n\n\tasync open(options) {\n\t\tthis.device = await Object(_device_base__WEBPACK_IMPORTED_MODULE_0__[\"openDeviceById\"])(this.id, options);\n\t}\n\n\tasync close() {\n\t\tawait this.device.close();\n\t}\n\n\tasync sendRequest(req, msg, opts) {\n\t\tif (!opts || !opts.timeout) {\n\t\t\tconst t = this._timeoutTime - Date.now();\n\t\t\tif (t <= 0) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"TimeoutError\"]();\n\t\t\t}\n\t\t\topts = Object.assign({}, opts, { timeout: t });\n\t\t} else if (Date.now() + opts.timeout >= this._timeoutTime) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"TimeoutError\"]();\n\t\t}\n\t\treturn this.device.sendRequest(req, msg, opts);\n\t}\n\n\tasync delay(ms) {\n\t\tif (Date.now() + ms >= this._timeoutTime) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"TimeoutError\"]();\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\tsetTimeout(() => resolve(), ms);\n\t\t});\n\t}\n}\n\n/**\n * Basic functionality supported by most of Particle devices.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass Device extends _device_base__WEBPACK_IMPORTED_MODULE_0__[\"DeviceBase\"] {\n\t/**\n\t * Get the device's serial number.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.5.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getSerialNumber({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].GET_SERIAL_NUMBER, null /* msg */, { timeout });\n\t\treturn r.serial;\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.force] Reset the device immediately, even if it is busy performing\n\t *        some blocking operation, such as writing to flash.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync reset({ force = false, timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn super.reset();\n\t\t}\n\t\tif (!force) {\n\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].RESET, null /* msg */, { timeout });\n\t\t}\n\t\tconst setup = {\n\t\t\tbmRequestType: _usb_protocol__WEBPACK_IMPORTED_MODULE_4__[\"BmRequestType\"].HOST_TO_DEVICE,\n\t\t\tbRequest: _usb_protocol__WEBPACK_IMPORTED_MODULE_4__[\"PARTICLE_BREQUEST\"],\n\t\t\twIndex: _request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].RESET.id,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this.usbDevice.transferOut(setup);\n\t}\n\n\t/**\n\t * Perform the factory reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tfactoryReset({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].FACTORY_RESET, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Reset and enter the DFU mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterDfuMode({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].DFU_MODE);\n\t\t\tawait s.close();\n\t\t\tlet isInDfuMode;\n\n\t\t\twhile (!isInDfuMode) {\n\t\t\t\ttry {\n\t\t\t\t\tawait s.open({ includeDfu: true });\n\t\t\t\t\tisInDfuMode = s.device.isInDfuMode;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// device is reconnecting, ignore\n\t\t\t\t}\n\t\t\t\tawait s.close();\n\t\t\t\tawait s.delay(500);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Reset and enter the safe mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterSafeMode({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].SAFE_MODE, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Enter the listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync enterListeningMode({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].START_LISTENING);\n\t\t\t// Wait until the device enters the listening mode\n\t\t\twhile (true) { // eslint-disable-line no-constant-condition\n\t\t\t\tconst r = await s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].GET_DEVICE_MODE, null, {\n\t\t\t\t\tdontThrow: true // This request may not be supported by the device\n\t\t\t\t});\n\t\t\t\tif (r.result !== _result__WEBPACK_IMPORTED_MODULE_2__[\"Result\"].OK || r.mode === _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].DeviceMode.LISTENING_MODE) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tawait s.delay(500);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Leave the listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tleaveListeningMode({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].STOP_LISTENING, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Get the device mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<DeviceMode>}\n\t */\n\tasync getDeviceMode({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].GET_DEVICE_MODE, null /* msg */, { timeout });\n\t\treturn DeviceMode.fromProtobuf(r.mode);\n\t}\n\n\t/**\n\t * Start the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstartNyanSignal({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].START_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Stop the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstopNyanSignal({ timeout = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout } = {}) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].STOP_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Perform the firmware update.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync updateFirmware(data, { timeout = DEFAULT_FIRMWARE_UPDATE_TIMEOUT } = {}) {\n\t\tif (!data.length) {\n\t\t\tthrow new RangeError('Invalid firmware size');\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tconst { chunkSize } = await s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].START_FIRMWARE_UPDATE, { size: data.length });\n\t\t\tlet offs = 0;\n\t\t\twhile (offs < data.length) {\n\t\t\t\tconst n = Math.min(chunkSize, data.length - offs);\n\t\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].FIRMWARE_UPDATE_DATA, { data: data.slice(offs, offs + n) });\n\t\t\t\toffs += n;\n\t\t\t}\n\t\t\tawait s.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].FINISH_FIRMWARE_UPDATE, { validateOnly: false });\n\t\t});\n\t}\n\n\t/**\n\t * Get firmware module data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} module Module type.\n\t * @param {Number} [index] Module index.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFirmwareModule(module, index) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tconst section = storage.modules.find(section => {\n\t\t\t\treturn (section.moduleType === module && section.moduleIndex === index);\n\t\t\t});\n\t\t\tif (!section) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(section).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(section, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Check if the device runs a modular firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Boolean>}\n\t */\n\thasModularFirmware() {\n\t\treturn this._getStorageInfo().then(storage => storage.hasModularFirmware);\n\t}\n\n\t/**\n\t * Set factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @return {Promise}\n\t */\n\tsetFactoryFirmware(data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.factory, 0, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFactoryFirmware() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(storage.factory).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(storage.factory, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Read configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadConfigData(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.config, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteConfigData(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.config, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetConfigDataSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn storage.config.size;\n\t\t});\n\t}\n\n\t/**\n\t * Read from EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadEeprom(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.eeprom, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write to EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteEeprom(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.eeprom, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Clear EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearEeprom() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn this._clearSectionData(storage.eeprom);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetEepromSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"NotFoundError\"]();\n\t\t\t}\n\t\t\treturn storage.eeprom.size;\n\t\t});\n\t}\n\n\t/**\n\t * Add a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @param {String} options.stream Output stream: `Serial`, `Serial1`, `USBSerial1`, etc.\n\t * @param {String} [options.format] Message format: `default`, `json`.\n\t * @param {String} [options.level] Default logging level: `trace`, `info`, `warn`, `error`, `none`, `all`.\n\t * @param {Array} [options.filters] Category filters.\n\t * @param {Number} [options.baudRate] Baud rate.\n\t * @return {Promise}\n\t */\n\tasync addLogHandler({ id, stream, format, level, filters, baudRate }) {\n\t\tconst req = {\n\t\t\tid,\n\t\t\tlevel: LogLevel.toProtobuf(level || 'all')\n\t\t};\n\t\tswitch ((format || 'default').toLowerCase()) {\n\t\t\tcase 'default': {\n\t\t\t\treq.handlerType = _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.LogHandlerType.DEFAULT_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'json': {\n\t\t\t\treq.handlerType = _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.LogHandlerType.JSON_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown message format: ${format}`);\n\t\t\t}\n\t\t}\n\t\tif (!stream) {\n\t\t\tthrow new RangeError('Output stream is not specified');\n\t\t}\n\t\tswitch (stream.toLowerCase()) {\n\t\t\tcase 'serial': {\n\t\t\t\treq.streamType = _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 0\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'usbserial1': {\n\t\t\t\treq.streamType = _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'serial1': {\n\t\t\t\treq.streamType = _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].logging.StreamType.HW_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1,\n\t\t\t\t\tbaudRate\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown output stream: ${stream}`);\n\t\t\t}\n\t\t}\n\t\tif (filters) {\n\t\t\treq.filters = filters.map(f => ({\n\t\t\t\tcategory: f.category,\n\t\t\t\tlevel: LogLevel.toProtobuf(f.level)\n\t\t\t}));\n\t\t}\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].ADD_LOG_HANDLER, req);\n\t}\n\n\t/**\n\t * Remove a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @return {Promise}\n\t */\n\tasync removeLogHandler({ id }) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].REMOVE_LOG_HANDLER, { id });\n\t}\n\n\t/**\n\t * Get the list of active log handlers.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @return {Promise<Array<Object>>}\n\t */\n\tasync getLogHandlers() {\n\t\tconst rep = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].GET_LOG_HANDLERS);\n\t\treturn rep.handlers.map(h => ({\n\t\t\tid: h.id\n\t\t}));\n\t}\n\n\t// Sends a Protobuf-encoded request\n\tsendRequest(req, msg, opts) {\n\t\tlet buf = null;\n\t\tif (msg && req.request) {\n\t\t\tconst m = req.request.create(msg); // Protobuf message object\n\t\t\tbuf = req.request.encode(m).finish();\n\t\t}\n\t\treturn this.sendControlRequest(req.id, buf, opts).then(rep => {\n\t\t\tlet r = undefined;\n\t\t\tif (opts && opts.dontThrow) {\n\t\t\t\tr = { result: rep.result };\n\t\t\t} else if (rep.result !== _result__WEBPACK_IMPORTED_MODULE_2__[\"Result\"].OK) {\n\t\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_5__[\"RequestError\"](rep.result, Object(_result__WEBPACK_IMPORTED_MODULE_2__[\"messageForResultCode\"])(rep.result));\n\t\t\t}\n\t\t\tif (req.reply) {\n\t\t\t\tif (rep.data) {\n\t\t\t\t\t// Parse the response message\n\t\t\t\t\tr = Object.assign(req.reply.decode(rep.data), r);\n\t\t\t\t} else {\n\t\t\t\t\t// Create a message with default-initialized properties\n\t\t\t\t\tr = Object.assign(req.reply.create(), r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t});\n\t}\n\n\t// This method is used to send multiple requests to the device. The overall execution time can be\n\t// limited via the `ms` argument (optional)\n\tasync timeout(ms, fn) {\n\t\tif (typeof ms === 'function') {\n\t\t\tfn = ms;\n\t\t\tms = undefined;\n\t\t}\n\t\tif (!ms) {\n\t\t\tms = _config__WEBPACK_IMPORTED_MODULE_6__[\"globalOptions\"].requestTimeout; // Default timeout\n\t\t}\n\t\tconst s = new RequestSender(this, ms);\n\t\treturn fn(s);\n\t}\n\n\t_readSectionData(section, offset, size) {\n\t\tconst data = Buffer.alloc(size);\n\t\tlet chunkSize = 4096;\n\t\tlet chunkOffs = 0;\n\t\tconst readChunk = () => {\n\t\t\tif (chunkOffs + chunkSize > size) {\n\t\t\t\tchunkSize = size - chunkOffs;\n\t\t\t}\n\t\t\tif (chunkSize === 0) {\n\t\t\t\treturn Promise.resolve(data);\n\t\t\t}\n\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].READ_SECTION_DATA, {\n\t\t\t\tstorage: section.storageIndex,\n\t\t\t\tsection: section.sectionIndex,\n\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\tsize: chunkSize\n\t\t\t}).then(rep => {\n\t\t\t\trep.data.copy(data, chunkOffs);\n\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\treturn readChunk();\n\t\t\t});\n\t\t};\n\t\treturn readChunk();\n\t}\n\n\t_writeSectionData(section, offset, data) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tif (section.needClear) {\n\t\t\t\treturn this._clearSectionData(section);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tlet chunkSize = 4096;\n\t\t\tlet chunkOffs = 0;\n\t\t\tconst writeChunk = () => {\n\t\t\t\tif (chunkOffs + chunkSize > data.length) {\n\t\t\t\t\tchunkSize = data.length - chunkOffs;\n\t\t\t\t}\n\t\t\t\tif (chunkSize === 0) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].WRITE_SECTION_DATA, {\n\t\t\t\t\tstorage: section.storageIndex,\n\t\t\t\t\tsection: section.sectionIndex,\n\t\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\t\tdata: data.slice(chunkOffs, chunkOffs + chunkSize)\n\t\t\t\t}).then(() => {\n\t\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\t\treturn writeChunk();\n\t\t\t\t});\n\t\t\t};\n\t\t\treturn writeChunk();\n\t\t});\n\t}\n\n\t_clearSectionData(section) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].CLEAR_SECTION_DATA, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t});\n\t}\n\n\t_getSectionDataSize(section) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].GET_SECTION_DATA_SIZE, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t}).then(rep => rep.size);\n\t}\n\n\t_getStorageInfo() {\n\t\t// Check if there's a cached storage info\n\t\tif (this._storageInfo) {\n\t\t\treturn Promise.resolve(this._storageInfo);\n\t\t}\n\t\t// Request storage info from the device\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].DESCRIBE_STORAGE).then(rep => {\n\t\t\tconst storage = {\n\t\t\t\tmodules: [],\n\t\t\t\tfactory: null,\n\t\t\t\tconfig: null,\n\t\t\t\teeprom: null,\n\t\t\t\thasModularFirmware: true\n\t\t\t};\n\t\t\tfor (let storageIndex = 0; storageIndex < rep.storage.length; ++storageIndex) {\n\t\t\t\tconst pbStorage = rep.storage[storageIndex];\n\t\t\t\tfor (let sectionIndex = 0; sectionIndex < pbStorage.sections.length; ++sectionIndex) {\n\t\t\t\t\tconst pbSection = pbStorage.sections[sectionIndex];\n\t\t\t\t\tconst section = {\n\t\t\t\t\t\tstorageIndex: storageIndex,\n\t\t\t\t\t\tsectionIndex: sectionIndex,\n\t\t\t\t\t\tsize: pbSection.size,\n\t\t\t\t\t\tneedClear: !!(pbSection.flags & _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SectionFlag.NEED_CLEAR)\n\t\t\t\t\t};\n\t\t\t\t\tswitch (pbSection.type) {\n\t\t\t\t\t\t// Firmware module\n\t\t\t\t\t\tcase _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SectionType.FIRMWARE: {\n\t\t\t\t\t\t\tconst pbFirmwareModule = pbSection.firmwareModule;\n\t\t\t\t\t\t\tif (pbFirmwareModule.type === _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].FirmwareModuleType.MONO_FIRMWARE) {\n\t\t\t\t\t\t\t\tstorage.hasModularFirmware = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsection.moduleType = FirmwareModule.fromProtobuf(pbFirmwareModule.type);\n\t\t\t\t\t\t\tif (pbFirmwareModule.index) {\n\t\t\t\t\t\t\t\tsection.moduleIndex = pbFirmwareModule.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstorage.modules.push(section);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factory firmware\n\t\t\t\t\t\tcase _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SectionType.FACTORY_BACKUP: {\n\t\t\t\t\t\t\tstorage.factory = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Device configuration\n\t\t\t\t\t\tcase _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SectionType.CONFIG: {\n\t\t\t\t\t\t\tstorage.config = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// EEPROM\n\t\t\t\t\t\tcase _protocol__WEBPACK_IMPORTED_MODULE_7__[\"default\"].SectionType.EEPROM: {\n\t\t\t\t\t\t\tstorage.eeprom = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._storageInfo = storage;\n\t\t\tthis.once('closed', () => {\n\t\t\t\tthis._storageInfo = null;\n\t\t\t});\n\t\t\treturn this._storageInfo;\n\t\t});\n\t}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/device.js?");

/***/ }),

/***/ "./src/dfu.js":
/*!********************!*\
  !*** ./src/dfu.js ***!
  \********************/
/*! exports provided: DfuError, DfuRequestType, DfuDeviceStatus, DfuDeviceStatusMap, DfuDeviceState, DfuDeviceStateMap, DfuseCommand, DfuBmRequestType, DFU_STATUS_SIZE, Dfu */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuError\", function() { return DfuError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuRequestType\", function() { return DfuRequestType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuDeviceStatus\", function() { return DfuDeviceStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuDeviceStatusMap\", function() { return DfuDeviceStatusMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuDeviceState\", function() { return DfuDeviceState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuDeviceStateMap\", function() { return DfuDeviceStateMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuseCommand\", function() { return DfuseCommand; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DfuBmRequestType\", function() { return DfuBmRequestType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DFU_STATUS_SIZE\", function() { return DFU_STATUS_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dfu\", function() { return Dfu; });\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n\n/**\n * A generic DFU error.\n */\nclass DfuError extends _error__WEBPACK_IMPORTED_MODULE_0__[\"DeviceError\"] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n// 3. Requests, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuRequestType = {\n\t// | wValue    | wIndex    | wLength | Data     |\n\t// +-----------+-----------+---------+----------+\n\tDFU_DETACH: 0, // | wTimeout  | Interface | Zero    | None     |\n\tDFU_DNLOAD: 1, // | wBlockNum | Interface | Length  | Firmware |\n\tDFU_UPLOAD: 2, // | Zero      | Interface | Length  | Firmware |\n\tDFU_GETSTATUS: 3, // | Zero      | Interface | 6       | Status   |\n\tDFU_CLRSTATUS: 4, // | Zero      | Interface | Zero    | None     |\n\tDFU_GETSTATE: 5, // | Zero      | Interface | 1       | State    |\n\tDFU_ABORT: 6 // | Zero      | Interface | Zero    | None     |\n};\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceStatus = {\n\t// No error condition is present.\n\tOK: 0x00,\n\t// File is not targeted for use by this device.\n\terrTARGET: 0x01,\n\t// File is for this device but fails some vendor-specific verification test.\n\terrFILE: 0x02,\n\t// Device is unable to write memory.\n\terrWRITE: 0x03,\n\t// Memory erase function failed.\n\terrERASE: 0x04,\n\t// Memory erase check failed.\n\terrCHECK_ERASED: 0x05,\n\t// Program memory function failed.\n\terrPROG: 0x06,\n\t// Programmed memory failed verification.\n\terrVERIFY: 0x07,\n\t// Cannot program memory due to received address that is out of range.\n\terrADDRESS: 0x08,\n\t// Received DFU_DNLOAD with wLength = 0, but device does not think it has all of the data yet.\n\terrNOTDONE: 0x09,\n\t// Devices firmware is corrupt. It cannot return to run-time (non-DFU) operations.\n\terrFIRMWARE: 0x0A,\n\t// iString indicates a vendor-specific error.\n\terrVENDOR: 0x0B,\n\t// Device detected unexpected USB reset signaling.\n\terrUSBR: 0x0C,\n\t// Device detected unexpected power on reset.\n\terrPOR: 0x0D,\n\t// Something went wrong, but the device does not know what it was.\n\terrUNKNOWN: 0x0E,\n\t// Device stalled an unexpected request.\n\terrSTALLEDPKT: 0x0F,\n};\n\nconst DfuDeviceStatusMap = Object.keys(DfuDeviceStatus).reduce((obj, key) => {\n\tobj[DfuDeviceStatus[key]] = key;\n\treturn obj;\n}, {});\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceState = {\n\t// Device is running its normal application.\n\tappIDLE: 0,\n\t// Device is running its normal application, has received the DFU_DETACH request, and is waiting\n\t// for a USB reset.\n\tappDETACH: 1,\n\t// Device is operating in the DFU mode and is waiting for requests.\n\tdfuIDLE: 2,\n\t// Device has received a block and is waiting for the host to solicit the status via DFU_GETSTATUS.\n\tdfuDNLOAD_SYNC: 3,\n\t// Device is programming a control-write block into its nonvolatile memories.\n\tdfuDNBUSY: 4,\n\t// Device is processing a download operation. Expecting DFU_DNLOAD requests.\n\tdfuDNLOAD_IDLE: 5,\n\t// Device has received the final block of firmware from the host and is waiting for receipt of\n\t// DFU_GETSTATUS to begin the Manifestation phase; or device has completed the Manifestation\n\t// phase and is waiting for receipt of DFU_GETSTATUS. (Devices that can enter this state after\n\t// the Manifestation phase set bmAttributes bit bitManifestationTolerant to 1.)\n\tdfuMANIFEST_SYNC: 6,\n\t// Device is in the Manifestation phase. (Not all devices will be able to respond to DFU_GETSTATUS\n\t// when in this state.)\n\tdfuMANIFEST: 7,\n\t// Device has programmed its memories and is waiting for a USB reset or a power on reset. (Devices\n\t// that must enter this state clear bitManifestationTolerant to 0.)\n\tdfuMANIFEST_WAIT_RESET: 8,\n\t// The device is processing an upload operation. Expecting DFU_UPLOAD requests.\n\tdfuUPLOAD_IDLE: 9,\n\t// An error has occurred. Awaiting the DFU_CLRSTATUS request.\n\tdfuERROR: 10\n};\n\nconst DfuDeviceStateMap = Object.keys(DfuDeviceState).reduce((obj, key) => {\n\tobj[DfuDeviceState[key]] = key;\n\treturn obj;\n}, {});\n\n\n/**\n * DFU with ST Microsystems extensions.\n *\n * AN3156: USB DFU protocol used in the STM32 bootloader.\n */\nconst DfuseCommand = {\n\tDFUSE_COMMAND_NONE: 0xff,\n\tDFUSE_COMMAND_GET_COMMAND: 0x00,\n\tDFUSE_COMMAND_SET_ADDRESS_POINTER: 0x21,\n\tDFUSE_COMMAND_ERASE: 0x41,\n\tDFUSE_COMMAND_READ_UNPROTECT: 0x92\n};\n\nconst DfuBmRequestType = {\n\tHOST_TO_DEVICE: 0x21,\n\tDEVICE_TO_HOST: 0xA1\n};\n\nconst DFU_STATUS_SIZE = 6;\n// FIXME:\nconst DEFAULT_INTERFACE = 0;\nconst DEFAULT_ALTERNATE = 0;\n\nclass Dfu {\n\tconstructor(dev, logger) {\n\t\tthis._dev = dev;\n\t\tthis._log = logger;\n\t\tthis._interface = DEFAULT_INTERFACE;\n\t\tthis._alternate = DEFAULT_ALTERNATE;\n\t\tthis._claimed = false;\n\t}\n\n\t/**\n\t * Open DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync open() {\n\t\tawait this._dev.claimInterface(this._interface);\n\t\tawait this._dev.setAltSetting(this._interface, this._alternate);\n\t\tthis._claimed = true;\n\t}\n\n\t/**\n\t * Close DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync close() {\n\t\tif (this._claimed) {\n\t\t\treturn this._dev.releaseInterface(this._interface);\n\t\t}\n\t}\n\n\t/**\n\t * Leave DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync leave() {\n\t\tawait this._goIntoDfuIdleOrDfuDnloadIdle();\n\n\t\tawait this._sendDnloadRequest({\n\t\t\t// Dummy non-zero block number\n\t\t\tblockNum: 1\n\t\t\t// No data\n\t\t});\n\n\t\t// Check if the leave command was executed without an error\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== 'dfuMANIFEST') {\n\t\t\t// This is a workaround for Gen 2 DFU implementation where in order to please dfu-util\n\t\t\t// for some reason we are going off-standard and instead of reporting the actual dfuMANIFEST state\n\t\t\t// report dfuDNLOAD_IDLE :|\n\t\t\tif (state.status === 'OK' && state.state !== 'dfuDNLOAD_IDLE') {\n\t\t\t\tthrow new DfuError('Invalid DFU state');\n\t\t\t}\n\t\t}\n\n\t\t// After this, the device will go into dfuMANIFSET_WAIT_RESET state\n\t\t// and eventually should reset\n\t}\n\n\tasync _goIntoDfuIdleOrDfuDnloadIdle() {\n\t\ttry {\n\t\t\tconst state = await this._getStatus();\n\t\t\tif (state.state === 'dfuERROR') {\n\t\t\t\t// If we are in dfuERROR state, simply issue DFU_CLRSTATUS and we'll go into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\n\t\t\tif (state.state !== 'dfuIDLE' && state.state !== 'dfuDNLOAD_IDLE') {\n\t\t\t\t// If we are in some kind of an unknown state, issue DFU_CLRSTATUS, which may fail,\n\t\t\t\t// but the device will go into dfuERROR state, so a subsequent DFU_CLRSTATUS will get us\n\t\t\t\t// into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// DFU_GETSTATUS or DFU_CLRSTATUS failed, we are most likely in dfuERROR state, clear it\n\t\t\tawait this._clearStatus();\n\t\t}\n\n\t\t// Confirm we are in dfuIDLE or dfuDNLOAD_IDLE\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== 'dfuIDLE' && state.state !== 'dfuDNLOAD_IDLE') {\n\t\t\tthrow new DfuError('Invalid state');\n\t\t}\n\t}\n\n\tasync _sendDnloadRequest(req) {\n\t\tif ((!req.cmd || req.cmd === DfuseCommand.DFUSE_COMMAND_NONE) && req.blockNum) {\n\t\t\t// Send data\n\t\t\tconst setup = {\n\t\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\t\tbRequest: DfuRequestType.DFU_DNLOAD,\n\t\t\t\twIndex: this._interface,\n\t\t\t\twValue: req.blockNum\n\t\t\t};\n\t\t\treturn this._dev.transferOut(setup, req.data ? req.data : Buffer.alloc(0));\n\t\t}\n\n\t\tthrow new DfuError('Unknown DFU_DNLOAD command');\n\t}\n\n\tasync _getStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: DfuRequestType.DFU_GETSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0,\n\t\t\twLength: DFU_STATUS_SIZE\n\t\t};\n\t\tconst data = await this._dev.transferIn(setup);\n\t\tif (!data || data.length !== DFU_STATUS_SIZE) {\n\t\t\tthrow new DfuError('Could not parse DFU_GETSTATUS response');\n\t\t}\n\n\t\tlet bStatusWithPollTimeout = data.readUInt32LE(0);\n\t\tconst bStatus = DfuDeviceStatusMap[(bStatusWithPollTimeout & 0xff)];\n\t\tbStatusWithPollTimeout &= ~(0xff);\n\t\tconst bState = DfuDeviceStateMap[data.readUInt8(4)];\n\n\t\tif (!bStatus || !bState) {\n\t\t\tthrow new DfuError('Could not parse DFU result or state');\n\t\t}\n\n\t\treturn {\n\t\t\tstatus: bStatus,\n\t\t\tpollTimeout: bStatusWithPollTimeout,\n\t\t\tstate: bState\n\t\t};\n\t}\n\n\tasync _clearStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_CLRSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this._dev.transferOut(setup, Buffer.alloc(0));\n\t}\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/dfu.js?");

/***/ }),

/***/ "./src/error.js":
/*!**********************!*\
  !*** ./src/error.js ***!
  \**********************/
/*! exports provided: DeviceError, NotFoundError, NotAllowedError, StateError, TimeoutError, MemoryError, ProtocolError, UsbError, InternalError, RequestError, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DeviceError\", function() { return DeviceError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotFoundError\", function() { return NotFoundError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NotAllowedError\", function() { return NotAllowedError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StateError\", function() { return StateError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MemoryError\", function() { return MemoryError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProtocolError\", function() { return ProtocolError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UsbError\", function() { return UsbError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InternalError\", function() { return InternalError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequestError\", function() { return RequestError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assert\", function() { return assert; });\n/* harmony import */ var verror__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! verror */ \"./node_modules/verror/lib/verror.js\");\n/* harmony import */ var verror__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(verror__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\n * Generic device error. This is a base class for all errors reported by the library.\n */\nclass DeviceError extends verror__WEBPACK_IMPORTED_MODULE_0__[\"VError\"] {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * An error reported when a requested resource cannot be found.\n */\nclass NotFoundError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * An error reported when a requested operation is not permitted.\n */\nclass NotAllowedError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * An error reported when an object is not in an appropriate state to perform an operation.\n */\nclass StateError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Timeout error.\n */\nclass TimeoutError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * An error reported when a device has no enough memory to perform an operation.\n */\nclass MemoryError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Protocol error.\n */\nclass ProtocolError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * USB error.\n */\nclass UsbError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Internal error.\n */\nclass InternalError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n/**\n * Request error.\n */\nclass RequestError extends DeviceError {\n\tconstructor(result, ...args) {\n\t\tsuper(...args);\n\t\tthis.result = result;\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\nfunction assert(val, msg = null) {\n\tif (!val) {\n\t\tthrow new InternalError(msg ? msg : 'Assertion failed');\n\t}\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./src/error.js?");

/***/ }),

/***/ "./src/mesh-device.js":
/*!****************************!*\
  !*** ./src/mesh-device.js ***!
  \****************************/
/*! exports provided: DiagnosticType, MeshDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DiagnosticType\", function() { return DiagnosticType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MeshDevice\", function() { return MeshDevice; });\n/* harmony import */ var _device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./device */ \"./src/device.js\");\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./result */ \"./src/result.js\");\n/* harmony import */ var _protobuf_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n/* harmony import */ var ip__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ip */ \"./node_modules/ip/lib/ip.js\");\n/* harmony import */ var ip__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ip__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n\n\n\n\n\n\n\n\nconst NETWORK_ID_LENGTH = 24;\nconst MAX_NETWORK_NAME_LENGTH = 16;\nconst MIN_NETWORK_PASSWORD_LENGTH = 6;\nconst MAX_NETWORK_PASSWORD_LENGTH = 255;\nconst DIAGNOSTIC_DEFAULT_TIMEOUT = 10000; // 10 seconds\n\nconst DiagnosticType = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_3__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_6__[\"default\"].mesh.DiagnosticType, {\n\tMAC_EXTENDED_ADDRESS: 'MAC_EXTENDED_ADDRESS',\n\tRLOC: 'RLOC',\n\tMAC_ADDRESS: 'MAC_ADDRESS',\n\tMODE: 'MODE',\n\tTIMEOUT: 'TIMEOUT',\n\tCONNECTIVITY: 'CONNECTIVITY',\n\tROUTE64: 'ROUTE64',\n\tLEADER_DATA: 'LEADER_DATA',\n\tNETWORK_DATA: 'NETWORK_DATA',\n\tIPV6_ADDRESS_LIST: 'IPV6_ADDRESS_LIST',\n\tMAC_COUNTERS: 'MAC_COUNTERS',\n\tBATTERY_LEVEL: 'BATTERY_LEVEL',\n\tSUPPLY_VOLTAGE: 'SUPPLY_VOLTAGE',\n\tCHILD_TABLE: 'CHILD_TABLE',\n\tCHANNEL_PAGES: 'CHANNEL_PAGES',\n\t// NOTE: it's not possible to query this diagnostic TLV\n\t// TYPE_LIST: 'TYPE_LIST',\n\tMAX_CHILD_TIMEOUT: 'MAX_CHILD_TIMEOUT'\n});\n\nfunction formatIpv6Address(addr) {\n\treturn ip__WEBPACK_IMPORTED_MODULE_5__[\"toString\"](Buffer.from(addr));\n}\n\nfunction formatExtMacAddress(addr) {\n\treturn Buffer.from(addr).toString('hex');\n}\n\nfunction formatDeviceId(id) {\n\treturn Buffer.from(id).toString('hex');\n}\n\nfunction transformNetworkData(data) {\n\tif (data.prefixes) {\n\t\tdata.prefixes = data.prefixes.map(p => {\n\t\t\tconst s = Buffer.concat([Buffer.from(p.prefix), Buffer.alloc(16 - p.prefix.length)]);\n\t\t\tp.prefix = `${ip__WEBPACK_IMPORTED_MODULE_5__[\"toString\"](s)}/${p.prefixLength}`;\n\t\t\tdelete p.prefixLength;\n\t\t\treturn p;\n\t\t});\n\t}\n\treturn data;\n}\n\nfunction transformNetworkDiagnosticInfo(info) {\n\tconst result = {};\n\tconst leaderRlocs = new Set();\n\tconst gatewayRlocs = new Set();\n\tresult.nodes = info.nodes.map(node => {\n\t\tif (node.ipv6AddressList) {\n\t\t\tnode.ipv6AddressList = node.ipv6AddressList.map(addr => {\n\t\t\t\treturn formatIpv6Address(addr.address);\n\t\t\t});\n\t\t}\n\t\tif (node.extMacAddress) {\n\t\t\tnode.extMacAddress = formatExtMacAddress(node.extMacAddress);\n\t\t}\n\t\tif (node.deviceId) {\n\t\t\tnode.deviceId = formatDeviceId(node.deviceId);\n\t\t}\n\t\tif (node.networkData) {\n\t\t\tconst data = node.networkData;\n\t\t\tif (data.stable) {\n\t\t\t\tdata.stable = transformNetworkData(data.stable);\n\t\t\t\tconst prefixes = data.stable.prefixes;\n\t\t\t\tif (prefixes) {\n\t\t\t\t\tprefixes.forEach(p => {\n\t\t\t\t\t\tconst entries = p.borderRouter.entries;\n\t\t\t\t\t\tif (entries) {\n\t\t\t\t\t\t\tentries.forEach(e => {\n\t\t\t\t\t\t\t\tgatewayRlocs.add(e.rloc);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (data.temporary) {\n\t\t\t\tdata.temporary = transformNetworkData(data.temporary);\n\t\t\t}\n\t\t}\n\t\tnode.role = [];\n\t\tif (node.rloc & 0x01ff) {\n\t\t\tnode.role.push('endpoint');\n\t\t\tnode.parentRloc = node.rloc & 0xfe00;\n\t\t} else {\n\t\t\tnode.role.push('repeater');\n\t\t}\n\t\tif (node.leaderData) {\n\t\t\tleaderRlocs.add(node.leaderData.leaderRloc);\n\t\t}\n\t\treturn node;\n\t});\n\tresult.nodes.forEach(node => {\n\t\tif (leaderRlocs.has(node.rloc)) {\n\t\t\tnode.role.push('leader');\n\t\t}\n\t\tif (gatewayRlocs.has(node.rloc)) {\n\t\t\tnode.role.push('gateway');\n\t\t}\n\t});\n\treturn result;\n}\n\n/**\n * Mesh device.\n *\n * @deprecated Mesh support has been removed in recent versions of Device OS. Methods provided by this\n *             class will be removed in future versions of this library.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst MeshDevice = base => class extends base {\n\t/**\n\t * Authenticate the host on the device.\n\t *\n\t * @param {String} pwd - Network password.\n\t * @return {Promise}\n\t */\n\tasync meshAuth(pwd) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_AUTH, {\n\t\t\tpassword: pwd\n\t\t});\n\t}\n\n\t/**\n\t * Create a new mesh network.\n\t *\n\t * @param {String} network.id - Network ID.\n\t * @param {String} network.name - Network name.\n\t * @param {String} network.password - Network password.\n\t * @param {Number} [network.channel] - Channel number.\n\t * @return {Promise}\n\t */\n\tasync createMeshNetwork(network) {\n\t\t// Perform some checks at the client side\n\t\tif (!network.id || Buffer.byteLength(network.id) !== NETWORK_ID_LENGTH) {\n\t\t\tthrow new RangeError('Invalid length of the network ID');\n\t\t}\n\t\tif (!network.name || Buffer.byteLength(network.name) > MAX_NETWORK_NAME_LENGTH) {\n\t\t\tthrow new RangeError('Invalid length of the network name');\n\t\t}\n\t\tconst pwdLen = network.password ? Buffer.byteLength(network.password) : 0;\n\t\tif (pwdLen < MIN_NETWORK_PASSWORD_LENGTH || pwdLen > MAX_NETWORK_PASSWORD_LENGTH) {\n\t\t\tthrow new RangeError('Invalid length of the network password');\n\t\t}\n\t\treturn this._runInListeningMode(async () => {\n\t\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_CREATE_NETWORK, {\n\t\t\t\tname: network.name,\n\t\t\t\tpassword: network.password,\n\t\t\t\tnetworkId: network.id,\n\t\t\t\tchannel: network.channel\n\t\t\t});\n\t\t\treturn {\n\t\t\t\tpanId: r.network.panId,\n\t\t\t\textPanId: r.network.extPanId,\n\t\t\t\tchannel: r.network.channel\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Leave the current mesh network.\n\t *\n\t * @return {Promise}\n\t */\n\tasync leaveMeshNetwork() {\n\t\treturn this._runInListeningMode(() => {\n\t\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_LEAVE_NETWORK);\n\t\t});\n\t}\n\n\t/**\n\t * Get info about the current mesh network.\n\t *\n\t * @return {Promise}\n\t */\n\tasync getMeshNetworkInfo() {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_GET_NETWORK_INFO, null, {\n\t\t\tdontThrow: true\n\t\t});\n\t\tif (r.result === _result__WEBPACK_IMPORTED_MODULE_2__[\"Result\"].NOT_FOUND) {\n\t\t\treturn null; // The device is not a member of a network\n\t\t}\n\t\tif (r.result !== _result__WEBPACK_IMPORTED_MODULE_2__[\"Result\"].OK) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_4__[\"RequestError\"](r.result);\n\t\t}\n\t\treturn {\n\t\t\tid: r.network.networkId,\n\t\t\tname: r.network.name,\n\t\t\tpanId: r.network.panId,\n\t\t\textPanId: r.network.extPanId,\n\t\t\tchannel: r.network.channel\n\t\t};\n\t}\n\n\t/**\n\t * Start the commissioner role.\n\t *\n\t * @param {Number} [timeout] - Time in milliseconds after which the role is automatically stopped.\n\t * @return {Promise}\n\t */\n\tasync startCommissioner(timeout) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_START_COMMISSIONER, {\n\t\t\ttimeout: timeout\n\t\t});\n\t}\n\n\t/**\n\t * Stop the commissioner role.\n\t *\n\t * @return {Promise}\n\t */\n\tasync stopCommissioner() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_STOP_COMMISSIONER);\n\t}\n\n\t/**\n\t * Join the network.\n\t *\n\t * @param {MeshDevice} commDev - Commissioner device.\n\t * @return {Promise}\n\t */\n\tasync joinMeshNetwork(commDev) {\n\t\treturn this._runInListeningMode(async () => {\n\t\t\t// TODO: Start the commissioner role automatically\n\t\t\tlet r = await commDev.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_GET_NETWORK_INFO);\n\t\t\tconst network = r.network;\n\t\t\tr = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_PREPARE_JOINER, {\n\t\t\t\tnetwork: network\n\t\t\t});\n\t\t\tconst eui64 = r.eui64;\n\t\t\tconst joinPwd = r.password;\n\t\t\tawait commDev.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_ADD_JOINER, {\n\t\t\t\teui64: eui64,\n\t\t\t\tpassword: joinPwd\n\t\t\t});\n\t\t\tawait this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_JOIN_NETWORK);\n\t\t});\n\t}\n\n\t/**\n\t * Scan for mesh networks.\n\t *\n\t * @return {Promise}\n\t */\n\tasync scanMeshNetworks() {\n\t\tconst r = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_SCAN_NETWORKS);\n\t\treturn r.networks.map(network => ({\n\t\t\tname: network.name,\n\t\t\tpanId: network.panId,\n\t\t\textPanId: network.extPanId,\n\t\t\tchannel: network.channel\n\t\t}));\n\t}\n\n\t/**\n\t * Set the setup done flag.\n\t *\n\t * @param {Boolean} [done] Flag value.\n\t * @return {Promise}\n\t */\n\tasync setSetupDone(done) {\n\t\tif (done === undefined) {\n\t\t\tdone = true;\n\t\t}\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].SET_DEVICE_SETUP_DONE, {\n\t\t\tdone: done\n\t\t});\n\t}\n\n\t/**\n\t * Set to `true` if this is a mesh device.\n\t */\n\tget isMeshDevice() {\n\t\treturn true;\n\t}\n\n\tasync _runInListeningMode(fn) {\n\t\t// Currently, Device OS requires a mesh device to be in the listening mode in order to perform\n\t\t// most of the mesh network operations\n\t\tconst mode = await this.getDeviceMode();\n\t\tif (mode === _device__WEBPACK_IMPORTED_MODULE_0__[\"DeviceMode\"].LISTENING) {\n\t\t\treturn fn();\n\t\t}\n\t\tawait this.enterListeningMode();\n\t\ttry {\n\t\t\treturn await fn();\n\t\t} finally {\n\t\t\tawait this.leaveListeningMode(); // Restore the device state\n\t\t}\n\t}\n\n\t/**\n\t * Collect network diagnostic information\n\t *\n\t * @param {Object} opts Request options\n\t * @return {Promise}\n\t */\n\tasync getMeshNetworkDiagnosticInfo(\n\t\topts = {\n\t\t\ttimeout: DIAGNOSTIC_DEFAULT_TIMEOUT,\n\t\t\tqueryChildren: false,\n\t\t\tdiagnosticTypes: ['RLOC']\n\t\t}\n\t) {\n\t\tif (opts.queryChildren && !opts.diagnosticTypes.includes('CHILD_TABLE')) {\n\t\t\topts.diagnosticTypes.push('CHILD_TABLE');\n\t\t}\n\n\t\tlet flags = 0;\n\t\tif (opts.queryChildren) {\n\t\t\tflags |= _protocol__WEBPACK_IMPORTED_MODULE_6__[\"default\"].mesh.GetNetworkDiagnosticsRequest.Flags['QUERY_CHILDREN'];\n\t\t}\n\n\t\tif (opts.resolveDeviceId) {\n\t\t\tflags |= _protocol__WEBPACK_IMPORTED_MODULE_6__[\"default\"].mesh.GetNetworkDiagnosticsRequest.Flags['RESOLVE_DEVICE_ID'];\n\t\t}\n\n\t\tconst info = await this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_1__[\"Request\"].MESH_GET_NETWORK_DIAGNOSTICS, {\n\t\t\tflags: flags,\n\t\t\tdiagnosticTypes: opts.diagnosticTypes.map(DiagnosticType.toProtobuf),\n\t\t\ttimeout: opts.timeout\n\t\t}, {\n\t\t\ttimeout: 180000 // Request timeout\n\t\t});\n\t\treturn transformNetworkDiagnosticInfo(info);\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/mesh-device.js?");

/***/ }),

/***/ "./src/network-device.js":
/*!*******************************!*\
  !*** ./src/network-device.js ***!
  \*******************************/
/*! exports provided: NetworkStatus, NetworkDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkStatus\", function() { return NetworkStatus; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NetworkDevice\", function() { return NetworkDevice; });\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _protobuf_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n\n\n\nconst DEFAULT_INTERFACE = 1;\n\n/**\n * Network status.\n */\nconst NetworkStatus = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].NetworkState, {\n\tDOWN: 'DOWN',\n\tUP: 'UP'\n});\n\n/**\n * Network device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst NetworkDevice = base => class extends base {\n\t/**\n\t * Get network status.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetNetworkStatus() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].NETWORK_GET_STATUS, {\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t}).then(rep => NetworkStatus.fromProtobuf(rep.config.state));\n\t}\n\n\t/**\n\t * Get network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Object>}\n\t */\n\tgetNetworkConfig() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].NETWORK_GET_CONFIGURATION, { // TODO\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t});\n\t}\n\n\t/**\n\t * Set network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} config Network configuration.\n\t * @return {Promise}\n\t */\n\tsetNetworkConfig(config) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].NETWORK_SET_CONFIGURATION, config); // TODO\n\t}\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/network-device.js?");

/***/ }),

/***/ "./src/particle-usb.js":
/*!*****************************!*\
  !*** ./src/particle-usb.js ***!
  \*****************************/
/*! exports provided: DeviceType, PollingPolicy, FirmwareModule, NetworkStatus, WifiAntenna, WifiSecurity, WifiCipher, EapMethod, CloudConnectionStatus, ServerProtocol, Result, DeviceError, NotFoundError, NotAllowedError, StateError, TimeoutError, MemoryError, ProtocolError, UsbError, InternalError, RequestError, config, Core, Photon, P1, Electron, Argon, Boron, Xenon, ArgonSom, BoronSom, XenonSom, B5Som, AssetTracker, getDevices, openDeviceById */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Core\", function() { return Core; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Photon\", function() { return Photon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"P1\", function() { return P1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Electron\", function() { return Electron; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Argon\", function() { return Argon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Boron\", function() { return Boron; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Xenon\", function() { return Xenon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ArgonSom\", function() { return ArgonSom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BoronSom\", function() { return BoronSom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"XenonSom\", function() { return XenonSom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"B5Som\", function() { return B5Som; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AssetTracker\", function() { return AssetTracker; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDevices\", function() { return getDevices; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openDeviceById\", function() { return openDeviceById; });\n/* harmony import */ var _device_type__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./device-type */ \"./src/device-type.js\");\n/* harmony import */ var _device_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\n/* harmony import */ var _device__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./device */ \"./src/device.js\");\n/* harmony import */ var _wifi_device__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./wifi-device */ \"./src/wifi-device.js\");\n/* harmony import */ var _cellular_device__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cellular-device */ \"./src/cellular-device.js\");\n/* harmony import */ var _cloud_device__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cloud-device */ \"./src/cloud-device.js\");\n/* harmony import */ var _mesh_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./mesh-device */ \"./src/mesh-device.js\");\n/* harmony import */ var _network_device__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./network-device */ \"./src/network-device.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DeviceType\", function() { return _device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PollingPolicy\", function() { return _device_base__WEBPACK_IMPORTED_MODULE_1__[\"PollingPolicy\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"FirmwareModule\", function() { return _device__WEBPACK_IMPORTED_MODULE_2__[\"FirmwareModule\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NetworkStatus\", function() { return _network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkStatus\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WifiAntenna\", function() { return _wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiAntenna\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WifiSecurity\", function() { return _wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiSecurity\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"WifiCipher\", function() { return _wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiCipher\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EapMethod\", function() { return _wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"EapMethod\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CloudConnectionStatus\", function() { return _cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudConnectionStatus\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ServerProtocol\", function() { return _cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"ServerProtocol\"]; });\n\n/* harmony import */ var _result__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./result */ \"./src/result.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Result\", function() { return _result__WEBPACK_IMPORTED_MODULE_8__[\"Result\"]; });\n\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DeviceError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"DeviceError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NotFoundError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"NotFoundError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"NotAllowedError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"NotAllowedError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"StateError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"StateError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"TimeoutError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"MemoryError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"MemoryError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ProtocolError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"ProtocolError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"UsbError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"UsbError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"InternalError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"InternalError\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RequestError\", function() { return _error__WEBPACK_IMPORTED_MODULE_9__[\"RequestError\"]; });\n\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./config */ \"./src/config.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"config\", function() { return _config__WEBPACK_IMPORTED_MODULE_10__[\"config\"]; });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Core extends _device_base__WEBPACK_IMPORTED_MODULE_1__[\"DeviceBase\"] {\n}\n\nclass Photon extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nclass P1 extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nclass Electron extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_cellular_device__WEBPACK_IMPORTED_MODULE_4__[\"CellularDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nclass Argon extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"])))) {\n}\n\nclass Boron extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_cellular_device__WEBPACK_IMPORTED_MODULE_4__[\"CellularDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"])))) {\n}\n\nclass Xenon extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nclass ArgonSom extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_wifi_device__WEBPACK_IMPORTED_MODULE_3__[\"WifiDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"])))) {\n}\n\nclass BoronSom extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_cellular_device__WEBPACK_IMPORTED_MODULE_4__[\"CellularDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"])))) {\n}\n\nclass XenonSom extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nclass B5Som extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_cellular_device__WEBPACK_IMPORTED_MODULE_4__[\"CellularDevice\"])(Object(_mesh_device__WEBPACK_IMPORTED_MODULE_6__[\"MeshDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"])))) {\n}\n\nclass AssetTracker extends Object(_cloud_device__WEBPACK_IMPORTED_MODULE_5__[\"CloudDevice\"])(Object(_cellular_device__WEBPACK_IMPORTED_MODULE_4__[\"CellularDevice\"])(Object(_network_device__WEBPACK_IMPORTED_MODULE_7__[\"NetworkDevice\"])(_device__WEBPACK_IMPORTED_MODULE_2__[\"Device\"]))) {\n}\n\nconst DEVICE_PROTOTYPES = {\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].CORE]: Core.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].PHOTON]: Photon.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].P1]: P1.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].ELECTRON]: Electron.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].ARGON]: Argon.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].BORON]: Boron.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].XENON]: Xenon.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].ARGON_SOM]: ArgonSom.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].BORON_SOM]: BoronSom.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].XENON_SOM]: XenonSom.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].B5_SOM]: B5Som.prototype,\n\t[_device_type__WEBPACK_IMPORTED_MODULE_0__[\"DeviceType\"].ASSET_TRACKER]: AssetTracker.prototype\n};\n\nfunction setDevicePrototype(dev) {\n\tconst proto = DEVICE_PROTOTYPES[dev.type];\n\tif (!proto) {\n\t\treturn dev;\n\t}\n\treturn Object.setPrototypeOf(dev, proto);\n}\n\n/**\n * Enumerate Particle USB devices attached to the host.\n *\n * @param {Object} options Options.\n * @param {Array<String>} [options.types] Device types (see {@link DeviceType}). By default, this\n *        function enumerates devices of all platforms supported by the library.\n * @param {Boolean} [options.includeDfu=true] Whether to include devices in DFU mode.\n * @return {Promise<Array<Device>>}\n */\nfunction getDevices(options) {\n\treturn Object(_device_base__WEBPACK_IMPORTED_MODULE_1__[\"getDevices\"])(options).then(devs => devs.map(dev => setDevicePrototype(dev)));\n}\n\n/**\n * Open a Particle USB device with the specified ID.\n *\n * @param {String} id Device ID.\n * @param {Object} [options] Options (see {@link DeviceBase#open}).\n * @return {Promise<Device>}\n */\nfunction openDeviceById(id, options) {\n\treturn Object(_device_base__WEBPACK_IMPORTED_MODULE_1__[\"openDeviceById\"])(id, options).then(dev => setDevicePrototype(dev));\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./src/particle-usb.js?");

/***/ }),

/***/ "./src/protobuf-util.js":
/*!******************************!*\
  !*** ./src/protobuf-util.js ***!
  \******************************/
/*! exports provided: fromProtobufEnum, fromProtobufMessage, toProtobufMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromProtobufEnum\", function() { return fromProtobufEnum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromProtobufMessage\", function() { return fromProtobufMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toProtobufMessage\", function() { return toProtobufMessage; });\n// Transforms a Protobuf enum to an API object according to the provided mapping. Resulting object\n// provides functions for a checked conversion between the protocol and API values\nfunction fromProtobufEnum(pbEnum, map, unknownVal) {\n\tconst mapToProtobuf = {};\n\tconst mapFromProtobuf = {};\n\tconst funcs = {\n\t\ttoProtobuf: (val) => {\n\t\t\tconst pbVal = mapToProtobuf[val.toLowerCase()];\n\t\t\tif (pbVal === undefined) {\n\t\t\t\tthrow new RangeError(`Invalid value: ${val}`);\n\t\t\t}\n\t\t\treturn pbVal;\n\t\t},\n\t\tfromProtobuf: (pbVal) => {\n\t\t\tconst val = mapFromProtobuf[pbVal];\n\t\t\tif (val === undefined) {\n\t\t\t\treturn (unknownVal !== undefined ? unknownVal : 'UNKNOWN');\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t};\n\tconst obj = Object.create(funcs);\n\tfor (let val in map) {\n\t\tconst pbName = map[val];\n\t\tconst pbVal = pbEnum[pbName];\n\t\tif (pbVal === undefined) {\n\t\t\tthrow new Error(`Unknown enum value: ${pbName}`);\n\t\t}\n\t\tconst v = val.toLowerCase();\n\t\tif (v in mapToProtobuf) {\n\t\t\tthrow new Error(`Duplicate value: ${val}`);\n\t\t}\n\t\tmapToProtobuf[v] = pbVal;\n\t\tmapFromProtobuf[pbVal] = val;\n\t\tobj[val] = val;\n\t}\n\treturn Object.freeze(obj);\n}\n\nfunction transformMessage(msg, map) {\n\tconst obj = {};\n\tfor (let name of Object.keys(msg)) { // Ignore prototype properties\n\t\tlet val = msg[name];\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m; // Rename property\n\t\t} else if (typeof m == 'function') {\n\t\t\tval = m(val); // Convert value\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name; // Rename property\n\t\t\t}\n\t\t\tif (m.value) {\n\t\t\t\tval = m.value(val); // Convert value\n\t\t\t}\n\t\t} else if (!m) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tif (val === undefined) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tobj[name] = val;\n\t}\n\treturn obj;\n}\n\nfunction checkFromProtobufMessageMap(pbMsgProto, map) {\n\tfor (let name in map) {\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction checkToProtobufMessageMap(pbMsgProto, map) {\n\tfor (let name in map) {\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m;\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name;\n\t\t\t}\n\t\t}\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction assignMessagePropertyMaps(obj, ...maps) {\n\tfor (let map of maps) {\n\t\tif (Array.isArray(map)) {\n\t\t\tmap = map.reduce((obj, name) => {\n\t\t\t\tobj[name] = true;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\t\t}\n\t\tObject.assign(obj, map);\n\t}\n\treturn obj;\n}\n\n// Returns a function that transforms a Protobuf message to an API object according to the provided mapping\nfunction fromProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckFromProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\n// Returns a function that transforms an API object to a Protobuf message according to the provided mapping\nfunction toProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckToProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./src/protobuf-util.js?");

/***/ }),

/***/ "./src/protocol.js":
/*!*************************!*\
  !*** ./src/protocol.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_pb_message__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/pb-message */ \"./lib/pb-message.js\");\n/* harmony import */ var _lib_pb_message__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_pb_message__WEBPACK_IMPORTED_MODULE_0__);\n// This is a wrapper module for the generated protocol data\n\n\nconst controlProto = _lib_pb_message__WEBPACK_IMPORTED_MODULE_0___default.a.particle.ctrl;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (controlProto);\n\n\n//# sourceURL=webpack://ParticleUsb/./src/protocol.js?");

/***/ }),

/***/ "./src/request.js":
/*!************************!*\
  !*** ./src/request.js ***!
  \************************/
/*! exports provided: Request */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n// Mapping of request types to Protobuf messages\nconst Request = {\n\tGET_SERIAL_NUMBER: {\n\t\tid: 21,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSerialNumberRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSerialNumberReply\n\t},\n\tRESET: {\n\t\tid: 40\n\t},\n\tFACTORY_RESET: {\n\t\tid: 41\n\t},\n\tDFU_MODE: {\n\t\tid: 50\n\t},\n\tSAFE_MODE: {\n\t\tid: 60\n\t},\n\tSTART_LISTENING: {\n\t\tid: 70\n\t},\n\tSTOP_LISTENING: {\n\t\tid: 71\n\t},\n\tGET_DEVICE_MODE: {\n\t\tid: 72,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetDeviceModeRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetDeviceModeReply\n\t},\n\tSET_DEVICE_SETUP_DONE: {\n\t\tid: 73,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetDeviceSetupDoneRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetDeviceSetupDoneReply\n\t},\n\tLOG_CONFIG: {\n\t\tid: 80\n\t},\n\tMODULE_INFO: {\n\t\tid: 90\n\t},\n\tDIAGNOSTIC_INFO: {\n\t\tid: 100\n\t},\n\tWIFI_SET_ANTENNA: {\n\t\tid: 110,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiSetAntennaRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiSetAntennaReply\n\t},\n\tWIFI_GET_ANTENNA: {\n\t\tid: 111,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiGetAntennaRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiGetAntennaReply\n\t},\n\tWIFI_SCAN: {\n\t\tid: 112,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiScanRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiScanReply\n\t},\n\tWIFI_SET_CREDENTIALS: {\n\t\tid: 113,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiSetCredentialsRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiSetCredentialsReply\n\t},\n\tWIFI_GET_CREDENTIALS: {\n\t\tid: 114,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiGetCredentialsRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiGetCredentialsReply\n\t},\n\tWIFI_CLEAR_CREDENTIALS: {\n\t\tid: 115,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiClearCredentialsRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WiFiClearCredentialsReply\n\t},\n\tNETWORK_SET_CONFIGURATION: {\n\t\tid: 120,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkSetConfigurationRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkSetConfigurationReply\n\t},\n\tNETWORK_GET_CONFIGURATION: {\n\t\tid: 121,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkGetConfigurationRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkGetConfigurationReply\n\t},\n\tNETWORK_GET_STATUS: {\n\t\tid: 122,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkGetStatusRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].NetworkGetStatusReply\n\t},\n\tSET_CLAIM_CODE: {\n\t\tid: 200,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetClaimCodeRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetClaimCodeReply\n\t},\n\tIS_CLAIMED: {\n\t\tid: 201,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IsClaimedRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IsClaimedReply\n\t},\n\tSET_SECURITY_KEY: {\n\t\tid: 210,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetSecurityKeyRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetSecurityKeyReply\n\t},\n\tGET_SECURITY_KEY: {\n\t\tid: 211,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSecurityKeyRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSecurityKeyReply\n\t},\n\tSET_SERVER_ADDRESS: {\n\t\tid: 220,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetServerAddressRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetServerAddressReply\n\t},\n\tGET_SERVER_ADDRESS: {\n\t\tid: 221,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetServerAddressRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetServerAddressReply\n\t},\n\tSET_SERVER_PROTOCOL: {\n\t\tid: 222,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetServerProtocolRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetServerProtocolReply\n\t},\n\tGET_SERVER_PROTOCOL: {\n\t\tid: 223,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetServerProtocolRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetServerProtocolReply\n\t},\n\tSTART_NYAN_SIGNAL: {\n\t\tid: 230\n\t},\n\tSTOP_NYAN_SIGNAL: {\n\t\tid: 231\n\t},\n\tSET_SOFTAP_SSID: {\n\t\tid: 240,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetSoftApSsidRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].SetSoftApSsidReply\n\t},\n\tSTART_FIRMWARE_UPDATE: {\n\t\tid: 250,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StartFirmwareUpdateRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].StartFirmwareUpdateReply\n\t},\n\tFINISH_FIRMWARE_UPDATE: {\n\t\tid: 251,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FinishFirmwareUpdateRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FinishFirmwareUpdateReply\n\t},\n\tCANCEL_FIRMWARE_UPDATE: {\n\t\tid: 252,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CancelFirmwareUpdateRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].CancelFirmwareUpdateReply\n\t},\n\tFIRMWARE_UPDATE_DATA: {\n\t\tid: 253,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FirmwareUpdateDataRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].FirmwareUpdateDataReply\n\t},\n\tDESCRIBE_STORAGE: {\n\t\tid: 260,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DescribeStorageRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].DescribeStorageReply\n\t},\n\tREAD_SECTION_DATA: {\n\t\tid: 261,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ReadSectionDataRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ReadSectionDataReply\n\t},\n\tWRITE_SECTION_DATA: {\n\t\tid: 262,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WriteSectionDataRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].WriteSectionDataReply\n\t},\n\tCLEAR_SECTION_DATA: {\n\t\tid: 263,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ClearSectionDataRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].ClearSectionDataReply\n\t},\n\tGET_SECTION_DATA_SIZE: {\n\t\tid: 264,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSectionDataSizeRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].GetSectionDataSizeReply\n\t},\n\t// Cloud connectivity\n\tCLOUD_STATUS: {\n\t\tid: 300,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.GetConnectionStatusRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.GetConnectionStatusReply\n\t},\n\tCLOUD_CONNECT: {\n\t\tid: 301,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.ConnectRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.ConnectReply\n\t},\n\tCLOUD_DISCONNECT: {\n\t\tid: 302,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.DisconnectRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cloud.DisconnectReply\n\t},\n\t// Cellular-specific requests\n\tCELLULAR_GET_ICCID: {\n\t\tid: 554,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellular.GetIccidRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].cellular.GetIccidReply\n\t},\n\t// Mesh network management\n\tMESH_AUTH: {\n\t\tid: 1001,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.AuthRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.AuthReply\n\t},\n\tMESH_CREATE_NETWORK: {\n\t\tid: 1002,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.CreateNetworkRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.CreateNetworkReply\n\t},\n\tMESH_START_COMMISSIONER: {\n\t\tid: 1003,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.StartCommissionerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.StartCommissionerReply\n\t},\n\tMESH_STOP_COMMISSIONER: {\n\t\tid: 1004,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.StopCommissionerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.StopCommissionerReply\n\t},\n\tMESH_PREPARE_JOINER: {\n\t\tid: 1005,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.PrepareJoinerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.PrepareJoinerReply\n\t},\n\tMESH_ADD_JOINER: {\n\t\tid: 1006,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.AddJoinerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.AddJoinerReply\n\t},\n\tMESH_REMOVE_JOINER: {\n\t\tid: 1007,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.RemoveJoinerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.RemoveJoinerReply\n\t},\n\tMESH_JOIN_NETWORK: {\n\t\tid: 1008,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.JoinNetworkRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.JoinNetworkReply\n\t},\n\tMESH_LEAVE_NETWORK: {\n\t\tid: 1009,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.LeaveNetworkRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.LeaveNetworkReply\n\t},\n\tMESH_GET_NETWORK_INFO: {\n\t\tid: 1010,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.GetNetworkInfoRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.GetNetworkInfoReply\n\t},\n\tMESH_SCAN_NETWORKS: {\n\t\tid: 1011,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.ScanNetworksRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.ScanNetworksReply\n\t},\n\tMESH_GET_NETWORK_DIAGNOSTICS: {\n\t\tid: 1012,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.GetNetworkDiagnosticsRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mesh.GetNetworkDiagnosticsReply\n\t},\n\t// Logging configuration\n\tADD_LOG_HANDLER: {\n\t\tid: 1100,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.AddLogHandlerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.AddLogHandlerReply\n\t},\n\tREMOVE_LOG_HANDLER: {\n\t\tid: 1101,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.RemoveLogHandlerRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.RemoveLogHandlerReply\n\t},\n\tGET_LOG_HANDLERS: {\n\t\tid: 1102,\n\t\trequest: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.GetLogHandlersRequest,\n\t\treply: _protocol__WEBPACK_IMPORTED_MODULE_0__[\"default\"].logging.GetLogHandlersReply\n\t}\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/request.js?");

/***/ }),

/***/ "./src/result.js":
/*!***********************!*\
  !*** ./src/result.js ***!
  \***********************/
/*! exports provided: Result, messageForResultCode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Result\", function() { return Result; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"messageForResultCode\", function() { return messageForResultCode; });\n// Result codes as defined by the firmware's system_error_t enum\nconst RESULT_CODES = [\n\t{\n\t\tid: 'OK',\n\t\tvalue: 0,\n\t\tmessage: 'Operation succeeded'\n\t},\n\t{\n\t\tid: 'ERROR',\n\t\tvalue: -100,\n\t\tmessage: 'Unknown error'\n\t},\n\t{\n\t\tid: 'BUSY',\n\t\tvalue: -110,\n\t\tmessage: 'Resource is busy'\n\t},\n\t{\n\t\tid: 'NOT_SUPPORTED',\n\t\tvalue: -120,\n\t\tmessage: 'Not supported'\n\t},\n\t{\n\t\tid: 'NOT_ALLOWED',\n\t\tvalue: -130,\n\t\tmessage: 'Not allowed'\n\t},\n\t{\n\t\tid: 'CANCELLED',\n\t\tvalue: -140,\n\t\tmessage: 'Operation cancelled'\n\t},\n\t{\n\t\tid: 'ABORTED',\n\t\tvalue: -150,\n\t\tmessage: 'Operation aborted'\n\t},\n\t{\n\t\tid: 'TIMEOUT_ERROR',\n\t\tvalue: -160,\n\t\tmessage: 'Timeout error'\n\t},\n\t{\n\t\tid: 'NOT_FOUND',\n\t\tvalue: -170,\n\t\tmessage: 'Not found'\n\t},\n\t{\n\t\tid: 'ALREADY_EXISTS',\n\t\tvalue: -180,\n\t\tmessage: 'Already exists'\n\t},\n\t{\n\t\tid: 'TOO_LARGE',\n\t\tvalue: -190,\n\t\tmessage: 'Data is too large'\n\t},\n\t{\n\t\tid: 'LIMIT_EXCEEDED',\n\t\tvalue: -200,\n\t\tmessage: 'Limit exceeded'\n\t},\n\t{\n\t\tid: 'INVALID_STATE',\n\t\tvalue: -210,\n\t\tmessage: 'Invalid state'\n\t},\n\t{\n\t\tid: 'IO_ERROR',\n\t\tvalue: -220,\n\t\tmessage: 'IO error'\n\t},\n\t{\n\t\tid: 'NETWORK_ERROR',\n\t\tvalue: -230,\n\t\tmessage: 'Network error'\n\t},\n\t{\n\t\tid: 'PROTOCOL_ERROR',\n\t\tvalue: -240,\n\t\tmessage: 'Protocol error'\n\t},\n\t{\n\t\tid: 'INTERNAL_ERROR',\n\t\tvalue: -250,\n\t\tmessage: 'Internal error'\n\t},\n\t{\n\t\tid: 'NO_MEMORY',\n\t\tvalue: -260,\n\t\tmessage: 'Memory allocation error'\n\t},\n\t{\n\t\tid: 'INVALID_ARGUMENT',\n\t\tvalue: -270,\n\t\tmessage: 'Invalid argument'\n\t},\n\t{\n\t\tid: 'BAD_DATA',\n\t\tvalue: -280,\n\t\tmessage: 'Invalid data format'\n\t},\n\t{\n\t\tid: 'OUT_OF_RANGE',\n\t\tvalue: -290,\n\t\tmessage: 'Out of range'\n\t}\n];\n\n// Result code messages\nconst RESULT_CODE_MESSAGES = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.value] = result.message;\n\treturn obj;\n}, {});\n\n/**\n * Request result codes.\n *\n * @enum {Number}\n */\nconst Result = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.id] = result.value;\n\treturn obj;\n}, {});\n\n/**\n * Return a message for the result code.\n *\n * @param {Number} result Result code.\n * @return {String} Error message.\n */\nfunction messageForResultCode(result) {\n\treturn (RESULT_CODE_MESSAGES[result] || 'Request error');\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./src/result.js?");

/***/ }),

/***/ "./src/usb-device-webusb.js":
/*!**********************************!*\
  !*** ./src/usb-device-webusb.js ***!
  \**********************************/
/*! exports provided: MAX_CONTROL_TRANSFER_DATA_SIZE, UsbDevice, getUsbDevices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_CONTROL_TRANSFER_DATA_SIZE\", function() { return MAX_CONTROL_TRANSFER_DATA_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UsbDevice\", function() { return UsbDevice; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getUsbDevices\", function() { return getUsbDevices; });\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n\n// Maximum size of a control transfer's data stage\nconst MAX_CONTROL_TRANSFER_DATA_SIZE = 4096;\n\nfunction bmRequestTypeToString(type) {\n\ttype = (type >> 5) & 0x03;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'standard';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'class';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'vendor';\n\t\t}\n\t\tdefault: {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n\nfunction bmRequestTypeToRecipientString(type) {\n\ttype = type & 0x0f;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'device';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'interface';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'endpoint';\n\t\t}\n\t\tcase 3:\n\t\tdefault: {\n\t\t\treturn 'other';\n\t\t}\n\t}\n}\n\nclass UsbDevice {\n\tconstructor(dev) {\n\t\tthis._dev = dev;\n\t\tthis._dev.timeout = 5000; // Use longer timeout for control transfers\n\t}\n\n\tasync open() {\n\t\ttry {\n\t\t\tawait this._dev.open();\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Unable to open USB device');\n\t\t}\n\t}\n\n\tasync close() {\n\t\ttry {\n\t\t\tawait this._dev.close();\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Unable to close USB device');\n\t\t}\n\t}\n\n\tasync transferIn(setup) {\n\t\ttry {\n\t\t\tconst res = await this._dev.controlTransferIn({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, setup.wLength);\n\t\t\treturn Buffer.from(res.data.buffer);\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'IN control transfer failed');\n\t\t}\n\t}\n\n\tasync transferOut(setup, data) {\n\t\ttry {\n\t\t\tawait this._dev.controlTransferOut({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, data); // data is optional\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'OUT control transfer failed');\n\t\t}\n\t}\n\n\tasync claimInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.claimInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Failed to claim interface');\n\t\t}\n\t}\n\n\tasync releaseInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.releaseInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Failed to release interface');\n\t\t}\n\t}\n\n\tasync setAltSetting(intrface, setting) {\n\t\ttry {\n\t\t\tawait this._dev.selectAlternateInterface(intrface, setting);\n\t\t} catch (err) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Failed to set alt setting');\n\t\t}\n\t}\n\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\tget serialNumber() {\n\t\treturn this._dev.serialNumber;\n\t}\n\n\tget isOpen() {\n\t\treturn this._dev.opened;\n\t}\n\n\tget internalObject() {\n\t\treturn this._dev;\n\t}\n}\n\nasync function getUsbDevices(filters) {\n\tif (filters) {\n\t\t// Validate filtering options\n\t\tfilters.forEach(f => {\n\t\t\tif (f.productId && !f.vendorId) {\n\t\t\t\tthrow new RangeError('Vendor ID is missing');\n\t\t\t}\n\t\t});\n\t} else {\n\t\tfilters = [];\n\t}\n\tlet devs = [];\n\ttry {\n\t\t// Fow now, always ask the user to grant access to the device, even if we already have a\n\t\t// permission to access it. The permissions API for USB is not yet implemented in Chrome,\n\t\t// and calling requestDevice() after getDevices() causes a SecurityError.\n\t\t// TODO: Implement a separate API to request a permission from the user\n\t\tlet newDev = null;\n\t\ttry {\n\t\t\tnewDev = await navigator.usb.requestDevice({ filters });\n\t\t} catch (e) {\n\t\t\t// Ignore NotFoundError which means that the user has cancelled the request\n\t\t\tif (e.name !== 'NotFoundError') {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Get the list of known devices and filter them according to the provided options\n\t\tdevs = await navigator.usb.getDevices();\n\t\tif (filters.length > 0) {\n\t\t\tdevs = devs.filter(dev => filters.some(f => ((!f.vendorId || dev.vendorId === f.vendorId) &&\n\t\t\t\t\t(!f.productId || dev.productId === f.productId) &&\n\t\t\t\t\t(!f.serialNumber || dev.serialNumber === f.serialNumber))));\n\t\t}\n\t\tif (newDev) {\n\t\t\t// Avoid listing the same device twice\n\t\t\tconst hasNewDev = devs.some(dev => dev.vendorId === newDev.vendorId && dev.productId === newDev.productId &&\n\t\t\t\t\tdev.serialNumber === newDev.serialNumber);\n\t\t\tif (!hasNewDev) {\n\t\t\t\tdevs.push(newDev);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"UsbError\"](err, 'Unable to enumerate USB devices');\n\t}\n\tdevs = devs.map(dev => new UsbDevice(dev));\n\treturn devs;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-device-webusb.js?");

/***/ }),

/***/ "./src/usb-protocol.js":
/*!*****************************!*\
  !*** ./src/usb-protocol.js ***!
  \*****************************/
/*! exports provided: ServiceType, FieldFlag, Status, BmRequestType, PARTICLE_BREQUEST, MIN_WLENGTH, MAX_REQUEST_ID, MAX_REQUEST_TYPE, MAX_PAYLOAD_SIZE, initRequest, checkRequest, sendRequest, recvRequest, resetRequest, parseReply, encodeReply */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ServiceType\", function() { return ServiceType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FieldFlag\", function() { return FieldFlag; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Status\", function() { return Status; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BmRequestType\", function() { return BmRequestType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PARTICLE_BREQUEST\", function() { return PARTICLE_BREQUEST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MIN_WLENGTH\", function() { return MIN_WLENGTH; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_REQUEST_ID\", function() { return MAX_REQUEST_ID; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_REQUEST_TYPE\", function() { return MAX_REQUEST_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MAX_PAYLOAD_SIZE\", function() { return MAX_PAYLOAD_SIZE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initRequest\", function() { return initRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"checkRequest\", function() { return checkRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sendRequest\", function() { return sendRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"recvRequest\", function() { return recvRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resetRequest\", function() { return resetRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseReply\", function() { return parseReply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encodeReply\", function() { return encodeReply; });\n/* harmony import */ var _error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n\n// Service request types\nconst ServiceType = {\n\tINIT: 1,\n\tCHECK: 2,\n\tSEND: 3,\n\tRECV: 4,\n\tRESET: 5\n};\n\n// Field flags\nconst FieldFlag = {\n\tSTATUS: 0x01,\n\tID: 0x02,\n\tSIZE: 0x04,\n\tRESULT: 0x08\n};\n\n// Status codes\nconst Status = {\n\tOK: 0,\n\tERROR: 1,\n\tPENDING: 2,\n\tBUSY: 3,\n\tNO_MEMORY: 4,\n\tNOT_FOUND: 5\n};\n\n// Values of the bmRequestType field used by the protocol\nconst BmRequestType = {\n\tHOST_TO_DEVICE: 0x40, // 01000000b (direction: host-to-device; type: vendor; recipient: device)\n\tDEVICE_TO_HOST: 0xc0 // 11000000b (direction: device_to_host; type: vendor; recipient: device)\n};\n\n// Value of the bRequest field for Particle vendor requests\nconst PARTICLE_BREQUEST = 0x50; // ASCII code of the character 'P'\n\n// Minimum length of the data stage for high-speed USB devices\nconst MIN_WLENGTH = 64;\n\n// Misc. constraints defined by the protocol and the USB specification\nconst MAX_REQUEST_ID = 0xffff;\nconst MAX_REQUEST_TYPE = 0xffff;\nconst MAX_PAYLOAD_SIZE = 0xffff;\n\n// Returns the setup packet fields for the INIT service request\nfunction initRequest(reqType, dataSize = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.INIT,\n\t\twIndex: reqType, // Request type\n\t\twValue: dataSize, // Payload size\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the CHECK service request\nfunction checkRequest(reqId) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.CHECK,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the SEND service request\nfunction sendRequest(reqId, dataSize) {\n\treturn {\n\t\t// SEND is the only host-to-device service request defined by the protocol\n\t\tbmRequestType: BmRequestType.HOST_TO_DEVICE,\n\t\tbRequest: ServiceType.SEND,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RECV service request\nfunction recvRequest(reqId, dataSize) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RECV,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RESET service request\nfunction resetRequest(reqId = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RESET,\n\t\twIndex: reqId, // Request ID (can be set to 0 to reset all requests)\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Parses service reply data\nfunction parseReply(data) {\n\ttry {\n\t\tconst rep = {};\n\t\tlet offs = 0;\n\t\t// Field flags (4 bytes)\n\t\trep.flags = data.readUInt32LE(offs);\n\t\toffs += 4;\n\t\t// Status code (2 bytes)\n\t\tif (!(rep.flags & FieldFlag.STATUS)) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"ProtocolError\"]('Service reply is missing mandatory status field');\n\t\t}\n\t\trep.status = data.readUInt16LE(offs);\n\t\toffs += 2;\n\t\t// Request ID (2 bytes, optional)\n\t\tif (rep.flags & FieldFlag.ID) {\n\t\t\trep.id = data.readUInt16LE(offs);\n\t\t\toffs += 2;\n\t\t}\n\t\t// Payload size (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.SIZE) {\n\t\t\trep.size = data.readUInt32LE(offs);\n\t\t\toffs += 4;\n\t\t}\n\t\t// Result code (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.RESULT) {\n\t\t\trep.result = data.readInt32LE(offs); // Signed\n\t\t\toffs += 4;\n\t\t}\n\t\treturn rep;\n\t} catch (err) {\n\t\tif (!(err instanceof _error__WEBPACK_IMPORTED_MODULE_0__[\"ProtocolError\"])) {\n\t\t\tthrow new _error__WEBPACK_IMPORTED_MODULE_0__[\"ProtocolError\"](err, 'Unable to parse service reply');\n\t\t}\n\t\tthrow err;\n\t}\n}\n\n// Serializes service reply data\nfunction encodeReply(rep) {\n\tlet flags = FieldFlag.STATUS; // Status code is a mandatory field\n\tlet size = 6; // 4 bytes for field flags and 2 bytes for status code\n\tif ('id' in rep) {\n\t\tflags |= FieldFlag.ID;\n\t\tsize += 2;\n\t}\n\tif ('size' in rep) {\n\t\tflags |= FieldFlag.SIZE;\n\t\tsize += 4;\n\t}\n\tif ('result' in rep) {\n\t\tflags |= FieldFlag.RESULT;\n\t\tsize += 4;\n\t}\n\tconst data = Buffer.alloc(size);\n\tlet offs = 0;\n\t// Field flags (4 bytes)\n\tdata.writeUInt32LE(flags, offs);\n\toffs += 4;\n\t// Status code (2 bytes)\n\tdata.writeUInt16LE(rep.status, offs);\n\toffs += 2;\n\t// Request ID (2 bytes, optional)\n\tif (flags & FieldFlag.ID) {\n\t\tdata.writeUInt16LE(rep.id, offs);\n\t\toffs += 2;\n\t}\n\t// Payload size (4 bytes, optional)\n\tif (flags & FieldFlag.SIZE) {\n\t\tdata.writeUInt32LE(rep.size, offs);\n\t\toffs += 4;\n\t}\n\t// Result code (4 bytes, optional)\n\tif (flags & FieldFlag.RESULT) {\n\t\tdata.writeInt32LE(rep.result, offs); // Signed\n\t\toffs += 4;\n\t}\n\treturn data;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-protocol.js?");

/***/ }),

/***/ "./src/wifi-device.js":
/*!****************************!*\
  !*** ./src/wifi-device.js ***!
  \****************************/
/*! exports provided: WifiAntenna, WifiSecurity, WifiCipher, EapMethod, WifiDevice */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WifiAntenna\", function() { return WifiAntenna; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WifiSecurity\", function() { return WifiSecurity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WifiCipher\", function() { return WifiCipher; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EapMethod\", function() { return EapMethod; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WifiDevice\", function() { return WifiDevice; });\n/* harmony import */ var _request__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./request */ \"./src/request.js\");\n/* harmony import */ var _protobuf_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n\n\n\n\n/**\n * WiFi antenna types.\n */\nconst WifiAntenna = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WiFiAntenna, {\n\tINTERNAL: 'INTERNAL',\n\tEXTERNAL: 'EXTERNAL',\n\tAUTO: 'AUTO'\n});\n\n/**\n * WiFi security types.\n */\nconst WifiSecurity = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WiFiSecurityType, {\n\tNONE: 'UNSEC',\n\tWEP: 'WEP',\n\tWPA: 'WPA',\n\tWPA2: 'WPA2',\n\tWPA_ENTERPRISE: 'WPA_ENTERPRISE',\n\tWPA2_ENTERPRISE: 'WPA2_ENTERPRISE',\n\tUNKNOWN: 'UNKNOWN'\n});\n\n/**\n * WiFi cipher types.\n */\nconst WifiCipher = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WiFiSecurityCipher, {\n\tAES: 'AES',\n\tTKIP: 'TKIP',\n\tAES_TKIP: 'AES_TKIP'\n});\n\n/**\n * EAP methods.\n */\nconst EapMethod = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufEnum\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EapType, {\n\tTLS: 'TLS',\n\tPEAP: 'PEAP'\n});\n\nfunction bssidFromProtobuf(bssid) {\n\treturn [...bssid].map(b => b.toString(16).padStart(2, '0')).join(':');\n}\n\nfunction bssidToProtobuf(bssid) {\n\treturn Buffer.from(bssid.replace(/:/g, ''), 'hex');\n}\n\nconst accessPointCommonProperties = ['ssid', 'channel', 'maxDataRate', 'rssi', 'password', 'innerIdentity',\n\t'outerIdentity', 'privateKey', 'clientCertificate', 'caCertificate'];\n\nconst accessPointFromProtobuf = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"fromProtobufMessage\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidFromProtobuf,\n\tsecurity: WifiSecurity.fromProtobuf,\n\tcipher: WifiCipher.fromProtobuf,\n\teapType: {\n\t\tname: 'eapMethod',\n\t\tvalue: EapMethod.fromProtobuf\n\t}\n});\n\nconst accessPointToProtobuf = Object(_protobuf_util__WEBPACK_IMPORTED_MODULE_1__[\"toProtobufMessage\"])(_protocol__WEBPACK_IMPORTED_MODULE_2__[\"default\"].WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidToProtobuf,\n\tsecurity: WifiSecurity.toProtobuf,\n\tcipher: WifiCipher.toProtobuf,\n\teapMethod: {\n\t\tname: 'eapType',\n\t\tvalue: EapMethod.toProtobuf\n\t}\n});\n\n/**\n * Wi-Fi device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst WifiDevice = base => class extends base {\n\t/**\n\t * Set the WiFi antenna to use.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} antenna Antenna type.\n\t * @return {Promise}\n\t */\n\tsetWifiAntenna(antenna) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_SET_ANTENNA, {\n\t\t\tantenna: WifiAntenna.toProtobuf(antenna)\n\t\t});\n\t}\n\n\t/**\n\t * Get the currently used WiFi antenna.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetWifiAntenna(/* antenna */) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_GET_ANTENNA).then(rep => {\n\t\t\treturn WifiAntenna.fromProtobuf(rep.antenna);\n\t\t});\n\t}\n\n\t/**\n\t * Perform the WiFi scan.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tscanWifiNetworks() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_SCAN).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Set the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} credentials Credentials.\n\t * @return {Promise}\n\t */\n\tsetWifiCredentials(credentials) {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_SET_CREDENTIALS, {\n\t\t\tap: accessPointToProtobuf(credentials)\n\t\t});\n\t}\n\n\t/**\n\t * Get the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tgetWifiCredentials() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_GET_CREDENTIALS).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Clear the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearWifiCredentials() {\n\t\treturn this.sendRequest(_request__WEBPACK_IMPORTED_MODULE_0__[\"Request\"].WIFI_CLEAR_CREDENTIALS);\n\t}\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://ParticleUsb/./src/wifi-device.js?");

/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ParticleUsb/util_(ignored)?");

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* (ignored) */\n\n//# sourceURL=webpack://ParticleUsb/util_(ignored)?");

/***/ })

/******/ });
});