/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("ParticleUsb", [], factory);
	else if(typeof exports === 'object')
		exports["ParticleUsb"] = factory();
	else
		root["ParticleUsb"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/pb-message.js":
/*!***************************!*\
  !*** ./lib/pb-message.js ***!
  \***************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (true)\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /* CommonJS */ else {}\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.particle = (function() {\n    \n        var particle = {};\n    \n        particle.ctrl = (function() {\n    \n            var ctrl = {};\n    \n            ctrl.cellular = (function() {\n    \n                var cellular = {};\n    \n                cellular.SimType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_SIM_TYPE\"] = 0;\n                    values[valuesById[1] = \"INTERNAL\"] = 1;\n                    values[valuesById[2] = \"EXTERNAL\"] = 2;\n                    return values;\n                })();\n    \n                cellular.AccessPoint = (function() {\n    \n                    function AccessPoint(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AccessPoint.prototype.apn = \"\";\n                    AccessPoint.prototype.user = \"\";\n                    AccessPoint.prototype.password = \"\";\n                    AccessPoint.prototype.useDefaults = false;\n    \n                    AccessPoint.create = function create(properties) {\n                        return new AccessPoint(properties);\n                    };\n    \n                    AccessPoint.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.apn != null && Object.hasOwnProperty.call(m, \"apn\"))\n                            w.uint32(10).string(m.apn);\n                        if (m.user != null && Object.hasOwnProperty.call(m, \"user\"))\n                            w.uint32(18).string(m.user);\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(26).string(m.password);\n                        if (m.useDefaults != null && Object.hasOwnProperty.call(m, \"useDefaults\"))\n                            w.uint32(32).bool(m.useDefaults);\n                        return w;\n                    };\n    \n                    AccessPoint.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.AccessPoint();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.apn = r.string();\n                                break;\n                            case 2:\n                                m.user = r.string();\n                                break;\n                            case 3:\n                                m.password = r.string();\n                                break;\n                            case 4:\n                                m.useDefaults = r.bool();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AccessPoint;\n                })();\n    \n                cellular.SetAccessPointRequest = (function() {\n    \n                    function SetAccessPointRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetAccessPointRequest.prototype.simType = 0;\n                    SetAccessPointRequest.prototype.accessPoint = null;\n    \n                    SetAccessPointRequest.create = function create(properties) {\n                        return new SetAccessPointRequest(properties);\n                    };\n    \n                    SetAccessPointRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && Object.hasOwnProperty.call(m, \"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        if (m.accessPoint != null && Object.hasOwnProperty.call(m, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(m.accessPoint, w.uint32(18).fork()).ldelim();\n                        return w;\n                    };\n    \n                    SetAccessPointRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetAccessPointRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            case 2:\n                                m.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetAccessPointRequest;\n                })();\n    \n                cellular.SetAccessPointReply = (function() {\n    \n                    function SetAccessPointReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetAccessPointReply.create = function create(properties) {\n                        return new SetAccessPointReply(properties);\n                    };\n    \n                    SetAccessPointReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    SetAccessPointReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetAccessPointReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetAccessPointReply;\n                })();\n    \n                cellular.GetAccessPointRequest = (function() {\n    \n                    function GetAccessPointRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetAccessPointRequest.prototype.simType = 0;\n    \n                    GetAccessPointRequest.create = function create(properties) {\n                        return new GetAccessPointRequest(properties);\n                    };\n    \n                    GetAccessPointRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && Object.hasOwnProperty.call(m, \"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    GetAccessPointRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetAccessPointRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetAccessPointRequest;\n                })();\n    \n                cellular.GetAccessPointReply = (function() {\n    \n                    function GetAccessPointReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetAccessPointReply.prototype.accessPoint = null;\n    \n                    GetAccessPointReply.create = function create(properties) {\n                        return new GetAccessPointReply(properties);\n                    };\n    \n                    GetAccessPointReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.accessPoint != null && Object.hasOwnProperty.call(m, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(m.accessPoint, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    GetAccessPointReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetAccessPointReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetAccessPointReply;\n                })();\n    \n                cellular.SetActiveSimRequest = (function() {\n    \n                    function SetActiveSimRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetActiveSimRequest.prototype.simType = 0;\n    \n                    SetActiveSimRequest.create = function create(properties) {\n                        return new SetActiveSimRequest(properties);\n                    };\n    \n                    SetActiveSimRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && Object.hasOwnProperty.call(m, \"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    SetActiveSimRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetActiveSimRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetActiveSimRequest;\n                })();\n    \n                cellular.SetActiveSimReply = (function() {\n    \n                    function SetActiveSimReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SetActiveSimReply.create = function create(properties) {\n                        return new SetActiveSimReply(properties);\n                    };\n    \n                    SetActiveSimReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    SetActiveSimReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.SetActiveSimReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SetActiveSimReply;\n                })();\n    \n                cellular.GetActiveSimRequest = (function() {\n    \n                    function GetActiveSimRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetActiveSimRequest.create = function create(properties) {\n                        return new GetActiveSimRequest(properties);\n                    };\n    \n                    GetActiveSimRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetActiveSimRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetActiveSimRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetActiveSimRequest;\n                })();\n    \n                cellular.GetActiveSimReply = (function() {\n    \n                    function GetActiveSimReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetActiveSimReply.prototype.simType = 0;\n    \n                    GetActiveSimReply.create = function create(properties) {\n                        return new GetActiveSimReply(properties);\n                    };\n    \n                    GetActiveSimReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.simType != null && Object.hasOwnProperty.call(m, \"simType\"))\n                            w.uint32(8).int32(m.simType);\n                        return w;\n                    };\n    \n                    GetActiveSimReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetActiveSimReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.simType = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetActiveSimReply;\n                })();\n    \n                cellular.GetIccidRequest = (function() {\n    \n                    function GetIccidRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetIccidRequest.create = function create(properties) {\n                        return new GetIccidRequest(properties);\n                    };\n    \n                    GetIccidRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetIccidRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetIccidRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetIccidRequest;\n                })();\n    \n                cellular.GetIccidReply = (function() {\n    \n                    function GetIccidReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetIccidReply.prototype.iccid = \"\";\n    \n                    GetIccidReply.create = function create(properties) {\n                        return new GetIccidReply(properties);\n                    };\n    \n                    GetIccidReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.iccid != null && Object.hasOwnProperty.call(m, \"iccid\"))\n                            w.uint32(10).string(m.iccid);\n                        return w;\n                    };\n    \n                    GetIccidReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cellular.GetIccidReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.iccid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetIccidReply;\n                })();\n    \n                return cellular;\n            })();\n    \n            ctrl.ResultCode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"OK\"] = 0;\n                values[valuesById[1] = \"NOT_ALLOWED\"] = 1;\n                values[valuesById[2] = \"TIMEOUT\"] = 2;\n                values[valuesById[3] = \"NOT_FOUND\"] = 3;\n                values[valuesById[4] = \"ALREADY_EXIST\"] = 4;\n                values[valuesById[5] = \"INVALID_STATE\"] = 5;\n                values[valuesById[6] = \"NO_MEMORY\"] = 6;\n                values[valuesById[7] = \"INVALID_PARAM\"] = 7;\n                return values;\n            })();\n    \n            ctrl.Ipv4Address = (function() {\n    \n                function Ipv4Address(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv4Address.prototype.address = 0;\n    \n                Ipv4Address.create = function create(properties) {\n                    return new Ipv4Address(properties);\n                };\n    \n                Ipv4Address.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        w.uint32(13).fixed32(m.address);\n                    return w;\n                };\n    \n                Ipv4Address.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv4Address();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.fixed32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv4Address;\n            })();\n    \n            ctrl.Ipv6Address = (function() {\n    \n                function Ipv6Address(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv6Address.prototype.address = $util.newBuffer([]);\n    \n                Ipv6Address.create = function create(properties) {\n                    return new Ipv6Address(properties);\n                };\n    \n                Ipv6Address.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        w.uint32(10).bytes(m.address);\n                    return w;\n                };\n    \n                Ipv6Address.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv6Address();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv6Address;\n            })();\n    \n            ctrl.IpAddress = (function() {\n    \n                function IpAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IpAddress.prototype.v4 = null;\n                IpAddress.prototype.v6 = null;\n    \n                var $oneOfFields;\n    \n                Object.defineProperty(IpAddress.prototype, \"address\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"v4\", \"v6\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                IpAddress.create = function create(properties) {\n                    return new IpAddress(properties);\n                };\n    \n                IpAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.v4 != null && Object.hasOwnProperty.call(m, \"v4\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.v4, w.uint32(10).fork()).ldelim();\n                    if (m.v6 != null && Object.hasOwnProperty.call(m, \"v6\"))\n                        $root.particle.ctrl.Ipv6Address.encode(m.v6, w.uint32(18).fork()).ldelim();\n                    return w;\n                };\n    \n                IpAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IpAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.v4 = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.v6 = $root.particle.ctrl.Ipv6Address.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IpAddress;\n            })();\n    \n            ctrl.IPAddress = (function() {\n    \n                function IPAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IPAddress.prototype.protocol = 0;\n                IPAddress.prototype.address = $util.newBuffer([]);\n    \n                IPAddress.create = function create(properties) {\n                    return new IPAddress(properties);\n                };\n    \n                IPAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && Object.hasOwnProperty.call(m, \"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        w.uint32(18).bytes(m.address);\n                    return w;\n                };\n    \n                IPAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IPAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        case 2:\n                            m.address = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                IPAddress.Protocol = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"IPv4\"] = 1;\n                    values[valuesById[2] = \"IPv6\"] = 2;\n                    return values;\n                })();\n    \n                return IPAddress;\n            })();\n    \n            ctrl.cloud = (function() {\n    \n                var cloud = {};\n    \n                cloud.ConnectionStatus = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DISCONNECTED\"] = 0;\n                    values[valuesById[1] = \"CONNECTING\"] = 1;\n                    values[valuesById[2] = \"CONNECTED\"] = 2;\n                    values[valuesById[3] = \"DISCONNECTING\"] = 3;\n                    return values;\n                })();\n    \n                cloud.GetConnectionStatusRequest = (function() {\n    \n                    function GetConnectionStatusRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetConnectionStatusRequest.create = function create(properties) {\n                        return new GetConnectionStatusRequest(properties);\n                    };\n    \n                    GetConnectionStatusRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetConnectionStatusRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.GetConnectionStatusRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetConnectionStatusRequest;\n                })();\n    \n                cloud.GetConnectionStatusReply = (function() {\n    \n                    function GetConnectionStatusReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetConnectionStatusReply.prototype.status = 0;\n    \n                    GetConnectionStatusReply.create = function create(properties) {\n                        return new GetConnectionStatusReply(properties);\n                    };\n    \n                    GetConnectionStatusReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.status != null && Object.hasOwnProperty.call(m, \"status\"))\n                            w.uint32(8).int32(m.status);\n                        return w;\n                    };\n    \n                    GetConnectionStatusReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.GetConnectionStatusReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.status = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetConnectionStatusReply;\n                })();\n    \n                cloud.ConnectRequest = (function() {\n    \n                    function ConnectRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ConnectRequest.create = function create(properties) {\n                        return new ConnectRequest(properties);\n                    };\n    \n                    ConnectRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ConnectRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.ConnectRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ConnectRequest;\n                })();\n    \n                cloud.ConnectReply = (function() {\n    \n                    function ConnectReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ConnectReply.create = function create(properties) {\n                        return new ConnectReply(properties);\n                    };\n    \n                    ConnectReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ConnectReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.ConnectReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ConnectReply;\n                })();\n    \n                cloud.DisconnectRequest = (function() {\n    \n                    function DisconnectRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DisconnectRequest.create = function create(properties) {\n                        return new DisconnectRequest(properties);\n                    };\n    \n                    DisconnectRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    DisconnectRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.DisconnectRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return DisconnectRequest;\n                })();\n    \n                cloud.DisconnectReply = (function() {\n    \n                    function DisconnectReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DisconnectReply.create = function create(properties) {\n                        return new DisconnectReply(properties);\n                    };\n    \n                    DisconnectReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    DisconnectReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.cloud.DisconnectReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return DisconnectReply;\n                })();\n    \n                return cloud;\n            })();\n    \n            ctrl.SecurityKeyType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECURITY_KEY\"] = 0;\n                values[valuesById[1] = \"TCP_DEVICE_PRIVATE_KEY\"] = 1;\n                values[valuesById[2] = \"TCP_DEVICE_PUBLIC_KEY\"] = 2;\n                values[valuesById[3] = \"TCP_SERVER_PUBLIC_KEY\"] = 3;\n                values[valuesById[4] = \"UDP_DEVICE_PRIVATE_KEY\"] = 4;\n                values[valuesById[5] = \"UDP_DEVICE_PUBLIC_KEY\"] = 5;\n                values[valuesById[6] = \"UDP_SERVER_PUBLIC_KEY\"] = 6;\n                return values;\n            })();\n    \n            ctrl.ServerProtocolType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_PROTOCOL\"] = 0;\n                values[valuesById[1] = \"TCP_PROTOCOL\"] = 1;\n                values[valuesById[2] = \"UDP_PROTOCOL\"] = 2;\n                return values;\n            })();\n    \n            ctrl.DeviceMode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NORMAL_MODE\"] = 0;\n                values[valuesById[1] = \"LISTENING_MODE\"] = 1;\n                return values;\n            })();\n    \n            ctrl.SystemCapabilityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SYSTEM_CAPABILITY_FLAGS\"] = 0;\n                values[valuesById[1] = \"COMPRESSED_OTA\"] = 1;\n                return values;\n            })();\n    \n            ctrl.Feature = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FEATURE\"] = 0;\n                values[valuesById[1] = \"ETHERNET_DETECTION\"] = 1;\n                return values;\n            })();\n    \n            ctrl.GetDeviceIdRequest = (function() {\n    \n                function GetDeviceIdRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceIdRequest.create = function create(properties) {\n                    return new GetDeviceIdRequest(properties);\n                };\n    \n                GetDeviceIdRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetDeviceIdRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceIdRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceIdRequest;\n            })();\n    \n            ctrl.GetDeviceIdReply = (function() {\n    \n                function GetDeviceIdReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceIdReply.prototype.id = \"\";\n    \n                GetDeviceIdReply.create = function create(properties) {\n                    return new GetDeviceIdReply(properties);\n                };\n    \n                GetDeviceIdReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.id != null && Object.hasOwnProperty.call(m, \"id\"))\n                        w.uint32(10).string(m.id);\n                    return w;\n                };\n    \n                GetDeviceIdReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceIdReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.id = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceIdReply;\n            })();\n    \n            ctrl.GetSerialNumberRequest = (function() {\n    \n                function GetSerialNumberRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSerialNumberRequest.create = function create(properties) {\n                    return new GetSerialNumberRequest(properties);\n                };\n    \n                GetSerialNumberRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSerialNumberRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSerialNumberRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSerialNumberRequest;\n            })();\n    \n            ctrl.GetSerialNumberReply = (function() {\n    \n                function GetSerialNumberReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSerialNumberReply.prototype.serial = \"\";\n    \n                GetSerialNumberReply.create = function create(properties) {\n                    return new GetSerialNumberReply(properties);\n                };\n    \n                GetSerialNumberReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.serial != null && Object.hasOwnProperty.call(m, \"serial\"))\n                        w.uint32(10).string(m.serial);\n                    return w;\n                };\n    \n                GetSerialNumberReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSerialNumberReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.serial = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSerialNumberReply;\n            })();\n    \n            ctrl.GetSystemVersionRequest = (function() {\n    \n                function GetSystemVersionRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemVersionRequest.create = function create(properties) {\n                    return new GetSystemVersionRequest(properties);\n                };\n    \n                GetSystemVersionRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSystemVersionRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemVersionRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemVersionRequest;\n            })();\n    \n            ctrl.GetSystemVersionReply = (function() {\n    \n                function GetSystemVersionReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemVersionReply.prototype.version = \"\";\n    \n                GetSystemVersionReply.create = function create(properties) {\n                    return new GetSystemVersionReply(properties);\n                };\n    \n                GetSystemVersionReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.version != null && Object.hasOwnProperty.call(m, \"version\"))\n                        w.uint32(10).string(m.version);\n                    return w;\n                };\n    \n                GetSystemVersionReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemVersionReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.version = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemVersionReply;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionRequest = (function() {\n    \n                function GetNcpFirmwareVersionRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetNcpFirmwareVersionRequest.create = function create(properties) {\n                    return new GetNcpFirmwareVersionRequest(properties);\n                };\n    \n                GetNcpFirmwareVersionRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetNcpFirmwareVersionRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetNcpFirmwareVersionRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetNcpFirmwareVersionRequest;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionReply = (function() {\n    \n                function GetNcpFirmwareVersionReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetNcpFirmwareVersionReply.prototype.version = \"\";\n                GetNcpFirmwareVersionReply.prototype.moduleVersion = 0;\n    \n                GetNcpFirmwareVersionReply.create = function create(properties) {\n                    return new GetNcpFirmwareVersionReply(properties);\n                };\n    \n                GetNcpFirmwareVersionReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.version != null && Object.hasOwnProperty.call(m, \"version\"))\n                        w.uint32(10).string(m.version);\n                    if (m.moduleVersion != null && Object.hasOwnProperty.call(m, \"moduleVersion\"))\n                        w.uint32(16).uint32(m.moduleVersion);\n                    return w;\n                };\n    \n                GetNcpFirmwareVersionReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetNcpFirmwareVersionReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.version = r.string();\n                            break;\n                        case 2:\n                            m.moduleVersion = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetNcpFirmwareVersionReply;\n            })();\n    \n            ctrl.GetSystemCapabilitiesRequest = (function() {\n    \n                function GetSystemCapabilitiesRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemCapabilitiesRequest.create = function create(properties) {\n                    return new GetSystemCapabilitiesRequest(properties);\n                };\n    \n                GetSystemCapabilitiesRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetSystemCapabilitiesRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemCapabilitiesRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemCapabilitiesRequest;\n            })();\n    \n            ctrl.GetSystemCapabilitiesReply = (function() {\n    \n                function GetSystemCapabilitiesReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSystemCapabilitiesReply.prototype.flags = 0;\n    \n                GetSystemCapabilitiesReply.create = function create(properties) {\n                    return new GetSystemCapabilitiesReply(properties);\n                };\n    \n                GetSystemCapabilitiesReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                        w.uint32(13).fixed32(m.flags);\n                    return w;\n                };\n    \n                GetSystemCapabilitiesReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSystemCapabilitiesReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.flags = r.fixed32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSystemCapabilitiesReply;\n            })();\n    \n            ctrl.SetClaimCodeRequest = (function() {\n    \n                function SetClaimCodeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetClaimCodeRequest.prototype.code = \"\";\n    \n                SetClaimCodeRequest.create = function create(properties) {\n                    return new SetClaimCodeRequest(properties);\n                };\n    \n                SetClaimCodeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.code != null && Object.hasOwnProperty.call(m, \"code\"))\n                        w.uint32(10).string(m.code);\n                    return w;\n                };\n    \n                SetClaimCodeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetClaimCodeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.code = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetClaimCodeRequest;\n            })();\n    \n            ctrl.SetClaimCodeReply = (function() {\n    \n                function SetClaimCodeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetClaimCodeReply.create = function create(properties) {\n                    return new SetClaimCodeReply(properties);\n                };\n    \n                SetClaimCodeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetClaimCodeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetClaimCodeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetClaimCodeReply;\n            })();\n    \n            ctrl.IsClaimedRequest = (function() {\n    \n                function IsClaimedRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsClaimedRequest.create = function create(properties) {\n                    return new IsClaimedRequest(properties);\n                };\n    \n                IsClaimedRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                IsClaimedRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsClaimedRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsClaimedRequest;\n            })();\n    \n            ctrl.IsClaimedReply = (function() {\n    \n                function IsClaimedReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsClaimedReply.prototype.claimed = false;\n    \n                IsClaimedReply.create = function create(properties) {\n                    return new IsClaimedReply(properties);\n                };\n    \n                IsClaimedReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.claimed != null && Object.hasOwnProperty.call(m, \"claimed\"))\n                        w.uint32(8).bool(m.claimed);\n                    return w;\n                };\n    \n                IsClaimedReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsClaimedReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.claimed = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsClaimedReply;\n            })();\n    \n            ctrl.SetSecurityKeyRequest = (function() {\n    \n                function SetSecurityKeyRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSecurityKeyRequest.prototype.type = 0;\n                SetSecurityKeyRequest.prototype.data = $util.newBuffer([]);\n    \n                SetSecurityKeyRequest.create = function create(properties) {\n                    return new SetSecurityKeyRequest(properties);\n                };\n    \n                SetSecurityKeyRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(8).int32(m.type);\n                    if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                        w.uint32(18).bytes(m.data);\n                    return w;\n                };\n    \n                SetSecurityKeyRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSecurityKeyRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        case 2:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSecurityKeyRequest;\n            })();\n    \n            ctrl.SetSecurityKeyReply = (function() {\n    \n                function SetSecurityKeyReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSecurityKeyReply.create = function create(properties) {\n                    return new SetSecurityKeyReply(properties);\n                };\n    \n                SetSecurityKeyReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetSecurityKeyReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSecurityKeyReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSecurityKeyReply;\n            })();\n    \n            ctrl.GetSecurityKeyRequest = (function() {\n    \n                function GetSecurityKeyRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSecurityKeyRequest.prototype.type = 0;\n    \n                GetSecurityKeyRequest.create = function create(properties) {\n                    return new GetSecurityKeyRequest(properties);\n                };\n    \n                GetSecurityKeyRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(8).int32(m.type);\n                    return w;\n                };\n    \n                GetSecurityKeyRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSecurityKeyRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSecurityKeyRequest;\n            })();\n    \n            ctrl.GetSecurityKeyReply = (function() {\n    \n                function GetSecurityKeyReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSecurityKeyReply.prototype.data = $util.newBuffer([]);\n    \n                GetSecurityKeyReply.create = function create(properties) {\n                    return new GetSecurityKeyReply(properties);\n                };\n    \n                GetSecurityKeyReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                GetSecurityKeyReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSecurityKeyReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSecurityKeyReply;\n            })();\n    \n            ctrl.SetServerAddressRequest = (function() {\n    \n                function SetServerAddressRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerAddressRequest.prototype.protocol = 0;\n                SetServerAddressRequest.prototype.address = \"\";\n                SetServerAddressRequest.prototype.port = 0;\n    \n                SetServerAddressRequest.create = function create(properties) {\n                    return new SetServerAddressRequest(properties);\n                };\n    \n                SetServerAddressRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && Object.hasOwnProperty.call(m, \"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        w.uint32(18).string(m.address);\n                    if (m.port != null && Object.hasOwnProperty.call(m, \"port\"))\n                        w.uint32(24).int32(m.port);\n                    return w;\n                };\n    \n                SetServerAddressRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerAddressRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        case 2:\n                            m.address = r.string();\n                            break;\n                        case 3:\n                            m.port = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerAddressRequest;\n            })();\n    \n            ctrl.SetServerAddressReply = (function() {\n    \n                function SetServerAddressReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerAddressReply.create = function create(properties) {\n                    return new SetServerAddressReply(properties);\n                };\n    \n                SetServerAddressReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetServerAddressReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerAddressReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerAddressReply;\n            })();\n    \n            ctrl.GetServerAddressRequest = (function() {\n    \n                function GetServerAddressRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerAddressRequest.prototype.protocol = 0;\n    \n                GetServerAddressRequest.create = function create(properties) {\n                    return new GetServerAddressRequest(properties);\n                };\n    \n                GetServerAddressRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && Object.hasOwnProperty.call(m, \"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                GetServerAddressRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerAddressRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerAddressRequest;\n            })();\n    \n            ctrl.GetServerAddressReply = (function() {\n    \n                function GetServerAddressReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerAddressReply.prototype.address = \"\";\n                GetServerAddressReply.prototype.port = 0;\n    \n                GetServerAddressReply.create = function create(properties) {\n                    return new GetServerAddressReply(properties);\n                };\n    \n                GetServerAddressReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        w.uint32(10).string(m.address);\n                    if (m.port != null && Object.hasOwnProperty.call(m, \"port\"))\n                        w.uint32(16).int32(m.port);\n                    return w;\n                };\n    \n                GetServerAddressReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerAddressReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = r.string();\n                            break;\n                        case 2:\n                            m.port = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerAddressReply;\n            })();\n    \n            ctrl.SetServerProtocolRequest = (function() {\n    \n                function SetServerProtocolRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerProtocolRequest.prototype.protocol = 0;\n    \n                SetServerProtocolRequest.create = function create(properties) {\n                    return new SetServerProtocolRequest(properties);\n                };\n    \n                SetServerProtocolRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && Object.hasOwnProperty.call(m, \"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                SetServerProtocolRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerProtocolRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerProtocolRequest;\n            })();\n    \n            ctrl.SetServerProtocolReply = (function() {\n    \n                function SetServerProtocolReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetServerProtocolReply.create = function create(properties) {\n                    return new SetServerProtocolReply(properties);\n                };\n    \n                SetServerProtocolReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetServerProtocolReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetServerProtocolReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetServerProtocolReply;\n            })();\n    \n            ctrl.GetServerProtocolRequest = (function() {\n    \n                function GetServerProtocolRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerProtocolRequest.create = function create(properties) {\n                    return new GetServerProtocolRequest(properties);\n                };\n    \n                GetServerProtocolRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetServerProtocolRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerProtocolRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerProtocolRequest;\n            })();\n    \n            ctrl.GetServerProtocolReply = (function() {\n    \n                function GetServerProtocolReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetServerProtocolReply.prototype.protocol = 0;\n    \n                GetServerProtocolReply.create = function create(properties) {\n                    return new GetServerProtocolReply(properties);\n                };\n    \n                GetServerProtocolReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.protocol != null && Object.hasOwnProperty.call(m, \"protocol\"))\n                        w.uint32(8).int32(m.protocol);\n                    return w;\n                };\n    \n                GetServerProtocolReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetServerProtocolReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.protocol = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetServerProtocolReply;\n            })();\n    \n            ctrl.SetSoftApSsidRequest = (function() {\n    \n                function SetSoftApSsidRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSoftApSsidRequest.prototype.prefix = \"\";\n                SetSoftApSsidRequest.prototype.suffix = \"\";\n    \n                SetSoftApSsidRequest.create = function create(properties) {\n                    return new SetSoftApSsidRequest(properties);\n                };\n    \n                SetSoftApSsidRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.prefix != null && Object.hasOwnProperty.call(m, \"prefix\"))\n                        w.uint32(10).string(m.prefix);\n                    if (m.suffix != null && Object.hasOwnProperty.call(m, \"suffix\"))\n                        w.uint32(18).string(m.suffix);\n                    return w;\n                };\n    \n                SetSoftApSsidRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSoftApSsidRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.prefix = r.string();\n                            break;\n                        case 2:\n                            m.suffix = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSoftApSsidRequest;\n            })();\n    \n            ctrl.SetSoftApSsidReply = (function() {\n    \n                function SetSoftApSsidReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetSoftApSsidReply.create = function create(properties) {\n                    return new SetSoftApSsidReply(properties);\n                };\n    \n                SetSoftApSsidReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetSoftApSsidReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetSoftApSsidReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetSoftApSsidReply;\n            })();\n    \n            ctrl.StartListeningModeRequest = (function() {\n    \n                function StartListeningModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartListeningModeRequest.create = function create(properties) {\n                    return new StartListeningModeRequest(properties);\n                };\n    \n                StartListeningModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StartListeningModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartListeningModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartListeningModeRequest;\n            })();\n    \n            ctrl.StartListeningModeReply = (function() {\n    \n                function StartListeningModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartListeningModeReply.create = function create(properties) {\n                    return new StartListeningModeReply(properties);\n                };\n    \n                StartListeningModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StartListeningModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartListeningModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartListeningModeReply;\n            })();\n    \n            ctrl.StopListeningModeRequest = (function() {\n    \n                function StopListeningModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StopListeningModeRequest.create = function create(properties) {\n                    return new StopListeningModeRequest(properties);\n                };\n    \n                StopListeningModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StopListeningModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StopListeningModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StopListeningModeRequest;\n            })();\n    \n            ctrl.StopListeningModeReply = (function() {\n    \n                function StopListeningModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StopListeningModeReply.create = function create(properties) {\n                    return new StopListeningModeReply(properties);\n                };\n    \n                StopListeningModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                StopListeningModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StopListeningModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StopListeningModeReply;\n            })();\n    \n            ctrl.GetDeviceModeRequest = (function() {\n    \n                function GetDeviceModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceModeRequest.create = function create(properties) {\n                    return new GetDeviceModeRequest(properties);\n                };\n    \n                GetDeviceModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetDeviceModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceModeRequest;\n            })();\n    \n            ctrl.GetDeviceModeReply = (function() {\n    \n                function GetDeviceModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetDeviceModeReply.prototype.mode = 0;\n    \n                GetDeviceModeReply.create = function create(properties) {\n                    return new GetDeviceModeReply(properties);\n                };\n    \n                GetDeviceModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n                        w.uint32(8).int32(m.mode);\n                    return w;\n                };\n    \n                GetDeviceModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetDeviceModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.mode = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetDeviceModeReply;\n            })();\n    \n            ctrl.SetDeviceSetupDoneRequest = (function() {\n    \n                function SetDeviceSetupDoneRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetDeviceSetupDoneRequest.prototype.done = false;\n    \n                SetDeviceSetupDoneRequest.create = function create(properties) {\n                    return new SetDeviceSetupDoneRequest(properties);\n                };\n    \n                SetDeviceSetupDoneRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.done != null && Object.hasOwnProperty.call(m, \"done\"))\n                        w.uint32(8).bool(m.done);\n                    return w;\n                };\n    \n                SetDeviceSetupDoneRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetDeviceSetupDoneRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.done = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.SetDeviceSetupDoneReply = (function() {\n    \n                function SetDeviceSetupDoneReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetDeviceSetupDoneReply.create = function create(properties) {\n                    return new SetDeviceSetupDoneReply(properties);\n                };\n    \n                SetDeviceSetupDoneReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetDeviceSetupDoneReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetDeviceSetupDoneReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetDeviceSetupDoneReply;\n            })();\n    \n            ctrl.IsDeviceSetupDoneRequest = (function() {\n    \n                function IsDeviceSetupDoneRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsDeviceSetupDoneRequest.create = function create(properties) {\n                    return new IsDeviceSetupDoneRequest(properties);\n                };\n    \n                IsDeviceSetupDoneRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                IsDeviceSetupDoneRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsDeviceSetupDoneRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.IsDeviceSetupDoneReply = (function() {\n    \n                function IsDeviceSetupDoneReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IsDeviceSetupDoneReply.prototype.done = false;\n    \n                IsDeviceSetupDoneReply.create = function create(properties) {\n                    return new IsDeviceSetupDoneReply(properties);\n                };\n    \n                IsDeviceSetupDoneReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.done != null && Object.hasOwnProperty.call(m, \"done\"))\n                        w.uint32(8).bool(m.done);\n                    return w;\n                };\n    \n                IsDeviceSetupDoneReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IsDeviceSetupDoneReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.done = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return IsDeviceSetupDoneReply;\n            })();\n    \n            ctrl.SetStartupModeRequest = (function() {\n    \n                function SetStartupModeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetStartupModeRequest.prototype.mode = 0;\n    \n                SetStartupModeRequest.create = function create(properties) {\n                    return new SetStartupModeRequest(properties);\n                };\n    \n                SetStartupModeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n                        w.uint32(8).int32(m.mode);\n                    return w;\n                };\n    \n                SetStartupModeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetStartupModeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.mode = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetStartupModeRequest;\n            })();\n    \n            ctrl.SetStartupModeReply = (function() {\n    \n                function SetStartupModeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetStartupModeReply.create = function create(properties) {\n                    return new SetStartupModeReply(properties);\n                };\n    \n                SetStartupModeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetStartupModeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetStartupModeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetStartupModeReply;\n            })();\n    \n            ctrl.SystemResetRequest = (function() {\n    \n                function SystemResetRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SystemResetRequest.create = function create(properties) {\n                    return new SystemResetRequest(properties);\n                };\n    \n                SystemResetRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SystemResetRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SystemResetRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SystemResetRequest;\n            })();\n    \n            ctrl.SystemResetReply = (function() {\n    \n                function SystemResetReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SystemResetReply.create = function create(properties) {\n                    return new SystemResetReply(properties);\n                };\n    \n                SystemResetReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SystemResetReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SystemResetReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SystemResetReply;\n            })();\n    \n            ctrl.SetFeatureRequest = (function() {\n    \n                function SetFeatureRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetFeatureRequest.prototype.feature = 0;\n                SetFeatureRequest.prototype.enabled = false;\n    \n                SetFeatureRequest.create = function create(properties) {\n                    return new SetFeatureRequest(properties);\n                };\n    \n                SetFeatureRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.feature != null && Object.hasOwnProperty.call(m, \"feature\"))\n                        w.uint32(8).int32(m.feature);\n                    if (m.enabled != null && Object.hasOwnProperty.call(m, \"enabled\"))\n                        w.uint32(16).bool(m.enabled);\n                    return w;\n                };\n    \n                SetFeatureRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetFeatureRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.feature = r.int32();\n                            break;\n                        case 2:\n                            m.enabled = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetFeatureRequest;\n            })();\n    \n            ctrl.SetFeatureReply = (function() {\n    \n                function SetFeatureReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SetFeatureReply.create = function create(properties) {\n                    return new SetFeatureReply(properties);\n                };\n    \n                SetFeatureReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                SetFeatureReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.SetFeatureReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return SetFeatureReply;\n            })();\n    \n            ctrl.GetFeatureRequest = (function() {\n    \n                function GetFeatureRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetFeatureRequest.prototype.feature = 0;\n    \n                GetFeatureRequest.create = function create(properties) {\n                    return new GetFeatureRequest(properties);\n                };\n    \n                GetFeatureRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.feature != null && Object.hasOwnProperty.call(m, \"feature\"))\n                        w.uint32(8).int32(m.feature);\n                    return w;\n                };\n    \n                GetFeatureRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetFeatureRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.feature = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetFeatureRequest;\n            })();\n    \n            ctrl.GetFeatureReply = (function() {\n    \n                function GetFeatureReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetFeatureReply.prototype.enabled = false;\n    \n                GetFeatureReply.create = function create(properties) {\n                    return new GetFeatureReply(properties);\n                };\n    \n                GetFeatureReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.enabled != null && Object.hasOwnProperty.call(m, \"enabled\"))\n                        w.uint32(8).bool(m.enabled);\n                    return w;\n                };\n    \n                GetFeatureReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetFeatureReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.enabled = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetFeatureReply;\n            })();\n    \n            ctrl.WiFiGetAntennaRequest = (function() {\n    \n                function WiFiGetAntennaRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetAntennaRequest.create = function create(properties) {\n                    return new WiFiGetAntennaRequest(properties);\n                };\n    \n                WiFiGetAntennaRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiGetAntennaRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetAntennaRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetAntennaRequest;\n            })();\n    \n            ctrl.WiFiGetAntennaReply = (function() {\n    \n                function WiFiGetAntennaReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetAntennaReply.prototype.antenna = 0;\n    \n                WiFiGetAntennaReply.create = function create(properties) {\n                    return new WiFiGetAntennaReply(properties);\n                };\n    \n                WiFiGetAntennaReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.antenna != null && Object.hasOwnProperty.call(m, \"antenna\"))\n                        w.uint32(8).int32(m.antenna);\n                    return w;\n                };\n    \n                WiFiGetAntennaReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetAntennaReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.antenna = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetAntennaReply;\n            })();\n    \n            ctrl.WiFiSetAntennaRequest = (function() {\n    \n                function WiFiSetAntennaRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetAntennaRequest.prototype.antenna = 0;\n    \n                WiFiSetAntennaRequest.create = function create(properties) {\n                    return new WiFiSetAntennaRequest(properties);\n                };\n    \n                WiFiSetAntennaRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.antenna != null && Object.hasOwnProperty.call(m, \"antenna\"))\n                        w.uint32(8).int32(m.antenna);\n                    return w;\n                };\n    \n                WiFiSetAntennaRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetAntennaRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.antenna = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetAntennaRequest;\n            })();\n    \n            ctrl.WiFiSetAntennaReply = (function() {\n    \n                function WiFiSetAntennaReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetAntennaReply.create = function create(properties) {\n                    return new WiFiSetAntennaReply(properties);\n                };\n    \n                WiFiSetAntennaReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiSetAntennaReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetAntennaReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetAntennaReply;\n            })();\n    \n            ctrl.WiFiScanRequest = (function() {\n    \n                function WiFiScanRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiScanRequest.create = function create(properties) {\n                    return new WiFiScanRequest(properties);\n                };\n    \n                WiFiScanRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiScanRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiScanRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiScanRequest;\n            })();\n    \n            ctrl.WiFiScanReply = (function() {\n    \n                function WiFiScanReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiScanReply.prototype.list = null;\n    \n                WiFiScanReply.create = function create(properties) {\n                    return new WiFiScanReply(properties);\n                };\n    \n                WiFiScanReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.list != null && Object.hasOwnProperty.call(m, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(m.list, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiScanReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiScanReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.list = $root.particle.ctrl.WiFiAccessPointList.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiScanReply;\n            })();\n    \n            ctrl.WiFiGetCredentialsRequest = (function() {\n    \n                function WiFiGetCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetCredentialsRequest.create = function create(properties) {\n                    return new WiFiGetCredentialsRequest(properties);\n                };\n    \n                WiFiGetCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiGetCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiGetCredentialsReply = (function() {\n    \n                function WiFiGetCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiGetCredentialsReply.prototype.list = null;\n    \n                WiFiGetCredentialsReply.create = function create(properties) {\n                    return new WiFiGetCredentialsReply(properties);\n                };\n    \n                WiFiGetCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.list != null && Object.hasOwnProperty.call(m, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(m.list, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiGetCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiGetCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.list = $root.particle.ctrl.WiFiAccessPointList.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiGetCredentialsReply;\n            })();\n    \n            ctrl.WiFiSetCredentialsRequest = (function() {\n    \n                function WiFiSetCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetCredentialsRequest.prototype.ap = null;\n    \n                WiFiSetCredentialsRequest.create = function create(properties) {\n                    return new WiFiSetCredentialsRequest(properties);\n                };\n    \n                WiFiSetCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ap != null && Object.hasOwnProperty.call(m, \"ap\"))\n                        $root.particle.ctrl.WiFiAccessPoint.encode(m.ap, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                WiFiSetCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ap = $root.particle.ctrl.WiFiAccessPoint.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiSetCredentialsReply = (function() {\n    \n                function WiFiSetCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiSetCredentialsReply.create = function create(properties) {\n                    return new WiFiSetCredentialsReply(properties);\n                };\n    \n                WiFiSetCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiSetCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiSetCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiSetCredentialsReply;\n            })();\n    \n            ctrl.WiFiClearCredentialsRequest = (function() {\n    \n                function WiFiClearCredentialsRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiClearCredentialsRequest.create = function create(properties) {\n                    return new WiFiClearCredentialsRequest(properties);\n                };\n    \n                WiFiClearCredentialsRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiClearCredentialsRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiClearCredentialsRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiClearCredentialsRequest;\n            })();\n    \n            ctrl.WiFiClearCredentialsReply = (function() {\n    \n                function WiFiClearCredentialsReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiClearCredentialsReply.create = function create(properties) {\n                    return new WiFiClearCredentialsReply(properties);\n                };\n    \n                WiFiClearCredentialsReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WiFiClearCredentialsReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiClearCredentialsReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiClearCredentialsReply;\n            })();\n    \n            ctrl.WiFiAntenna = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"ANTENNA_NONE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                values[valuesById[2] = \"EXTERNAL\"] = 2;\n                values[valuesById[3] = \"AUTO\"] = 3;\n                return values;\n            })();\n    \n            ctrl.WiFiSecurityType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"UNSEC\"] = 0;\n                values[valuesById[1] = \"WEP\"] = 1;\n                values[valuesById[2] = \"WPA\"] = 2;\n                values[valuesById[3] = \"WPA2\"] = 3;\n                values[valuesById[4] = \"WPA_ENTERPRISE\"] = 4;\n                values[valuesById[5] = \"WPA2_ENTERPRISE\"] = 5;\n                values[valuesById[255] = \"UNKNOWN\"] = 255;\n                return values;\n            })();\n    \n            ctrl.WiFiSecurityCipher = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"CIPHER_NONE\"] = 0;\n                values[valuesById[1] = \"AES\"] = 1;\n                values[valuesById[2] = \"TKIP\"] = 2;\n                values[valuesById[3] = \"AES_TKIP\"] = 3;\n                return values;\n            })();\n    \n            ctrl.EapType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"EAP_TYPE_NONE\"] = 0;\n                values[valuesById[13] = \"TLS\"] = 13;\n                values[valuesById[25] = \"PEAP\"] = 25;\n                return values;\n            })();\n    \n            ctrl.WiFiAccessPoint = (function() {\n    \n                function WiFiAccessPoint(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiAccessPoint.prototype.ssid = \"\";\n                WiFiAccessPoint.prototype.bssid = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.security = 0;\n                WiFiAccessPoint.prototype.cipher = 0;\n                WiFiAccessPoint.prototype.channel = 0;\n                WiFiAccessPoint.prototype.maxDataRate = 0;\n                WiFiAccessPoint.prototype.rssi = 0;\n                WiFiAccessPoint.prototype.password = \"\";\n                WiFiAccessPoint.prototype.eapType = 0;\n                WiFiAccessPoint.prototype.innerIdentity = \"\";\n                WiFiAccessPoint.prototype.outerIdentity = \"\";\n                WiFiAccessPoint.prototype.privateKey = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.clientCertificate = $util.newBuffer([]);\n                WiFiAccessPoint.prototype.caCertificate = $util.newBuffer([]);\n    \n                WiFiAccessPoint.create = function create(properties) {\n                    return new WiFiAccessPoint(properties);\n                };\n    \n                WiFiAccessPoint.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                        w.uint32(10).string(m.ssid);\n                    if (m.bssid != null && Object.hasOwnProperty.call(m, \"bssid\"))\n                        w.uint32(18).bytes(m.bssid);\n                    if (m.security != null && Object.hasOwnProperty.call(m, \"security\"))\n                        w.uint32(24).int32(m.security);\n                    if (m.cipher != null && Object.hasOwnProperty.call(m, \"cipher\"))\n                        w.uint32(32).int32(m.cipher);\n                    if (m.channel != null && Object.hasOwnProperty.call(m, \"channel\"))\n                        w.uint32(40).uint32(m.channel);\n                    if (m.maxDataRate != null && Object.hasOwnProperty.call(m, \"maxDataRate\"))\n                        w.uint32(48).int32(m.maxDataRate);\n                    if (m.rssi != null && Object.hasOwnProperty.call(m, \"rssi\"))\n                        w.uint32(56).int32(m.rssi);\n                    if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                        w.uint32(66).string(m.password);\n                    if (m.eapType != null && Object.hasOwnProperty.call(m, \"eapType\"))\n                        w.uint32(72).int32(m.eapType);\n                    if (m.innerIdentity != null && Object.hasOwnProperty.call(m, \"innerIdentity\"))\n                        w.uint32(82).string(m.innerIdentity);\n                    if (m.outerIdentity != null && Object.hasOwnProperty.call(m, \"outerIdentity\"))\n                        w.uint32(90).string(m.outerIdentity);\n                    if (m.privateKey != null && Object.hasOwnProperty.call(m, \"privateKey\"))\n                        w.uint32(98).bytes(m.privateKey);\n                    if (m.clientCertificate != null && Object.hasOwnProperty.call(m, \"clientCertificate\"))\n                        w.uint32(106).bytes(m.clientCertificate);\n                    if (m.caCertificate != null && Object.hasOwnProperty.call(m, \"caCertificate\"))\n                        w.uint32(114).bytes(m.caCertificate);\n                    return w;\n                };\n    \n                WiFiAccessPoint.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiAccessPoint();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ssid = r.string();\n                            break;\n                        case 2:\n                            m.bssid = r.bytes();\n                            break;\n                        case 3:\n                            m.security = r.int32();\n                            break;\n                        case 4:\n                            m.cipher = r.int32();\n                            break;\n                        case 5:\n                            m.channel = r.uint32();\n                            break;\n                        case 6:\n                            m.maxDataRate = r.int32();\n                            break;\n                        case 7:\n                            m.rssi = r.int32();\n                            break;\n                        case 8:\n                            m.password = r.string();\n                            break;\n                        case 9:\n                            m.eapType = r.int32();\n                            break;\n                        case 10:\n                            m.innerIdentity = r.string();\n                            break;\n                        case 11:\n                            m.outerIdentity = r.string();\n                            break;\n                        case 12:\n                            m.privateKey = r.bytes();\n                            break;\n                        case 13:\n                            m.clientCertificate = r.bytes();\n                            break;\n                        case 14:\n                            m.caCertificate = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiAccessPoint;\n            })();\n    \n            ctrl.WiFiAccessPointList = (function() {\n    \n                function WiFiAccessPointList(p) {\n                    this.aps = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WiFiAccessPointList.prototype.aps = $util.emptyArray;\n    \n                WiFiAccessPointList.create = function create(properties) {\n                    return new WiFiAccessPointList(properties);\n                };\n    \n                WiFiAccessPointList.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.aps != null && m.aps.length) {\n                        for (var i = 0; i < m.aps.length; ++i)\n                            $root.particle.ctrl.WiFiAccessPoint.encode(m.aps[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                WiFiAccessPointList.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WiFiAccessPointList();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.aps && m.aps.length))\n                                m.aps = [];\n                            m.aps.push($root.particle.ctrl.WiFiAccessPoint.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WiFiAccessPointList;\n            })();\n    \n            ctrl.NetworkGetStatusRequest = (function() {\n    \n                function NetworkGetStatusRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetStatusRequest.prototype[\"interface\"] = 0;\n    \n                NetworkGetStatusRequest.create = function create(properties) {\n                    return new NetworkGetStatusRequest(properties);\n                };\n    \n                NetworkGetStatusRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && Object.hasOwnProperty.call(m, \"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    return w;\n                };\n    \n                NetworkGetStatusRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetStatusRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetStatusRequest;\n            })();\n    \n            ctrl.NetworkGetStatusReply = (function() {\n    \n                function NetworkGetStatusReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetStatusReply.prototype.config = null;\n    \n                NetworkGetStatusReply.create = function create(properties) {\n                    return new NetworkGetStatusReply(properties);\n                };\n    \n                NetworkGetStatusReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && Object.hasOwnProperty.call(m, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkGetStatusReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetStatusReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetStatusReply;\n            })();\n    \n            ctrl.NetworkGetConfigurationRequest = (function() {\n    \n                function NetworkGetConfigurationRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetConfigurationRequest.prototype[\"interface\"] = 0;\n    \n                NetworkGetConfigurationRequest.create = function create(properties) {\n                    return new NetworkGetConfigurationRequest(properties);\n                };\n    \n                NetworkGetConfigurationRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && Object.hasOwnProperty.call(m, \"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    return w;\n                };\n    \n                NetworkGetConfigurationRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetConfigurationRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkGetConfigurationReply = (function() {\n    \n                function NetworkGetConfigurationReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkGetConfigurationReply.prototype.config = null;\n    \n                NetworkGetConfigurationReply.create = function create(properties) {\n                    return new NetworkGetConfigurationReply(properties);\n                };\n    \n                NetworkGetConfigurationReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && Object.hasOwnProperty.call(m, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkGetConfigurationReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkGetConfigurationReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkGetConfigurationReply;\n            })();\n    \n            ctrl.NetworkSetConfigurationRequest = (function() {\n    \n                function NetworkSetConfigurationRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkSetConfigurationRequest.prototype.config = null;\n    \n                NetworkSetConfigurationRequest.create = function create(properties) {\n                    return new NetworkSetConfigurationRequest(properties);\n                };\n    \n                NetworkSetConfigurationRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.config != null && Object.hasOwnProperty.call(m, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(m.config, w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkSetConfigurationRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkSetConfigurationRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.config = $root.particle.ctrl.NetworkConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkSetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkSetConfigurationReply = (function() {\n    \n                function NetworkSetConfigurationReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkSetConfigurationReply.create = function create(properties) {\n                    return new NetworkSetConfigurationReply(properties);\n                };\n    \n                NetworkSetConfigurationReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                NetworkSetConfigurationReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkSetConfigurationReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkSetConfigurationReply;\n            })();\n    \n            ctrl.NetworkState = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NETWORK_STATUS_NONE\"] = 0;\n                values[valuesById[1] = \"DOWN\"] = 1;\n                values[valuesById[2] = \"UP\"] = 2;\n                return values;\n            })();\n    \n            ctrl.IPConfiguration = (function() {\n    \n                function IPConfiguration(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                IPConfiguration.prototype.type = 0;\n                IPConfiguration.prototype.address = null;\n                IPConfiguration.prototype.netmask = null;\n                IPConfiguration.prototype.gateway = null;\n                IPConfiguration.prototype.dhcpServer = null;\n                IPConfiguration.prototype.hostname = \"\";\n    \n                IPConfiguration.create = function create(properties) {\n                    return new IPConfiguration(properties);\n                };\n    \n                IPConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(8).int32(m.type);\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        $root.particle.ctrl.IPAddress.encode(m.address, w.uint32(18).fork()).ldelim();\n                    if (m.netmask != null && Object.hasOwnProperty.call(m, \"netmask\"))\n                        $root.particle.ctrl.IPAddress.encode(m.netmask, w.uint32(26).fork()).ldelim();\n                    if (m.gateway != null && Object.hasOwnProperty.call(m, \"gateway\"))\n                        $root.particle.ctrl.IPAddress.encode(m.gateway, w.uint32(34).fork()).ldelim();\n                    if (m.dhcpServer != null && Object.hasOwnProperty.call(m, \"dhcpServer\"))\n                        $root.particle.ctrl.IPAddress.encode(m.dhcpServer, w.uint32(42).fork()).ldelim();\n                    if (m.hostname != null && Object.hasOwnProperty.call(m, \"hostname\"))\n                        w.uint32(50).string(m.hostname);\n                    return w;\n                };\n    \n                IPConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.IPConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.type = r.int32();\n                            break;\n                        case 2:\n                            m.address = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.netmask = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 4:\n                            m.gateway = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 5:\n                            m.dhcpServer = $root.particle.ctrl.IPAddress.decode(r, r.uint32());\n                            break;\n                        case 6:\n                            m.hostname = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                IPConfiguration.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"DHCP\"] = 1;\n                    values[valuesById[2] = \"STATIC\"] = 2;\n                    return values;\n                })();\n    \n                return IPConfiguration;\n            })();\n    \n            ctrl.DNSConfiguration = (function() {\n    \n                function DNSConfiguration(p) {\n                    this.servers = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DNSConfiguration.prototype.servers = $util.emptyArray;\n    \n                DNSConfiguration.create = function create(properties) {\n                    return new DNSConfiguration(properties);\n                };\n    \n                DNSConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.servers != null && m.servers.length) {\n                        for (var i = 0; i < m.servers.length; ++i)\n                            $root.particle.ctrl.IPAddress.encode(m.servers[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                DNSConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DNSConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.servers && m.servers.length))\n                                m.servers = [];\n                            m.servers.push($root.particle.ctrl.IPAddress.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return DNSConfiguration;\n            })();\n    \n            ctrl.NetworkConfiguration = (function() {\n    \n                function NetworkConfiguration(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                NetworkConfiguration.prototype[\"interface\"] = 0;\n                NetworkConfiguration.prototype.state = 0;\n                NetworkConfiguration.prototype.name = \"\";\n                NetworkConfiguration.prototype.mac = $util.newBuffer([]);\n                NetworkConfiguration.prototype.ipconfig = null;\n                NetworkConfiguration.prototype.dnsconfig = null;\n    \n                NetworkConfiguration.create = function create(properties) {\n                    return new NetworkConfiguration(properties);\n                };\n    \n                NetworkConfiguration.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && Object.hasOwnProperty.call(m, \"interface\"))\n                        w.uint32(8).int32(m[\"interface\"]);\n                    if (m.state != null && Object.hasOwnProperty.call(m, \"state\"))\n                        w.uint32(16).int32(m.state);\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(26).string(m.name);\n                    if (m.mac != null && Object.hasOwnProperty.call(m, \"mac\"))\n                        w.uint32(34).bytes(m.mac);\n                    if (m.ipconfig != null && Object.hasOwnProperty.call(m, \"ipconfig\"))\n                        $root.particle.ctrl.IPConfiguration.encode(m.ipconfig, w.uint32(42).fork()).ldelim();\n                    if (m.dnsconfig != null && Object.hasOwnProperty.call(m, \"dnsconfig\"))\n                        $root.particle.ctrl.DNSConfiguration.encode(m.dnsconfig, w.uint32(50).fork()).ldelim();\n                    return w;\n                };\n    \n                NetworkConfiguration.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.NetworkConfiguration();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = r.int32();\n                            break;\n                        case 2:\n                            m.state = r.int32();\n                            break;\n                        case 3:\n                            m.name = r.string();\n                            break;\n                        case 4:\n                            m.mac = r.bytes();\n                            break;\n                        case 5:\n                            m.ipconfig = $root.particle.ctrl.IPConfiguration.decode(r, r.uint32());\n                            break;\n                        case 6:\n                            m.dnsconfig = $root.particle.ctrl.DNSConfiguration.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return NetworkConfiguration;\n            })();\n    \n            ctrl.InterfaceAddress = (function() {\n    \n                function InterfaceAddress(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                InterfaceAddress.prototype.address = null;\n                InterfaceAddress.prototype.prefixLength = 0;\n    \n                InterfaceAddress.create = function create(properties) {\n                    return new InterfaceAddress(properties);\n                };\n    \n                InterfaceAddress.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.address != null && Object.hasOwnProperty.call(m, \"address\"))\n                        $root.particle.ctrl.IpAddress.encode(m.address, w.uint32(10).fork()).ldelim();\n                    if (m.prefixLength != null && Object.hasOwnProperty.call(m, \"prefixLength\"))\n                        w.uint32(16).uint32(m.prefixLength);\n                    return w;\n                };\n    \n                InterfaceAddress.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.InterfaceAddress();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.address = $root.particle.ctrl.IpAddress.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.prefixLength = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return InterfaceAddress;\n            })();\n    \n            ctrl.Ipv4Config = (function() {\n    \n                function Ipv4Config(p) {\n                    this.addresses = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv4Config.prototype.addresses = $util.emptyArray;\n                Ipv4Config.prototype.peer = null;\n                Ipv4Config.prototype.gateway = null;\n    \n                Ipv4Config.create = function create(properties) {\n                    return new Ipv4Config(properties);\n                };\n    \n                Ipv4Config.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.addresses != null && m.addresses.length) {\n                        for (var i = 0; i < m.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(m.addresses[i], w.uint32(10).fork()).ldelim();\n                    }\n                    if (m.peer != null && Object.hasOwnProperty.call(m, \"peer\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.peer, w.uint32(18).fork()).ldelim();\n                    if (m.gateway != null && Object.hasOwnProperty.call(m, \"gateway\"))\n                        $root.particle.ctrl.Ipv4Address.encode(m.gateway, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                Ipv4Config.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv4Config();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.addresses && m.addresses.length))\n                                m.addresses = [];\n                            m.addresses.push($root.particle.ctrl.InterfaceAddress.decode(r, r.uint32()));\n                            break;\n                        case 2:\n                            m.peer = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.gateway = $root.particle.ctrl.Ipv4Address.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv4Config;\n            })();\n    \n            ctrl.Ipv6Config = (function() {\n    \n                function Ipv6Config(p) {\n                    this.addresses = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Ipv6Config.prototype.addresses = $util.emptyArray;\n    \n                Ipv6Config.create = function create(properties) {\n                    return new Ipv6Config(properties);\n                };\n    \n                Ipv6Config.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.addresses != null && m.addresses.length) {\n                        for (var i = 0; i < m.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(m.addresses[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                Ipv6Config.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Ipv6Config();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.addresses && m.addresses.length))\n                                m.addresses = [];\n                            m.addresses.push($root.particle.ctrl.InterfaceAddress.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Ipv6Config;\n            })();\n    \n            ctrl.InterfaceFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFF_NONE\"] = 0;\n                values[valuesById[1] = \"IFF_UP\"] = 1;\n                values[valuesById[2] = \"IFF_BROADCAST\"] = 2;\n                values[valuesById[4] = \"IFF_DEBUG\"] = 4;\n                values[valuesById[8] = \"IFF_LOOPBACK\"] = 8;\n                values[valuesById[16] = \"IFF_POINTTOPOINT\"] = 16;\n                values[valuesById[64] = \"IFF_RUNNING\"] = 64;\n                values[\"IFF_LOWER_UP\"] = 64;\n                values[valuesById[128] = \"IFF_NOARP\"] = 128;\n                values[valuesById[256] = \"IFF_PROMISC\"] = 256;\n                values[valuesById[512] = \"IFF_ALLMULTI\"] = 512;\n                values[valuesById[32768] = \"IFF_MULTICAST\"] = 32768;\n                values[valuesById[65536] = \"IFF_NOND6\"] = 65536;\n                return values;\n            })();\n    \n            ctrl.InterfaceExtFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFXF_NONE\"] = 0;\n                values[valuesById[16] = \"IFXF_WOL\"] = 16;\n                values[valuesById[32] = \"IFXF_AUTOCONF6\"] = 32;\n                values[valuesById[65536] = \"IFXF_DHCP\"] = 65536;\n                values[valuesById[131072] = \"IFXF_DHCP6\"] = 131072;\n                values[valuesById[262144] = \"IFXF_AUTOIP\"] = 262144;\n                return values;\n            })();\n    \n            ctrl.InterfaceType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_INTERFACE_TYPE\"] = 0;\n                values[valuesById[1] = \"LOOPBACK\"] = 1;\n                values[valuesById[2] = \"THREAD\"] = 2;\n                values[valuesById[4] = \"ETHERNET\"] = 4;\n                values[valuesById[8] = \"WIFI\"] = 8;\n                values[valuesById[16] = \"PPP\"] = 16;\n                return values;\n            })();\n    \n            ctrl.Interface = (function() {\n    \n                function Interface(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                Interface.prototype.index = 0;\n                Interface.prototype.name = \"\";\n                Interface.prototype.type = 0;\n                Interface.prototype.flags = 0;\n                Interface.prototype.extFlags = 0;\n                Interface.prototype.ipv4Config = null;\n                Interface.prototype.ipv6Config = null;\n                Interface.prototype.hwAddress = $util.newBuffer([]);\n                Interface.prototype.mtu = 0;\n                Interface.prototype.metric = 0;\n    \n                Interface.create = function create(properties) {\n                    return new Interface(properties);\n                };\n    \n                Interface.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                        w.uint32(8).uint32(m.index);\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(18).string(m.name);\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(24).int32(m.type);\n                    if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                        w.uint32(32).uint32(m.flags);\n                    if (m.extFlags != null && Object.hasOwnProperty.call(m, \"extFlags\"))\n                        w.uint32(40).uint32(m.extFlags);\n                    if (m.ipv4Config != null && Object.hasOwnProperty.call(m, \"ipv4Config\"))\n                        $root.particle.ctrl.Ipv4Config.encode(m.ipv4Config, w.uint32(50).fork()).ldelim();\n                    if (m.ipv6Config != null && Object.hasOwnProperty.call(m, \"ipv6Config\"))\n                        $root.particle.ctrl.Ipv6Config.encode(m.ipv6Config, w.uint32(58).fork()).ldelim();\n                    if (m.hwAddress != null && Object.hasOwnProperty.call(m, \"hwAddress\"))\n                        w.uint32(66).bytes(m.hwAddress);\n                    if (m.mtu != null && Object.hasOwnProperty.call(m, \"mtu\"))\n                        w.uint32(72).uint32(m.mtu);\n                    if (m.metric != null && Object.hasOwnProperty.call(m, \"metric\"))\n                        w.uint32(80).uint32(m.metric);\n                    return w;\n                };\n    \n                Interface.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.Interface();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        case 2:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.type = r.int32();\n                            break;\n                        case 4:\n                            m.flags = r.uint32();\n                            break;\n                        case 5:\n                            m.extFlags = r.uint32();\n                            break;\n                        case 6:\n                            m.ipv4Config = $root.particle.ctrl.Ipv4Config.decode(r, r.uint32());\n                            break;\n                        case 7:\n                            m.ipv6Config = $root.particle.ctrl.Ipv6Config.decode(r, r.uint32());\n                            break;\n                        case 8:\n                            m.hwAddress = r.bytes();\n                            break;\n                        case 9:\n                            m.mtu = r.uint32();\n                            break;\n                        case 10:\n                            m.metric = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return Interface;\n            })();\n    \n            ctrl.InterfaceEntry = (function() {\n    \n                function InterfaceEntry(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                InterfaceEntry.prototype.index = 0;\n                InterfaceEntry.prototype.name = \"\";\n                InterfaceEntry.prototype.type = 0;\n    \n                InterfaceEntry.create = function create(properties) {\n                    return new InterfaceEntry(properties);\n                };\n    \n                InterfaceEntry.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                        w.uint32(8).uint32(m.index);\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(18).string(m.name);\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(24).int32(m.type);\n                    return w;\n                };\n    \n                InterfaceEntry.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.InterfaceEntry();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        case 2:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.type = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return InterfaceEntry;\n            })();\n    \n            ctrl.GetInterfaceListRequest = (function() {\n    \n                function GetInterfaceListRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceListRequest.create = function create(properties) {\n                    return new GetInterfaceListRequest(properties);\n                };\n    \n                GetInterfaceListRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetInterfaceListRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceListRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceListRequest;\n            })();\n    \n            ctrl.GetInterfaceListReply = (function() {\n    \n                function GetInterfaceListReply(p) {\n                    this.interfaces = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceListReply.prototype.interfaces = $util.emptyArray;\n    \n                GetInterfaceListReply.create = function create(properties) {\n                    return new GetInterfaceListReply(properties);\n                };\n    \n                GetInterfaceListReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.interfaces != null && m.interfaces.length) {\n                        for (var i = 0; i < m.interfaces.length; ++i)\n                            $root.particle.ctrl.InterfaceEntry.encode(m.interfaces[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GetInterfaceListReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceListReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.interfaces && m.interfaces.length))\n                                m.interfaces = [];\n                            m.interfaces.push($root.particle.ctrl.InterfaceEntry.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceListReply;\n            })();\n    \n            ctrl.GetInterfaceRequest = (function() {\n    \n                function GetInterfaceRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceRequest.prototype.index = 0;\n    \n                GetInterfaceRequest.create = function create(properties) {\n                    return new GetInterfaceRequest(properties);\n                };\n    \n                GetInterfaceRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                        w.uint32(8).uint32(m.index);\n                    return w;\n                };\n    \n                GetInterfaceRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.index = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceRequest;\n            })();\n    \n            ctrl.GetInterfaceReply = (function() {\n    \n                function GetInterfaceReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetInterfaceReply.prototype[\"interface\"] = null;\n    \n                GetInterfaceReply.create = function create(properties) {\n                    return new GetInterfaceReply(properties);\n                };\n    \n                GetInterfaceReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m[\"interface\"] != null && Object.hasOwnProperty.call(m, \"interface\"))\n                        $root.particle.ctrl.Interface.encode(m[\"interface\"], w.uint32(10).fork()).ldelim();\n                    return w;\n                };\n    \n                GetInterfaceReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetInterfaceReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m[\"interface\"] = $root.particle.ctrl.Interface.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetInterfaceReply;\n            })();\n    \n            ctrl.wifi = (function() {\n    \n                var wifi = {};\n    \n                wifi.Security = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_SECURITY\"] = 0;\n                    values[valuesById[1] = \"WEP\"] = 1;\n                    values[valuesById[2] = \"WPA_PSK\"] = 2;\n                    values[valuesById[3] = \"WPA2_PSK\"] = 3;\n                    values[valuesById[4] = \"WPA_WPA2_PSK\"] = 4;\n                    return values;\n                })();\n    \n                wifi.CredentialsType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_CREDENTIALS\"] = 0;\n                    values[valuesById[1] = \"PASSWORD\"] = 1;\n                    return values;\n                })();\n    \n                wifi.Credentials = (function() {\n    \n                    function Credentials(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Credentials.prototype.type = 0;\n                    Credentials.prototype.password = \"\";\n    \n                    Credentials.create = function create(properties) {\n                        return new Credentials(properties);\n                    };\n    \n                    Credentials.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(18).string(m.password);\n                        return w;\n                    };\n    \n                    Credentials.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.Credentials();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Credentials;\n                })();\n    \n                wifi.JoinNewNetworkRequest = (function() {\n    \n                    function JoinNewNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNewNetworkRequest.prototype.ssid = \"\";\n                    JoinNewNetworkRequest.prototype.bssid = $util.newBuffer([]);\n                    JoinNewNetworkRequest.prototype.security = 0;\n                    JoinNewNetworkRequest.prototype.credentials = null;\n    \n                    JoinNewNetworkRequest.create = function create(properties) {\n                        return new JoinNewNetworkRequest(properties);\n                    };\n    \n                    JoinNewNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && Object.hasOwnProperty.call(m, \"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.security != null && Object.hasOwnProperty.call(m, \"security\"))\n                            w.uint32(24).int32(m.security);\n                        if (m.credentials != null && Object.hasOwnProperty.call(m, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(m.credentials, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    JoinNewNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinNewNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.security = r.int32();\n                                break;\n                            case 4:\n                                m.credentials = $root.particle.ctrl.wifi.Credentials.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNewNetworkRequest;\n                })();\n    \n                wifi.JoinNewNetworkReply = (function() {\n    \n                    function JoinNewNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNewNetworkReply.create = function create(properties) {\n                        return new JoinNewNetworkReply(properties);\n                    };\n    \n                    JoinNewNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinNewNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinNewNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNewNetworkReply;\n                })();\n    \n                wifi.JoinKnownNetworkRequest = (function() {\n    \n                    function JoinKnownNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    JoinKnownNetworkRequest.create = function create(properties) {\n                        return new JoinKnownNetworkRequest(properties);\n                    };\n    \n                    JoinKnownNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        return w;\n                    };\n    \n                    JoinKnownNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinKnownNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinKnownNetworkRequest;\n                })();\n    \n                wifi.JoinKnownNetworkReply = (function() {\n    \n                    function JoinKnownNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinKnownNetworkReply.create = function create(properties) {\n                        return new JoinKnownNetworkReply(properties);\n                    };\n    \n                    JoinKnownNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinKnownNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.JoinKnownNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinKnownNetworkReply;\n                })();\n    \n                wifi.GetKnownNetworksRequest = (function() {\n    \n                    function GetKnownNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetKnownNetworksRequest.create = function create(properties) {\n                        return new GetKnownNetworksRequest(properties);\n                    };\n    \n                    GetKnownNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetKnownNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetKnownNetworksRequest;\n                })();\n    \n                wifi.GetKnownNetworksReply = (function() {\n    \n                    function GetKnownNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetKnownNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    GetKnownNetworksReply.create = function create(properties) {\n                        return new GetKnownNetworksReply(properties);\n                    };\n    \n                    GetKnownNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.wifi.GetKnownNetworksReply.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetKnownNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.wifi.GetKnownNetworksReply.Network.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetKnownNetworksReply.Network = (function() {\n    \n                        function Network(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Network.prototype.ssid = \"\";\n                        Network.prototype.security = 0;\n                        Network.prototype.credentialsType = 0;\n    \n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        Network.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                                w.uint32(10).string(m.ssid);\n                            if (m.security != null && Object.hasOwnProperty.call(m, \"security\"))\n                                w.uint32(16).int32(m.security);\n                            if (m.credentialsType != null && Object.hasOwnProperty.call(m, \"credentialsType\"))\n                                w.uint32(24).int32(m.credentialsType);\n                            return w;\n                        };\n    \n                        Network.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetKnownNetworksReply.Network();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ssid = r.string();\n                                    break;\n                                case 2:\n                                    m.security = r.int32();\n                                    break;\n                                case 3:\n                                    m.credentialsType = r.int32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return GetKnownNetworksReply;\n                })();\n    \n                wifi.RemoveKnownNetworkRequest = (function() {\n    \n                    function RemoveKnownNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    RemoveKnownNetworkRequest.create = function create(properties) {\n                        return new RemoveKnownNetworkRequest(properties);\n                    };\n    \n                    RemoveKnownNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        return w;\n                    };\n    \n                    RemoveKnownNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.RemoveKnownNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveKnownNetworkRequest;\n                })();\n    \n                wifi.RemoveKnownNetworkReply = (function() {\n    \n                    function RemoveKnownNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveKnownNetworkReply.create = function create(properties) {\n                        return new RemoveKnownNetworkReply(properties);\n                    };\n    \n                    RemoveKnownNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveKnownNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.RemoveKnownNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveKnownNetworkReply;\n                })();\n    \n                wifi.ClearKnownNetworksRequest = (function() {\n    \n                    function ClearKnownNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ClearKnownNetworksRequest.create = function create(properties) {\n                        return new ClearKnownNetworksRequest(properties);\n                    };\n    \n                    ClearKnownNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ClearKnownNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ClearKnownNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ClearKnownNetworksRequest;\n                })();\n    \n                wifi.ClearKnownNetworksReply = (function() {\n    \n                    function ClearKnownNetworksReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ClearKnownNetworksReply.create = function create(properties) {\n                        return new ClearKnownNetworksReply(properties);\n                    };\n    \n                    ClearKnownNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ClearKnownNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ClearKnownNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ClearKnownNetworksReply;\n                })();\n    \n                wifi.GetCurrentNetworkRequest = (function() {\n    \n                    function GetCurrentNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetCurrentNetworkRequest.create = function create(properties) {\n                        return new GetCurrentNetworkRequest(properties);\n                    };\n    \n                    GetCurrentNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetCurrentNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetCurrentNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetCurrentNetworkRequest;\n                })();\n    \n                wifi.GetCurrentNetworkReply = (function() {\n    \n                    function GetCurrentNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetCurrentNetworkReply.prototype.ssid = \"\";\n                    GetCurrentNetworkReply.prototype.bssid = $util.newBuffer([]);\n                    GetCurrentNetworkReply.prototype.channel = 0;\n                    GetCurrentNetworkReply.prototype.rssi = 0;\n    \n                    GetCurrentNetworkReply.create = function create(properties) {\n                        return new GetCurrentNetworkReply(properties);\n                    };\n    \n                    GetCurrentNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && Object.hasOwnProperty.call(m, \"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.channel != null && Object.hasOwnProperty.call(m, \"channel\"))\n                            w.uint32(24).int32(m.channel);\n                        if (m.rssi != null && Object.hasOwnProperty.call(m, \"rssi\"))\n                            w.uint32(32).int32(m.rssi);\n                        return w;\n                    };\n    \n                    GetCurrentNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.GetCurrentNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.channel = r.int32();\n                                break;\n                            case 4:\n                                m.rssi = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetCurrentNetworkReply;\n                })();\n    \n                wifi.ScanNetworksRequest = (function() {\n    \n                    function ScanNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    ScanNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    ScanNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                wifi.ScanNetworksReply = (function() {\n    \n                    function ScanNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    ScanNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.wifi.ScanNetworksReply.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    ScanNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.wifi.ScanNetworksReply.Network.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    ScanNetworksReply.Network = (function() {\n    \n                        function Network(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Network.prototype.ssid = \"\";\n                        Network.prototype.bssid = $util.newBuffer([]);\n                        Network.prototype.security = 0;\n                        Network.prototype.channel = 0;\n                        Network.prototype.rssi = 0;\n    \n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        Network.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                                w.uint32(10).string(m.ssid);\n                            if (m.bssid != null && Object.hasOwnProperty.call(m, \"bssid\"))\n                                w.uint32(18).bytes(m.bssid);\n                            if (m.security != null && Object.hasOwnProperty.call(m, \"security\"))\n                                w.uint32(24).int32(m.security);\n                            if (m.channel != null && Object.hasOwnProperty.call(m, \"channel\"))\n                                w.uint32(32).int32(m.channel);\n                            if (m.rssi != null && Object.hasOwnProperty.call(m, \"rssi\"))\n                                w.uint32(40).int32(m.rssi);\n                            return w;\n                        };\n    \n                        Network.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.wifi.ScanNetworksReply.Network();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ssid = r.string();\n                                    break;\n                                case 2:\n                                    m.bssid = r.bytes();\n                                    break;\n                                case 3:\n                                    m.security = r.int32();\n                                    break;\n                                case 4:\n                                    m.channel = r.int32();\n                                    break;\n                                case 5:\n                                    m.rssi = r.int32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return ScanNetworksReply;\n                })();\n    \n                return wifi;\n            })();\n    \n            ctrl.logging = (function() {\n    \n                var logging = {};\n    \n                logging.LogLevel = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_LEVEL\"] = 0;\n                    values[valuesById[1] = \"ALL\"] = 1;\n                    values[\"TRACE\"] = 1;\n                    values[valuesById[30] = \"INFO\"] = 30;\n                    values[valuesById[40] = \"WARN\"] = 40;\n                    values[valuesById[50] = \"ERROR\"] = 50;\n                    values[valuesById[70] = \"NONE\"] = 70;\n                    return values;\n                })();\n    \n                logging.LogHandlerType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_HANDLER_TYPE\"] = 0;\n                    values[valuesById[1] = \"DEFAULT_STREAM_HANDLER\"] = 1;\n                    values[valuesById[2] = \"JSON_STREAM_HANDLER\"] = 2;\n                    return values;\n                })();\n    \n                logging.StreamType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_STREAM_TYPE\"] = 0;\n                    values[valuesById[1] = \"USB_SERIAL_STREAM\"] = 1;\n                    values[valuesById[2] = \"HW_SERIAL_STREAM\"] = 2;\n                    return values;\n                })();\n    \n                logging.LogFilter = (function() {\n    \n                    function LogFilter(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LogFilter.prototype.category = \"\";\n                    LogFilter.prototype.level = 0;\n    \n                    LogFilter.create = function create(properties) {\n                        return new LogFilter(properties);\n                    };\n    \n                    LogFilter.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.category != null && Object.hasOwnProperty.call(m, \"category\"))\n                            w.uint32(10).string(m.category);\n                        if (m.level != null && Object.hasOwnProperty.call(m, \"level\"))\n                            w.uint32(16).int32(m.level);\n                        return w;\n                    };\n    \n                    LogFilter.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.LogFilter();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.category = r.string();\n                                break;\n                            case 2:\n                                m.level = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LogFilter;\n                })();\n    \n                logging.SerialStreamParams = (function() {\n    \n                    function SerialStreamParams(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    SerialStreamParams.prototype.index = 0;\n                    SerialStreamParams.prototype.baudRate = 0;\n    \n                    SerialStreamParams.create = function create(properties) {\n                        return new SerialStreamParams(properties);\n                    };\n    \n                    SerialStreamParams.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                            w.uint32(8).uint32(m.index);\n                        if (m.baudRate != null && Object.hasOwnProperty.call(m, \"baudRate\"))\n                            w.uint32(16).uint32(m.baudRate);\n                        return w;\n                    };\n    \n                    SerialStreamParams.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.SerialStreamParams();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.index = r.uint32();\n                                break;\n                            case 2:\n                                m.baudRate = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return SerialStreamParams;\n                })();\n    \n                logging.AddLogHandlerRequest = (function() {\n    \n                    function AddLogHandlerRequest(p) {\n                        this.filters = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddLogHandlerRequest.prototype.id = \"\";\n                    AddLogHandlerRequest.prototype.handlerType = 0;\n                    AddLogHandlerRequest.prototype.level = 0;\n                    AddLogHandlerRequest.prototype.filters = $util.emptyArray;\n                    AddLogHandlerRequest.prototype.streamType = 0;\n                    AddLogHandlerRequest.prototype.serial = null;\n    \n                    var $oneOfFields;\n    \n                    Object.defineProperty(AddLogHandlerRequest.prototype, \"streamParams\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"serial\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    AddLogHandlerRequest.create = function create(properties) {\n                        return new AddLogHandlerRequest(properties);\n                    };\n    \n                    AddLogHandlerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.id != null && Object.hasOwnProperty.call(m, \"id\"))\n                            w.uint32(10).string(m.id);\n                        if (m.handlerType != null && Object.hasOwnProperty.call(m, \"handlerType\"))\n                            w.uint32(16).int32(m.handlerType);\n                        if (m.level != null && Object.hasOwnProperty.call(m, \"level\"))\n                            w.uint32(24).int32(m.level);\n                        if (m.filters != null && m.filters.length) {\n                            for (var i = 0; i < m.filters.length; ++i)\n                                $root.particle.ctrl.logging.LogFilter.encode(m.filters[i], w.uint32(34).fork()).ldelim();\n                        }\n                        if (m.streamType != null && Object.hasOwnProperty.call(m, \"streamType\"))\n                            w.uint32(40).int32(m.streamType);\n                        if (m.serial != null && Object.hasOwnProperty.call(m, \"serial\"))\n                            $root.particle.ctrl.logging.SerialStreamParams.encode(m.serial, w.uint32(50).fork()).ldelim();\n                        return w;\n                    };\n    \n                    AddLogHandlerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.AddLogHandlerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.id = r.string();\n                                break;\n                            case 2:\n                                m.handlerType = r.int32();\n                                break;\n                            case 3:\n                                m.level = r.int32();\n                                break;\n                            case 4:\n                                if (!(m.filters && m.filters.length))\n                                    m.filters = [];\n                                m.filters.push($root.particle.ctrl.logging.LogFilter.decode(r, r.uint32()));\n                                break;\n                            case 5:\n                                m.streamType = r.int32();\n                                break;\n                            case 6:\n                                m.serial = $root.particle.ctrl.logging.SerialStreamParams.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddLogHandlerRequest;\n                })();\n    \n                logging.AddLogHandlerReply = (function() {\n    \n                    function AddLogHandlerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddLogHandlerReply.create = function create(properties) {\n                        return new AddLogHandlerReply(properties);\n                    };\n    \n                    AddLogHandlerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AddLogHandlerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.AddLogHandlerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddLogHandlerReply;\n                })();\n    \n                logging.RemoveLogHandlerRequest = (function() {\n    \n                    function RemoveLogHandlerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveLogHandlerRequest.prototype.id = \"\";\n    \n                    RemoveLogHandlerRequest.create = function create(properties) {\n                        return new RemoveLogHandlerRequest(properties);\n                    };\n    \n                    RemoveLogHandlerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.id != null && Object.hasOwnProperty.call(m, \"id\"))\n                            w.uint32(10).string(m.id);\n                        return w;\n                    };\n    \n                    RemoveLogHandlerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.RemoveLogHandlerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.id = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveLogHandlerRequest;\n                })();\n    \n                logging.RemoveLogHandlerReply = (function() {\n    \n                    function RemoveLogHandlerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveLogHandlerReply.create = function create(properties) {\n                        return new RemoveLogHandlerReply(properties);\n                    };\n    \n                    RemoveLogHandlerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveLogHandlerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.RemoveLogHandlerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveLogHandlerReply;\n                })();\n    \n                logging.GetLogHandlersRequest = (function() {\n    \n                    function GetLogHandlersRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetLogHandlersRequest.create = function create(properties) {\n                        return new GetLogHandlersRequest(properties);\n                    };\n    \n                    GetLogHandlersRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetLogHandlersRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetLogHandlersRequest;\n                })();\n    \n                logging.GetLogHandlersReply = (function() {\n    \n                    function GetLogHandlersReply(p) {\n                        this.handlers = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetLogHandlersReply.prototype.handlers = $util.emptyArray;\n    \n                    GetLogHandlersReply.create = function create(properties) {\n                        return new GetLogHandlersReply(properties);\n                    };\n    \n                    GetLogHandlersReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.handlers != null && m.handlers.length) {\n                            for (var i = 0; i < m.handlers.length; ++i)\n                                $root.particle.ctrl.logging.GetLogHandlersReply.Handler.encode(m.handlers[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetLogHandlersReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.handlers && m.handlers.length))\n                                    m.handlers = [];\n                                m.handlers.push($root.particle.ctrl.logging.GetLogHandlersReply.Handler.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetLogHandlersReply.Handler = (function() {\n    \n                        function Handler(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Handler.prototype.id = \"\";\n    \n                        Handler.create = function create(properties) {\n                            return new Handler(properties);\n                        };\n    \n                        Handler.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.id != null && Object.hasOwnProperty.call(m, \"id\"))\n                                w.uint32(10).string(m.id);\n                            return w;\n                        };\n    \n                        Handler.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.logging.GetLogHandlersReply.Handler();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.id = r.string();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Handler;\n                    })();\n    \n                    return GetLogHandlersReply;\n                })();\n    \n                return logging;\n            })();\n    \n            ctrl.mesh = (function() {\n    \n                var mesh = {};\n    \n                mesh.NetworkInfo = (function() {\n    \n                    function NetworkInfo(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    NetworkInfo.prototype.name = \"\";\n                    NetworkInfo.prototype.extPanId = \"\";\n                    NetworkInfo.prototype.panId = 0;\n                    NetworkInfo.prototype.channel = 0;\n                    NetworkInfo.prototype.networkId = \"\";\n    \n                    NetworkInfo.create = function create(properties) {\n                        return new NetworkInfo(properties);\n                    };\n    \n                    NetworkInfo.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                            w.uint32(10).string(m.name);\n                        if (m.extPanId != null && Object.hasOwnProperty.call(m, \"extPanId\"))\n                            w.uint32(18).string(m.extPanId);\n                        if (m.panId != null && Object.hasOwnProperty.call(m, \"panId\"))\n                            w.uint32(24).uint32(m.panId);\n                        if (m.channel != null && Object.hasOwnProperty.call(m, \"channel\"))\n                            w.uint32(32).uint32(m.channel);\n                        if (m.networkId != null && Object.hasOwnProperty.call(m, \"networkId\"))\n                            w.uint32(42).string(m.networkId);\n                        return w;\n                    };\n    \n                    NetworkInfo.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.NetworkInfo();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.name = r.string();\n                                break;\n                            case 2:\n                                m.extPanId = r.string();\n                                break;\n                            case 3:\n                                m.panId = r.uint32();\n                                break;\n                            case 4:\n                                m.channel = r.uint32();\n                                break;\n                            case 5:\n                                m.networkId = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return NetworkInfo;\n                })();\n    \n                mesh.AuthRequest = (function() {\n    \n                    function AuthRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AuthRequest.prototype.password = \"\";\n    \n                    AuthRequest.create = function create(properties) {\n                        return new AuthRequest(properties);\n                    };\n    \n                    AuthRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(10).string(m.password);\n                        return w;\n                    };\n    \n                    AuthRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AuthRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AuthRequest;\n                })();\n    \n                mesh.AuthReply = (function() {\n    \n                    function AuthReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AuthReply.create = function create(properties) {\n                        return new AuthReply(properties);\n                    };\n    \n                    AuthReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AuthReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AuthReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AuthReply;\n                })();\n    \n                mesh.CreateNetworkRequest = (function() {\n    \n                    function CreateNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    CreateNetworkRequest.prototype.name = \"\";\n                    CreateNetworkRequest.prototype.password = \"\";\n                    CreateNetworkRequest.prototype.channel = 0;\n                    CreateNetworkRequest.prototype.networkId = \"\";\n    \n                    CreateNetworkRequest.create = function create(properties) {\n                        return new CreateNetworkRequest(properties);\n                    };\n    \n                    CreateNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                            w.uint32(10).string(m.name);\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(18).string(m.password);\n                        if (m.channel != null && Object.hasOwnProperty.call(m, \"channel\"))\n                            w.uint32(24).uint32(m.channel);\n                        if (m.networkId != null && Object.hasOwnProperty.call(m, \"networkId\"))\n                            w.uint32(34).string(m.networkId);\n                        return w;\n                    };\n    \n                    CreateNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.CreateNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.name = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            case 3:\n                                m.channel = r.uint32();\n                                break;\n                            case 4:\n                                m.networkId = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return CreateNetworkRequest;\n                })();\n    \n                mesh.CreateNetworkReply = (function() {\n    \n                    function CreateNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    CreateNetworkReply.prototype.network = null;\n    \n                    CreateNetworkReply.create = function create(properties) {\n                        return new CreateNetworkReply(properties);\n                    };\n    \n                    CreateNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && Object.hasOwnProperty.call(m, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    CreateNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.CreateNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return CreateNetworkReply;\n                })();\n    \n                mesh.StartCommissionerRequest = (function() {\n    \n                    function StartCommissionerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StartCommissionerRequest.prototype.timeout = 0;\n    \n                    StartCommissionerRequest.create = function create(properties) {\n                        return new StartCommissionerRequest(properties);\n                    };\n    \n                    StartCommissionerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                            w.uint32(8).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    StartCommissionerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StartCommissionerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StartCommissionerRequest;\n                })();\n    \n                mesh.StartCommissionerReply = (function() {\n    \n                    function StartCommissionerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StartCommissionerReply.create = function create(properties) {\n                        return new StartCommissionerReply(properties);\n                    };\n    \n                    StartCommissionerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StartCommissionerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StartCommissionerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StartCommissionerReply;\n                })();\n    \n                mesh.StopCommissionerRequest = (function() {\n    \n                    function StopCommissionerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StopCommissionerRequest.create = function create(properties) {\n                        return new StopCommissionerRequest(properties);\n                    };\n    \n                    StopCommissionerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StopCommissionerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StopCommissionerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StopCommissionerRequest;\n                })();\n    \n                mesh.StopCommissionerReply = (function() {\n    \n                    function StopCommissionerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    StopCommissionerReply.create = function create(properties) {\n                        return new StopCommissionerReply(properties);\n                    };\n    \n                    StopCommissionerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    StopCommissionerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.StopCommissionerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return StopCommissionerReply;\n                })();\n    \n                mesh.PrepareJoinerRequest = (function() {\n    \n                    function PrepareJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    PrepareJoinerRequest.prototype.network = null;\n    \n                    PrepareJoinerRequest.create = function create(properties) {\n                        return new PrepareJoinerRequest(properties);\n                    };\n    \n                    PrepareJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && Object.hasOwnProperty.call(m, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    PrepareJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.PrepareJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return PrepareJoinerRequest;\n                })();\n    \n                mesh.PrepareJoinerReply = (function() {\n    \n                    function PrepareJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    PrepareJoinerReply.prototype.eui64 = \"\";\n                    PrepareJoinerReply.prototype.password = \"\";\n    \n                    PrepareJoinerReply.create = function create(properties) {\n                        return new PrepareJoinerReply(properties);\n                    };\n    \n                    PrepareJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && Object.hasOwnProperty.call(m, \"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(18).string(m.password);\n                        return w;\n                    };\n    \n                    PrepareJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.PrepareJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return PrepareJoinerReply;\n                })();\n    \n                mesh.AddJoinerRequest = (function() {\n    \n                    function AddJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddJoinerRequest.prototype.eui64 = \"\";\n                    AddJoinerRequest.prototype.password = \"\";\n                    AddJoinerRequest.prototype.timeout = 0;\n    \n                    AddJoinerRequest.create = function create(properties) {\n                        return new AddJoinerRequest(properties);\n                    };\n    \n                    AddJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && Object.hasOwnProperty.call(m, \"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        if (m.password != null && Object.hasOwnProperty.call(m, \"password\"))\n                            w.uint32(18).string(m.password);\n                        if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                            w.uint32(24).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    AddJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AddJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            case 2:\n                                m.password = r.string();\n                                break;\n                            case 3:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddJoinerRequest;\n                })();\n    \n                mesh.AddJoinerReply = (function() {\n    \n                    function AddJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    AddJoinerReply.create = function create(properties) {\n                        return new AddJoinerReply(properties);\n                    };\n    \n                    AddJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    AddJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.AddJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return AddJoinerReply;\n                })();\n    \n                mesh.RemoveJoinerRequest = (function() {\n    \n                    function RemoveJoinerRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveJoinerRequest.prototype.eui64 = \"\";\n    \n                    RemoveJoinerRequest.create = function create(properties) {\n                        return new RemoveJoinerRequest(properties);\n                    };\n    \n                    RemoveJoinerRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.eui64 != null && Object.hasOwnProperty.call(m, \"eui64\"))\n                            w.uint32(10).string(m.eui64);\n                        return w;\n                    };\n    \n                    RemoveJoinerRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.RemoveJoinerRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.eui64 = r.string();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveJoinerRequest;\n                })();\n    \n                mesh.RemoveJoinerReply = (function() {\n    \n                    function RemoveJoinerReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    RemoveJoinerReply.create = function create(properties) {\n                        return new RemoveJoinerReply(properties);\n                    };\n    \n                    RemoveJoinerReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    RemoveJoinerReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.RemoveJoinerReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return RemoveJoinerReply;\n                })();\n    \n                mesh.JoinNetworkRequest = (function() {\n    \n                    function JoinNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNetworkRequest.prototype.timeout = 0;\n    \n                    JoinNetworkRequest.create = function create(properties) {\n                        return new JoinNetworkRequest(properties);\n                    };\n    \n                    JoinNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                            w.uint32(8).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    JoinNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.JoinNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNetworkRequest;\n                })();\n    \n                mesh.JoinNetworkReply = (function() {\n    \n                    function JoinNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    JoinNetworkReply.create = function create(properties) {\n                        return new JoinNetworkReply(properties);\n                    };\n    \n                    JoinNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    JoinNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.JoinNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return JoinNetworkReply;\n                })();\n    \n                mesh.LeaveNetworkRequest = (function() {\n    \n                    function LeaveNetworkRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LeaveNetworkRequest.create = function create(properties) {\n                        return new LeaveNetworkRequest(properties);\n                    };\n    \n                    LeaveNetworkRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    LeaveNetworkRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.LeaveNetworkRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LeaveNetworkRequest;\n                })();\n    \n                mesh.LeaveNetworkReply = (function() {\n    \n                    function LeaveNetworkReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    LeaveNetworkReply.create = function create(properties) {\n                        return new LeaveNetworkReply(properties);\n                    };\n    \n                    LeaveNetworkReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    LeaveNetworkReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.LeaveNetworkReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return LeaveNetworkReply;\n                })();\n    \n                mesh.GetNetworkInfoRequest = (function() {\n    \n                    function GetNetworkInfoRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkInfoRequest.create = function create(properties) {\n                        return new GetNetworkInfoRequest(properties);\n                    };\n    \n                    GetNetworkInfoRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        return w;\n                    };\n    \n                    GetNetworkInfoRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkInfoRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkInfoRequest;\n                })();\n    \n                mesh.GetNetworkInfoReply = (function() {\n    \n                    function GetNetworkInfoReply(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkInfoReply.prototype.network = null;\n    \n                    GetNetworkInfoReply.create = function create(properties) {\n                        return new GetNetworkInfoReply(properties);\n                    };\n    \n                    GetNetworkInfoReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.network != null && Object.hasOwnProperty.call(m, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(m.network, w.uint32(10).fork()).ldelim();\n                        return w;\n                    };\n    \n                    GetNetworkInfoReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkInfoReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.network = $root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkInfoReply;\n                })();\n    \n                mesh.ScanNetworksRequest = (function() {\n    \n                    function ScanNetworksRequest(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksRequest.prototype.duration = 0;\n    \n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    ScanNetworksRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.duration != null && Object.hasOwnProperty.call(m, \"duration\"))\n                            w.uint32(8).uint32(m.duration);\n                        return w;\n                    };\n    \n                    ScanNetworksRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.ScanNetworksRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.duration = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                mesh.ScanNetworksReply = (function() {\n    \n                    function ScanNetworksReply(p) {\n                        this.networks = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    ScanNetworksReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.networks != null && m.networks.length) {\n                            for (var i = 0; i < m.networks.length; ++i)\n                                $root.particle.ctrl.mesh.NetworkInfo.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    ScanNetworksReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.ScanNetworksReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.networks && m.networks.length))\n                                    m.networks = [];\n                                m.networks.push($root.particle.ctrl.mesh.NetworkInfo.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ScanNetworksReply;\n                })();\n    \n                mesh.DiagnosticType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"MAC_EXTENDED_ADDRESS\"] = 0;\n                    values[valuesById[1] = \"RLOC\"] = 1;\n                    values[\"MAC_ADDRESS\"] = 1;\n                    values[valuesById[2] = \"MODE\"] = 2;\n                    values[valuesById[3] = \"TIMEOUT\"] = 3;\n                    values[valuesById[4] = \"CONNECTIVITY\"] = 4;\n                    values[valuesById[5] = \"ROUTE64\"] = 5;\n                    values[valuesById[6] = \"LEADER_DATA\"] = 6;\n                    values[valuesById[7] = \"NETWORK_DATA\"] = 7;\n                    values[valuesById[8] = \"IPV6_ADDRESS_LIST\"] = 8;\n                    values[valuesById[9] = \"MAC_COUNTERS\"] = 9;\n                    values[valuesById[14] = \"BATTERY_LEVEL\"] = 14;\n                    values[valuesById[15] = \"SUPPLY_VOLTAGE\"] = 15;\n                    values[valuesById[16] = \"CHILD_TABLE\"] = 16;\n                    values[valuesById[17] = \"CHANNEL_PAGES\"] = 17;\n                    values[valuesById[18] = \"TYPE_LIST\"] = 18;\n                    values[valuesById[19] = \"MAX_CHILD_TIMEOUT\"] = 19;\n                    return values;\n                })();\n    \n                mesh.DiagnosticInfo = (function() {\n    \n                    function DiagnosticInfo(p) {\n                        this.ipv6AddressList = [];\n                        this.typeList = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    DiagnosticInfo.prototype.extMacAddress = $util.newBuffer([]);\n                    DiagnosticInfo.prototype.rloc = 0;\n                    DiagnosticInfo.prototype.mode = 0;\n                    DiagnosticInfo.prototype.timeout = 0;\n                    DiagnosticInfo.prototype.connectivity = null;\n                    DiagnosticInfo.prototype.route64 = null;\n                    DiagnosticInfo.prototype.leaderData = null;\n                    DiagnosticInfo.prototype.networkData = null;\n                    DiagnosticInfo.prototype.ipv6AddressList = $util.emptyArray;\n                    DiagnosticInfo.prototype.macCounters = null;\n                    DiagnosticInfo.prototype.batteryLevel = 0;\n                    DiagnosticInfo.prototype.supplyVoltage = 0;\n                    DiagnosticInfo.prototype.childTable = null;\n                    DiagnosticInfo.prototype.channelPages = $util.newBuffer([]);\n                    DiagnosticInfo.prototype.typeList = $util.emptyArray;\n                    DiagnosticInfo.prototype.maxChildTimeout = 0;\n                    DiagnosticInfo.prototype.deviceId = $util.newBuffer([]);\n    \n                    DiagnosticInfo.create = function create(properties) {\n                        return new DiagnosticInfo(properties);\n                    };\n    \n                    DiagnosticInfo.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.extMacAddress != null && Object.hasOwnProperty.call(m, \"extMacAddress\"))\n                            w.uint32(10).bytes(m.extMacAddress);\n                        if (m.rloc != null && Object.hasOwnProperty.call(m, \"rloc\"))\n                            w.uint32(16).uint32(m.rloc);\n                        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n                            w.uint32(24).uint32(m.mode);\n                        if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                            w.uint32(32).uint32(m.timeout);\n                        if (m.connectivity != null && Object.hasOwnProperty.call(m, \"connectivity\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.encode(m.connectivity, w.uint32(42).fork()).ldelim();\n                        if (m.route64 != null && Object.hasOwnProperty.call(m, \"route64\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Route64.encode(m.route64, w.uint32(50).fork()).ldelim();\n                        if (m.leaderData != null && Object.hasOwnProperty.call(m, \"leaderData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.encode(m.leaderData, w.uint32(58).fork()).ldelim();\n                        if (m.networkData != null && Object.hasOwnProperty.call(m, \"networkData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.encode(m.networkData, w.uint32(66).fork()).ldelim();\n                        if (m.ipv6AddressList != null && m.ipv6AddressList.length) {\n                            for (var i = 0; i < m.ipv6AddressList.length; ++i)\n                                $root.particle.ctrl.Ipv6Address.encode(m.ipv6AddressList[i], w.uint32(74).fork()).ldelim();\n                        }\n                        if (m.macCounters != null && Object.hasOwnProperty.call(m, \"macCounters\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.encode(m.macCounters, w.uint32(82).fork()).ldelim();\n                        if (m.batteryLevel != null && Object.hasOwnProperty.call(m, \"batteryLevel\"))\n                            w.uint32(120).uint32(m.batteryLevel);\n                        if (m.supplyVoltage != null && Object.hasOwnProperty.call(m, \"supplyVoltage\"))\n                            w.uint32(128).uint32(m.supplyVoltage);\n                        if (m.childTable != null && Object.hasOwnProperty.call(m, \"childTable\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.encode(m.childTable, w.uint32(138).fork()).ldelim();\n                        if (m.channelPages != null && Object.hasOwnProperty.call(m, \"channelPages\"))\n                            w.uint32(146).bytes(m.channelPages);\n                        if (m.typeList != null && m.typeList.length) {\n                            w.uint32(154).fork();\n                            for (var i = 0; i < m.typeList.length; ++i)\n                                w.int32(m.typeList[i]);\n                            w.ldelim();\n                        }\n                        if (m.maxChildTimeout != null && Object.hasOwnProperty.call(m, \"maxChildTimeout\"))\n                            w.uint32(160).uint32(m.maxChildTimeout);\n                        if (m.deviceId != null && Object.hasOwnProperty.call(m, \"deviceId\"))\n                            w.uint32(802).bytes(m.deviceId);\n                        return w;\n                    };\n    \n                    DiagnosticInfo.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.extMacAddress = r.bytes();\n                                break;\n                            case 2:\n                                m.rloc = r.uint32();\n                                break;\n                            case 3:\n                                m.mode = r.uint32();\n                                break;\n                            case 4:\n                                m.timeout = r.uint32();\n                                break;\n                            case 5:\n                                m.connectivity = $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.decode(r, r.uint32());\n                                break;\n                            case 6:\n                                m.route64 = $root.particle.ctrl.mesh.DiagnosticInfo.Route64.decode(r, r.uint32());\n                                break;\n                            case 7:\n                                m.leaderData = $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.decode(r, r.uint32());\n                                break;\n                            case 8:\n                                m.networkData = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.decode(r, r.uint32());\n                                break;\n                            case 9:\n                                if (!(m.ipv6AddressList && m.ipv6AddressList.length))\n                                    m.ipv6AddressList = [];\n                                m.ipv6AddressList.push($root.particle.ctrl.Ipv6Address.decode(r, r.uint32()));\n                                break;\n                            case 10:\n                                m.macCounters = $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.decode(r, r.uint32());\n                                break;\n                            case 15:\n                                m.batteryLevel = r.uint32();\n                                break;\n                            case 16:\n                                m.supplyVoltage = r.uint32();\n                                break;\n                            case 17:\n                                m.childTable = $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.decode(r, r.uint32());\n                                break;\n                            case 18:\n                                m.channelPages = r.bytes();\n                                break;\n                            case 19:\n                                if (!(m.typeList && m.typeList.length))\n                                    m.typeList = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.typeList.push(r.int32());\n                                } else\n                                    m.typeList.push(r.int32());\n                                break;\n                            case 20:\n                                m.maxChildTimeout = r.uint32();\n                                break;\n                            case 100:\n                                m.deviceId = r.bytes();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    DiagnosticInfo.Mode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[16] = \"RECEIVER_ON_WHEN_IDLE\"] = 16;\n                        values[valuesById[32] = \"SECURE_DATA_REQUESTS\"] = 32;\n                        values[valuesById[48] = \"DEVICE_TYPE\"] = 48;\n                        values[\"DEVICE_TYPE_FTD\"] = 48;\n                        values[valuesById[64] = \"NETWORK_DATA\"] = 64;\n                        values[\"NETWORK_DATA_FULL\"] = 64;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.Connectivity = (function() {\n    \n                        function Connectivity(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Connectivity.prototype.parentPriority = 0;\n                        Connectivity.prototype.linkQuality_1 = 0;\n                        Connectivity.prototype.linkQuality_2 = 0;\n                        Connectivity.prototype.linkQuality_3 = 0;\n                        Connectivity.prototype.leaderCost = 0;\n                        Connectivity.prototype.idSequence = 0;\n                        Connectivity.prototype.activeRouters = 0;\n                        Connectivity.prototype.sedBufferSize = 0;\n                        Connectivity.prototype.sedDatagramCount = 0;\n    \n                        Connectivity.create = function create(properties) {\n                            return new Connectivity(properties);\n                        };\n    \n                        Connectivity.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.parentPriority != null && Object.hasOwnProperty.call(m, \"parentPriority\"))\n                                w.uint32(8).uint32(m.parentPriority);\n                            if (m.linkQuality_1 != null && Object.hasOwnProperty.call(m, \"linkQuality_1\"))\n                                w.uint32(16).uint32(m.linkQuality_1);\n                            if (m.linkQuality_2 != null && Object.hasOwnProperty.call(m, \"linkQuality_2\"))\n                                w.uint32(24).uint32(m.linkQuality_2);\n                            if (m.linkQuality_3 != null && Object.hasOwnProperty.call(m, \"linkQuality_3\"))\n                                w.uint32(32).uint32(m.linkQuality_3);\n                            if (m.leaderCost != null && Object.hasOwnProperty.call(m, \"leaderCost\"))\n                                w.uint32(40).uint32(m.leaderCost);\n                            if (m.idSequence != null && Object.hasOwnProperty.call(m, \"idSequence\"))\n                                w.uint32(48).uint32(m.idSequence);\n                            if (m.activeRouters != null && Object.hasOwnProperty.call(m, \"activeRouters\"))\n                                w.uint32(56).uint32(m.activeRouters);\n                            if (m.sedBufferSize != null && Object.hasOwnProperty.call(m, \"sedBufferSize\"))\n                                w.uint32(64).uint32(m.sedBufferSize);\n                            if (m.sedDatagramCount != null && Object.hasOwnProperty.call(m, \"sedDatagramCount\"))\n                                w.uint32(72).uint32(m.sedDatagramCount);\n                            return w;\n                        };\n    \n                        Connectivity.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.parentPriority = r.uint32();\n                                    break;\n                                case 2:\n                                    m.linkQuality_1 = r.uint32();\n                                    break;\n                                case 3:\n                                    m.linkQuality_2 = r.uint32();\n                                    break;\n                                case 4:\n                                    m.linkQuality_3 = r.uint32();\n                                    break;\n                                case 5:\n                                    m.leaderCost = r.uint32();\n                                    break;\n                                case 6:\n                                    m.idSequence = r.uint32();\n                                    break;\n                                case 7:\n                                    m.activeRouters = r.uint32();\n                                    break;\n                                case 8:\n                                    m.sedBufferSize = r.uint32();\n                                    break;\n                                case 9:\n                                    m.sedDatagramCount = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return Connectivity;\n                    })();\n    \n                    DiagnosticInfo.Route64 = (function() {\n    \n                        function Route64(p) {\n                            this.routes = [];\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        Route64.prototype.idSequence = 0;\n                        Route64.prototype.routes = $util.emptyArray;\n    \n                        Route64.create = function create(properties) {\n                            return new Route64(properties);\n                        };\n    \n                        Route64.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.idSequence != null && Object.hasOwnProperty.call(m, \"idSequence\"))\n                                w.uint32(8).uint32(m.idSequence);\n                            if (m.routes != null && m.routes.length) {\n                                for (var i = 0; i < m.routes.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.encode(m.routes[i], w.uint32(18).fork()).ldelim();\n                            }\n                            return w;\n                        };\n    \n                        Route64.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.idSequence = r.uint32();\n                                    break;\n                                case 2:\n                                    if (!(m.routes && m.routes.length))\n                                        m.routes = [];\n                                    m.routes.push($root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.decode(r, r.uint32()));\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        Route64.RouteData = (function() {\n    \n                            function RouteData(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            RouteData.prototype.routerRloc = 0;\n                            RouteData.prototype.linkQualityOut = 0;\n                            RouteData.prototype.linkQualityIn = 0;\n                            RouteData.prototype.routeCost = 0;\n    \n                            RouteData.create = function create(properties) {\n                                return new RouteData(properties);\n                            };\n    \n                            RouteData.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.routerRloc != null && Object.hasOwnProperty.call(m, \"routerRloc\"))\n                                    w.uint32(8).uint32(m.routerRloc);\n                                if (m.linkQualityOut != null && Object.hasOwnProperty.call(m, \"linkQualityOut\"))\n                                    w.uint32(16).uint32(m.linkQualityOut);\n                                if (m.linkQualityIn != null && Object.hasOwnProperty.call(m, \"linkQualityIn\"))\n                                    w.uint32(24).uint32(m.linkQualityIn);\n                                if (m.routeCost != null && Object.hasOwnProperty.call(m, \"routeCost\"))\n                                    w.uint32(32).uint32(m.routeCost);\n                                return w;\n                            };\n    \n                            RouteData.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.routerRloc = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.linkQualityOut = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.linkQualityIn = r.uint32();\n                                        break;\n                                    case 4:\n                                        m.routeCost = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return RouteData;\n                        })();\n    \n                        return Route64;\n                    })();\n    \n                    DiagnosticInfo.LeaderData = (function() {\n    \n                        function LeaderData(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        LeaderData.prototype.partitionId = 0;\n                        LeaderData.prototype.weighting = 0;\n                        LeaderData.prototype.dataVersion = 0;\n                        LeaderData.prototype.stableDataVersion = 0;\n                        LeaderData.prototype.leaderRloc = 0;\n    \n                        LeaderData.create = function create(properties) {\n                            return new LeaderData(properties);\n                        };\n    \n                        LeaderData.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.partitionId != null && Object.hasOwnProperty.call(m, \"partitionId\"))\n                                w.uint32(8).uint32(m.partitionId);\n                            if (m.weighting != null && Object.hasOwnProperty.call(m, \"weighting\"))\n                                w.uint32(16).uint32(m.weighting);\n                            if (m.dataVersion != null && Object.hasOwnProperty.call(m, \"dataVersion\"))\n                                w.uint32(24).uint32(m.dataVersion);\n                            if (m.stableDataVersion != null && Object.hasOwnProperty.call(m, \"stableDataVersion\"))\n                                w.uint32(32).uint32(m.stableDataVersion);\n                            if (m.leaderRloc != null && Object.hasOwnProperty.call(m, \"leaderRloc\"))\n                                w.uint32(40).uint32(m.leaderRloc);\n                            return w;\n                        };\n    \n                        LeaderData.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.partitionId = r.uint32();\n                                    break;\n                                case 2:\n                                    m.weighting = r.uint32();\n                                    break;\n                                case 3:\n                                    m.dataVersion = r.uint32();\n                                    break;\n                                case 4:\n                                    m.stableDataVersion = r.uint32();\n                                    break;\n                                case 5:\n                                    m.leaderRloc = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return LeaderData;\n                    })();\n    \n                    DiagnosticInfo.RoutePreference = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"MEDIUM\"] = 0;\n                        values[valuesById[1] = \"HIGH\"] = 1;\n                        values[valuesById[-1] = \"LOW\"] = -1;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.NetworkData = (function() {\n    \n                        function NetworkData(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        NetworkData.prototype.stable = null;\n                        NetworkData.prototype.temporary = null;\n    \n                        NetworkData.create = function create(properties) {\n                            return new NetworkData(properties);\n                        };\n    \n                        NetworkData.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.stable != null && Object.hasOwnProperty.call(m, \"stable\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(m.stable, w.uint32(10).fork()).ldelim();\n                            if (m.temporary != null && Object.hasOwnProperty.call(m, \"temporary\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(m.temporary, w.uint32(18).fork()).ldelim();\n                            return w;\n                        };\n    \n                        NetworkData.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.stable = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(r, r.uint32());\n                                    break;\n                                case 2:\n                                    m.temporary = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(r, r.uint32());\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        NetworkData.HasRoute = (function() {\n    \n                            function HasRoute(p) {\n                                this.entries = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            HasRoute.prototype.entries = $util.emptyArray;\n    \n                            HasRoute.create = function create(properties) {\n                                return new HasRoute(properties);\n                            };\n    \n                            HasRoute.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.entries != null && m.entries.length) {\n                                    for (var i = 0; i < m.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.encode(m.entries[i], w.uint32(10).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            HasRoute.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.entries && m.entries.length))\n                                            m.entries = [];\n                                        m.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            HasRoute.HasRouteEntry = (function() {\n    \n                                function HasRouteEntry(p) {\n                                    if (p)\n                                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                            if (p[ks[i]] != null)\n                                                this[ks[i]] = p[ks[i]];\n                                }\n    \n                                HasRouteEntry.prototype.rloc = 0;\n                                HasRouteEntry.prototype.preference = 0;\n    \n                                HasRouteEntry.create = function create(properties) {\n                                    return new HasRouteEntry(properties);\n                                };\n    \n                                HasRouteEntry.encode = function encode(m, w) {\n                                    if (!w)\n                                        w = $Writer.create();\n                                    if (m.rloc != null && Object.hasOwnProperty.call(m, \"rloc\"))\n                                        w.uint32(8).uint32(m.rloc);\n                                    if (m.preference != null && Object.hasOwnProperty.call(m, \"preference\"))\n                                        w.uint32(16).int32(m.preference);\n                                    return w;\n                                };\n    \n                                HasRouteEntry.decode = function decode(r, l) {\n                                    if (!(r instanceof $Reader))\n                                        r = $Reader.create(r);\n                                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry();\n                                    while (r.pos < c) {\n                                        var t = r.uint32();\n                                        switch (t >>> 3) {\n                                        case 1:\n                                            m.rloc = r.uint32();\n                                            break;\n                                        case 2:\n                                            m.preference = r.int32();\n                                            break;\n                                        default:\n                                            r.skipType(t & 7);\n                                            break;\n                                        }\n                                    }\n                                    return m;\n                                };\n    \n                                return HasRouteEntry;\n                            })();\n    \n                            return HasRoute;\n                        })();\n    \n                        NetworkData.BorderRouter = (function() {\n    \n                            function BorderRouter(p) {\n                                this.entries = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            BorderRouter.prototype.entries = $util.emptyArray;\n    \n                            BorderRouter.create = function create(properties) {\n                                return new BorderRouter(properties);\n                            };\n    \n                            BorderRouter.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.entries != null && m.entries.length) {\n                                    for (var i = 0; i < m.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.encode(m.entries[i], w.uint32(10).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            BorderRouter.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.entries && m.entries.length))\n                                            m.entries = [];\n                                        m.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            BorderRouter.BorderRouterEntry = (function() {\n    \n                                function BorderRouterEntry(p) {\n                                    if (p)\n                                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                            if (p[ks[i]] != null)\n                                                this[ks[i]] = p[ks[i]];\n                                }\n    \n                                BorderRouterEntry.prototype.rloc = 0;\n                                BorderRouterEntry.prototype.preference = 0;\n                                BorderRouterEntry.prototype.flags = 0;\n    \n                                BorderRouterEntry.create = function create(properties) {\n                                    return new BorderRouterEntry(properties);\n                                };\n    \n                                BorderRouterEntry.encode = function encode(m, w) {\n                                    if (!w)\n                                        w = $Writer.create();\n                                    if (m.rloc != null && Object.hasOwnProperty.call(m, \"rloc\"))\n                                        w.uint32(8).uint32(m.rloc);\n                                    if (m.preference != null && Object.hasOwnProperty.call(m, \"preference\"))\n                                        w.uint32(16).int32(m.preference);\n                                    if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                                        w.uint32(24).uint32(m.flags);\n                                    return w;\n                                };\n    \n                                BorderRouterEntry.decode = function decode(r, l) {\n                                    if (!(r instanceof $Reader))\n                                        r = $Reader.create(r);\n                                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry();\n                                    while (r.pos < c) {\n                                        var t = r.uint32();\n                                        switch (t >>> 3) {\n                                        case 1:\n                                            m.rloc = r.uint32();\n                                            break;\n                                        case 2:\n                                            m.preference = r.int32();\n                                            break;\n                                        case 3:\n                                            m.flags = r.uint32();\n                                            break;\n                                        default:\n                                            r.skipType(t & 7);\n                                            break;\n                                        }\n                                    }\n                                    return m;\n                                };\n    \n                                BorderRouterEntry.Flags = (function() {\n                                    var valuesById = {}, values = Object.create(valuesById);\n                                    values[valuesById[0] = \"NONE\"] = 0;\n                                    values[valuesById[1] = \"PREFERRED\"] = 1;\n                                    values[valuesById[2] = \"SLAAC\"] = 2;\n                                    values[valuesById[4] = \"DHCP\"] = 4;\n                                    values[valuesById[8] = \"CONFIGURE\"] = 8;\n                                    values[valuesById[16] = \"DEFAULT_ROUTE\"] = 16;\n                                    values[valuesById[32] = \"ON_MESH\"] = 32;\n                                    values[valuesById[64] = \"ND_DNS\"] = 64;\n                                    return values;\n                                })();\n    \n                                return BorderRouterEntry;\n                            })();\n    \n                            return BorderRouter;\n                        })();\n    \n                        NetworkData.Context = (function() {\n    \n                            function Context(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Context.prototype.cid = 0;\n                            Context.prototype.compress = false;\n                            Context.prototype.contextLength = 0;\n    \n                            Context.create = function create(properties) {\n                                return new Context(properties);\n                            };\n    \n                            Context.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.cid != null && Object.hasOwnProperty.call(m, \"cid\"))\n                                    w.uint32(8).uint32(m.cid);\n                                if (m.compress != null && Object.hasOwnProperty.call(m, \"compress\"))\n                                    w.uint32(16).bool(m.compress);\n                                if (m.contextLength != null && Object.hasOwnProperty.call(m, \"contextLength\"))\n                                    w.uint32(24).uint32(m.contextLength);\n                                return w;\n                            };\n    \n                            Context.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.cid = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.compress = r.bool();\n                                        break;\n                                    case 3:\n                                        m.contextLength = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Context;\n                        })();\n    \n                        NetworkData.Prefix = (function() {\n    \n                            function Prefix(p) {\n                                this.context = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Prefix.prototype.domainId = 0;\n                            Prefix.prototype.prefixLength = 0;\n                            Prefix.prototype.prefix = $util.newBuffer([]);\n                            Prefix.prototype.context = $util.emptyArray;\n                            Prefix.prototype.hasRoute = null;\n                            Prefix.prototype.borderRouter = null;\n    \n                            Prefix.create = function create(properties) {\n                                return new Prefix(properties);\n                            };\n    \n                            Prefix.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.domainId != null && Object.hasOwnProperty.call(m, \"domainId\"))\n                                    w.uint32(8).uint32(m.domainId);\n                                if (m.prefixLength != null && Object.hasOwnProperty.call(m, \"prefixLength\"))\n                                    w.uint32(16).uint32(m.prefixLength);\n                                if (m.prefix != null && Object.hasOwnProperty.call(m, \"prefix\"))\n                                    w.uint32(26).bytes(m.prefix);\n                                if (m.context != null && m.context.length) {\n                                    for (var i = 0; i < m.context.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.encode(m.context[i], w.uint32(34).fork()).ldelim();\n                                }\n                                if (m.hasRoute != null && Object.hasOwnProperty.call(m, \"hasRoute\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.encode(m.hasRoute, w.uint32(42).fork()).ldelim();\n                                if (m.borderRouter != null && Object.hasOwnProperty.call(m, \"borderRouter\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.encode(m.borderRouter, w.uint32(50).fork()).ldelim();\n                                return w;\n                            };\n    \n                            Prefix.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.domainId = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.prefixLength = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.prefix = r.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(m.context && m.context.length))\n                                            m.context = [];\n                                        m.context.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.decode(r, r.uint32()));\n                                        break;\n                                    case 5:\n                                        m.hasRoute = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.decode(r, r.uint32());\n                                        break;\n                                    case 6:\n                                        m.borderRouter = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.decode(r, r.uint32());\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Prefix;\n                        })();\n    \n                        NetworkData.Server = (function() {\n    \n                            function Server(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Server.prototype.rloc = 0;\n                            Server.prototype.data = $util.newBuffer([]);\n    \n                            Server.create = function create(properties) {\n                                return new Server(properties);\n                            };\n    \n                            Server.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.rloc != null && Object.hasOwnProperty.call(m, \"rloc\"))\n                                    w.uint32(8).uint32(m.rloc);\n                                if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                                    w.uint32(18).bytes(m.data);\n                                return w;\n                            };\n    \n                            Server.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.rloc = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.data = r.bytes();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Server;\n                        })();\n    \n                        NetworkData.Service = (function() {\n    \n                            function Service(p) {\n                                this.servers = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Service.prototype.sid = 0;\n                            Service.prototype.enterpriseNumber = 0;\n                            Service.prototype.data = $util.newBuffer([]);\n                            Service.prototype.servers = $util.emptyArray;\n    \n                            Service.create = function create(properties) {\n                                return new Service(properties);\n                            };\n    \n                            Service.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.sid != null && Object.hasOwnProperty.call(m, \"sid\"))\n                                    w.uint32(8).uint32(m.sid);\n                                if (m.enterpriseNumber != null && Object.hasOwnProperty.call(m, \"enterpriseNumber\"))\n                                    w.uint32(16).uint32(m.enterpriseNumber);\n                                if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                                    w.uint32(26).bytes(m.data);\n                                if (m.servers != null && m.servers.length) {\n                                    for (var i = 0; i < m.servers.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.encode(m.servers[i], w.uint32(34).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            Service.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.sid = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.enterpriseNumber = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.data = r.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(m.servers && m.servers.length))\n                                            m.servers = [];\n                                        m.servers.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Service;\n                        })();\n    \n                        NetworkData.Data = (function() {\n    \n                            function Data(p) {\n                                this.prefixes = [];\n                                this.services = [];\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            Data.prototype.prefixes = $util.emptyArray;\n                            Data.prototype.services = $util.emptyArray;\n    \n                            Data.create = function create(properties) {\n                                return new Data(properties);\n                            };\n    \n                            Data.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.prefixes != null && m.prefixes.length) {\n                                    for (var i = 0; i < m.prefixes.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.encode(m.prefixes[i], w.uint32(10).fork()).ldelim();\n                                }\n                                if (m.services != null && m.services.length) {\n                                    for (var i = 0; i < m.services.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.encode(m.services[i], w.uint32(18).fork()).ldelim();\n                                }\n                                return w;\n                            };\n    \n                            Data.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        if (!(m.prefixes && m.prefixes.length))\n                                            m.prefixes = [];\n                                        m.prefixes.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.decode(r, r.uint32()));\n                                        break;\n                                    case 2:\n                                        if (!(m.services && m.services.length))\n                                            m.services = [];\n                                        m.services.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.decode(r, r.uint32()));\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return Data;\n                        })();\n    \n                        return NetworkData;\n                    })();\n    \n                    DiagnosticInfo.MacCounters = (function() {\n    \n                        function MacCounters(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        MacCounters.prototype.ifInUnknownProtos = 0;\n                        MacCounters.prototype.ifInErrors = 0;\n                        MacCounters.prototype.ifOutErrors = 0;\n                        MacCounters.prototype.ifInUcastPkts = 0;\n                        MacCounters.prototype.ifInBroadcastPkts = 0;\n                        MacCounters.prototype.ifInDiscards = 0;\n                        MacCounters.prototype.ifOutUcastPkts = 0;\n                        MacCounters.prototype.ifOutBroadcastPkts = 0;\n                        MacCounters.prototype.ifOutDiscards = 0;\n    \n                        MacCounters.create = function create(properties) {\n                            return new MacCounters(properties);\n                        };\n    \n                        MacCounters.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.ifInUnknownProtos != null && Object.hasOwnProperty.call(m, \"ifInUnknownProtos\"))\n                                w.uint32(8).uint32(m.ifInUnknownProtos);\n                            if (m.ifInErrors != null && Object.hasOwnProperty.call(m, \"ifInErrors\"))\n                                w.uint32(16).uint32(m.ifInErrors);\n                            if (m.ifOutErrors != null && Object.hasOwnProperty.call(m, \"ifOutErrors\"))\n                                w.uint32(24).uint32(m.ifOutErrors);\n                            if (m.ifInUcastPkts != null && Object.hasOwnProperty.call(m, \"ifInUcastPkts\"))\n                                w.uint32(32).uint32(m.ifInUcastPkts);\n                            if (m.ifInBroadcastPkts != null && Object.hasOwnProperty.call(m, \"ifInBroadcastPkts\"))\n                                w.uint32(40).uint32(m.ifInBroadcastPkts);\n                            if (m.ifInDiscards != null && Object.hasOwnProperty.call(m, \"ifInDiscards\"))\n                                w.uint32(48).uint32(m.ifInDiscards);\n                            if (m.ifOutUcastPkts != null && Object.hasOwnProperty.call(m, \"ifOutUcastPkts\"))\n                                w.uint32(56).uint32(m.ifOutUcastPkts);\n                            if (m.ifOutBroadcastPkts != null && Object.hasOwnProperty.call(m, \"ifOutBroadcastPkts\"))\n                                w.uint32(64).uint32(m.ifOutBroadcastPkts);\n                            if (m.ifOutDiscards != null && Object.hasOwnProperty.call(m, \"ifOutDiscards\"))\n                                w.uint32(72).uint32(m.ifOutDiscards);\n                            return w;\n                        };\n    \n                        MacCounters.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.ifInUnknownProtos = r.uint32();\n                                    break;\n                                case 2:\n                                    m.ifInErrors = r.uint32();\n                                    break;\n                                case 3:\n                                    m.ifOutErrors = r.uint32();\n                                    break;\n                                case 4:\n                                    m.ifInUcastPkts = r.uint32();\n                                    break;\n                                case 5:\n                                    m.ifInBroadcastPkts = r.uint32();\n                                    break;\n                                case 6:\n                                    m.ifInDiscards = r.uint32();\n                                    break;\n                                case 7:\n                                    m.ifOutUcastPkts = r.uint32();\n                                    break;\n                                case 8:\n                                    m.ifOutBroadcastPkts = r.uint32();\n                                    break;\n                                case 9:\n                                    m.ifOutDiscards = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return MacCounters;\n                    })();\n    \n                    DiagnosticInfo.ChildTable = (function() {\n    \n                        function ChildTable(p) {\n                            this.children = [];\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        ChildTable.prototype.children = $util.emptyArray;\n    \n                        ChildTable.create = function create(properties) {\n                            return new ChildTable(properties);\n                        };\n    \n                        ChildTable.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.children != null && m.children.length) {\n                                for (var i = 0; i < m.children.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.encode(m.children[i], w.uint32(10).fork()).ldelim();\n                            }\n                            return w;\n                        };\n    \n                        ChildTable.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    if (!(m.children && m.children.length))\n                                        m.children = [];\n                                    m.children.push($root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.decode(r, r.uint32()));\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        ChildTable.ChildEntry = (function() {\n    \n                            function ChildEntry(p) {\n                                if (p)\n                                    for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                        if (p[ks[i]] != null)\n                                            this[ks[i]] = p[ks[i]];\n                            }\n    \n                            ChildEntry.prototype.timeout = 0;\n                            ChildEntry.prototype.childId = 0;\n                            ChildEntry.prototype.mode = 0;\n    \n                            ChildEntry.create = function create(properties) {\n                                return new ChildEntry(properties);\n                            };\n    \n                            ChildEntry.encode = function encode(m, w) {\n                                if (!w)\n                                    w = $Writer.create();\n                                if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                                    w.uint32(8).uint32(m.timeout);\n                                if (m.childId != null && Object.hasOwnProperty.call(m, \"childId\"))\n                                    w.uint32(16).uint32(m.childId);\n                                if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n                                    w.uint32(24).uint32(m.mode);\n                                return w;\n                            };\n    \n                            ChildEntry.decode = function decode(r, l) {\n                                if (!(r instanceof $Reader))\n                                    r = $Reader.create(r);\n                                var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry();\n                                while (r.pos < c) {\n                                    var t = r.uint32();\n                                    switch (t >>> 3) {\n                                    case 1:\n                                        m.timeout = r.uint32();\n                                        break;\n                                    case 2:\n                                        m.childId = r.uint32();\n                                        break;\n                                    case 3:\n                                        m.mode = r.uint32();\n                                        break;\n                                    default:\n                                        r.skipType(t & 7);\n                                        break;\n                                    }\n                                }\n                                return m;\n                            };\n    \n                            return ChildEntry;\n                        })();\n    \n                        return ChildTable;\n                    })();\n    \n                    return DiagnosticInfo;\n                })();\n    \n                mesh.GetNetworkDiagnosticsRequest = (function() {\n    \n                    function GetNetworkDiagnosticsRequest(p) {\n                        this.diagnosticTypes = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkDiagnosticsRequest.prototype.flags = 0;\n                    GetNetworkDiagnosticsRequest.prototype.diagnosticTypes = $util.emptyArray;\n                    GetNetworkDiagnosticsRequest.prototype.timeout = 0;\n    \n                    GetNetworkDiagnosticsRequest.create = function create(properties) {\n                        return new GetNetworkDiagnosticsRequest(properties);\n                    };\n    \n                    GetNetworkDiagnosticsRequest.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                            w.uint32(8).uint32(m.flags);\n                        if (m.diagnosticTypes != null && m.diagnosticTypes.length) {\n                            w.uint32(18).fork();\n                            for (var i = 0; i < m.diagnosticTypes.length; ++i)\n                                w.int32(m.diagnosticTypes[i]);\n                            w.ldelim();\n                        }\n                        if (m.timeout != null && Object.hasOwnProperty.call(m, \"timeout\"))\n                            w.uint32(24).uint32(m.timeout);\n                        return w;\n                    };\n    \n                    GetNetworkDiagnosticsRequest.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsRequest();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.flags = r.uint32();\n                                break;\n                            case 2:\n                                if (!(m.diagnosticTypes && m.diagnosticTypes.length))\n                                    m.diagnosticTypes = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.diagnosticTypes.push(r.int32());\n                                } else\n                                    m.diagnosticTypes.push(r.int32());\n                                break;\n                            case 3:\n                                m.timeout = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    GetNetworkDiagnosticsRequest.Flags = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[1] = \"QUERY_CHILDREN\"] = 1;\n                        values[valuesById[2] = \"RESOLVE_DEVICE_ID\"] = 2;\n                        return values;\n                    })();\n    \n                    return GetNetworkDiagnosticsRequest;\n                })();\n    \n                mesh.GetNetworkDiagnosticsReply = (function() {\n    \n                    function GetNetworkDiagnosticsReply(p) {\n                        this.nodes = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    GetNetworkDiagnosticsReply.prototype.nodes = $util.emptyArray;\n    \n                    GetNetworkDiagnosticsReply.create = function create(properties) {\n                        return new GetNetworkDiagnosticsReply(properties);\n                    };\n    \n                    GetNetworkDiagnosticsReply.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.nodes != null && m.nodes.length) {\n                            for (var i = 0; i < m.nodes.length; ++i)\n                                $root.particle.ctrl.mesh.DiagnosticInfo.encode(m.nodes[i], w.uint32(10).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    GetNetworkDiagnosticsReply.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsReply();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.nodes && m.nodes.length))\n                                    m.nodes = [];\n                                m.nodes.push($root.particle.ctrl.mesh.DiagnosticInfo.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return GetNetworkDiagnosticsReply;\n                })();\n    \n                return mesh;\n            })();\n    \n            ctrl.StorageType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_STORAGE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                return values;\n            })();\n    \n            ctrl.SectionType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECTION\"] = 0;\n                values[valuesById[1] = \"FIRMWARE\"] = 1;\n                values[valuesById[2] = \"OTA_BACKUP\"] = 2;\n                values[valuesById[3] = \"FACTORY_BACKUP\"] = 3;\n                values[valuesById[4] = \"CONFIG\"] = 4;\n                values[valuesById[5] = \"EEPROM\"] = 5;\n                return values;\n            })();\n    \n            ctrl.FirmwareModuleType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FIRMWARE_MODULE\"] = 0;\n                values[valuesById[1] = \"BOOTLOADER\"] = 1;\n                values[valuesById[2] = \"SYSTEM_PART\"] = 2;\n                values[valuesById[3] = \"USER_PART\"] = 3;\n                values[valuesById[4] = \"MONO_FIRMWARE\"] = 4;\n                values[valuesById[5] = \"NCP_FIRMWARE\"] = 5;\n                return values;\n            })();\n    \n            ctrl.FirmwareModuleValidityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_VALIDATION_ERRORS\"] = 0;\n                values[valuesById[1] = \"INTEGRITY_CHECK_FAILED\"] = 1;\n                values[valuesById[2] = \"DEPENDENCY_CHECK_FAILED\"] = 2;\n                return values;\n            })();\n    \n            ctrl.SectionFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SECTION_FLAGS\"] = 0;\n                values[valuesById[1] = \"CAN_READ\"] = 1;\n                values[valuesById[2] = \"CAN_WRITE\"] = 2;\n                values[valuesById[4] = \"CAN_CLEAR\"] = 4;\n                values[valuesById[8] = \"CAN_GET_SIZE\"] = 8;\n                values[valuesById[16] = \"NEED_CLEAR\"] = 16;\n                return values;\n            })();\n    \n            ctrl.FileFormat = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"BIN\"] = 0;\n                values[valuesById[1] = \"MINIZ\"] = 1;\n                return values;\n            })();\n    \n            ctrl.StartFirmwareUpdateRequest = (function() {\n    \n                function StartFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartFirmwareUpdateRequest.prototype.size = 0;\n                StartFirmwareUpdateRequest.prototype.format = 0;\n    \n                StartFirmwareUpdateRequest.create = function create(properties) {\n                    return new StartFirmwareUpdateRequest(properties);\n                };\n    \n                StartFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.size != null && Object.hasOwnProperty.call(m, \"size\"))\n                        w.uint32(8).uint32(m.size);\n                    if (m.format != null && Object.hasOwnProperty.call(m, \"format\"))\n                        w.uint32(16).int32(m.format);\n                    return w;\n                };\n    \n                StartFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.size = r.uint32();\n                            break;\n                        case 2:\n                            m.format = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartFirmwareUpdateRequest;\n            })();\n    \n            ctrl.StartFirmwareUpdateReply = (function() {\n    \n                function StartFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                StartFirmwareUpdateReply.prototype.chunkSize = 0;\n    \n                StartFirmwareUpdateReply.create = function create(properties) {\n                    return new StartFirmwareUpdateReply(properties);\n                };\n    \n                StartFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.chunkSize != null && Object.hasOwnProperty.call(m, \"chunkSize\"))\n                        w.uint32(8).uint32(m.chunkSize);\n                    return w;\n                };\n    \n                StartFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.StartFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.chunkSize = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return StartFirmwareUpdateReply;\n            })();\n    \n            ctrl.FinishFirmwareUpdateRequest = (function() {\n    \n                function FinishFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FinishFirmwareUpdateRequest.prototype.validateOnly = false;\n    \n                FinishFirmwareUpdateRequest.create = function create(properties) {\n                    return new FinishFirmwareUpdateRequest(properties);\n                };\n    \n                FinishFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.validateOnly != null && Object.hasOwnProperty.call(m, \"validateOnly\"))\n                        w.uint32(8).bool(m.validateOnly);\n                    return w;\n                };\n    \n                FinishFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FinishFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.validateOnly = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FinishFirmwareUpdateRequest;\n            })();\n    \n            ctrl.FinishFirmwareUpdateReply = (function() {\n    \n                function FinishFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FinishFirmwareUpdateReply.create = function create(properties) {\n                    return new FinishFirmwareUpdateReply(properties);\n                };\n    \n                FinishFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                FinishFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FinishFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FinishFirmwareUpdateReply;\n            })();\n    \n            ctrl.CancelFirmwareUpdateRequest = (function() {\n    \n                function CancelFirmwareUpdateRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CancelFirmwareUpdateRequest.create = function create(properties) {\n                    return new CancelFirmwareUpdateRequest(properties);\n                };\n    \n                CancelFirmwareUpdateRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                CancelFirmwareUpdateRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.CancelFirmwareUpdateRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CancelFirmwareUpdateRequest;\n            })();\n    \n            ctrl.CancelFirmwareUpdateReply = (function() {\n    \n                function CancelFirmwareUpdateReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CancelFirmwareUpdateReply.create = function create(properties) {\n                    return new CancelFirmwareUpdateReply(properties);\n                };\n    \n                CancelFirmwareUpdateReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                CancelFirmwareUpdateReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.CancelFirmwareUpdateReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CancelFirmwareUpdateReply;\n            })();\n    \n            ctrl.FirmwareUpdateDataRequest = (function() {\n    \n                function FirmwareUpdateDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FirmwareUpdateDataRequest.prototype.data = $util.newBuffer([]);\n    \n                FirmwareUpdateDataRequest.create = function create(properties) {\n                    return new FirmwareUpdateDataRequest(properties);\n                };\n    \n                FirmwareUpdateDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                FirmwareUpdateDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FirmwareUpdateDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FirmwareUpdateDataRequest;\n            })();\n    \n            ctrl.FirmwareUpdateDataReply = (function() {\n    \n                function FirmwareUpdateDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FirmwareUpdateDataReply.create = function create(properties) {\n                    return new FirmwareUpdateDataReply(properties);\n                };\n    \n                FirmwareUpdateDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                FirmwareUpdateDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.FirmwareUpdateDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FirmwareUpdateDataReply;\n            })();\n    \n            ctrl.DescribeStorageRequest = (function() {\n    \n                function DescribeStorageRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescribeStorageRequest.create = function create(properties) {\n                    return new DescribeStorageRequest(properties);\n                };\n    \n                DescribeStorageRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                DescribeStorageRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return DescribeStorageRequest;\n            })();\n    \n            ctrl.DescribeStorageReply = (function() {\n    \n                function DescribeStorageReply(p) {\n                    this.storage = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescribeStorageReply.prototype.storage = $util.emptyArray;\n    \n                DescribeStorageReply.create = function create(properties) {\n                    return new DescribeStorageReply(properties);\n                };\n    \n                DescribeStorageReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && m.storage.length) {\n                        for (var i = 0; i < m.storage.length; ++i)\n                            $root.particle.ctrl.DescribeStorageReply.Storage.encode(m.storage[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                DescribeStorageReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.storage && m.storage.length))\n                                m.storage = [];\n                            m.storage.push($root.particle.ctrl.DescribeStorageReply.Storage.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                DescribeStorageReply.Section = (function() {\n    \n                    function Section(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Section.prototype.type = 0;\n                    Section.prototype.size = 0;\n                    Section.prototype.flags = 0;\n                    Section.prototype.firmwareModule = null;\n    \n                    Section.create = function create(properties) {\n                        return new Section(properties);\n                    };\n    \n                    Section.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.size != null && Object.hasOwnProperty.call(m, \"size\"))\n                            w.uint32(16).uint32(m.size);\n                        if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                            w.uint32(24).uint32(m.flags);\n                        if (m.firmwareModule != null && Object.hasOwnProperty.call(m, \"firmwareModule\"))\n                            $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.encode(m.firmwareModule, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    Section.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Section();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.size = r.uint32();\n                                break;\n                            case 3:\n                                m.flags = r.uint32();\n                                break;\n                            case 4:\n                                m.firmwareModule = $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    Section.FirmwareModule = (function() {\n    \n                        function FirmwareModule(p) {\n                            if (p)\n                                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                    if (p[ks[i]] != null)\n                                        this[ks[i]] = p[ks[i]];\n                        }\n    \n                        FirmwareModule.prototype.type = 0;\n                        FirmwareModule.prototype.index = 0;\n    \n                        FirmwareModule.create = function create(properties) {\n                            return new FirmwareModule(properties);\n                        };\n    \n                        FirmwareModule.encode = function encode(m, w) {\n                            if (!w)\n                                w = $Writer.create();\n                            if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                                w.uint32(8).int32(m.type);\n                            if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                                w.uint32(16).uint32(m.index);\n                            return w;\n                        };\n    \n                        FirmwareModule.decode = function decode(r, l) {\n                            if (!(r instanceof $Reader))\n                                r = $Reader.create(r);\n                            var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule();\n                            while (r.pos < c) {\n                                var t = r.uint32();\n                                switch (t >>> 3) {\n                                case 1:\n                                    m.type = r.int32();\n                                    break;\n                                case 2:\n                                    m.index = r.uint32();\n                                    break;\n                                default:\n                                    r.skipType(t & 7);\n                                    break;\n                                }\n                            }\n                            return m;\n                        };\n    \n                        return FirmwareModule;\n                    })();\n    \n                    return Section;\n                })();\n    \n                DescribeStorageReply.Storage = (function() {\n    \n                    function Storage(p) {\n                        this.sections = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Storage.prototype.type = 0;\n                    Storage.prototype.flags = 0;\n                    Storage.prototype.sections = $util.emptyArray;\n    \n                    Storage.create = function create(properties) {\n                        return new Storage(properties);\n                    };\n    \n                    Storage.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.flags != null && Object.hasOwnProperty.call(m, \"flags\"))\n                            w.uint32(16).uint32(m.flags);\n                        if (m.sections != null && m.sections.length) {\n                            for (var i = 0; i < m.sections.length; ++i)\n                                $root.particle.ctrl.DescribeStorageReply.Section.encode(m.sections[i], w.uint32(26).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    Storage.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.DescribeStorageReply.Storage();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.flags = r.uint32();\n                                break;\n                            case 3:\n                                if (!(m.sections && m.sections.length))\n                                    m.sections = [];\n                                m.sections.push($root.particle.ctrl.DescribeStorageReply.Section.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Storage;\n                })();\n    \n                return DescribeStorageReply;\n            })();\n    \n            ctrl.ReadSectionDataRequest = (function() {\n    \n                function ReadSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ReadSectionDataRequest.prototype.storage = 0;\n                ReadSectionDataRequest.prototype.section = 0;\n                ReadSectionDataRequest.prototype.offset = 0;\n                ReadSectionDataRequest.prototype.size = 0;\n    \n                ReadSectionDataRequest.create = function create(properties) {\n                    return new ReadSectionDataRequest(properties);\n                };\n    \n                ReadSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && Object.hasOwnProperty.call(m, \"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && Object.hasOwnProperty.call(m, \"section\"))\n                        w.uint32(16).uint32(m.section);\n                    if (m.offset != null && Object.hasOwnProperty.call(m, \"offset\"))\n                        w.uint32(24).uint32(m.offset);\n                    if (m.size != null && Object.hasOwnProperty.call(m, \"size\"))\n                        w.uint32(32).uint32(m.size);\n                    return w;\n                };\n    \n                ReadSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ReadSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        case 3:\n                            m.offset = r.uint32();\n                            break;\n                        case 4:\n                            m.size = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ReadSectionDataRequest;\n            })();\n    \n            ctrl.ReadSectionDataReply = (function() {\n    \n                function ReadSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ReadSectionDataReply.prototype.data = $util.newBuffer([]);\n    \n                ReadSectionDataReply.create = function create(properties) {\n                    return new ReadSectionDataReply(properties);\n                };\n    \n                ReadSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                        w.uint32(10).bytes(m.data);\n                    return w;\n                };\n    \n                ReadSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ReadSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ReadSectionDataReply;\n            })();\n    \n            ctrl.WriteSectionDataRequest = (function() {\n    \n                function WriteSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WriteSectionDataRequest.prototype.storage = 0;\n                WriteSectionDataRequest.prototype.section = 0;\n                WriteSectionDataRequest.prototype.offset = 0;\n                WriteSectionDataRequest.prototype.data = $util.newBuffer([]);\n    \n                WriteSectionDataRequest.create = function create(properties) {\n                    return new WriteSectionDataRequest(properties);\n                };\n    \n                WriteSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && Object.hasOwnProperty.call(m, \"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && Object.hasOwnProperty.call(m, \"section\"))\n                        w.uint32(16).uint32(m.section);\n                    if (m.offset != null && Object.hasOwnProperty.call(m, \"offset\"))\n                        w.uint32(24).uint32(m.offset);\n                    if (m.data != null && Object.hasOwnProperty.call(m, \"data\"))\n                        w.uint32(34).bytes(m.data);\n                    return w;\n                };\n    \n                WriteSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WriteSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        case 3:\n                            m.offset = r.uint32();\n                            break;\n                        case 4:\n                            m.data = r.bytes();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WriteSectionDataRequest;\n            })();\n    \n            ctrl.WriteSectionDataReply = (function() {\n    \n                function WriteSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WriteSectionDataReply.create = function create(properties) {\n                    return new WriteSectionDataReply(properties);\n                };\n    \n                WriteSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                WriteSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.WriteSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return WriteSectionDataReply;\n            })();\n    \n            ctrl.ClearSectionDataRequest = (function() {\n    \n                function ClearSectionDataRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ClearSectionDataRequest.prototype.storage = 0;\n                ClearSectionDataRequest.prototype.section = 0;\n    \n                ClearSectionDataRequest.create = function create(properties) {\n                    return new ClearSectionDataRequest(properties);\n                };\n    \n                ClearSectionDataRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && Object.hasOwnProperty.call(m, \"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && Object.hasOwnProperty.call(m, \"section\"))\n                        w.uint32(16).uint32(m.section);\n                    return w;\n                };\n    \n                ClearSectionDataRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ClearSectionDataRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ClearSectionDataRequest;\n            })();\n    \n            ctrl.ClearSectionDataReply = (function() {\n    \n                function ClearSectionDataReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ClearSectionDataReply.create = function create(properties) {\n                    return new ClearSectionDataReply(properties);\n                };\n    \n                ClearSectionDataReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                ClearSectionDataReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.ClearSectionDataReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ClearSectionDataReply;\n            })();\n    \n            ctrl.GetSectionDataSizeRequest = (function() {\n    \n                function GetSectionDataSizeRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSectionDataSizeRequest.prototype.storage = 0;\n                GetSectionDataSizeRequest.prototype.section = 0;\n    \n                GetSectionDataSizeRequest.create = function create(properties) {\n                    return new GetSectionDataSizeRequest(properties);\n                };\n    \n                GetSectionDataSizeRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.storage != null && Object.hasOwnProperty.call(m, \"storage\"))\n                        w.uint32(8).uint32(m.storage);\n                    if (m.section != null && Object.hasOwnProperty.call(m, \"section\"))\n                        w.uint32(16).uint32(m.section);\n                    return w;\n                };\n    \n                GetSectionDataSizeRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSectionDataSizeRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.storage = r.uint32();\n                            break;\n                        case 2:\n                            m.section = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSectionDataSizeRequest;\n            })();\n    \n            ctrl.GetSectionDataSizeReply = (function() {\n    \n                function GetSectionDataSizeReply(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetSectionDataSizeReply.prototype.size = 0;\n    \n                GetSectionDataSizeReply.create = function create(properties) {\n                    return new GetSectionDataSizeReply(properties);\n                };\n    \n                GetSectionDataSizeReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.size != null && Object.hasOwnProperty.call(m, \"size\"))\n                        w.uint32(8).uint32(m.size);\n                    return w;\n                };\n    \n                GetSectionDataSizeReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetSectionDataSizeReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.size = r.uint32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetSectionDataSizeReply;\n            })();\n    \n            ctrl.GetModuleInfoRequest = (function() {\n    \n                function GetModuleInfoRequest(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetModuleInfoRequest.create = function create(properties) {\n                    return new GetModuleInfoRequest(properties);\n                };\n    \n                GetModuleInfoRequest.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    return w;\n                };\n    \n                GetModuleInfoRequest.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoRequest();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return GetModuleInfoRequest;\n            })();\n    \n            ctrl.GetModuleInfoReply = (function() {\n    \n                function GetModuleInfoReply(p) {\n                    this.modules = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GetModuleInfoReply.prototype.modules = $util.emptyArray;\n    \n                GetModuleInfoReply.create = function create(properties) {\n                    return new GetModuleInfoReply(properties);\n                };\n    \n                GetModuleInfoReply.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.modules != null && m.modules.length) {\n                        for (var i = 0; i < m.modules.length; ++i)\n                            $root.particle.ctrl.GetModuleInfoReply.Module.encode(m.modules[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GetModuleInfoReply.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.modules && m.modules.length))\n                                m.modules = [];\n                            m.modules.push($root.particle.ctrl.GetModuleInfoReply.Module.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                GetModuleInfoReply.Dependency = (function() {\n    \n                    function Dependency(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Dependency.prototype.type = 0;\n                    Dependency.prototype.index = 0;\n                    Dependency.prototype.version = 0;\n    \n                    Dependency.create = function create(properties) {\n                        return new Dependency(properties);\n                    };\n    \n                    Dependency.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                            w.uint32(16).uint32(m.index);\n                        if (m.version != null && Object.hasOwnProperty.call(m, \"version\"))\n                            w.uint32(24).uint32(m.version);\n                        return w;\n                    };\n    \n                    Dependency.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply.Dependency();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.index = r.uint32();\n                                break;\n                            case 3:\n                                m.version = r.uint32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Dependency;\n                })();\n    \n                GetModuleInfoReply.Module = (function() {\n    \n                    function Module(p) {\n                        this.dependencies = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Module.prototype.type = 0;\n                    Module.prototype.index = 0;\n                    Module.prototype.version = 0;\n                    Module.prototype.size = 0;\n                    Module.prototype.validity = 0;\n                    Module.prototype.dependencies = $util.emptyArray;\n    \n                    Module.create = function create(properties) {\n                        return new Module(properties);\n                    };\n    \n                    Module.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                            w.uint32(8).int32(m.type);\n                        if (m.index != null && Object.hasOwnProperty.call(m, \"index\"))\n                            w.uint32(16).uint32(m.index);\n                        if (m.version != null && Object.hasOwnProperty.call(m, \"version\"))\n                            w.uint32(24).uint32(m.version);\n                        if (m.size != null && Object.hasOwnProperty.call(m, \"size\"))\n                            w.uint32(32).uint32(m.size);\n                        if (m.validity != null && Object.hasOwnProperty.call(m, \"validity\"))\n                            w.uint32(40).uint32(m.validity);\n                        if (m.dependencies != null && m.dependencies.length) {\n                            for (var i = 0; i < m.dependencies.length; ++i)\n                                $root.particle.ctrl.GetModuleInfoReply.Dependency.encode(m.dependencies[i], w.uint32(50).fork()).ldelim();\n                        }\n                        return w;\n                    };\n    \n                    Module.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.ctrl.GetModuleInfoReply.Module();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.type = r.int32();\n                                break;\n                            case 2:\n                                m.index = r.uint32();\n                                break;\n                            case 3:\n                                m.version = r.uint32();\n                                break;\n                            case 4:\n                                m.size = r.uint32();\n                                break;\n                            case 5:\n                                m.validity = r.uint32();\n                                break;\n                            case 6:\n                                if (!(m.dependencies && m.dependencies.length))\n                                    m.dependencies = [];\n                                m.dependencies.push($root.particle.ctrl.GetModuleInfoReply.Dependency.decode(r, r.uint32()));\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Module;\n                })();\n    \n                return GetModuleInfoReply;\n            })();\n    \n            return ctrl;\n        })();\n    \n        particle.firmware = (function() {\n    \n            var firmware = {};\n    \n            firmware.WifiConfig = (function() {\n    \n                function WifiConfig(p) {\n                    this.networks = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                WifiConfig.prototype.networks = $util.emptyArray;\n    \n                WifiConfig.create = function create(properties) {\n                    return new WifiConfig(properties);\n                };\n    \n                WifiConfig.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.networks != null && m.networks.length) {\n                        for (var i = 0; i < m.networks.length; ++i)\n                            $root.particle.firmware.WifiConfig.Network.encode(m.networks[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                WifiConfig.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.WifiConfig();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.networks && m.networks.length))\n                                m.networks = [];\n                            m.networks.push($root.particle.firmware.WifiConfig.Network.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                WifiConfig.Network = (function() {\n    \n                    function Network(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Network.prototype.ssid = \"\";\n                    Network.prototype.bssid = $util.newBuffer([]);\n                    Network.prototype.security = 0;\n                    Network.prototype.credentials = null;\n    \n                    Network.create = function create(properties) {\n                        return new Network(properties);\n                    };\n    \n                    Network.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.ssid != null && Object.hasOwnProperty.call(m, \"ssid\"))\n                            w.uint32(10).string(m.ssid);\n                        if (m.bssid != null && Object.hasOwnProperty.call(m, \"bssid\"))\n                            w.uint32(18).bytes(m.bssid);\n                        if (m.security != null && Object.hasOwnProperty.call(m, \"security\"))\n                            w.uint32(24).int32(m.security);\n                        if (m.credentials != null && Object.hasOwnProperty.call(m, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(m.credentials, w.uint32(34).fork()).ldelim();\n                        return w;\n                    };\n    \n                    Network.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.WifiConfig.Network();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.ssid = r.string();\n                                break;\n                            case 2:\n                                m.bssid = r.bytes();\n                                break;\n                            case 3:\n                                m.security = r.int32();\n                                break;\n                            case 4:\n                                m.credentials = $root.particle.ctrl.wifi.Credentials.decode(r, r.uint32());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Network;\n                })();\n    \n                return WifiConfig;\n            })();\n    \n            firmware.CellularConfig = (function() {\n    \n                function CellularConfig(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                CellularConfig.prototype.internalSim = null;\n                CellularConfig.prototype.externalSim = null;\n                CellularConfig.prototype.activeSim = 0;\n    \n                CellularConfig.create = function create(properties) {\n                    return new CellularConfig(properties);\n                };\n    \n                CellularConfig.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.internalSim != null && Object.hasOwnProperty.call(m, \"internalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(m.internalSim, w.uint32(10).fork()).ldelim();\n                    if (m.externalSim != null && Object.hasOwnProperty.call(m, \"externalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(m.externalSim, w.uint32(18).fork()).ldelim();\n                    if (m.activeSim != null && Object.hasOwnProperty.call(m, \"activeSim\"))\n                        w.uint32(24).int32(m.activeSim);\n                    return w;\n                };\n    \n                CellularConfig.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.particle.firmware.CellularConfig();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.internalSim = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                            break;\n                        case 2:\n                            m.externalSim = $root.particle.ctrl.cellular.AccessPoint.decode(r, r.uint32());\n                            break;\n                        case 3:\n                            m.activeSim = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return CellularConfig;\n            })();\n    \n            return firmware;\n        })();\n    \n        return particle;\n    })();\n    \n    $root.google = (function() {\n    \n        var google = {};\n    \n        google.protobuf = (function() {\n    \n            var protobuf = {};\n    \n            protobuf.FileDescriptorSet = (function() {\n    \n                function FileDescriptorSet(p) {\n                    this.file = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileDescriptorSet.prototype.file = $util.emptyArray;\n    \n                FileDescriptorSet.create = function create(properties) {\n                    return new FileDescriptorSet(properties);\n                };\n    \n                FileDescriptorSet.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.file != null && m.file.length) {\n                        for (var i = 0; i < m.file.length; ++i)\n                            $root.google.protobuf.FileDescriptorProto.encode(m.file[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                FileDescriptorSet.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileDescriptorSet();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.file && m.file.length))\n                                m.file = [];\n                            m.file.push($root.google.protobuf.FileDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FileDescriptorSet;\n            })();\n    \n            protobuf.FileDescriptorProto = (function() {\n    \n                function FileDescriptorProto(p) {\n                    this.dependency = [];\n                    this.publicDependency = [];\n                    this.weakDependency = [];\n                    this.messageType = [];\n                    this.enumType = [];\n                    this.service = [];\n                    this.extension = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileDescriptorProto.prototype.name = \"\";\n                FileDescriptorProto.prototype[\"package\"] = \"\";\n                FileDescriptorProto.prototype.dependency = $util.emptyArray;\n                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n                FileDescriptorProto.prototype.messageType = $util.emptyArray;\n                FileDescriptorProto.prototype.enumType = $util.emptyArray;\n                FileDescriptorProto.prototype.service = $util.emptyArray;\n                FileDescriptorProto.prototype.extension = $util.emptyArray;\n                FileDescriptorProto.prototype.options = null;\n                FileDescriptorProto.prototype.sourceCodeInfo = null;\n                FileDescriptorProto.prototype.syntax = \"\";\n    \n                FileDescriptorProto.create = function create(properties) {\n                    return new FileDescriptorProto(properties);\n                };\n    \n                FileDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m[\"package\"] != null && Object.hasOwnProperty.call(m, \"package\"))\n                        w.uint32(18).string(m[\"package\"]);\n                    if (m.dependency != null && m.dependency.length) {\n                        for (var i = 0; i < m.dependency.length; ++i)\n                            w.uint32(26).string(m.dependency[i]);\n                    }\n                    if (m.messageType != null && m.messageType.length) {\n                        for (var i = 0; i < m.messageType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(m.messageType[i], w.uint32(34).fork()).ldelim();\n                    }\n                    if (m.enumType != null && m.enumType.length) {\n                        for (var i = 0; i < m.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(m.enumType[i], w.uint32(42).fork()).ldelim();\n                    }\n                    if (m.service != null && m.service.length) {\n                        for (var i = 0; i < m.service.length; ++i)\n                            $root.google.protobuf.ServiceDescriptorProto.encode(m.service[i], w.uint32(50).fork()).ldelim();\n                    }\n                    if (m.extension != null && m.extension.length) {\n                        for (var i = 0; i < m.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.extension[i], w.uint32(58).fork()).ldelim();\n                    }\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.FileOptions.encode(m.options, w.uint32(66).fork()).ldelim();\n                    if (m.sourceCodeInfo != null && Object.hasOwnProperty.call(m, \"sourceCodeInfo\"))\n                        $root.google.protobuf.SourceCodeInfo.encode(m.sourceCodeInfo, w.uint32(74).fork()).ldelim();\n                    if (m.publicDependency != null && m.publicDependency.length) {\n                        for (var i = 0; i < m.publicDependency.length; ++i)\n                            w.uint32(80).int32(m.publicDependency[i]);\n                    }\n                    if (m.weakDependency != null && m.weakDependency.length) {\n                        for (var i = 0; i < m.weakDependency.length; ++i)\n                            w.uint32(88).int32(m.weakDependency[i]);\n                    }\n                    if (m.syntax != null && Object.hasOwnProperty.call(m, \"syntax\"))\n                        w.uint32(98).string(m.syntax);\n                    return w;\n                };\n    \n                FileDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m[\"package\"] = r.string();\n                            break;\n                        case 3:\n                            if (!(m.dependency && m.dependency.length))\n                                m.dependency = [];\n                            m.dependency.push(r.string());\n                            break;\n                        case 10:\n                            if (!(m.publicDependency && m.publicDependency.length))\n                                m.publicDependency = [];\n                            if ((t & 7) === 2) {\n                                var c2 = r.uint32() + r.pos;\n                                while (r.pos < c2)\n                                    m.publicDependency.push(r.int32());\n                            } else\n                                m.publicDependency.push(r.int32());\n                            break;\n                        case 11:\n                            if (!(m.weakDependency && m.weakDependency.length))\n                                m.weakDependency = [];\n                            if ((t & 7) === 2) {\n                                var c2 = r.uint32() + r.pos;\n                                while (r.pos < c2)\n                                    m.weakDependency.push(r.int32());\n                            } else\n                                m.weakDependency.push(r.int32());\n                            break;\n                        case 4:\n                            if (!(m.messageType && m.messageType.length))\n                                m.messageType = [];\n                            m.messageType.push($root.google.protobuf.DescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 5:\n                            if (!(m.enumType && m.enumType.length))\n                                m.enumType = [];\n                            m.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 6:\n                            if (!(m.service && m.service.length))\n                                m.service = [];\n                            m.service.push($root.google.protobuf.ServiceDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 7:\n                            if (!(m.extension && m.extension.length))\n                                m.extension = [];\n                            m.extension.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 8:\n                            m.options = $root.google.protobuf.FileOptions.decode(r, r.uint32());\n                            break;\n                        case 9:\n                            m.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(r, r.uint32());\n                            break;\n                        case 12:\n                            m.syntax = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return FileDescriptorProto;\n            })();\n    \n            protobuf.DescriptorProto = (function() {\n    \n                function DescriptorProto(p) {\n                    this.field = [];\n                    this.extension = [];\n                    this.nestedType = [];\n                    this.enumType = [];\n                    this.extensionRange = [];\n                    this.oneofDecl = [];\n                    this.reservedRange = [];\n                    this.reservedName = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                DescriptorProto.prototype.name = \"\";\n                DescriptorProto.prototype.field = $util.emptyArray;\n                DescriptorProto.prototype.extension = $util.emptyArray;\n                DescriptorProto.prototype.nestedType = $util.emptyArray;\n                DescriptorProto.prototype.enumType = $util.emptyArray;\n                DescriptorProto.prototype.extensionRange = $util.emptyArray;\n                DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n                DescriptorProto.prototype.options = null;\n                DescriptorProto.prototype.reservedRange = $util.emptyArray;\n                DescriptorProto.prototype.reservedName = $util.emptyArray;\n    \n                DescriptorProto.create = function create(properties) {\n                    return new DescriptorProto(properties);\n                };\n    \n                DescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.field != null && m.field.length) {\n                        for (var i = 0; i < m.field.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.field[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.nestedType != null && m.nestedType.length) {\n                        for (var i = 0; i < m.nestedType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(m.nestedType[i], w.uint32(26).fork()).ldelim();\n                    }\n                    if (m.enumType != null && m.enumType.length) {\n                        for (var i = 0; i < m.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(m.enumType[i], w.uint32(34).fork()).ldelim();\n                    }\n                    if (m.extensionRange != null && m.extensionRange.length) {\n                        for (var i = 0; i < m.extensionRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(m.extensionRange[i], w.uint32(42).fork()).ldelim();\n                    }\n                    if (m.extension != null && m.extension.length) {\n                        for (var i = 0; i < m.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(m.extension[i], w.uint32(50).fork()).ldelim();\n                    }\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.MessageOptions.encode(m.options, w.uint32(58).fork()).ldelim();\n                    if (m.oneofDecl != null && m.oneofDecl.length) {\n                        for (var i = 0; i < m.oneofDecl.length; ++i)\n                            $root.google.protobuf.OneofDescriptorProto.encode(m.oneofDecl[i], w.uint32(66).fork()).ldelim();\n                    }\n                    if (m.reservedRange != null && m.reservedRange.length) {\n                        for (var i = 0; i < m.reservedRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(m.reservedRange[i], w.uint32(74).fork()).ldelim();\n                    }\n                    if (m.reservedName != null && m.reservedName.length) {\n                        for (var i = 0; i < m.reservedName.length; ++i)\n                            w.uint32(82).string(m.reservedName[i]);\n                    }\n                    return w;\n                };\n    \n                DescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.field && m.field.length))\n                                m.field = [];\n                            m.field.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 6:\n                            if (!(m.extension && m.extension.length))\n                                m.extension = [];\n                            m.extension.push($root.google.protobuf.FieldDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            if (!(m.nestedType && m.nestedType.length))\n                                m.nestedType = [];\n                            m.nestedType.push($root.google.protobuf.DescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 4:\n                            if (!(m.enumType && m.enumType.length))\n                                m.enumType = [];\n                            m.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 5:\n                            if (!(m.extensionRange && m.extensionRange.length))\n                                m.extensionRange = [];\n                            m.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(r, r.uint32()));\n                            break;\n                        case 8:\n                            if (!(m.oneofDecl && m.oneofDecl.length))\n                                m.oneofDecl = [];\n                            m.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 7:\n                            m.options = $root.google.protobuf.MessageOptions.decode(r, r.uint32());\n                            break;\n                        case 9:\n                            if (!(m.reservedRange && m.reservedRange.length))\n                                m.reservedRange = [];\n                            m.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(r, r.uint32()));\n                            break;\n                        case 10:\n                            if (!(m.reservedName && m.reservedName.length))\n                                m.reservedName = [];\n                            m.reservedName.push(r.string());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                DescriptorProto.ExtensionRange = (function() {\n    \n                    function ExtensionRange(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ExtensionRange.prototype.start = 0;\n                    ExtensionRange.prototype.end = 0;\n    \n                    ExtensionRange.create = function create(properties) {\n                        return new ExtensionRange(properties);\n                    };\n    \n                    ExtensionRange.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.start != null && Object.hasOwnProperty.call(m, \"start\"))\n                            w.uint32(8).int32(m.start);\n                        if (m.end != null && Object.hasOwnProperty.call(m, \"end\"))\n                            w.uint32(16).int32(m.end);\n                        return w;\n                    };\n    \n                    ExtensionRange.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.start = r.int32();\n                                break;\n                            case 2:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ExtensionRange;\n                })();\n    \n                DescriptorProto.ReservedRange = (function() {\n    \n                    function ReservedRange(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    ReservedRange.prototype.start = 0;\n                    ReservedRange.prototype.end = 0;\n    \n                    ReservedRange.create = function create(properties) {\n                        return new ReservedRange(properties);\n                    };\n    \n                    ReservedRange.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.start != null && Object.hasOwnProperty.call(m, \"start\"))\n                            w.uint32(8).int32(m.start);\n                        if (m.end != null && Object.hasOwnProperty.call(m, \"end\"))\n                            w.uint32(16).int32(m.end);\n                        return w;\n                    };\n    \n                    ReservedRange.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.DescriptorProto.ReservedRange();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.start = r.int32();\n                                break;\n                            case 2:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return ReservedRange;\n                })();\n    \n                return DescriptorProto;\n            })();\n    \n            protobuf.FieldDescriptorProto = (function() {\n    \n                function FieldDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FieldDescriptorProto.prototype.name = \"\";\n                FieldDescriptorProto.prototype.number = 0;\n                FieldDescriptorProto.prototype.label = 1;\n                FieldDescriptorProto.prototype.type = 1;\n                FieldDescriptorProto.prototype.typeName = \"\";\n                FieldDescriptorProto.prototype.extendee = \"\";\n                FieldDescriptorProto.prototype.defaultValue = \"\";\n                FieldDescriptorProto.prototype.oneofIndex = 0;\n                FieldDescriptorProto.prototype.jsonName = \"\";\n                FieldDescriptorProto.prototype.options = null;\n    \n                FieldDescriptorProto.create = function create(properties) {\n                    return new FieldDescriptorProto(properties);\n                };\n    \n                FieldDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.extendee != null && Object.hasOwnProperty.call(m, \"extendee\"))\n                        w.uint32(18).string(m.extendee);\n                    if (m.number != null && Object.hasOwnProperty.call(m, \"number\"))\n                        w.uint32(24).int32(m.number);\n                    if (m.label != null && Object.hasOwnProperty.call(m, \"label\"))\n                        w.uint32(32).int32(m.label);\n                    if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                        w.uint32(40).int32(m.type);\n                    if (m.typeName != null && Object.hasOwnProperty.call(m, \"typeName\"))\n                        w.uint32(50).string(m.typeName);\n                    if (m.defaultValue != null && Object.hasOwnProperty.call(m, \"defaultValue\"))\n                        w.uint32(58).string(m.defaultValue);\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.FieldOptions.encode(m.options, w.uint32(66).fork()).ldelim();\n                    if (m.oneofIndex != null && Object.hasOwnProperty.call(m, \"oneofIndex\"))\n                        w.uint32(72).int32(m.oneofIndex);\n                    if (m.jsonName != null && Object.hasOwnProperty.call(m, \"jsonName\"))\n                        w.uint32(82).string(m.jsonName);\n                    return w;\n                };\n    \n                FieldDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FieldDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 3:\n                            m.number = r.int32();\n                            break;\n                        case 4:\n                            m.label = r.int32();\n                            break;\n                        case 5:\n                            m.type = r.int32();\n                            break;\n                        case 6:\n                            m.typeName = r.string();\n                            break;\n                        case 2:\n                            m.extendee = r.string();\n                            break;\n                        case 7:\n                            m.defaultValue = r.string();\n                            break;\n                        case 9:\n                            m.oneofIndex = r.int32();\n                            break;\n                        case 10:\n                            m.jsonName = r.string();\n                            break;\n                        case 8:\n                            m.options = $root.google.protobuf.FieldOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FieldDescriptorProto.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n                    values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n                    values[valuesById[3] = \"TYPE_INT64\"] = 3;\n                    values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n                    values[valuesById[5] = \"TYPE_INT32\"] = 5;\n                    values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n                    values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n                    values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n                    values[valuesById[9] = \"TYPE_STRING\"] = 9;\n                    values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n                    values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n                    values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n                    values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n                    values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n                    values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n                    values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n                    values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n                    values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n                    return values;\n                })();\n    \n                FieldDescriptorProto.Label = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n                    values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n                    values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n                    return values;\n                })();\n    \n                return FieldDescriptorProto;\n            })();\n    \n            protobuf.OneofDescriptorProto = (function() {\n    \n                function OneofDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                OneofDescriptorProto.prototype.name = \"\";\n                OneofDescriptorProto.prototype.options = null;\n    \n                OneofDescriptorProto.create = function create(properties) {\n                    return new OneofDescriptorProto(properties);\n                };\n    \n                OneofDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.OneofOptions.encode(m.options, w.uint32(18).fork()).ldelim();\n                    return w;\n                };\n    \n                OneofDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.OneofDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.options = $root.google.protobuf.OneofOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return OneofDescriptorProto;\n            })();\n    \n            protobuf.EnumDescriptorProto = (function() {\n    \n                function EnumDescriptorProto(p) {\n                    this.value = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumDescriptorProto.prototype.name = \"\";\n                EnumDescriptorProto.prototype.value = $util.emptyArray;\n                EnumDescriptorProto.prototype.options = null;\n    \n                EnumDescriptorProto.create = function create(properties) {\n                    return new EnumDescriptorProto(properties);\n                };\n    \n                EnumDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.value != null && m.value.length) {\n                        for (var i = 0; i < m.value.length; ++i)\n                            $root.google.protobuf.EnumValueDescriptorProto.encode(m.value[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.EnumOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.value && m.value.length))\n                                m.value = [];\n                            m.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.EnumOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumDescriptorProto;\n            })();\n    \n            protobuf.EnumValueDescriptorProto = (function() {\n    \n                function EnumValueDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumValueDescriptorProto.prototype.name = \"\";\n                EnumValueDescriptorProto.prototype.number = 0;\n                EnumValueDescriptorProto.prototype.options = null;\n    \n                EnumValueDescriptorProto.create = function create(properties) {\n                    return new EnumValueDescriptorProto(properties);\n                };\n    \n                EnumValueDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.number != null && Object.hasOwnProperty.call(m, \"number\"))\n                        w.uint32(16).int32(m.number);\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.EnumValueOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumValueDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumValueDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.number = r.int32();\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.EnumValueOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumValueDescriptorProto;\n            })();\n    \n            protobuf.ServiceDescriptorProto = (function() {\n    \n                function ServiceDescriptorProto(p) {\n                    this.method = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ServiceDescriptorProto.prototype.name = \"\";\n                ServiceDescriptorProto.prototype.method = $util.emptyArray;\n                ServiceDescriptorProto.prototype.options = null;\n    \n                ServiceDescriptorProto.create = function create(properties) {\n                    return new ServiceDescriptorProto(properties);\n                };\n    \n                ServiceDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.method != null && m.method.length) {\n                        for (var i = 0; i < m.method.length; ++i)\n                            $root.google.protobuf.MethodDescriptorProto.encode(m.method[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.ServiceOptions.encode(m.options, w.uint32(26).fork()).ldelim();\n                    return w;\n                };\n    \n                ServiceDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.ServiceDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            if (!(m.method && m.method.length))\n                                m.method = [];\n                            m.method.push($root.google.protobuf.MethodDescriptorProto.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.options = $root.google.protobuf.ServiceOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ServiceDescriptorProto;\n            })();\n    \n            protobuf.MethodDescriptorProto = (function() {\n    \n                function MethodDescriptorProto(p) {\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MethodDescriptorProto.prototype.name = \"\";\n                MethodDescriptorProto.prototype.inputType = \"\";\n                MethodDescriptorProto.prototype.outputType = \"\";\n                MethodDescriptorProto.prototype.options = null;\n                MethodDescriptorProto.prototype.clientStreaming = false;\n                MethodDescriptorProto.prototype.serverStreaming = false;\n    \n                MethodDescriptorProto.create = function create(properties) {\n                    return new MethodDescriptorProto(properties);\n                };\n    \n                MethodDescriptorProto.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && Object.hasOwnProperty.call(m, \"name\"))\n                        w.uint32(10).string(m.name);\n                    if (m.inputType != null && Object.hasOwnProperty.call(m, \"inputType\"))\n                        w.uint32(18).string(m.inputType);\n                    if (m.outputType != null && Object.hasOwnProperty.call(m, \"outputType\"))\n                        w.uint32(26).string(m.outputType);\n                    if (m.options != null && Object.hasOwnProperty.call(m, \"options\"))\n                        $root.google.protobuf.MethodOptions.encode(m.options, w.uint32(34).fork()).ldelim();\n                    if (m.clientStreaming != null && Object.hasOwnProperty.call(m, \"clientStreaming\"))\n                        w.uint32(40).bool(m.clientStreaming);\n                    if (m.serverStreaming != null && Object.hasOwnProperty.call(m, \"serverStreaming\"))\n                        w.uint32(48).bool(m.serverStreaming);\n                    return w;\n                };\n    \n                MethodDescriptorProto.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MethodDescriptorProto();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.name = r.string();\n                            break;\n                        case 2:\n                            m.inputType = r.string();\n                            break;\n                        case 3:\n                            m.outputType = r.string();\n                            break;\n                        case 4:\n                            m.options = $root.google.protobuf.MethodOptions.decode(r, r.uint32());\n                            break;\n                        case 5:\n                            m.clientStreaming = r.bool();\n                            break;\n                        case 6:\n                            m.serverStreaming = r.bool();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MethodDescriptorProto;\n            })();\n    \n            protobuf.FileOptions = (function() {\n    \n                function FileOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FileOptions.prototype.javaPackage = \"\";\n                FileOptions.prototype.javaOuterClassname = \"\";\n                FileOptions.prototype.javaMultipleFiles = false;\n                FileOptions.prototype.javaGenerateEqualsAndHash = false;\n                FileOptions.prototype.javaStringCheckUtf8 = false;\n                FileOptions.prototype.optimizeFor = 1;\n                FileOptions.prototype.goPackage = \"\";\n                FileOptions.prototype.ccGenericServices = false;\n                FileOptions.prototype.javaGenericServices = false;\n                FileOptions.prototype.pyGenericServices = false;\n                FileOptions.prototype.deprecated = false;\n                FileOptions.prototype.ccEnableArenas = false;\n                FileOptions.prototype.objcClassPrefix = \"\";\n                FileOptions.prototype.csharpNamespace = \"\";\n                FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n                FileOptions.prototype[\".nanopbFileopt\"] = null;\n    \n                FileOptions.create = function create(properties) {\n                    return new FileOptions(properties);\n                };\n    \n                FileOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.javaPackage != null && Object.hasOwnProperty.call(m, \"javaPackage\"))\n                        w.uint32(10).string(m.javaPackage);\n                    if (m.javaOuterClassname != null && Object.hasOwnProperty.call(m, \"javaOuterClassname\"))\n                        w.uint32(66).string(m.javaOuterClassname);\n                    if (m.optimizeFor != null && Object.hasOwnProperty.call(m, \"optimizeFor\"))\n                        w.uint32(72).int32(m.optimizeFor);\n                    if (m.javaMultipleFiles != null && Object.hasOwnProperty.call(m, \"javaMultipleFiles\"))\n                        w.uint32(80).bool(m.javaMultipleFiles);\n                    if (m.goPackage != null && Object.hasOwnProperty.call(m, \"goPackage\"))\n                        w.uint32(90).string(m.goPackage);\n                    if (m.ccGenericServices != null && Object.hasOwnProperty.call(m, \"ccGenericServices\"))\n                        w.uint32(128).bool(m.ccGenericServices);\n                    if (m.javaGenericServices != null && Object.hasOwnProperty.call(m, \"javaGenericServices\"))\n                        w.uint32(136).bool(m.javaGenericServices);\n                    if (m.pyGenericServices != null && Object.hasOwnProperty.call(m, \"pyGenericServices\"))\n                        w.uint32(144).bool(m.pyGenericServices);\n                    if (m.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(m, \"javaGenerateEqualsAndHash\"))\n                        w.uint32(160).bool(m.javaGenerateEqualsAndHash);\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(184).bool(m.deprecated);\n                    if (m.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(m, \"javaStringCheckUtf8\"))\n                        w.uint32(216).bool(m.javaStringCheckUtf8);\n                    if (m.ccEnableArenas != null && Object.hasOwnProperty.call(m, \"ccEnableArenas\"))\n                        w.uint32(248).bool(m.ccEnableArenas);\n                    if (m.objcClassPrefix != null && Object.hasOwnProperty.call(m, \"objcClassPrefix\"))\n                        w.uint32(290).string(m.objcClassPrefix);\n                    if (m.csharpNamespace != null && Object.hasOwnProperty.call(m, \"csharpNamespace\"))\n                        w.uint32(298).string(m.csharpNamespace);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbFileopt\"] != null && Object.hasOwnProperty.call(m, \".nanopbFileopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbFileopt\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                FileOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FileOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.javaPackage = r.string();\n                            break;\n                        case 8:\n                            m.javaOuterClassname = r.string();\n                            break;\n                        case 10:\n                            m.javaMultipleFiles = r.bool();\n                            break;\n                        case 20:\n                            m.javaGenerateEqualsAndHash = r.bool();\n                            break;\n                        case 27:\n                            m.javaStringCheckUtf8 = r.bool();\n                            break;\n                        case 9:\n                            m.optimizeFor = r.int32();\n                            break;\n                        case 11:\n                            m.goPackage = r.string();\n                            break;\n                        case 16:\n                            m.ccGenericServices = r.bool();\n                            break;\n                        case 17:\n                            m.javaGenericServices = r.bool();\n                            break;\n                        case 18:\n                            m.pyGenericServices = r.bool();\n                            break;\n                        case 23:\n                            m.deprecated = r.bool();\n                            break;\n                        case 31:\n                            m.ccEnableArenas = r.bool();\n                            break;\n                        case 36:\n                            m.objcClassPrefix = r.string();\n                            break;\n                        case 37:\n                            m.csharpNamespace = r.string();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopbFileopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FileOptions.OptimizeMode = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"SPEED\"] = 1;\n                    values[valuesById[2] = \"CODE_SIZE\"] = 2;\n                    values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n                    return values;\n                })();\n    \n                return FileOptions;\n            })();\n    \n            protobuf.MessageOptions = (function() {\n    \n                function MessageOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MessageOptions.prototype.messageSetWireFormat = false;\n                MessageOptions.prototype.noStandardDescriptorAccessor = false;\n                MessageOptions.prototype.deprecated = false;\n                MessageOptions.prototype.mapEntry = false;\n                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n                MessageOptions.prototype[\".typeId\"] = 0;\n                MessageOptions.prototype[\".nanopbMsgopt\"] = null;\n    \n                MessageOptions.create = function create(properties) {\n                    return new MessageOptions(properties);\n                };\n    \n                MessageOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.messageSetWireFormat != null && Object.hasOwnProperty.call(m, \"messageSetWireFormat\"))\n                        w.uint32(8).bool(m.messageSetWireFormat);\n                    if (m.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(m, \"noStandardDescriptorAccessor\"))\n                        w.uint32(16).bool(m.noStandardDescriptorAccessor);\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.mapEntry != null && Object.hasOwnProperty.call(m, \"mapEntry\"))\n                        w.uint32(56).bool(m.mapEntry);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbMsgopt\"] != null && Object.hasOwnProperty.call(m, \".nanopbMsgopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbMsgopt\"], w.uint32(8082).fork()).ldelim();\n                    if (m[\".typeId\"] != null && Object.hasOwnProperty.call(m, \".typeId\"))\n                        w.uint32(400008).int32(m[\".typeId\"]);\n                    return w;\n                };\n    \n                MessageOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MessageOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.messageSetWireFormat = r.bool();\n                            break;\n                        case 2:\n                            m.noStandardDescriptorAccessor = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 7:\n                            m.mapEntry = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 50001:\n                            m[\".typeId\"] = r.int32();\n                            break;\n                        case 1010:\n                            m[\".nanopbMsgopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MessageOptions;\n            })();\n    \n            protobuf.FieldOptions = (function() {\n    \n                function FieldOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                FieldOptions.prototype.ctype = 0;\n                FieldOptions.prototype.packed = false;\n                FieldOptions.prototype.jstype = 0;\n                FieldOptions.prototype.lazy = false;\n                FieldOptions.prototype.deprecated = false;\n                FieldOptions.prototype.weak = false;\n                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n                FieldOptions.prototype[\".nanopb\"] = null;\n    \n                FieldOptions.create = function create(properties) {\n                    return new FieldOptions(properties);\n                };\n    \n                FieldOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.ctype != null && Object.hasOwnProperty.call(m, \"ctype\"))\n                        w.uint32(8).int32(m.ctype);\n                    if (m.packed != null && Object.hasOwnProperty.call(m, \"packed\"))\n                        w.uint32(16).bool(m.packed);\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.lazy != null && Object.hasOwnProperty.call(m, \"lazy\"))\n                        w.uint32(40).bool(m.lazy);\n                    if (m.jstype != null && Object.hasOwnProperty.call(m, \"jstype\"))\n                        w.uint32(48).int32(m.jstype);\n                    if (m.weak != null && Object.hasOwnProperty.call(m, \"weak\"))\n                        w.uint32(80).bool(m.weak);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopb\"] != null && Object.hasOwnProperty.call(m, \".nanopb\"))\n                        $root.NanoPBOptions.encode(m[\".nanopb\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                FieldOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.FieldOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.ctype = r.int32();\n                            break;\n                        case 2:\n                            m.packed = r.bool();\n                            break;\n                        case 6:\n                            m.jstype = r.int32();\n                            break;\n                        case 5:\n                            m.lazy = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 10:\n                            m.weak = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopb\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                FieldOptions.CType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"STRING\"] = 0;\n                    values[valuesById[1] = \"CORD\"] = 1;\n                    values[valuesById[2] = \"STRING_PIECE\"] = 2;\n                    return values;\n                })();\n    \n                FieldOptions.JSType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"JS_NORMAL\"] = 0;\n                    values[valuesById[1] = \"JS_STRING\"] = 1;\n                    values[valuesById[2] = \"JS_NUMBER\"] = 2;\n                    return values;\n                })();\n    \n                return FieldOptions;\n            })();\n    \n            protobuf.OneofOptions = (function() {\n    \n                function OneofOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                OneofOptions.create = function create(properties) {\n                    return new OneofOptions(properties);\n                };\n    \n                OneofOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                OneofOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.OneofOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return OneofOptions;\n            })();\n    \n            protobuf.EnumOptions = (function() {\n    \n                function EnumOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumOptions.prototype.allowAlias = false;\n                EnumOptions.prototype.deprecated = false;\n                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n                EnumOptions.prototype[\".nanopbEnumopt\"] = null;\n    \n                EnumOptions.create = function create(properties) {\n                    return new EnumOptions(properties);\n                };\n    \n                EnumOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.allowAlias != null && Object.hasOwnProperty.call(m, \"allowAlias\"))\n                        w.uint32(16).bool(m.allowAlias);\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(24).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".nanopbEnumopt\"] != null && Object.hasOwnProperty.call(m, \".nanopbEnumopt\"))\n                        $root.NanoPBOptions.encode(m[\".nanopbEnumopt\"], w.uint32(8082).fork()).ldelim();\n                    return w;\n                };\n    \n                EnumOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 2:\n                            m.allowAlias = r.bool();\n                            break;\n                        case 3:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 1010:\n                            m[\".nanopbEnumopt\"] = $root.NanoPBOptions.decode(r, r.uint32());\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumOptions;\n            })();\n    \n            protobuf.EnumValueOptions = (function() {\n    \n                function EnumValueOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                EnumValueOptions.prototype.deprecated = false;\n                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n                EnumValueOptions.prototype[\".intValue\"] = 0;\n    \n                EnumValueOptions.create = function create(properties) {\n                    return new EnumValueOptions(properties);\n                };\n    \n                EnumValueOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(8).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    if (m[\".intValue\"] != null && Object.hasOwnProperty.call(m, \".intValue\"))\n                        w.uint32(400016).int32(m[\".intValue\"]);\n                    return w;\n                };\n    \n                EnumValueOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.EnumValueOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        case 50002:\n                            m[\".intValue\"] = r.int32();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return EnumValueOptions;\n            })();\n    \n            protobuf.ServiceOptions = (function() {\n    \n                function ServiceOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                ServiceOptions.prototype.deprecated = false;\n                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                ServiceOptions.create = function create(properties) {\n                    return new ServiceOptions(properties);\n                };\n    \n                ServiceOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(264).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                ServiceOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.ServiceOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 33:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return ServiceOptions;\n            })();\n    \n            protobuf.MethodOptions = (function() {\n    \n                function MethodOptions(p) {\n                    this.uninterpretedOption = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                MethodOptions.prototype.deprecated = false;\n                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                MethodOptions.create = function create(properties) {\n                    return new MethodOptions(properties);\n                };\n    \n                MethodOptions.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.deprecated != null && Object.hasOwnProperty.call(m, \"deprecated\"))\n                        w.uint32(264).bool(m.deprecated);\n                    if (m.uninterpretedOption != null && m.uninterpretedOption.length) {\n                        for (var i = 0; i < m.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(m.uninterpretedOption[i], w.uint32(7994).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                MethodOptions.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.MethodOptions();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 33:\n                            m.deprecated = r.bool();\n                            break;\n                        case 999:\n                            if (!(m.uninterpretedOption && m.uninterpretedOption.length))\n                                m.uninterpretedOption = [];\n                            m.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                return MethodOptions;\n            })();\n    \n            protobuf.UninterpretedOption = (function() {\n    \n                function UninterpretedOption(p) {\n                    this.name = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                UninterpretedOption.prototype.name = $util.emptyArray;\n                UninterpretedOption.prototype.identifierValue = \"\";\n                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n                UninterpretedOption.prototype.doubleValue = 0;\n                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n                UninterpretedOption.prototype.aggregateValue = \"\";\n    \n                UninterpretedOption.create = function create(properties) {\n                    return new UninterpretedOption(properties);\n                };\n    \n                UninterpretedOption.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.name != null && m.name.length) {\n                        for (var i = 0; i < m.name.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.NamePart.encode(m.name[i], w.uint32(18).fork()).ldelim();\n                    }\n                    if (m.identifierValue != null && Object.hasOwnProperty.call(m, \"identifierValue\"))\n                        w.uint32(26).string(m.identifierValue);\n                    if (m.positiveIntValue != null && Object.hasOwnProperty.call(m, \"positiveIntValue\"))\n                        w.uint32(32).uint64(m.positiveIntValue);\n                    if (m.negativeIntValue != null && Object.hasOwnProperty.call(m, \"negativeIntValue\"))\n                        w.uint32(40).int64(m.negativeIntValue);\n                    if (m.doubleValue != null && Object.hasOwnProperty.call(m, \"doubleValue\"))\n                        w.uint32(49).double(m.doubleValue);\n                    if (m.stringValue != null && Object.hasOwnProperty.call(m, \"stringValue\"))\n                        w.uint32(58).bytes(m.stringValue);\n                    if (m.aggregateValue != null && Object.hasOwnProperty.call(m, \"aggregateValue\"))\n                        w.uint32(66).string(m.aggregateValue);\n                    return w;\n                };\n    \n                UninterpretedOption.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UninterpretedOption();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 2:\n                            if (!(m.name && m.name.length))\n                                m.name = [];\n                            m.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(r, r.uint32()));\n                            break;\n                        case 3:\n                            m.identifierValue = r.string();\n                            break;\n                        case 4:\n                            m.positiveIntValue = r.uint64();\n                            break;\n                        case 5:\n                            m.negativeIntValue = r.int64();\n                            break;\n                        case 6:\n                            m.doubleValue = r.double();\n                            break;\n                        case 7:\n                            m.stringValue = r.bytes();\n                            break;\n                        case 8:\n                            m.aggregateValue = r.string();\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                UninterpretedOption.NamePart = (function() {\n    \n                    function NamePart(p) {\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    NamePart.prototype.namePart = \"\";\n                    NamePart.prototype.isExtension = false;\n    \n                    NamePart.create = function create(properties) {\n                        return new NamePart(properties);\n                    };\n    \n                    NamePart.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        w.uint32(10).string(m.namePart);\n                        w.uint32(16).bool(m.isExtension);\n                        return w;\n                    };\n    \n                    NamePart.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.UninterpretedOption.NamePart();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                m.namePart = r.string();\n                                break;\n                            case 2:\n                                m.isExtension = r.bool();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        if (!m.hasOwnProperty(\"namePart\"))\n                            throw $util.ProtocolError(\"missing required 'namePart'\", { instance: m });\n                        if (!m.hasOwnProperty(\"isExtension\"))\n                            throw $util.ProtocolError(\"missing required 'isExtension'\", { instance: m });\n                        return m;\n                    };\n    \n                    return NamePart;\n                })();\n    \n                return UninterpretedOption;\n            })();\n    \n            protobuf.SourceCodeInfo = (function() {\n    \n                function SourceCodeInfo(p) {\n                    this.location = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                SourceCodeInfo.prototype.location = $util.emptyArray;\n    \n                SourceCodeInfo.create = function create(properties) {\n                    return new SourceCodeInfo(properties);\n                };\n    \n                SourceCodeInfo.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.location != null && m.location.length) {\n                        for (var i = 0; i < m.location.length; ++i)\n                            $root.google.protobuf.SourceCodeInfo.Location.encode(m.location[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                SourceCodeInfo.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.SourceCodeInfo();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.location && m.location.length))\n                                m.location = [];\n                            m.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                SourceCodeInfo.Location = (function() {\n    \n                    function Location(p) {\n                        this.path = [];\n                        this.span = [];\n                        this.leadingDetachedComments = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Location.prototype.path = $util.emptyArray;\n                    Location.prototype.span = $util.emptyArray;\n                    Location.prototype.leadingComments = \"\";\n                    Location.prototype.trailingComments = \"\";\n                    Location.prototype.leadingDetachedComments = $util.emptyArray;\n    \n                    Location.create = function create(properties) {\n                        return new Location(properties);\n                    };\n    \n                    Location.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.path != null && m.path.length) {\n                            w.uint32(10).fork();\n                            for (var i = 0; i < m.path.length; ++i)\n                                w.int32(m.path[i]);\n                            w.ldelim();\n                        }\n                        if (m.span != null && m.span.length) {\n                            w.uint32(18).fork();\n                            for (var i = 0; i < m.span.length; ++i)\n                                w.int32(m.span[i]);\n                            w.ldelim();\n                        }\n                        if (m.leadingComments != null && Object.hasOwnProperty.call(m, \"leadingComments\"))\n                            w.uint32(26).string(m.leadingComments);\n                        if (m.trailingComments != null && Object.hasOwnProperty.call(m, \"trailingComments\"))\n                            w.uint32(34).string(m.trailingComments);\n                        if (m.leadingDetachedComments != null && m.leadingDetachedComments.length) {\n                            for (var i = 0; i < m.leadingDetachedComments.length; ++i)\n                                w.uint32(50).string(m.leadingDetachedComments[i]);\n                        }\n                        return w;\n                    };\n    \n                    Location.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.SourceCodeInfo.Location();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.path && m.path.length))\n                                    m.path = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.path.push(r.int32());\n                                } else\n                                    m.path.push(r.int32());\n                                break;\n                            case 2:\n                                if (!(m.span && m.span.length))\n                                    m.span = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.span.push(r.int32());\n                                } else\n                                    m.span.push(r.int32());\n                                break;\n                            case 3:\n                                m.leadingComments = r.string();\n                                break;\n                            case 4:\n                                m.trailingComments = r.string();\n                                break;\n                            case 6:\n                                if (!(m.leadingDetachedComments && m.leadingDetachedComments.length))\n                                    m.leadingDetachedComments = [];\n                                m.leadingDetachedComments.push(r.string());\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Location;\n                })();\n    \n                return SourceCodeInfo;\n            })();\n    \n            protobuf.GeneratedCodeInfo = (function() {\n    \n                function GeneratedCodeInfo(p) {\n                    this.annotation = [];\n                    if (p)\n                        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                            if (p[ks[i]] != null)\n                                this[ks[i]] = p[ks[i]];\n                }\n    \n                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n    \n                GeneratedCodeInfo.create = function create(properties) {\n                    return new GeneratedCodeInfo(properties);\n                };\n    \n                GeneratedCodeInfo.encode = function encode(m, w) {\n                    if (!w)\n                        w = $Writer.create();\n                    if (m.annotation != null && m.annotation.length) {\n                        for (var i = 0; i < m.annotation.length; ++i)\n                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(m.annotation[i], w.uint32(10).fork()).ldelim();\n                    }\n                    return w;\n                };\n    \n                GeneratedCodeInfo.decode = function decode(r, l) {\n                    if (!(r instanceof $Reader))\n                        r = $Reader.create(r);\n                    var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.GeneratedCodeInfo();\n                    while (r.pos < c) {\n                        var t = r.uint32();\n                        switch (t >>> 3) {\n                        case 1:\n                            if (!(m.annotation && m.annotation.length))\n                                m.annotation = [];\n                            m.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(r, r.uint32()));\n                            break;\n                        default:\n                            r.skipType(t & 7);\n                            break;\n                        }\n                    }\n                    return m;\n                };\n    \n                GeneratedCodeInfo.Annotation = (function() {\n    \n                    function Annotation(p) {\n                        this.path = [];\n                        if (p)\n                            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                                if (p[ks[i]] != null)\n                                    this[ks[i]] = p[ks[i]];\n                    }\n    \n                    Annotation.prototype.path = $util.emptyArray;\n                    Annotation.prototype.sourceFile = \"\";\n                    Annotation.prototype.begin = 0;\n                    Annotation.prototype.end = 0;\n    \n                    Annotation.create = function create(properties) {\n                        return new Annotation(properties);\n                    };\n    \n                    Annotation.encode = function encode(m, w) {\n                        if (!w)\n                            w = $Writer.create();\n                        if (m.path != null && m.path.length) {\n                            w.uint32(10).fork();\n                            for (var i = 0; i < m.path.length; ++i)\n                                w.int32(m.path[i]);\n                            w.ldelim();\n                        }\n                        if (m.sourceFile != null && Object.hasOwnProperty.call(m, \"sourceFile\"))\n                            w.uint32(18).string(m.sourceFile);\n                        if (m.begin != null && Object.hasOwnProperty.call(m, \"begin\"))\n                            w.uint32(24).int32(m.begin);\n                        if (m.end != null && Object.hasOwnProperty.call(m, \"end\"))\n                            w.uint32(32).int32(m.end);\n                        return w;\n                    };\n    \n                    Annotation.decode = function decode(r, l) {\n                        if (!(r instanceof $Reader))\n                            r = $Reader.create(r);\n                        var c = l === undefined ? r.len : r.pos + l, m = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n                        while (r.pos < c) {\n                            var t = r.uint32();\n                            switch (t >>> 3) {\n                            case 1:\n                                if (!(m.path && m.path.length))\n                                    m.path = [];\n                                if ((t & 7) === 2) {\n                                    var c2 = r.uint32() + r.pos;\n                                    while (r.pos < c2)\n                                        m.path.push(r.int32());\n                                } else\n                                    m.path.push(r.int32());\n                                break;\n                            case 2:\n                                m.sourceFile = r.string();\n                                break;\n                            case 3:\n                                m.begin = r.int32();\n                                break;\n                            case 4:\n                                m.end = r.int32();\n                                break;\n                            default:\n                                r.skipType(t & 7);\n                                break;\n                            }\n                        }\n                        return m;\n                    };\n    \n                    return Annotation;\n                })();\n    \n                return GeneratedCodeInfo;\n            })();\n    \n            return protobuf;\n        })();\n    \n        return google;\n    })();\n    \n    $root.FieldType = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"FT_DEFAULT\"] = 0;\n        values[valuesById[1] = \"FT_CALLBACK\"] = 1;\n        values[valuesById[4] = \"FT_POINTER\"] = 4;\n        values[valuesById[2] = \"FT_STATIC\"] = 2;\n        values[valuesById[3] = \"FT_IGNORE\"] = 3;\n        values[valuesById[5] = \"FT_INLINE\"] = 5;\n        return values;\n    })();\n    \n    $root.IntSize = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"IS_DEFAULT\"] = 0;\n        values[valuesById[8] = \"IS_8\"] = 8;\n        values[valuesById[16] = \"IS_16\"] = 16;\n        values[valuesById[32] = \"IS_32\"] = 32;\n        values[valuesById[64] = \"IS_64\"] = 64;\n        return values;\n    })();\n    \n    $root.NanoPBOptions = (function() {\n    \n        function NanoPBOptions(p) {\n            if (p)\n                for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                    if (p[ks[i]] != null)\n                        this[ks[i]] = p[ks[i]];\n        }\n    \n        NanoPBOptions.prototype.maxSize = 0;\n        NanoPBOptions.prototype.maxLength = 0;\n        NanoPBOptions.prototype.maxCount = 0;\n        NanoPBOptions.prototype.intSize = 0;\n        NanoPBOptions.prototype.type = 0;\n        NanoPBOptions.prototype.longNames = true;\n        NanoPBOptions.prototype.packedStruct = false;\n        NanoPBOptions.prototype.packedEnum = false;\n        NanoPBOptions.prototype.skipMessage = false;\n        NanoPBOptions.prototype.noUnions = false;\n        NanoPBOptions.prototype.msgid = 0;\n        NanoPBOptions.prototype.anonymousOneof = false;\n        NanoPBOptions.prototype.proto3 = false;\n        NanoPBOptions.prototype.enumToString = false;\n        NanoPBOptions.prototype.fixedLength = false;\n        NanoPBOptions.prototype.fixedCount = false;\n    \n        NanoPBOptions.create = function create(properties) {\n            return new NanoPBOptions(properties);\n        };\n    \n        NanoPBOptions.encode = function encode(m, w) {\n            if (!w)\n                w = $Writer.create();\n            if (m.maxSize != null && Object.hasOwnProperty.call(m, \"maxSize\"))\n                w.uint32(8).int32(m.maxSize);\n            if (m.maxCount != null && Object.hasOwnProperty.call(m, \"maxCount\"))\n                w.uint32(16).int32(m.maxCount);\n            if (m.type != null && Object.hasOwnProperty.call(m, \"type\"))\n                w.uint32(24).int32(m.type);\n            if (m.longNames != null && Object.hasOwnProperty.call(m, \"longNames\"))\n                w.uint32(32).bool(m.longNames);\n            if (m.packedStruct != null && Object.hasOwnProperty.call(m, \"packedStruct\"))\n                w.uint32(40).bool(m.packedStruct);\n            if (m.skipMessage != null && Object.hasOwnProperty.call(m, \"skipMessage\"))\n                w.uint32(48).bool(m.skipMessage);\n            if (m.intSize != null && Object.hasOwnProperty.call(m, \"intSize\"))\n                w.uint32(56).int32(m.intSize);\n            if (m.noUnions != null && Object.hasOwnProperty.call(m, \"noUnions\"))\n                w.uint32(64).bool(m.noUnions);\n            if (m.msgid != null && Object.hasOwnProperty.call(m, \"msgid\"))\n                w.uint32(72).uint32(m.msgid);\n            if (m.packedEnum != null && Object.hasOwnProperty.call(m, \"packedEnum\"))\n                w.uint32(80).bool(m.packedEnum);\n            if (m.anonymousOneof != null && Object.hasOwnProperty.call(m, \"anonymousOneof\"))\n                w.uint32(88).bool(m.anonymousOneof);\n            if (m.proto3 != null && Object.hasOwnProperty.call(m, \"proto3\"))\n                w.uint32(96).bool(m.proto3);\n            if (m.enumToString != null && Object.hasOwnProperty.call(m, \"enumToString\"))\n                w.uint32(104).bool(m.enumToString);\n            if (m.maxLength != null && Object.hasOwnProperty.call(m, \"maxLength\"))\n                w.uint32(112).int32(m.maxLength);\n            if (m.fixedLength != null && Object.hasOwnProperty.call(m, \"fixedLength\"))\n                w.uint32(120).bool(m.fixedLength);\n            if (m.fixedCount != null && Object.hasOwnProperty.call(m, \"fixedCount\"))\n                w.uint32(128).bool(m.fixedCount);\n            return w;\n        };\n    \n        NanoPBOptions.decode = function decode(r, l) {\n            if (!(r instanceof $Reader))\n                r = $Reader.create(r);\n            var c = l === undefined ? r.len : r.pos + l, m = new $root.NanoPBOptions();\n            while (r.pos < c) {\n                var t = r.uint32();\n                switch (t >>> 3) {\n                case 1:\n                    m.maxSize = r.int32();\n                    break;\n                case 14:\n                    m.maxLength = r.int32();\n                    break;\n                case 2:\n                    m.maxCount = r.int32();\n                    break;\n                case 7:\n                    m.intSize = r.int32();\n                    break;\n                case 3:\n                    m.type = r.int32();\n                    break;\n                case 4:\n                    m.longNames = r.bool();\n                    break;\n                case 5:\n                    m.packedStruct = r.bool();\n                    break;\n                case 10:\n                    m.packedEnum = r.bool();\n                    break;\n                case 6:\n                    m.skipMessage = r.bool();\n                    break;\n                case 8:\n                    m.noUnions = r.bool();\n                    break;\n                case 9:\n                    m.msgid = r.uint32();\n                    break;\n                case 11:\n                    m.anonymousOneof = r.bool();\n                    break;\n                case 12:\n                    m.proto3 = r.bool();\n                    break;\n                case 13:\n                    m.enumToString = r.bool();\n                    break;\n                case 15:\n                    m.fixedLength = r.bool();\n                    break;\n                case 16:\n                    m.fixedCount = r.bool();\n                    break;\n                default:\n                    r.skipType(t & 7);\n                    break;\n                }\n            }\n            return m;\n        };\n    \n        return NanoPBOptions;\n    })();\n\n    return $root;\n});\n\n\n//# sourceURL=webpack://ParticleUsb/./lib/pb-message.js?");

/***/ }),

/***/ "./node_modules/@particle/device-os-protobuf/src/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/index.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const pbjsGeneratedProtobufCode = __webpack_require__(/*! ./pbjs-generated/definitions */ \"./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js\");\n\nclass DeviceOSProtobuf {\n\t/**\n\t * Create a valid Buffer of bytes that can be sent to DeviceOS, typically used with \"Request\" messages.\n\t *\n\t * @example <caption>Encoding a request to get serial number</caption>\n\t * // returns a zero length Buffer because there is no properties for this message, just the option type_id\n\t * const buffer = DeviceOSProtobuf.encode('GetSerialNumberRequest');\n\t *\n\t * @param {string|ProtobufMessage} protobufMessageNameOrMessage - Protobuf message name or actual message object. See getDefinitions() to valid options.\n\t * @param {Object} protobufMessageData - An object containing key data/code to encode & decode protobufjs messages from Device OS\n\t * @returns {Buffer} - A Buffer of bytes representing a valid protobuf message that Device OS can interpret\n\t */\n\tstatic encode(protobufMessageNameOrMessage, protobufMessageData = null) {\n\t\tconst message = this._resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage);\n\t\tconst msg = message.create(protobufMessageData);\n\t\tconst buffer = message.encode(msg).finish();\n\t\treturn buffer;\n\t}\n\n\tstatic _resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage) {\n\t\tlet message;\n\t\tif (typeof protobufMessageNameOrMessage === 'string') {\n\t\t\tconst protobufDefinition = this.getDefinition(protobufMessageNameOrMessage);\n\t\t\tmessage = protobufDefinition.message;\n\t\t} else {\n\t\t\tmessage = protobufMessageNameOrMessage;\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Create a JavaScript object by decoding a Buffer representing a protobuf message from DeviceOS; typically used with \"Reply\" messages\"\n\t *\n\t * @example <caption>Decode a GetSerialNumberReply</caption>\n\t * // returns a Javascript object with .serial property\n\t * const object = DeviceOSProtobuf.decode('GetSerialNumberReply', buffer);\n\t * // shows the serial number as a string\n\t * console.log(object.serial);\n\t * @param {string|ProtobufMessage} protobufMessageNameOrMessage - Protobuf message name or actual message object. See getDefinitions() to valid options.\n\t * @param {Buffer} buffer - Buffer from DeviceOS representing valid non-decoded Protobuf message\n\t * @returns {Object} - A JavaScript object with properties for each data item declared in the *.proto file\n\t */\n\tstatic decode(protobufMessageNameOrMessage, buffer) {\n\t\tconst message = this._resolveProtobufMessageNameOrMessageToMessage(protobufMessageNameOrMessage);\n\t\treturn message.decode(buffer);\n\t}\n\n\t/**\n\t * @param {string} protobufMessageName - Protobuf definition from *.proto files like \"GetSerialNumberRequest\". To access definitions in a namespace, prefix with \"<namespace>.\"\n\t * @returns {ProtobufDefinition} protobufDefinition An object containing code to encode & decode protobufjs messages from Device OS\n\t */\n\tstatic getDefinition(protobufMessageName) {\n\t\tconst message = this._getProtobufMessage(protobufMessageName);\n\n\t\tlet id, replyMessage;\n\t\tif (protobufMessageName.match(/Request$/)) {\n\t\t\tid = this._getIDFromJSON(protobufMessageName);\n\t\t\treplyMessage = this._getProtobufReplyMessage(protobufMessageName);\n\t\t} else {\n\t\t\tid = null;\n\t\t\treplyMessage = null;\n\t\t}\n\n\t\treturn {\n\t\t\tmessage,\n\t\t\tid,\n\t\t\treplyMessage\n\t\t};\n\t}\n\n\t/**\n\t * @typedef {Object} ProtobufDefinition\n\t * @property {Function} message - protobufjs generated Javascript function that includes encode and decode methods.\n\t * @property {(number|null)} id - integer request ID of the message for \"Request\" protobuf definitions, null otherwise.\n\t * @property {(Function | null)} replyMessage The corresponding reply message to a given \"Request\" message, null otherwise.\n   */\n\n\n\t/**\n\t * This is typedef describing the auto-generated code that pbjs generates\n\t * @typedef {Object} ProtobufMessage\n\t * @property {Function} create\n\t * @property {Function} encode\n\t * @property {Function} decode\n   */\n\n\n\t/**\n\t * @returns {Array} valid strings that can be passed to getDefinition(). Includes all Request/Reply style messages as well as non request messages and enums.\n\t */\n\tstatic getDefinitions() {\n\t\tconst namespaces = this.getNamespaces();\n\t\tconst returnThis = [];\n\t\tfor (const key of Object.keys(this.definitions)) {\n\t\t\tif (namespaces.includes(key)) {\n\t\t\t\tconst namespace = namespaces[namespaces.indexOf(key)];\n\t\t\t\tfor (const namespacedKey of Object.keys(this.definitions[namespace])) {\n\t\t\t\t\treturnThis.push(`${namespace}.${namespacedKey}`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturnThis.push(key);\n\t\t\t}\n\t\t}\n\t\treturn returnThis;\n\t}\n\n\t/**\n\t * @returns {Array} valid dot prefixes to getDefinition() arguments (i.e. the \"cellular\" from \"cellular\".GetIccidRequest, etc)\n\t */\n\tstatic getNamespaces() {\n\t\treturn [\n\t\t\t'wifi',\n\t\t\t'logging',\n\t\t\t'mesh',\n\t\t\t'cloud',\n\t\t\t'cellular'\n\t\t];\n\t}\n\n\tstatic _getIDFromJSON(protobufMessageName) {\n\t\tlet rootJSONObject;\n\t\tif (this._isNamespaced(protobufMessageName)) {\n\t\t\tconst [namespace, nonNamespacedName] = this._getNamespaceAndMessageName(protobufMessageName);\n\t\t\trootJSONObject = DeviceOSProtobuf._pbjsJSON.nested.particle.nested.ctrl\n\t\t\t\t.nested[namespace].nested[nonNamespacedName];\n\t\t} else {\n\t\t\trootJSONObject = DeviceOSProtobuf._pbjsJSON.nested.particle.nested.ctrl\n\t\t\t\t.nested[protobufMessageName];\n\t\t}\n\n\t\ttry {\n\t\t\treturn rootJSONObject.options['(type_id)'];\n\t\t} catch (e) {\n\t\t\tthrow new Error(`Could not extract request type id from pbjs json where protobufMessageName=${protobufMessageName}`);\n\t\t}\n\t}\n\n\tstatic _isNamespaced(protobufMessageName) {\n\t\treturn protobufMessageName.includes('.');\n\t}\n\n\tstatic _getNamespaceAndMessageName(protobufMessageName) {\n\t\treturn protobufMessageName.split('.');\n\t}\n\n\t// Get's a pbjs generated Function by name or namespace.name\n\tstatic _getProtobufMessage(protobufMessageName) {\n\t\tlet rootObject;\n\t\tif (protobufMessageName.includes('.')) {\n\t\t\tconst [namespace, nonNamespacedName] = this._getNamespaceAndMessageName(protobufMessageName);\n\t\t\tprotobufMessageName = nonNamespacedName;\n\t\t\trootObject = this.definitions[namespace];\n\t\t} else {\n\t\t\trootObject = this.definitions;\n\t\t}\n\t\tif (!(protobufMessageName in rootObject)) {\n\t\t\tthrow new Error(`There is no pbjs generated protobuf Function for protobufMessageName=${protobufMessageName}`);\n\t\t}\n\t\treturn rootObject[protobufMessageName];\n\t}\n\n\tstatic _getProtobufReplyMessage(protobufMessageName) {\n\t\treturn this._getProtobufMessage(protobufMessageName.replace('Request', 'Reply'));\n\t}\n}\n\n/**\n * Parsed JSON object generated via `npm run build:json`; this is how we get the type id associated with\n * a given ctrl request\n */\nDeviceOSProtobuf._pbjsJSON = __webpack_require__(/*! ./pbjs-generated/definitions.json */ \"./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json\");\n\n/**\n * All of the interesting auto-generated Javascript objects from `control/*.proto` files live in this definitions object\n * (which is keyed by protobuf message name)\n */\nDeviceOSProtobuf.definitions = pbjsGeneratedProtobufCode.particle.ctrl;\n\nmodule.exports = DeviceOSProtobuf;\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/index.js?");

/***/ }),

/***/ "./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js ***!
  \*************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function(global, factory) { /* global define, require, module */\n\n    /* AMD */ if (true)\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n    /* CommonJS */ else {}\n\n})(this, function($protobuf) {\n    \"use strict\";\n\n    // Common aliases\n    var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n    \n    // Exported root namespace\n    var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n    \n    $root.particle = (function() {\n    \n        /**\n         * Namespace particle.\n         * @exports particle\n         * @namespace\n         */\n        var particle = {};\n    \n        particle.ctrl = (function() {\n    \n            /**\n             * Namespace ctrl.\n             * @memberof particle\n             * @namespace\n             */\n            var ctrl = {};\n    \n            ctrl.cellular = (function() {\n    \n                /**\n                 * Namespace cellular.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var cellular = {};\n    \n                /**\n                 * SIM card types.\n                 * \n                 * Note: The values of this enum should match the values defined by the `SimType` enum in the firmware.\n                 * @name particle.ctrl.cellular.SimType\n                 * @enum {number}\n                 * @property {number} INVALID_SIM_TYPE=0 INVALID_SIM_TYPE value\n                 * @property {number} INTERNAL=1 INTERNAL value\n                 * @property {number} EXTERNAL=2 EXTERNAL value\n                 */\n                cellular.SimType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_SIM_TYPE\"] = 0;\n                    values[valuesById[1] = \"INTERNAL\"] = 1;\n                    values[valuesById[2] = \"EXTERNAL\"] = 2;\n                    return values;\n                })();\n    \n                cellular.AccessPoint = (function() {\n    \n                    /**\n                     * Properties of an AccessPoint.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IAccessPoint\n                     * @property {string|null} [apn] AccessPoint apn\n                     * @property {string|null} [user] AccessPoint user\n                     * @property {string|null} [password] AccessPoint password\n                     * @property {boolean|null} [useDefaults] AccessPoint useDefaults\n                     */\n    \n                    /**\n                     * Constructs a new AccessPoint.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Access point settings.\n                     * @implements IAccessPoint\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set\n                     */\n                    function AccessPoint(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AccessPoint apn.\n                     * @member {string} apn\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.apn = \"\";\n    \n                    /**\n                     * AccessPoint user.\n                     * @member {string} user\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.user = \"\";\n    \n                    /**\n                     * AccessPoint password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.password = \"\";\n    \n                    /**\n                     * AccessPoint useDefaults.\n                     * @member {boolean} useDefaults\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @instance\n                     */\n                    AccessPoint.prototype.useDefaults = false;\n    \n                    /**\n                     * Creates a new AccessPoint instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {particle.ctrl.cellular.IAccessPoint=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint instance\n                     */\n                    AccessPoint.create = function create(properties) {\n                        return new AccessPoint(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AccessPoint message. Does not implicitly {@link particle.ctrl.cellular.AccessPoint.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {particle.ctrl.cellular.IAccessPoint} message AccessPoint message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AccessPoint.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.apn != null && Object.hasOwnProperty.call(message, \"apn\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.apn);\n                        if (message.user != null && Object.hasOwnProperty.call(message, \"user\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.user);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.password);\n                        if (message.useDefaults != null && Object.hasOwnProperty.call(message, \"useDefaults\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).bool(message.useDefaults);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AccessPoint message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.AccessPoint\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.AccessPoint} AccessPoint\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AccessPoint.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.AccessPoint();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.apn = reader.string();\n                                break;\n                            case 2:\n                                message.user = reader.string();\n                                break;\n                            case 3:\n                                message.password = reader.string();\n                                break;\n                            case 4:\n                                message.useDefaults = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AccessPoint;\n                })();\n    \n                cellular.SetAccessPointRequest = (function() {\n    \n                    /**\n                     * Properties of a SetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetAccessPointRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetAccessPointRequest simType\n                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] SetAccessPointRequest accessPoint\n                     */\n    \n                    /**\n                     * Constructs a new SetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Set access point settings.\n                     * @implements ISetAccessPointRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set\n                     */\n                    function SetAccessPointRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SetAccessPointRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @instance\n                     */\n                    SetAccessPointRequest.prototype.simType = 0;\n    \n                    /**\n                     * SetAccessPointRequest accessPoint.\n                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @instance\n                     */\n                    SetAccessPointRequest.prototype.accessPoint = null;\n    \n                    /**\n                     * Creates a new SetAccessPointRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest instance\n                     */\n                    SetAccessPointRequest.create = function create(properties) {\n                        return new SetAccessPointRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointRequest} message SetAccessPointRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetAccessPointRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetAccessPointRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetAccessPointRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetAccessPointRequest} SetAccessPointRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetAccessPointRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            case 2:\n                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetAccessPointRequest;\n                })();\n    \n                cellular.SetAccessPointReply = (function() {\n    \n                    /**\n                     * Properties of a SetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetAccessPointReply\n                     */\n    \n                    /**\n                     * Constructs a new SetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a SetAccessPointReply.\n                     * @implements ISetAccessPointReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set\n                     */\n                    function SetAccessPointReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetAccessPointReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply instance\n                     */\n                    SetAccessPointReply.create = function create(properties) {\n                        return new SetAccessPointReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.SetAccessPointReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetAccessPointReply} message SetAccessPointReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetAccessPointReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetAccessPointReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetAccessPointReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetAccessPointReply} SetAccessPointReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetAccessPointReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetAccessPointReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetAccessPointReply;\n                })();\n    \n                cellular.GetAccessPointRequest = (function() {\n    \n                    /**\n                     * Properties of a GetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetAccessPointRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetAccessPointRequest simType\n                     */\n    \n                    /**\n                     * Constructs a new GetAccessPointRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get access point settings.\n                     * @implements IGetAccessPointRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set\n                     */\n                    function GetAccessPointRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetAccessPointRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @instance\n                     */\n                    GetAccessPointRequest.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new GetAccessPointRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest instance\n                     */\n                    GetAccessPointRequest.create = function create(properties) {\n                        return new GetAccessPointRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetAccessPointRequest message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointRequest} message GetAccessPointRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetAccessPointRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetAccessPointRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetAccessPointRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetAccessPointRequest} GetAccessPointRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetAccessPointRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetAccessPointRequest;\n                })();\n    \n                cellular.GetAccessPointReply = (function() {\n    \n                    /**\n                     * Properties of a GetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetAccessPointReply\n                     * @property {particle.ctrl.cellular.IAccessPoint|null} [accessPoint] GetAccessPointReply accessPoint\n                     */\n    \n                    /**\n                     * Constructs a new GetAccessPointReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetAccessPointReply.\n                     * @implements IGetAccessPointReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set\n                     */\n                    function GetAccessPointReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetAccessPointReply accessPoint.\n                     * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} accessPoint\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @instance\n                     */\n                    GetAccessPointReply.prototype.accessPoint = null;\n    \n                    /**\n                     * Creates a new GetAccessPointReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply instance\n                     */\n                    GetAccessPointReply.create = function create(properties) {\n                        return new GetAccessPointReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetAccessPointReply message. Does not implicitly {@link particle.ctrl.cellular.GetAccessPointReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetAccessPointReply} message GetAccessPointReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetAccessPointReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.accessPoint != null && Object.hasOwnProperty.call(message, \"accessPoint\"))\n                            $root.particle.ctrl.cellular.AccessPoint.encode(message.accessPoint, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetAccessPointReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetAccessPointReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetAccessPointReply} GetAccessPointReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetAccessPointReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetAccessPointReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.accessPoint = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetAccessPointReply;\n                })();\n    \n                cellular.SetActiveSimRequest = (function() {\n    \n                    /**\n                     * Properties of a SetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetActiveSimRequest\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] SetActiveSimRequest simType\n                     */\n    \n                    /**\n                     * Constructs a new SetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Set active SIM card.\n                     * \n                     * Note: The device needs to be reset in order for the settings to take effect.\n                     * @implements ISetActiveSimRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set\n                     */\n                    function SetActiveSimRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SetActiveSimRequest simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @instance\n                     */\n                    SetActiveSimRequest.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new SetActiveSimRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest instance\n                     */\n                    SetActiveSimRequest.create = function create(properties) {\n                        return new SetActiveSimRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimRequest} message SetActiveSimRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetActiveSimRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetActiveSimRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetActiveSimRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetActiveSimRequest} SetActiveSimRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetActiveSimRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetActiveSimRequest;\n                })();\n    \n                cellular.SetActiveSimReply = (function() {\n    \n                    /**\n                     * Properties of a SetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface ISetActiveSimReply\n                     */\n    \n                    /**\n                     * Constructs a new SetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a SetActiveSimReply.\n                     * @implements ISetActiveSimReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set\n                     */\n                    function SetActiveSimReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new SetActiveSimReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply instance\n                     */\n                    SetActiveSimReply.create = function create(properties) {\n                        return new SetActiveSimReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.SetActiveSimReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.ISetActiveSimReply} message SetActiveSimReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SetActiveSimReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SetActiveSimReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.SetActiveSimReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.SetActiveSimReply} SetActiveSimReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SetActiveSimReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.SetActiveSimReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SetActiveSimReply;\n                })();\n    \n                cellular.GetActiveSimRequest = (function() {\n    \n                    /**\n                     * Properties of a GetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetActiveSimRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetActiveSimRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get active SIM card.\n                     * @implements IGetActiveSimRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set\n                     */\n                    function GetActiveSimRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetActiveSimRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest instance\n                     */\n                    GetActiveSimRequest.create = function create(properties) {\n                        return new GetActiveSimRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetActiveSimRequest message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimRequest} message GetActiveSimRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetActiveSimRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetActiveSimRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetActiveSimRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetActiveSimRequest} GetActiveSimRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetActiveSimRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetActiveSimRequest;\n                })();\n    \n                cellular.GetActiveSimReply = (function() {\n    \n                    /**\n                     * Properties of a GetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetActiveSimReply\n                     * @property {particle.ctrl.cellular.SimType|null} [simType] GetActiveSimReply simType\n                     */\n    \n                    /**\n                     * Constructs a new GetActiveSimReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetActiveSimReply.\n                     * @implements IGetActiveSimReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set\n                     */\n                    function GetActiveSimReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetActiveSimReply simType.\n                     * @member {particle.ctrl.cellular.SimType} simType\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @instance\n                     */\n                    GetActiveSimReply.prototype.simType = 0;\n    \n                    /**\n                     * Creates a new GetActiveSimReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply instance\n                     */\n                    GetActiveSimReply.create = function create(properties) {\n                        return new GetActiveSimReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetActiveSimReply message. Does not implicitly {@link particle.ctrl.cellular.GetActiveSimReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetActiveSimReply} message GetActiveSimReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetActiveSimReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.simType != null && Object.hasOwnProperty.call(message, \"simType\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.simType);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetActiveSimReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetActiveSimReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetActiveSimReply} GetActiveSimReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetActiveSimReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetActiveSimReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.simType = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetActiveSimReply;\n                })();\n    \n                cellular.GetIccidRequest = (function() {\n    \n                    /**\n                     * Properties of a GetIccidRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetIccidRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetIccidRequest.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Get ICCID.\n                     * @implements IGetIccidRequest\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set\n                     */\n                    function GetIccidRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetIccidRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest instance\n                     */\n                    GetIccidRequest.create = function create(properties) {\n                        return new GetIccidRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetIccidRequest message. Does not implicitly {@link particle.ctrl.cellular.GetIccidRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidRequest} message GetIccidRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetIccidRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetIccidRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetIccidRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetIccidRequest} GetIccidRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetIccidRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetIccidRequest;\n                })();\n    \n                cellular.GetIccidReply = (function() {\n    \n                    /**\n                     * Properties of a GetIccidReply.\n                     * @memberof particle.ctrl.cellular\n                     * @interface IGetIccidReply\n                     * @property {string|null} [iccid] GetIccidReply iccid\n                     */\n    \n                    /**\n                     * Constructs a new GetIccidReply.\n                     * @memberof particle.ctrl.cellular\n                     * @classdesc Represents a GetIccidReply.\n                     * @implements IGetIccidReply\n                     * @constructor\n                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set\n                     */\n                    function GetIccidReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetIccidReply iccid.\n                     * @member {string} iccid\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @instance\n                     */\n                    GetIccidReply.prototype.iccid = \"\";\n    \n                    /**\n                     * Creates a new GetIccidReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply instance\n                     */\n                    GetIccidReply.create = function create(properties) {\n                        return new GetIccidReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetIccidReply message. Does not implicitly {@link particle.ctrl.cellular.GetIccidReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {particle.ctrl.cellular.IGetIccidReply} message GetIccidReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetIccidReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.iccid != null && Object.hasOwnProperty.call(message, \"iccid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.iccid);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetIccidReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cellular.GetIccidReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cellular.GetIccidReply} GetIccidReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetIccidReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cellular.GetIccidReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.iccid = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetIccidReply;\n                })();\n    \n                return cellular;\n            })();\n    \n            /**\n             * ResultCode enum.\n             * @name particle.ctrl.ResultCode\n             * @enum {number}\n             * @property {number} OK=0 OK value\n             * @property {number} NOT_ALLOWED=1 NOT_ALLOWED value\n             * @property {number} TIMEOUT=2 TIMEOUT value\n             * @property {number} NOT_FOUND=3 NOT_FOUND value\n             * @property {number} ALREADY_EXIST=4 ALREADY_EXIST value\n             * @property {number} INVALID_STATE=5 INVALID_STATE value\n             * @property {number} NO_MEMORY=6 NO_MEMORY value\n             * @property {number} INVALID_PARAM=7 INVALID_PARAM value\n             */\n            ctrl.ResultCode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"OK\"] = 0;\n                values[valuesById[1] = \"NOT_ALLOWED\"] = 1;\n                values[valuesById[2] = \"TIMEOUT\"] = 2;\n                values[valuesById[3] = \"NOT_FOUND\"] = 3;\n                values[valuesById[4] = \"ALREADY_EXIST\"] = 4;\n                values[valuesById[5] = \"INVALID_STATE\"] = 5;\n                values[valuesById[6] = \"NO_MEMORY\"] = 6;\n                values[valuesById[7] = \"INVALID_PARAM\"] = 7;\n                return values;\n            })();\n    \n            ctrl.Ipv4Address = (function() {\n    \n                /**\n                 * Properties of an Ipv4Address.\n                 * @memberof particle.ctrl\n                 * @interface IIpv4Address\n                 * @property {number|null} [address] Ipv4Address address\n                 */\n    \n                /**\n                 * Constructs a new Ipv4Address.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv4Address.\n                 * @implements IIpv4Address\n                 * @constructor\n                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set\n                 */\n                function Ipv4Address(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv4Address address.\n                 * @member {number} address\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @instance\n                 */\n                Ipv4Address.prototype.address = 0;\n    \n                /**\n                 * Creates a new Ipv4Address instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {particle.ctrl.IIpv4Address=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address instance\n                 */\n                Ipv4Address.create = function create(properties) {\n                    return new Ipv4Address(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv4Address message. Does not implicitly {@link particle.ctrl.Ipv4Address.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {particle.ctrl.IIpv4Address} message Ipv4Address message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv4Address.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv4Address message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv4Address\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv4Address} Ipv4Address\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv4Address.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Address();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv4Address;\n            })();\n    \n            ctrl.Ipv6Address = (function() {\n    \n                /**\n                 * Properties of an Ipv6Address.\n                 * @memberof particle.ctrl\n                 * @interface IIpv6Address\n                 * @property {Uint8Array|null} [address] Ipv6Address address\n                 */\n    \n                /**\n                 * Constructs a new Ipv6Address.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv6Address.\n                 * @implements IIpv6Address\n                 * @constructor\n                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set\n                 */\n                function Ipv6Address(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv6Address address.\n                 * @member {Uint8Array} address\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @instance\n                 */\n                Ipv6Address.prototype.address = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new Ipv6Address instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {particle.ctrl.IIpv6Address=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address instance\n                 */\n                Ipv6Address.create = function create(properties) {\n                    return new Ipv6Address(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv6Address message. Does not implicitly {@link particle.ctrl.Ipv6Address.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {particle.ctrl.IIpv6Address} message Ipv6Address message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv6Address.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv6Address message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv6Address\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv6Address} Ipv6Address\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv6Address.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Address();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv6Address;\n            })();\n    \n            ctrl.IpAddress = (function() {\n    \n                /**\n                 * Properties of an IpAddress.\n                 * @memberof particle.ctrl\n                 * @interface IIpAddress\n                 * @property {particle.ctrl.IIpv4Address|null} [v4] IpAddress v4\n                 * @property {particle.ctrl.IIpv6Address|null} [v6] IpAddress v6\n                 */\n    \n                /**\n                 * Constructs a new IpAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IpAddress.\n                 * @implements IIpAddress\n                 * @constructor\n                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set\n                 */\n                function IpAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IpAddress v4.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} v4\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                IpAddress.prototype.v4 = null;\n    \n                /**\n                 * IpAddress v6.\n                 * @member {particle.ctrl.IIpv6Address|null|undefined} v6\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                IpAddress.prototype.v6 = null;\n    \n                // OneOf field names bound to virtual getters and setters\n                var $oneOfFields;\n    \n                /**\n                 * IpAddress address.\n                 * @member {\"v4\"|\"v6\"|undefined} address\n                 * @memberof particle.ctrl.IpAddress\n                 * @instance\n                 */\n                Object.defineProperty(IpAddress.prototype, \"address\", {\n                    get: $util.oneOfGetter($oneOfFields = [\"v4\", \"v6\"]),\n                    set: $util.oneOfSetter($oneOfFields)\n                });\n    \n                /**\n                 * Creates a new IpAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {particle.ctrl.IIpAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.IpAddress} IpAddress instance\n                 */\n                IpAddress.create = function create(properties) {\n                    return new IpAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified IpAddress message. Does not implicitly {@link particle.ctrl.IpAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {particle.ctrl.IIpAddress} message IpAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IpAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.v4 != null && Object.hasOwnProperty.call(message, \"v4\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.v4, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.v6 != null && Object.hasOwnProperty.call(message, \"v6\"))\n                        $root.particle.ctrl.Ipv6Address.encode(message.v6, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IpAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IpAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IpAddress} IpAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IpAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IpAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.v4 = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            message.v6 = $root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IpAddress;\n            })();\n    \n            ctrl.IPAddress = (function() {\n    \n                /**\n                 * Properties of a IPAddress.\n                 * @memberof particle.ctrl\n                 * @interface IIPAddress\n                 * @property {particle.ctrl.IPAddress.Protocol|null} [protocol] IPAddress protocol\n                 * @property {Uint8Array|null} [address] IPAddress address\n                 */\n    \n                /**\n                 * Constructs a new IPAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a IPAddress.\n                 * @implements IIPAddress\n                 * @constructor\n                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set\n                 */\n                function IPAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IPAddress protocol.\n                 * @member {particle.ctrl.IPAddress.Protocol} protocol\n                 * @memberof particle.ctrl.IPAddress\n                 * @instance\n                 */\n                IPAddress.prototype.protocol = 0;\n    \n                /**\n                 * IPAddress address.\n                 * @member {Uint8Array} address\n                 * @memberof particle.ctrl.IPAddress\n                 * @instance\n                 */\n                IPAddress.prototype.address = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new IPAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {particle.ctrl.IIPAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.IPAddress} IPAddress instance\n                 */\n                IPAddress.create = function create(properties) {\n                    return new IPAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified IPAddress message. Does not implicitly {@link particle.ctrl.IPAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {particle.ctrl.IIPAddress} message IPAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IPAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.address);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a IPAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IPAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IPAddress} IPAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IPAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        case 2:\n                            message.address = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Protocol enum.\n                 * @name particle.ctrl.IPAddress.Protocol\n                 * @enum {number}\n                 * @property {number} NONE=0 NONE value\n                 * @property {number} IPv4=1 IPv4 value\n                 * @property {number} IPv6=2 IPv6 value\n                 */\n                IPAddress.Protocol = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"IPv4\"] = 1;\n                    values[valuesById[2] = \"IPv6\"] = 2;\n                    return values;\n                })();\n    \n                return IPAddress;\n            })();\n    \n            ctrl.cloud = (function() {\n    \n                /**\n                 * Namespace cloud.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var cloud = {};\n    \n                /**\n                 * ConnectionStatus enum.\n                 * @name particle.ctrl.cloud.ConnectionStatus\n                 * @enum {number}\n                 * @property {number} DISCONNECTED=0 DISCONNECTED value\n                 * @property {number} CONNECTING=1 CONNECTING value\n                 * @property {number} CONNECTED=2 CONNECTED value\n                 * @property {number} DISCONNECTING=3 DISCONNECTING value\n                 */\n                cloud.ConnectionStatus = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"DISCONNECTED\"] = 0;\n                    values[valuesById[1] = \"CONNECTING\"] = 1;\n                    values[valuesById[2] = \"CONNECTED\"] = 2;\n                    values[valuesById[3] = \"DISCONNECTING\"] = 3;\n                    return values;\n                })();\n    \n                cloud.GetConnectionStatusRequest = (function() {\n    \n                    /**\n                     * Properties of a GetConnectionStatusRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IGetConnectionStatusRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetConnectionStatusRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a GetConnectionStatusRequest.\n                     * @implements IGetConnectionStatusRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set\n                     */\n                    function GetConnectionStatusRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetConnectionStatusRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest instance\n                     */\n                    GetConnectionStatusRequest.create = function create(properties) {\n                        return new GetConnectionStatusRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetConnectionStatusRequest message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusRequest} message GetConnectionStatusRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetConnectionStatusRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetConnectionStatusRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusRequest} GetConnectionStatusRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetConnectionStatusRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetConnectionStatusRequest;\n                })();\n    \n                cloud.GetConnectionStatusReply = (function() {\n    \n                    /**\n                     * Properties of a GetConnectionStatusReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IGetConnectionStatusReply\n                     * @property {particle.ctrl.cloud.ConnectionStatus|null} [status] GetConnectionStatusReply status\n                     */\n    \n                    /**\n                     * Constructs a new GetConnectionStatusReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a GetConnectionStatusReply.\n                     * @implements IGetConnectionStatusReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set\n                     */\n                    function GetConnectionStatusReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetConnectionStatusReply status.\n                     * @member {particle.ctrl.cloud.ConnectionStatus} status\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @instance\n                     */\n                    GetConnectionStatusReply.prototype.status = 0;\n    \n                    /**\n                     * Creates a new GetConnectionStatusReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply instance\n                     */\n                    GetConnectionStatusReply.create = function create(properties) {\n                        return new GetConnectionStatusReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetConnectionStatusReply message. Does not implicitly {@link particle.ctrl.cloud.GetConnectionStatusReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IGetConnectionStatusReply} message GetConnectionStatusReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetConnectionStatusReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.status != null && Object.hasOwnProperty.call(message, \"status\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.status);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetConnectionStatusReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.GetConnectionStatusReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.GetConnectionStatusReply} GetConnectionStatusReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetConnectionStatusReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.GetConnectionStatusReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.status = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetConnectionStatusReply;\n                })();\n    \n                cloud.ConnectRequest = (function() {\n    \n                    /**\n                     * Properties of a ConnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IConnectRequest\n                     */\n    \n                    /**\n                     * Constructs a new ConnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a ConnectRequest.\n                     * @implements IConnectRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set\n                     */\n                    function ConnectRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ConnectRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest instance\n                     */\n                    ConnectRequest.create = function create(properties) {\n                        return new ConnectRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ConnectRequest message. Does not implicitly {@link particle.ctrl.cloud.ConnectRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectRequest} message ConnectRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ConnectRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ConnectRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.ConnectRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.ConnectRequest} ConnectRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ConnectRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ConnectRequest;\n                })();\n    \n                cloud.ConnectReply = (function() {\n    \n                    /**\n                     * Properties of a ConnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IConnectReply\n                     */\n    \n                    /**\n                     * Constructs a new ConnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a ConnectReply.\n                     * @implements IConnectReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set\n                     */\n                    function ConnectReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ConnectReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply instance\n                     */\n                    ConnectReply.create = function create(properties) {\n                        return new ConnectReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ConnectReply message. Does not implicitly {@link particle.ctrl.cloud.ConnectReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IConnectReply} message ConnectReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ConnectReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ConnectReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.ConnectReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.ConnectReply} ConnectReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ConnectReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.ConnectReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ConnectReply;\n                })();\n    \n                cloud.DisconnectRequest = (function() {\n    \n                    /**\n                     * Properties of a DisconnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IDisconnectRequest\n                     */\n    \n                    /**\n                     * Constructs a new DisconnectRequest.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a DisconnectRequest.\n                     * @implements IDisconnectRequest\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set\n                     */\n                    function DisconnectRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new DisconnectRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest instance\n                     */\n                    DisconnectRequest.create = function create(properties) {\n                        return new DisconnectRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DisconnectRequest message. Does not implicitly {@link particle.ctrl.cloud.DisconnectRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectRequest} message DisconnectRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DisconnectRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DisconnectRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.DisconnectRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.DisconnectRequest} DisconnectRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DisconnectRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return DisconnectRequest;\n                })();\n    \n                cloud.DisconnectReply = (function() {\n    \n                    /**\n                     * Properties of a DisconnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @interface IDisconnectReply\n                     */\n    \n                    /**\n                     * Constructs a new DisconnectReply.\n                     * @memberof particle.ctrl.cloud\n                     * @classdesc Represents a DisconnectReply.\n                     * @implements IDisconnectReply\n                     * @constructor\n                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set\n                     */\n                    function DisconnectReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new DisconnectReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply instance\n                     */\n                    DisconnectReply.create = function create(properties) {\n                        return new DisconnectReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DisconnectReply message. Does not implicitly {@link particle.ctrl.cloud.DisconnectReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {particle.ctrl.cloud.IDisconnectReply} message DisconnectReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DisconnectReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DisconnectReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.cloud.DisconnectReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.cloud.DisconnectReply} DisconnectReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DisconnectReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.cloud.DisconnectReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return DisconnectReply;\n                })();\n    \n                return cloud;\n            })();\n    \n            /**\n             * SecurityKeyType enum.\n             * @name particle.ctrl.SecurityKeyType\n             * @enum {number}\n             * @property {number} INVALID_SECURITY_KEY=0 INVALID_SECURITY_KEY value\n             * @property {number} TCP_DEVICE_PRIVATE_KEY=1 TCP_DEVICE_PRIVATE_KEY value\n             * @property {number} TCP_DEVICE_PUBLIC_KEY=2 TCP_DEVICE_PUBLIC_KEY value\n             * @property {number} TCP_SERVER_PUBLIC_KEY=3 TCP_SERVER_PUBLIC_KEY value\n             * @property {number} UDP_DEVICE_PRIVATE_KEY=4 UDP_DEVICE_PRIVATE_KEY value\n             * @property {number} UDP_DEVICE_PUBLIC_KEY=5 UDP_DEVICE_PUBLIC_KEY value\n             * @property {number} UDP_SERVER_PUBLIC_KEY=6 UDP_SERVER_PUBLIC_KEY value\n             */\n            ctrl.SecurityKeyType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECURITY_KEY\"] = 0;\n                values[valuesById[1] = \"TCP_DEVICE_PRIVATE_KEY\"] = 1;\n                values[valuesById[2] = \"TCP_DEVICE_PUBLIC_KEY\"] = 2;\n                values[valuesById[3] = \"TCP_SERVER_PUBLIC_KEY\"] = 3;\n                values[valuesById[4] = \"UDP_DEVICE_PRIVATE_KEY\"] = 4;\n                values[valuesById[5] = \"UDP_DEVICE_PUBLIC_KEY\"] = 5;\n                values[valuesById[6] = \"UDP_SERVER_PUBLIC_KEY\"] = 6;\n                return values;\n            })();\n    \n            /**\n             * ServerProtocolType enum.\n             * @name particle.ctrl.ServerProtocolType\n             * @enum {number}\n             * @property {number} INVALID_PROTOCOL=0 INVALID_PROTOCOL value\n             * @property {number} TCP_PROTOCOL=1 TCP_PROTOCOL value\n             * @property {number} UDP_PROTOCOL=2 UDP_PROTOCOL value\n             */\n            ctrl.ServerProtocolType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_PROTOCOL\"] = 0;\n                values[valuesById[1] = \"TCP_PROTOCOL\"] = 1;\n                values[valuesById[2] = \"UDP_PROTOCOL\"] = 2;\n                return values;\n            })();\n    \n            /**\n             * DeviceMode enum.\n             * @name particle.ctrl.DeviceMode\n             * @enum {number}\n             * @property {number} NORMAL_MODE=0 NORMAL_MODE value\n             * @property {number} LISTENING_MODE=1 LISTENING_MODE value\n             */\n            ctrl.DeviceMode = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NORMAL_MODE\"] = 0;\n                values[valuesById[1] = \"LISTENING_MODE\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * SystemCapabilityFlag enum.\n             * @name particle.ctrl.SystemCapabilityFlag\n             * @enum {number}\n             * @property {number} NO_SYSTEM_CAPABILITY_FLAGS=0 NO_SYSTEM_CAPABILITY_FLAGS value\n             * @property {number} COMPRESSED_OTA=1 COMPRESSED_OTA value\n             */\n            ctrl.SystemCapabilityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SYSTEM_CAPABILITY_FLAGS\"] = 0;\n                values[valuesById[1] = \"COMPRESSED_OTA\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * Feature enum.\n             * @name particle.ctrl.Feature\n             * @enum {number}\n             * @property {number} INVALID_FEATURE=0 INVALID_FEATURE value\n             * @property {number} ETHERNET_DETECTION=1 ETHERNET_DETECTION value\n             */\n            ctrl.Feature = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FEATURE\"] = 0;\n                values[valuesById[1] = \"ETHERNET_DETECTION\"] = 1;\n                return values;\n            })();\n    \n            ctrl.GetDeviceIdRequest = (function() {\n    \n                /**\n                 * Properties of a GetDeviceIdRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceIdRequest\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceIdRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceIdRequest.\n                 * @implements IGetDeviceIdRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set\n                 */\n                function GetDeviceIdRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetDeviceIdRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest instance\n                 */\n                GetDeviceIdRequest.create = function create(properties) {\n                    return new GetDeviceIdRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceIdRequest message. Does not implicitly {@link particle.ctrl.GetDeviceIdRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdRequest} message GetDeviceIdRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceIdRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceIdRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceIdRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceIdRequest} GetDeviceIdRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceIdRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceIdRequest;\n            })();\n    \n            ctrl.GetDeviceIdReply = (function() {\n    \n                /**\n                 * Properties of a GetDeviceIdReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceIdReply\n                 * @property {string|null} [id] GetDeviceIdReply id\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceIdReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceIdReply.\n                 * @implements IGetDeviceIdReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set\n                 */\n                function GetDeviceIdReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetDeviceIdReply id.\n                 * @member {string} id\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @instance\n                 */\n                GetDeviceIdReply.prototype.id = \"\";\n    \n                /**\n                 * Creates a new GetDeviceIdReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply instance\n                 */\n                GetDeviceIdReply.create = function create(properties) {\n                    return new GetDeviceIdReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceIdReply message. Does not implicitly {@link particle.ctrl.GetDeviceIdReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceIdReply} message GetDeviceIdReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceIdReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceIdReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceIdReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceIdReply} GetDeviceIdReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceIdReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceIdReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.id = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceIdReply;\n            })();\n    \n            ctrl.GetSerialNumberRequest = (function() {\n    \n                /**\n                 * Properties of a GetSerialNumberRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSerialNumberRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSerialNumberRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSerialNumberRequest.\n                 * @implements IGetSerialNumberRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set\n                 */\n                function GetSerialNumberRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSerialNumberRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest instance\n                 */\n                GetSerialNumberRequest.create = function create(properties) {\n                    return new GetSerialNumberRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSerialNumberRequest message. Does not implicitly {@link particle.ctrl.GetSerialNumberRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberRequest} message GetSerialNumberRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSerialNumberRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSerialNumberRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSerialNumberRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSerialNumberRequest} GetSerialNumberRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSerialNumberRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSerialNumberRequest;\n            })();\n    \n            ctrl.GetSerialNumberReply = (function() {\n    \n                /**\n                 * Properties of a GetSerialNumberReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSerialNumberReply\n                 * @property {string|null} [serial] GetSerialNumberReply serial\n                 */\n    \n                /**\n                 * Constructs a new GetSerialNumberReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSerialNumberReply.\n                 * @implements IGetSerialNumberReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set\n                 */\n                function GetSerialNumberReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSerialNumberReply serial.\n                 * @member {string} serial\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @instance\n                 */\n                GetSerialNumberReply.prototype.serial = \"\";\n    \n                /**\n                 * Creates a new GetSerialNumberReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply instance\n                 */\n                GetSerialNumberReply.create = function create(properties) {\n                    return new GetSerialNumberReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSerialNumberReply message. Does not implicitly {@link particle.ctrl.GetSerialNumberReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {particle.ctrl.IGetSerialNumberReply} message GetSerialNumberReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSerialNumberReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.serial != null && Object.hasOwnProperty.call(message, \"serial\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.serial);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSerialNumberReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSerialNumberReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSerialNumberReply} GetSerialNumberReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSerialNumberReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSerialNumberReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.serial = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSerialNumberReply;\n            })();\n    \n            ctrl.GetSystemVersionRequest = (function() {\n    \n                /**\n                 * Properties of a GetSystemVersionRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemVersionRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSystemVersionRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemVersionRequest.\n                 * @implements IGetSystemVersionRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set\n                 */\n                function GetSystemVersionRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSystemVersionRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest instance\n                 */\n                GetSystemVersionRequest.create = function create(properties) {\n                    return new GetSystemVersionRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemVersionRequest message. Does not implicitly {@link particle.ctrl.GetSystemVersionRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionRequest} message GetSystemVersionRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemVersionRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemVersionRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemVersionRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemVersionRequest} GetSystemVersionRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemVersionRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemVersionRequest;\n            })();\n    \n            ctrl.GetSystemVersionReply = (function() {\n    \n                /**\n                 * Properties of a GetSystemVersionReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemVersionReply\n                 * @property {string|null} [version] GetSystemVersionReply version\n                 */\n    \n                /**\n                 * Constructs a new GetSystemVersionReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemVersionReply.\n                 * @implements IGetSystemVersionReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set\n                 */\n                function GetSystemVersionReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSystemVersionReply version.\n                 * @member {string} version\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @instance\n                 */\n                GetSystemVersionReply.prototype.version = \"\";\n    \n                /**\n                 * Creates a new GetSystemVersionReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply instance\n                 */\n                GetSystemVersionReply.create = function create(properties) {\n                    return new GetSystemVersionReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemVersionReply message. Does not implicitly {@link particle.ctrl.GetSystemVersionReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemVersionReply} message GetSystemVersionReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemVersionReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemVersionReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemVersionReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemVersionReply} GetSystemVersionReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemVersionReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemVersionReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.version = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemVersionReply;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionRequest = (function() {\n    \n                /**\n                 * Properties of a GetNcpFirmwareVersionRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetNcpFirmwareVersionRequest\n                 */\n    \n                /**\n                 * Constructs a new GetNcpFirmwareVersionRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetNcpFirmwareVersionRequest.\n                 * @implements IGetNcpFirmwareVersionRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set\n                 */\n                function GetNcpFirmwareVersionRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetNcpFirmwareVersionRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest instance\n                 */\n                GetNcpFirmwareVersionRequest.create = function create(properties) {\n                    return new GetNcpFirmwareVersionRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetNcpFirmwareVersionRequest message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionRequest} message GetNcpFirmwareVersionRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetNcpFirmwareVersionRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetNcpFirmwareVersionRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionRequest} GetNcpFirmwareVersionRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetNcpFirmwareVersionRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetNcpFirmwareVersionRequest;\n            })();\n    \n            ctrl.GetNcpFirmwareVersionReply = (function() {\n    \n                /**\n                 * Properties of a GetNcpFirmwareVersionReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetNcpFirmwareVersionReply\n                 * @property {string|null} [version] GetNcpFirmwareVersionReply version\n                 * @property {number|null} [moduleVersion] GetNcpFirmwareVersionReply moduleVersion\n                 */\n    \n                /**\n                 * Constructs a new GetNcpFirmwareVersionReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetNcpFirmwareVersionReply.\n                 * @implements IGetNcpFirmwareVersionReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set\n                 */\n                function GetNcpFirmwareVersionReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetNcpFirmwareVersionReply version.\n                 * @member {string} version\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @instance\n                 */\n                GetNcpFirmwareVersionReply.prototype.version = \"\";\n    \n                /**\n                 * GetNcpFirmwareVersionReply moduleVersion.\n                 * @member {number} moduleVersion\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @instance\n                 */\n                GetNcpFirmwareVersionReply.prototype.moduleVersion = 0;\n    \n                /**\n                 * Creates a new GetNcpFirmwareVersionReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply instance\n                 */\n                GetNcpFirmwareVersionReply.create = function create(properties) {\n                    return new GetNcpFirmwareVersionReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetNcpFirmwareVersionReply message. Does not implicitly {@link particle.ctrl.GetNcpFirmwareVersionReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {particle.ctrl.IGetNcpFirmwareVersionReply} message GetNcpFirmwareVersionReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetNcpFirmwareVersionReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.version);\n                    if (message.moduleVersion != null && Object.hasOwnProperty.call(message, \"moduleVersion\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.moduleVersion);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetNcpFirmwareVersionReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetNcpFirmwareVersionReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetNcpFirmwareVersionReply} GetNcpFirmwareVersionReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetNcpFirmwareVersionReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetNcpFirmwareVersionReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.version = reader.string();\n                            break;\n                        case 2:\n                            message.moduleVersion = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetNcpFirmwareVersionReply;\n            })();\n    \n            ctrl.GetSystemCapabilitiesRequest = (function() {\n    \n                /**\n                 * Properties of a GetSystemCapabilitiesRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemCapabilitiesRequest\n                 */\n    \n                /**\n                 * Constructs a new GetSystemCapabilitiesRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemCapabilitiesRequest.\n                 * @implements IGetSystemCapabilitiesRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set\n                 */\n                function GetSystemCapabilitiesRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetSystemCapabilitiesRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest instance\n                 */\n                GetSystemCapabilitiesRequest.create = function create(properties) {\n                    return new GetSystemCapabilitiesRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemCapabilitiesRequest message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesRequest} message GetSystemCapabilitiesRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemCapabilitiesRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemCapabilitiesRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemCapabilitiesRequest} GetSystemCapabilitiesRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemCapabilitiesRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemCapabilitiesRequest;\n            })();\n    \n            ctrl.GetSystemCapabilitiesReply = (function() {\n    \n                /**\n                 * Properties of a GetSystemCapabilitiesReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSystemCapabilitiesReply\n                 * @property {number|null} [flags] GetSystemCapabilitiesReply flags\n                 */\n    \n                /**\n                 * Constructs a new GetSystemCapabilitiesReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSystemCapabilitiesReply.\n                 * @implements IGetSystemCapabilitiesReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set\n                 */\n                function GetSystemCapabilitiesReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSystemCapabilitiesReply flags.\n                 * @member {number} flags\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @instance\n                 */\n                GetSystemCapabilitiesReply.prototype.flags = 0;\n    \n                /**\n                 * Creates a new GetSystemCapabilitiesReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply instance\n                 */\n                GetSystemCapabilitiesReply.create = function create(properties) {\n                    return new GetSystemCapabilitiesReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSystemCapabilitiesReply message. Does not implicitly {@link particle.ctrl.GetSystemCapabilitiesReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {particle.ctrl.IGetSystemCapabilitiesReply} message GetSystemCapabilitiesReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSystemCapabilitiesReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                        writer.uint32(/* id 1, wireType 5 =*/13).fixed32(message.flags);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSystemCapabilitiesReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSystemCapabilitiesReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSystemCapabilitiesReply} GetSystemCapabilitiesReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSystemCapabilitiesReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSystemCapabilitiesReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.flags = reader.fixed32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSystemCapabilitiesReply;\n            })();\n    \n            ctrl.SetClaimCodeRequest = (function() {\n    \n                /**\n                 * Properties of a SetClaimCodeRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetClaimCodeRequest\n                 * @property {string|null} [code] SetClaimCodeRequest code\n                 */\n    \n                /**\n                 * Constructs a new SetClaimCodeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetClaimCodeRequest.\n                 * @implements ISetClaimCodeRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set\n                 */\n                function SetClaimCodeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetClaimCodeRequest code.\n                 * @member {string} code\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @instance\n                 */\n                SetClaimCodeRequest.prototype.code = \"\";\n    \n                /**\n                 * Creates a new SetClaimCodeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest instance\n                 */\n                SetClaimCodeRequest.create = function create(properties) {\n                    return new SetClaimCodeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetClaimCodeRequest message. Does not implicitly {@link particle.ctrl.SetClaimCodeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeRequest} message SetClaimCodeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetClaimCodeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.code != null && Object.hasOwnProperty.call(message, \"code\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetClaimCodeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetClaimCodeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetClaimCodeRequest} SetClaimCodeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetClaimCodeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.code = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetClaimCodeRequest;\n            })();\n    \n            ctrl.SetClaimCodeReply = (function() {\n    \n                /**\n                 * Properties of a SetClaimCodeReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetClaimCodeReply\n                 */\n    \n                /**\n                 * Constructs a new SetClaimCodeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetClaimCodeReply.\n                 * @implements ISetClaimCodeReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set\n                 */\n                function SetClaimCodeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetClaimCodeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply instance\n                 */\n                SetClaimCodeReply.create = function create(properties) {\n                    return new SetClaimCodeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetClaimCodeReply message. Does not implicitly {@link particle.ctrl.SetClaimCodeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {particle.ctrl.ISetClaimCodeReply} message SetClaimCodeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetClaimCodeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetClaimCodeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetClaimCodeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetClaimCodeReply} SetClaimCodeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetClaimCodeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetClaimCodeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetClaimCodeReply;\n            })();\n    \n            ctrl.IsClaimedRequest = (function() {\n    \n                /**\n                 * Properties of an IsClaimedRequest.\n                 * @memberof particle.ctrl\n                 * @interface IIsClaimedRequest\n                 */\n    \n                /**\n                 * Constructs a new IsClaimedRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsClaimedRequest.\n                 * @implements IIsClaimedRequest\n                 * @constructor\n                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set\n                 */\n                function IsClaimedRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new IsClaimedRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest instance\n                 */\n                IsClaimedRequest.create = function create(properties) {\n                    return new IsClaimedRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsClaimedRequest message. Does not implicitly {@link particle.ctrl.IsClaimedRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedRequest} message IsClaimedRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsClaimedRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsClaimedRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsClaimedRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsClaimedRequest} IsClaimedRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsClaimedRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsClaimedRequest;\n            })();\n    \n            ctrl.IsClaimedReply = (function() {\n    \n                /**\n                 * Properties of an IsClaimedReply.\n                 * @memberof particle.ctrl\n                 * @interface IIsClaimedReply\n                 * @property {boolean|null} [claimed] IsClaimedReply claimed\n                 */\n    \n                /**\n                 * Constructs a new IsClaimedReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsClaimedReply.\n                 * @implements IIsClaimedReply\n                 * @constructor\n                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set\n                 */\n                function IsClaimedReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IsClaimedReply claimed.\n                 * @member {boolean} claimed\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @instance\n                 */\n                IsClaimedReply.prototype.claimed = false;\n    \n                /**\n                 * Creates a new IsClaimedReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply instance\n                 */\n                IsClaimedReply.create = function create(properties) {\n                    return new IsClaimedReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsClaimedReply message. Does not implicitly {@link particle.ctrl.IsClaimedReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {particle.ctrl.IIsClaimedReply} message IsClaimedReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsClaimedReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.claimed != null && Object.hasOwnProperty.call(message, \"claimed\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.claimed);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsClaimedReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsClaimedReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsClaimedReply} IsClaimedReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsClaimedReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsClaimedReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.claimed = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsClaimedReply;\n            })();\n    \n            ctrl.SetSecurityKeyRequest = (function() {\n    \n                /**\n                 * Properties of a SetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetSecurityKeyRequest\n                 * @property {particle.ctrl.SecurityKeyType|null} [type] SetSecurityKeyRequest type\n                 * @property {Uint8Array|null} [data] SetSecurityKeyRequest data\n                 */\n    \n                /**\n                 * Constructs a new SetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSecurityKeyRequest.\n                 * @implements ISetSecurityKeyRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set\n                 */\n                function SetSecurityKeyRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetSecurityKeyRequest type.\n                 * @member {particle.ctrl.SecurityKeyType} type\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @instance\n                 */\n                SetSecurityKeyRequest.prototype.type = 0;\n    \n                /**\n                 * SetSecurityKeyRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @instance\n                 */\n                SetSecurityKeyRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new SetSecurityKeyRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest instance\n                 */\n                SetSecurityKeyRequest.create = function create(properties) {\n                    return new SetSecurityKeyRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.SetSecurityKeyRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyRequest} message SetSecurityKeyRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSecurityKeyRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSecurityKeyRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSecurityKeyRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSecurityKeyRequest} SetSecurityKeyRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSecurityKeyRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSecurityKeyRequest;\n            })();\n    \n            ctrl.SetSecurityKeyReply = (function() {\n    \n                /**\n                 * Properties of a SetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetSecurityKeyReply\n                 */\n    \n                /**\n                 * Constructs a new SetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSecurityKeyReply.\n                 * @implements ISetSecurityKeyReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set\n                 */\n                function SetSecurityKeyReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetSecurityKeyReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply instance\n                 */\n                SetSecurityKeyReply.create = function create(properties) {\n                    return new SetSecurityKeyReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.SetSecurityKeyReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.ISetSecurityKeyReply} message SetSecurityKeyReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSecurityKeyReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSecurityKeyReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSecurityKeyReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSecurityKeyReply} SetSecurityKeyReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSecurityKeyReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSecurityKeyReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSecurityKeyReply;\n            })();\n    \n            ctrl.GetSecurityKeyRequest = (function() {\n    \n                /**\n                 * Properties of a GetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSecurityKeyRequest\n                 * @property {particle.ctrl.SecurityKeyType|null} [type] GetSecurityKeyRequest type\n                 */\n    \n                /**\n                 * Constructs a new GetSecurityKeyRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSecurityKeyRequest.\n                 * @implements IGetSecurityKeyRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set\n                 */\n                function GetSecurityKeyRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSecurityKeyRequest type.\n                 * @member {particle.ctrl.SecurityKeyType} type\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @instance\n                 */\n                GetSecurityKeyRequest.prototype.type = 0;\n    \n                /**\n                 * Creates a new GetSecurityKeyRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest instance\n                 */\n                GetSecurityKeyRequest.create = function create(properties) {\n                    return new GetSecurityKeyRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSecurityKeyRequest message. Does not implicitly {@link particle.ctrl.GetSecurityKeyRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyRequest} message GetSecurityKeyRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSecurityKeyRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSecurityKeyRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSecurityKeyRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSecurityKeyRequest} GetSecurityKeyRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSecurityKeyRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSecurityKeyRequest;\n            })();\n    \n            ctrl.GetSecurityKeyReply = (function() {\n    \n                /**\n                 * Properties of a GetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSecurityKeyReply\n                 * @property {Uint8Array|null} [data] GetSecurityKeyReply data\n                 */\n    \n                /**\n                 * Constructs a new GetSecurityKeyReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSecurityKeyReply.\n                 * @implements IGetSecurityKeyReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set\n                 */\n                function GetSecurityKeyReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSecurityKeyReply data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @instance\n                 */\n                GetSecurityKeyReply.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new GetSecurityKeyReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply instance\n                 */\n                GetSecurityKeyReply.create = function create(properties) {\n                    return new GetSecurityKeyReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSecurityKeyReply message. Does not implicitly {@link particle.ctrl.GetSecurityKeyReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {particle.ctrl.IGetSecurityKeyReply} message GetSecurityKeyReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSecurityKeyReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSecurityKeyReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSecurityKeyReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSecurityKeyReply} GetSecurityKeyReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSecurityKeyReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSecurityKeyReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSecurityKeyReply;\n            })();\n    \n            ctrl.SetServerAddressRequest = (function() {\n    \n                /**\n                 * Properties of a SetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerAddressRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerAddressRequest protocol\n                 * @property {string|null} [address] SetServerAddressRequest address\n                 * @property {number|null} [port] SetServerAddressRequest port\n                 */\n    \n                /**\n                 * Constructs a new SetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerAddressRequest.\n                 * @implements ISetServerAddressRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set\n                 */\n                function SetServerAddressRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetServerAddressRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.protocol = 0;\n    \n                /**\n                 * SetServerAddressRequest address.\n                 * @member {string} address\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.address = \"\";\n    \n                /**\n                 * SetServerAddressRequest port.\n                 * @member {number} port\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @instance\n                 */\n                SetServerAddressRequest.prototype.port = 0;\n    \n                /**\n                 * Creates a new SetServerAddressRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest instance\n                 */\n                SetServerAddressRequest.create = function create(properties) {\n                    return new SetServerAddressRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerAddressRequest message. Does not implicitly {@link particle.ctrl.SetServerAddressRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressRequest} message SetServerAddressRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerAddressRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.address);\n                    if (message.port != null && Object.hasOwnProperty.call(message, \"port\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.port);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerAddressRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerAddressRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerAddressRequest} SetServerAddressRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerAddressRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        case 2:\n                            message.address = reader.string();\n                            break;\n                        case 3:\n                            message.port = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerAddressRequest;\n            })();\n    \n            ctrl.SetServerAddressReply = (function() {\n    \n                /**\n                 * Properties of a SetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerAddressReply\n                 */\n    \n                /**\n                 * Constructs a new SetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerAddressReply.\n                 * @implements ISetServerAddressReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set\n                 */\n                function SetServerAddressReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetServerAddressReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply instance\n                 */\n                SetServerAddressReply.create = function create(properties) {\n                    return new SetServerAddressReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerAddressReply message. Does not implicitly {@link particle.ctrl.SetServerAddressReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerAddressReply} message SetServerAddressReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerAddressReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerAddressReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerAddressReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerAddressReply} SetServerAddressReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerAddressReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerAddressReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerAddressReply;\n            })();\n    \n            ctrl.GetServerAddressRequest = (function() {\n    \n                /**\n                 * Properties of a GetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerAddressRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerAddressRequest protocol\n                 */\n    \n                /**\n                 * Constructs a new GetServerAddressRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerAddressRequest.\n                 * @implements IGetServerAddressRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set\n                 */\n                function GetServerAddressRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerAddressRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @instance\n                 */\n                GetServerAddressRequest.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new GetServerAddressRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest instance\n                 */\n                GetServerAddressRequest.create = function create(properties) {\n                    return new GetServerAddressRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerAddressRequest message. Does not implicitly {@link particle.ctrl.GetServerAddressRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressRequest} message GetServerAddressRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerAddressRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerAddressRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerAddressRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerAddressRequest} GetServerAddressRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerAddressRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerAddressRequest;\n            })();\n    \n            ctrl.GetServerAddressReply = (function() {\n    \n                /**\n                 * Properties of a GetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerAddressReply\n                 * @property {string|null} [address] GetServerAddressReply address\n                 * @property {number|null} [port] GetServerAddressReply port\n                 */\n    \n                /**\n                 * Constructs a new GetServerAddressReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerAddressReply.\n                 * @implements IGetServerAddressReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set\n                 */\n                function GetServerAddressReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerAddressReply address.\n                 * @member {string} address\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @instance\n                 */\n                GetServerAddressReply.prototype.address = \"\";\n    \n                /**\n                 * GetServerAddressReply port.\n                 * @member {number} port\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @instance\n                 */\n                GetServerAddressReply.prototype.port = 0;\n    \n                /**\n                 * Creates a new GetServerAddressReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply instance\n                 */\n                GetServerAddressReply.create = function create(properties) {\n                    return new GetServerAddressReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerAddressReply message. Does not implicitly {@link particle.ctrl.GetServerAddressReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerAddressReply} message GetServerAddressReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerAddressReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.address);\n                    if (message.port != null && Object.hasOwnProperty.call(message, \"port\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.port);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerAddressReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerAddressReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerAddressReply} GetServerAddressReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerAddressReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerAddressReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = reader.string();\n                            break;\n                        case 2:\n                            message.port = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerAddressReply;\n            })();\n    \n            ctrl.SetServerProtocolRequest = (function() {\n    \n                /**\n                 * Properties of a SetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerProtocolRequest\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] SetServerProtocolRequest protocol\n                 */\n    \n                /**\n                 * Constructs a new SetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerProtocolRequest.\n                 * @implements ISetServerProtocolRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set\n                 */\n                function SetServerProtocolRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetServerProtocolRequest protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @instance\n                 */\n                SetServerProtocolRequest.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new SetServerProtocolRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest instance\n                 */\n                SetServerProtocolRequest.create = function create(properties) {\n                    return new SetServerProtocolRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.SetServerProtocolRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolRequest} message SetServerProtocolRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerProtocolRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerProtocolRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerProtocolRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerProtocolRequest} SetServerProtocolRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerProtocolRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerProtocolRequest;\n            })();\n    \n            ctrl.SetServerProtocolReply = (function() {\n    \n                /**\n                 * Properties of a SetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetServerProtocolReply\n                 */\n    \n                /**\n                 * Constructs a new SetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetServerProtocolReply.\n                 * @implements ISetServerProtocolReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set\n                 */\n                function SetServerProtocolReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetServerProtocolReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply instance\n                 */\n                SetServerProtocolReply.create = function create(properties) {\n                    return new SetServerProtocolReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetServerProtocolReply message. Does not implicitly {@link particle.ctrl.SetServerProtocolReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.ISetServerProtocolReply} message SetServerProtocolReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetServerProtocolReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetServerProtocolReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetServerProtocolReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetServerProtocolReply} SetServerProtocolReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetServerProtocolReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetServerProtocolReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetServerProtocolReply;\n            })();\n    \n            ctrl.GetServerProtocolRequest = (function() {\n    \n                /**\n                 * Properties of a GetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerProtocolRequest\n                 */\n    \n                /**\n                 * Constructs a new GetServerProtocolRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerProtocolRequest.\n                 * @implements IGetServerProtocolRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set\n                 */\n                function GetServerProtocolRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetServerProtocolRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest instance\n                 */\n                GetServerProtocolRequest.create = function create(properties) {\n                    return new GetServerProtocolRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerProtocolRequest message. Does not implicitly {@link particle.ctrl.GetServerProtocolRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolRequest} message GetServerProtocolRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerProtocolRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerProtocolRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerProtocolRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerProtocolRequest} GetServerProtocolRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerProtocolRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerProtocolRequest;\n            })();\n    \n            ctrl.GetServerProtocolReply = (function() {\n    \n                /**\n                 * Properties of a GetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetServerProtocolReply\n                 * @property {particle.ctrl.ServerProtocolType|null} [protocol] GetServerProtocolReply protocol\n                 */\n    \n                /**\n                 * Constructs a new GetServerProtocolReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetServerProtocolReply.\n                 * @implements IGetServerProtocolReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set\n                 */\n                function GetServerProtocolReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetServerProtocolReply protocol.\n                 * @member {particle.ctrl.ServerProtocolType} protocol\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @instance\n                 */\n                GetServerProtocolReply.prototype.protocol = 0;\n    \n                /**\n                 * Creates a new GetServerProtocolReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply instance\n                 */\n                GetServerProtocolReply.create = function create(properties) {\n                    return new GetServerProtocolReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetServerProtocolReply message. Does not implicitly {@link particle.ctrl.GetServerProtocolReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {particle.ctrl.IGetServerProtocolReply} message GetServerProtocolReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetServerProtocolReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.protocol != null && Object.hasOwnProperty.call(message, \"protocol\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.protocol);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetServerProtocolReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetServerProtocolReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetServerProtocolReply} GetServerProtocolReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetServerProtocolReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetServerProtocolReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.protocol = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetServerProtocolReply;\n            })();\n    \n            ctrl.SetSoftApSsidRequest = (function() {\n    \n                /**\n                 * Properties of a SetSoftApSsidRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetSoftApSsidRequest\n                 * @property {string|null} [prefix] SetSoftApSsidRequest prefix\n                 * @property {string|null} [suffix] SetSoftApSsidRequest suffix\n                 */\n    \n                /**\n                 * Constructs a new SetSoftApSsidRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSoftApSsidRequest.\n                 * @implements ISetSoftApSsidRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set\n                 */\n                function SetSoftApSsidRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetSoftApSsidRequest prefix.\n                 * @member {string} prefix\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @instance\n                 */\n                SetSoftApSsidRequest.prototype.prefix = \"\";\n    \n                /**\n                 * SetSoftApSsidRequest suffix.\n                 * @member {string} suffix\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @instance\n                 */\n                SetSoftApSsidRequest.prototype.suffix = \"\";\n    \n                /**\n                 * Creates a new SetSoftApSsidRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest instance\n                 */\n                SetSoftApSsidRequest.create = function create(properties) {\n                    return new SetSoftApSsidRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSoftApSsidRequest message. Does not implicitly {@link particle.ctrl.SetSoftApSsidRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidRequest} message SetSoftApSsidRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSoftApSsidRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.prefix != null && Object.hasOwnProperty.call(message, \"prefix\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.prefix);\n                    if (message.suffix != null && Object.hasOwnProperty.call(message, \"suffix\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.suffix);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSoftApSsidRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSoftApSsidRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSoftApSsidRequest} SetSoftApSsidRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSoftApSsidRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.prefix = reader.string();\n                            break;\n                        case 2:\n                            message.suffix = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSoftApSsidRequest;\n            })();\n    \n            ctrl.SetSoftApSsidReply = (function() {\n    \n                /**\n                 * Properties of a SetSoftApSsidReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetSoftApSsidReply\n                 */\n    \n                /**\n                 * Constructs a new SetSoftApSsidReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetSoftApSsidReply.\n                 * @implements ISetSoftApSsidReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set\n                 */\n                function SetSoftApSsidReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetSoftApSsidReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply instance\n                 */\n                SetSoftApSsidReply.create = function create(properties) {\n                    return new SetSoftApSsidReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetSoftApSsidReply message. Does not implicitly {@link particle.ctrl.SetSoftApSsidReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {particle.ctrl.ISetSoftApSsidReply} message SetSoftApSsidReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetSoftApSsidReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetSoftApSsidReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetSoftApSsidReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetSoftApSsidReply} SetSoftApSsidReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetSoftApSsidReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetSoftApSsidReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetSoftApSsidReply;\n            })();\n    \n            ctrl.StartListeningModeRequest = (function() {\n    \n                /**\n                 * Properties of a StartListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartListeningModeRequest\n                 */\n    \n                /**\n                 * Constructs a new StartListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartListeningModeRequest.\n                 * @implements IStartListeningModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set\n                 */\n                function StartListeningModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartListeningModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest instance\n                 */\n                StartListeningModeRequest.create = function create(properties) {\n                    return new StartListeningModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartListeningModeRequest message. Does not implicitly {@link particle.ctrl.StartListeningModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeRequest} message StartListeningModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartListeningModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartListeningModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartListeningModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartListeningModeRequest} StartListeningModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartListeningModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartListeningModeRequest;\n            })();\n    \n            ctrl.StartListeningModeReply = (function() {\n    \n                /**\n                 * Properties of a StartListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartListeningModeReply\n                 */\n    \n                /**\n                 * Constructs a new StartListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartListeningModeReply.\n                 * @implements IStartListeningModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set\n                 */\n                function StartListeningModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartListeningModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply instance\n                 */\n                StartListeningModeReply.create = function create(properties) {\n                    return new StartListeningModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartListeningModeReply message. Does not implicitly {@link particle.ctrl.StartListeningModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStartListeningModeReply} message StartListeningModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartListeningModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartListeningModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartListeningModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartListeningModeReply} StartListeningModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartListeningModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartListeningModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartListeningModeReply;\n            })();\n    \n            ctrl.StopListeningModeRequest = (function() {\n    \n                /**\n                 * Properties of a StopListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStopListeningModeRequest\n                 */\n    \n                /**\n                 * Constructs a new StopListeningModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopListeningModeRequest.\n                 * @implements IStopListeningModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set\n                 */\n                function StopListeningModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopListeningModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest instance\n                 */\n                StopListeningModeRequest.create = function create(properties) {\n                    return new StopListeningModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopListeningModeRequest message. Does not implicitly {@link particle.ctrl.StopListeningModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeRequest} message StopListeningModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopListeningModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopListeningModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopListeningModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopListeningModeRequest} StopListeningModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopListeningModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopListeningModeRequest;\n            })();\n    \n            ctrl.StopListeningModeReply = (function() {\n    \n                /**\n                 * Properties of a StopListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IStopListeningModeReply\n                 */\n    \n                /**\n                 * Constructs a new StopListeningModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopListeningModeReply.\n                 * @implements IStopListeningModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set\n                 */\n                function StopListeningModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopListeningModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply instance\n                 */\n                StopListeningModeReply.create = function create(properties) {\n                    return new StopListeningModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopListeningModeReply message. Does not implicitly {@link particle.ctrl.StopListeningModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {particle.ctrl.IStopListeningModeReply} message StopListeningModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopListeningModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopListeningModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopListeningModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopListeningModeReply} StopListeningModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopListeningModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopListeningModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopListeningModeReply;\n            })();\n    \n            ctrl.GetDeviceModeRequest = (function() {\n    \n                /**\n                 * Properties of a GetDeviceModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceModeRequest\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceModeRequest.\n                 * @implements IGetDeviceModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set\n                 */\n                function GetDeviceModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetDeviceModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest instance\n                 */\n                GetDeviceModeRequest.create = function create(properties) {\n                    return new GetDeviceModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceModeRequest message. Does not implicitly {@link particle.ctrl.GetDeviceModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeRequest} message GetDeviceModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceModeRequest} GetDeviceModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceModeRequest;\n            })();\n    \n            ctrl.GetDeviceModeReply = (function() {\n    \n                /**\n                 * Properties of a GetDeviceModeReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetDeviceModeReply\n                 * @property {particle.ctrl.DeviceMode|null} [mode] GetDeviceModeReply mode\n                 */\n    \n                /**\n                 * Constructs a new GetDeviceModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetDeviceModeReply.\n                 * @implements IGetDeviceModeReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set\n                 */\n                function GetDeviceModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetDeviceModeReply mode.\n                 * @member {particle.ctrl.DeviceMode} mode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @instance\n                 */\n                GetDeviceModeReply.prototype.mode = 0;\n    \n                /**\n                 * Creates a new GetDeviceModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply instance\n                 */\n                GetDeviceModeReply.create = function create(properties) {\n                    return new GetDeviceModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetDeviceModeReply message. Does not implicitly {@link particle.ctrl.GetDeviceModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {particle.ctrl.IGetDeviceModeReply} message GetDeviceModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetDeviceModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetDeviceModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetDeviceModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetDeviceModeReply} GetDeviceModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetDeviceModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetDeviceModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.mode = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetDeviceModeReply;\n            })();\n    \n            ctrl.SetDeviceSetupDoneRequest = (function() {\n    \n                /**\n                 * Properties of a SetDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetDeviceSetupDoneRequest\n                 * @property {boolean|null} [done] SetDeviceSetupDoneRequest done\n                 */\n    \n                /**\n                 * Constructs a new SetDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetDeviceSetupDoneRequest.\n                 * @implements ISetDeviceSetupDoneRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set\n                 */\n                function SetDeviceSetupDoneRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetDeviceSetupDoneRequest done.\n                 * @member {boolean} done\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @instance\n                 */\n                SetDeviceSetupDoneRequest.prototype.done = false;\n    \n                /**\n                 * Creates a new SetDeviceSetupDoneRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest instance\n                 */\n                SetDeviceSetupDoneRequest.create = function create(properties) {\n                    return new SetDeviceSetupDoneRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneRequest} message SetDeviceSetupDoneRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetDeviceSetupDoneRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.done != null && Object.hasOwnProperty.call(message, \"done\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetDeviceSetupDoneRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetDeviceSetupDoneRequest} SetDeviceSetupDoneRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetDeviceSetupDoneRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.done = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.SetDeviceSetupDoneReply = (function() {\n    \n                /**\n                 * Properties of a SetDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetDeviceSetupDoneReply\n                 */\n    \n                /**\n                 * Constructs a new SetDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetDeviceSetupDoneReply.\n                 * @implements ISetDeviceSetupDoneReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set\n                 */\n                function SetDeviceSetupDoneReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetDeviceSetupDoneReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply instance\n                 */\n                SetDeviceSetupDoneReply.create = function create(properties) {\n                    return new SetDeviceSetupDoneReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.SetDeviceSetupDoneReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.ISetDeviceSetupDoneReply} message SetDeviceSetupDoneReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetDeviceSetupDoneReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetDeviceSetupDoneReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetDeviceSetupDoneReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetDeviceSetupDoneReply} SetDeviceSetupDoneReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetDeviceSetupDoneReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetDeviceSetupDoneReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetDeviceSetupDoneReply;\n            })();\n    \n            ctrl.IsDeviceSetupDoneRequest = (function() {\n    \n                /**\n                 * Properties of an IsDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @interface IIsDeviceSetupDoneRequest\n                 */\n    \n                /**\n                 * Constructs a new IsDeviceSetupDoneRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsDeviceSetupDoneRequest.\n                 * @implements IIsDeviceSetupDoneRequest\n                 * @constructor\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set\n                 */\n                function IsDeviceSetupDoneRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new IsDeviceSetupDoneRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest instance\n                 */\n                IsDeviceSetupDoneRequest.create = function create(properties) {\n                    return new IsDeviceSetupDoneRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsDeviceSetupDoneRequest message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneRequest} message IsDeviceSetupDoneRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsDeviceSetupDoneRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsDeviceSetupDoneRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsDeviceSetupDoneRequest} IsDeviceSetupDoneRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsDeviceSetupDoneRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsDeviceSetupDoneRequest;\n            })();\n    \n            ctrl.IsDeviceSetupDoneReply = (function() {\n    \n                /**\n                 * Properties of an IsDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @interface IIsDeviceSetupDoneReply\n                 * @property {boolean|null} [done] IsDeviceSetupDoneReply done\n                 */\n    \n                /**\n                 * Constructs a new IsDeviceSetupDoneReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an IsDeviceSetupDoneReply.\n                 * @implements IIsDeviceSetupDoneReply\n                 * @constructor\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set\n                 */\n                function IsDeviceSetupDoneReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IsDeviceSetupDoneReply done.\n                 * @member {boolean} done\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @instance\n                 */\n                IsDeviceSetupDoneReply.prototype.done = false;\n    \n                /**\n                 * Creates a new IsDeviceSetupDoneReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply instance\n                 */\n                IsDeviceSetupDoneReply.create = function create(properties) {\n                    return new IsDeviceSetupDoneReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified IsDeviceSetupDoneReply message. Does not implicitly {@link particle.ctrl.IsDeviceSetupDoneReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {particle.ctrl.IIsDeviceSetupDoneReply} message IsDeviceSetupDoneReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IsDeviceSetupDoneReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.done != null && Object.hasOwnProperty.call(message, \"done\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.done);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an IsDeviceSetupDoneReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IsDeviceSetupDoneReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IsDeviceSetupDoneReply} IsDeviceSetupDoneReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IsDeviceSetupDoneReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IsDeviceSetupDoneReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.done = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return IsDeviceSetupDoneReply;\n            })();\n    \n            ctrl.SetStartupModeRequest = (function() {\n    \n                /**\n                 * Properties of a SetStartupModeRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetStartupModeRequest\n                 * @property {particle.ctrl.DeviceMode|null} [mode] SetStartupModeRequest mode\n                 */\n    \n                /**\n                 * Constructs a new SetStartupModeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetStartupModeRequest.\n                 * @implements ISetStartupModeRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set\n                 */\n                function SetStartupModeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetStartupModeRequest mode.\n                 * @member {particle.ctrl.DeviceMode} mode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @instance\n                 */\n                SetStartupModeRequest.prototype.mode = 0;\n    \n                /**\n                 * Creates a new SetStartupModeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest instance\n                 */\n                SetStartupModeRequest.create = function create(properties) {\n                    return new SetStartupModeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetStartupModeRequest message. Does not implicitly {@link particle.ctrl.SetStartupModeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeRequest} message SetStartupModeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetStartupModeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.mode);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetStartupModeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetStartupModeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetStartupModeRequest} SetStartupModeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetStartupModeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.mode = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetStartupModeRequest;\n            })();\n    \n            ctrl.SetStartupModeReply = (function() {\n    \n                /**\n                 * Properties of a SetStartupModeReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetStartupModeReply\n                 */\n    \n                /**\n                 * Constructs a new SetStartupModeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetStartupModeReply.\n                 * @implements ISetStartupModeReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set\n                 */\n                function SetStartupModeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetStartupModeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply instance\n                 */\n                SetStartupModeReply.create = function create(properties) {\n                    return new SetStartupModeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetStartupModeReply message. Does not implicitly {@link particle.ctrl.SetStartupModeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {particle.ctrl.ISetStartupModeReply} message SetStartupModeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetStartupModeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetStartupModeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetStartupModeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetStartupModeReply} SetStartupModeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetStartupModeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetStartupModeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetStartupModeReply;\n            })();\n    \n            ctrl.SystemResetRequest = (function() {\n    \n                /**\n                 * Properties of a SystemResetRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISystemResetRequest\n                 */\n    \n                /**\n                 * Constructs a new SystemResetRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SystemResetRequest.\n                 * @implements ISystemResetRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set\n                 */\n                function SystemResetRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SystemResetRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {particle.ctrl.ISystemResetRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest instance\n                 */\n                SystemResetRequest.create = function create(properties) {\n                    return new SystemResetRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SystemResetRequest message. Does not implicitly {@link particle.ctrl.SystemResetRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {particle.ctrl.ISystemResetRequest} message SystemResetRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SystemResetRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SystemResetRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SystemResetRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SystemResetRequest} SystemResetRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SystemResetRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SystemResetRequest;\n            })();\n    \n            ctrl.SystemResetReply = (function() {\n    \n                /**\n                 * Properties of a SystemResetReply.\n                 * @memberof particle.ctrl\n                 * @interface ISystemResetReply\n                 */\n    \n                /**\n                 * Constructs a new SystemResetReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SystemResetReply.\n                 * @implements ISystemResetReply\n                 * @constructor\n                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set\n                 */\n                function SystemResetReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SystemResetReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {particle.ctrl.ISystemResetReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply instance\n                 */\n                SystemResetReply.create = function create(properties) {\n                    return new SystemResetReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SystemResetReply message. Does not implicitly {@link particle.ctrl.SystemResetReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {particle.ctrl.ISystemResetReply} message SystemResetReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SystemResetReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SystemResetReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SystemResetReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SystemResetReply} SystemResetReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SystemResetReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SystemResetReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SystemResetReply;\n            })();\n    \n            ctrl.SetFeatureRequest = (function() {\n    \n                /**\n                 * Properties of a SetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @interface ISetFeatureRequest\n                 * @property {particle.ctrl.Feature|null} [feature] SetFeatureRequest feature\n                 * @property {boolean|null} [enabled] SetFeatureRequest enabled\n                 */\n    \n                /**\n                 * Constructs a new SetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetFeatureRequest.\n                 * @implements ISetFeatureRequest\n                 * @constructor\n                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set\n                 */\n                function SetFeatureRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SetFeatureRequest feature.\n                 * @member {particle.ctrl.Feature} feature\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @instance\n                 */\n                SetFeatureRequest.prototype.feature = 0;\n    \n                /**\n                 * SetFeatureRequest enabled.\n                 * @member {boolean} enabled\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @instance\n                 */\n                SetFeatureRequest.prototype.enabled = false;\n    \n                /**\n                 * Creates a new SetFeatureRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest instance\n                 */\n                SetFeatureRequest.create = function create(properties) {\n                    return new SetFeatureRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetFeatureRequest message. Does not implicitly {@link particle.ctrl.SetFeatureRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureRequest} message SetFeatureRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetFeatureRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.feature != null && Object.hasOwnProperty.call(message, \"feature\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);\n                    if (message.enabled != null && Object.hasOwnProperty.call(message, \"enabled\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.enabled);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetFeatureRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetFeatureRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetFeatureRequest} SetFeatureRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetFeatureRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.feature = reader.int32();\n                            break;\n                        case 2:\n                            message.enabled = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetFeatureRequest;\n            })();\n    \n            ctrl.SetFeatureReply = (function() {\n    \n                /**\n                 * Properties of a SetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @interface ISetFeatureReply\n                 */\n    \n                /**\n                 * Constructs a new SetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a SetFeatureReply.\n                 * @implements ISetFeatureReply\n                 * @constructor\n                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set\n                 */\n                function SetFeatureReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new SetFeatureReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply instance\n                 */\n                SetFeatureReply.create = function create(properties) {\n                    return new SetFeatureReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified SetFeatureReply message. Does not implicitly {@link particle.ctrl.SetFeatureReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.ISetFeatureReply} message SetFeatureReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SetFeatureReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SetFeatureReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.SetFeatureReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.SetFeatureReply} SetFeatureReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SetFeatureReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.SetFeatureReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return SetFeatureReply;\n            })();\n    \n            ctrl.GetFeatureRequest = (function() {\n    \n                /**\n                 * Properties of a GetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetFeatureRequest\n                 * @property {particle.ctrl.Feature|null} [feature] GetFeatureRequest feature\n                 */\n    \n                /**\n                 * Constructs a new GetFeatureRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetFeatureRequest.\n                 * @implements IGetFeatureRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set\n                 */\n                function GetFeatureRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetFeatureRequest feature.\n                 * @member {particle.ctrl.Feature} feature\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @instance\n                 */\n                GetFeatureRequest.prototype.feature = 0;\n    \n                /**\n                 * Creates a new GetFeatureRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest instance\n                 */\n                GetFeatureRequest.create = function create(properties) {\n                    return new GetFeatureRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetFeatureRequest message. Does not implicitly {@link particle.ctrl.GetFeatureRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureRequest} message GetFeatureRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetFeatureRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.feature != null && Object.hasOwnProperty.call(message, \"feature\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.feature);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetFeatureRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetFeatureRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetFeatureRequest} GetFeatureRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetFeatureRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.feature = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetFeatureRequest;\n            })();\n    \n            ctrl.GetFeatureReply = (function() {\n    \n                /**\n                 * Properties of a GetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetFeatureReply\n                 * @property {boolean|null} [enabled] GetFeatureReply enabled\n                 */\n    \n                /**\n                 * Constructs a new GetFeatureReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetFeatureReply.\n                 * @implements IGetFeatureReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set\n                 */\n                function GetFeatureReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetFeatureReply enabled.\n                 * @member {boolean} enabled\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @instance\n                 */\n                GetFeatureReply.prototype.enabled = false;\n    \n                /**\n                 * Creates a new GetFeatureReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply instance\n                 */\n                GetFeatureReply.create = function create(properties) {\n                    return new GetFeatureReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetFeatureReply message. Does not implicitly {@link particle.ctrl.GetFeatureReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {particle.ctrl.IGetFeatureReply} message GetFeatureReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetFeatureReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.enabled != null && Object.hasOwnProperty.call(message, \"enabled\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enabled);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetFeatureReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetFeatureReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetFeatureReply} GetFeatureReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetFeatureReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetFeatureReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.enabled = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetFeatureReply;\n            })();\n    \n            ctrl.StartNyanSignalRequest = (function() {\n    \n                /**\n                 * Properties of a StartNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartNyanSignalRequest\n                 */\n    \n                /**\n                 * Constructs a new StartNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartNyanSignalRequest.\n                 * @implements IStartNyanSignalRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set\n                 */\n                function StartNyanSignalRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartNyanSignalRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest instance\n                 */\n                StartNyanSignalRequest.create = function create(properties) {\n                    return new StartNyanSignalRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StartNyanSignalRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalRequest} message StartNyanSignalRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartNyanSignalRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartNyanSignalRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartNyanSignalRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartNyanSignalRequest} StartNyanSignalRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartNyanSignalRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartNyanSignalRequest;\n            })();\n    \n            ctrl.StartNyanSignalReply = (function() {\n    \n                /**\n                 * Properties of a StartNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartNyanSignalReply\n                 */\n    \n                /**\n                 * Constructs a new StartNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartNyanSignalReply.\n                 * @implements IStartNyanSignalReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set\n                 */\n                function StartNyanSignalReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StartNyanSignalReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply instance\n                 */\n                StartNyanSignalReply.create = function create(properties) {\n                    return new StartNyanSignalReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartNyanSignalReply message. Does not implicitly {@link particle.ctrl.StartNyanSignalReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStartNyanSignalReply} message StartNyanSignalReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartNyanSignalReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartNyanSignalReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartNyanSignalReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartNyanSignalReply} StartNyanSignalReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartNyanSignalReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartNyanSignalReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartNyanSignalReply;\n            })();\n    \n            ctrl.StopNyanSignalRequest = (function() {\n    \n                /**\n                 * Properties of a StopNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStopNyanSignalRequest\n                 */\n    \n                /**\n                 * Constructs a new StopNyanSignalRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopNyanSignalRequest.\n                 * @implements IStopNyanSignalRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set\n                 */\n                function StopNyanSignalRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopNyanSignalRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest instance\n                 */\n                StopNyanSignalRequest.create = function create(properties) {\n                    return new StopNyanSignalRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopNyanSignalRequest message. Does not implicitly {@link particle.ctrl.StopNyanSignalRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalRequest} message StopNyanSignalRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopNyanSignalRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopNyanSignalRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopNyanSignalRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopNyanSignalRequest} StopNyanSignalRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopNyanSignalRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopNyanSignalRequest;\n            })();\n    \n            ctrl.StopNyanSignalReply = (function() {\n    \n                /**\n                 * Properties of a StopNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @interface IStopNyanSignalReply\n                 */\n    \n                /**\n                 * Constructs a new StopNyanSignalReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StopNyanSignalReply.\n                 * @implements IStopNyanSignalReply\n                 * @constructor\n                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set\n                 */\n                function StopNyanSignalReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new StopNyanSignalReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply instance\n                 */\n                StopNyanSignalReply.create = function create(properties) {\n                    return new StopNyanSignalReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StopNyanSignalReply message. Does not implicitly {@link particle.ctrl.StopNyanSignalReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {particle.ctrl.IStopNyanSignalReply} message StopNyanSignalReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StopNyanSignalReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StopNyanSignalReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StopNyanSignalReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StopNyanSignalReply} StopNyanSignalReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StopNyanSignalReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StopNyanSignalReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StopNyanSignalReply;\n            })();\n    \n            ctrl.WiFiGetAntennaRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiGetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetAntennaRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetAntennaRequest.\n                 * @implements IWiFiGetAntennaRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set\n                 */\n                function WiFiGetAntennaRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiGetAntennaRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest instance\n                 */\n                WiFiGetAntennaRequest.create = function create(properties) {\n                    return new WiFiGetAntennaRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaRequest} message WiFiGetAntennaRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetAntennaRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetAntennaRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetAntennaRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetAntennaRequest} WiFiGetAntennaRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetAntennaRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetAntennaRequest;\n            })();\n    \n            ctrl.WiFiGetAntennaReply = (function() {\n    \n                /**\n                 * Properties of a WiFiGetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetAntennaReply\n                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiGetAntennaReply antenna\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetAntennaReply.\n                 * @implements IWiFiGetAntennaReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set\n                 */\n                function WiFiGetAntennaReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiGetAntennaReply antenna.\n                 * @member {particle.ctrl.WiFiAntenna} antenna\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @instance\n                 */\n                WiFiGetAntennaReply.prototype.antenna = 0;\n    \n                /**\n                 * Creates a new WiFiGetAntennaReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply instance\n                 */\n                WiFiGetAntennaReply.create = function create(properties) {\n                    return new WiFiGetAntennaReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiGetAntennaReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetAntennaReply} message WiFiGetAntennaReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetAntennaReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.antenna != null && Object.hasOwnProperty.call(message, \"antenna\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetAntennaReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetAntennaReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetAntennaReply} WiFiGetAntennaReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetAntennaReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetAntennaReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.antenna = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetAntennaReply;\n            })();\n    \n            ctrl.WiFiSetAntennaRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiSetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetAntennaRequest\n                 * @property {particle.ctrl.WiFiAntenna|null} [antenna] WiFiSetAntennaRequest antenna\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetAntennaRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetAntennaRequest.\n                 * @implements IWiFiSetAntennaRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set\n                 */\n                function WiFiSetAntennaRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiSetAntennaRequest antenna.\n                 * @member {particle.ctrl.WiFiAntenna} antenna\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @instance\n                 */\n                WiFiSetAntennaRequest.prototype.antenna = 0;\n    \n                /**\n                 * Creates a new WiFiSetAntennaRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest instance\n                 */\n                WiFiSetAntennaRequest.create = function create(properties) {\n                    return new WiFiSetAntennaRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetAntennaRequest message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaRequest} message WiFiSetAntennaRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetAntennaRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.antenna != null && Object.hasOwnProperty.call(message, \"antenna\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.antenna);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetAntennaRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetAntennaRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetAntennaRequest} WiFiSetAntennaRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetAntennaRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.antenna = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetAntennaRequest;\n            })();\n    \n            ctrl.WiFiSetAntennaReply = (function() {\n    \n                /**\n                 * Properties of a WiFiSetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetAntennaReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetAntennaReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetAntennaReply.\n                 * @implements IWiFiSetAntennaReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set\n                 */\n                function WiFiSetAntennaReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiSetAntennaReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply instance\n                 */\n                WiFiSetAntennaReply.create = function create(properties) {\n                    return new WiFiSetAntennaReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetAntennaReply message. Does not implicitly {@link particle.ctrl.WiFiSetAntennaReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetAntennaReply} message WiFiSetAntennaReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetAntennaReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetAntennaReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetAntennaReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetAntennaReply} WiFiSetAntennaReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetAntennaReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetAntennaReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetAntennaReply;\n            })();\n    \n            ctrl.WiFiScanRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiScanRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiScanRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiScanRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiScanRequest.\n                 * @implements IWiFiScanRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set\n                 */\n                function WiFiScanRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiScanRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest instance\n                 */\n                WiFiScanRequest.create = function create(properties) {\n                    return new WiFiScanRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiScanRequest message. Does not implicitly {@link particle.ctrl.WiFiScanRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanRequest} message WiFiScanRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiScanRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiScanRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiScanRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiScanRequest} WiFiScanRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiScanRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiScanRequest;\n            })();\n    \n            ctrl.WiFiScanReply = (function() {\n    \n                /**\n                 * Properties of a WiFiScanReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiScanReply\n                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiScanReply list\n                 */\n    \n                /**\n                 * Constructs a new WiFiScanReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiScanReply.\n                 * @implements IWiFiScanReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set\n                 */\n                function WiFiScanReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiScanReply list.\n                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @instance\n                 */\n                WiFiScanReply.prototype.list = null;\n    \n                /**\n                 * Creates a new WiFiScanReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply instance\n                 */\n                WiFiScanReply.create = function create(properties) {\n                    return new WiFiScanReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiScanReply message. Does not implicitly {@link particle.ctrl.WiFiScanReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiScanReply} message WiFiScanReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiScanReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.list != null && Object.hasOwnProperty.call(message, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiScanReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiScanReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiScanReply} WiFiScanReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiScanReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiScanReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiScanReply;\n            })();\n    \n            ctrl.WiFiGetCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiGetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetCredentialsRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetCredentialsRequest.\n                 * @implements IWiFiGetCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiGetCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiGetCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest instance\n                 */\n                WiFiGetCredentialsRequest.create = function create(properties) {\n                    return new WiFiGetCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsRequest} message WiFiGetCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetCredentialsRequest} WiFiGetCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiGetCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiGetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiGetCredentialsReply\n                 * @property {particle.ctrl.IWiFiAccessPointList|null} [list] WiFiGetCredentialsReply list\n                 */\n    \n                /**\n                 * Constructs a new WiFiGetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiGetCredentialsReply.\n                 * @implements IWiFiGetCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiGetCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiGetCredentialsReply list.\n                 * @member {particle.ctrl.IWiFiAccessPointList|null|undefined} list\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @instance\n                 */\n                WiFiGetCredentialsReply.prototype.list = null;\n    \n                /**\n                 * Creates a new WiFiGetCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply instance\n                 */\n                WiFiGetCredentialsReply.create = function create(properties) {\n                    return new WiFiGetCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiGetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiGetCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiGetCredentialsReply} message WiFiGetCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiGetCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.list != null && Object.hasOwnProperty.call(message, \"list\"))\n                        $root.particle.ctrl.WiFiAccessPointList.encode(message.list, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiGetCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiGetCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiGetCredentialsReply} WiFiGetCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiGetCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiGetCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.list = $root.particle.ctrl.WiFiAccessPointList.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiGetCredentialsReply;\n            })();\n    \n            ctrl.WiFiSetCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiSetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetCredentialsRequest\n                 * @property {particle.ctrl.IWiFiAccessPoint|null} [ap] WiFiSetCredentialsRequest ap\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetCredentialsRequest.\n                 * @implements IWiFiSetCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiSetCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiSetCredentialsRequest ap.\n                 * @member {particle.ctrl.IWiFiAccessPoint|null|undefined} ap\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @instance\n                 */\n                WiFiSetCredentialsRequest.prototype.ap = null;\n    \n                /**\n                 * Creates a new WiFiSetCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest instance\n                 */\n                WiFiSetCredentialsRequest.create = function create(properties) {\n                    return new WiFiSetCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsRequest} message WiFiSetCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ap != null && Object.hasOwnProperty.call(message, \"ap\"))\n                        $root.particle.ctrl.WiFiAccessPoint.encode(message.ap, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetCredentialsRequest} WiFiSetCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ap = $root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetCredentialsRequest;\n            })();\n    \n            ctrl.WiFiSetCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiSetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiSetCredentialsReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiSetCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiSetCredentialsReply.\n                 * @implements IWiFiSetCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiSetCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiSetCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply instance\n                 */\n                WiFiSetCredentialsReply.create = function create(properties) {\n                    return new WiFiSetCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiSetCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiSetCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiSetCredentialsReply} message WiFiSetCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiSetCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiSetCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiSetCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiSetCredentialsReply} WiFiSetCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiSetCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiSetCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiSetCredentialsReply;\n            })();\n    \n            ctrl.WiFiClearCredentialsRequest = (function() {\n    \n                /**\n                 * Properties of a WiFiClearCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiClearCredentialsRequest\n                 */\n    \n                /**\n                 * Constructs a new WiFiClearCredentialsRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiClearCredentialsRequest.\n                 * @implements IWiFiClearCredentialsRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set\n                 */\n                function WiFiClearCredentialsRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiClearCredentialsRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest instance\n                 */\n                WiFiClearCredentialsRequest.create = function create(properties) {\n                    return new WiFiClearCredentialsRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiClearCredentialsRequest message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsRequest} message WiFiClearCredentialsRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiClearCredentialsRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiClearCredentialsRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiClearCredentialsRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiClearCredentialsRequest} WiFiClearCredentialsRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiClearCredentialsRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiClearCredentialsRequest;\n            })();\n    \n            ctrl.WiFiClearCredentialsReply = (function() {\n    \n                /**\n                 * Properties of a WiFiClearCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiClearCredentialsReply\n                 */\n    \n                /**\n                 * Constructs a new WiFiClearCredentialsReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiClearCredentialsReply.\n                 * @implements IWiFiClearCredentialsReply\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set\n                 */\n                function WiFiClearCredentialsReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WiFiClearCredentialsReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply instance\n                 */\n                WiFiClearCredentialsReply.create = function create(properties) {\n                    return new WiFiClearCredentialsReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiClearCredentialsReply message. Does not implicitly {@link particle.ctrl.WiFiClearCredentialsReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {particle.ctrl.IWiFiClearCredentialsReply} message WiFiClearCredentialsReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiClearCredentialsReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiClearCredentialsReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiClearCredentialsReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiClearCredentialsReply} WiFiClearCredentialsReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiClearCredentialsReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiClearCredentialsReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiClearCredentialsReply;\n            })();\n    \n            /**\n             * WiFiAntenna enum.\n             * @name particle.ctrl.WiFiAntenna\n             * @enum {number}\n             * @property {number} ANTENNA_NONE=0 ANTENNA_NONE value\n             * @property {number} INTERNAL=1 INTERNAL value\n             * @property {number} EXTERNAL=2 EXTERNAL value\n             * @property {number} AUTO=3 AUTO value\n             */\n            ctrl.WiFiAntenna = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"ANTENNA_NONE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                values[valuesById[2] = \"EXTERNAL\"] = 2;\n                values[valuesById[3] = \"AUTO\"] = 3;\n                return values;\n            })();\n    \n            /**\n             * WiFiSecurityType enum.\n             * @name particle.ctrl.WiFiSecurityType\n             * @enum {number}\n             * @property {number} UNSEC=0 UNSEC value\n             * @property {number} WEP=1 WEP value\n             * @property {number} WPA=2 WPA value\n             * @property {number} WPA2=3 WPA2 value\n             * @property {number} WPA_ENTERPRISE=4 WPA_ENTERPRISE value\n             * @property {number} WPA2_ENTERPRISE=5 WPA2_ENTERPRISE value\n             * @property {number} UNKNOWN=255 UNKNOWN value\n             */\n            ctrl.WiFiSecurityType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"UNSEC\"] = 0;\n                values[valuesById[1] = \"WEP\"] = 1;\n                values[valuesById[2] = \"WPA\"] = 2;\n                values[valuesById[3] = \"WPA2\"] = 3;\n                values[valuesById[4] = \"WPA_ENTERPRISE\"] = 4;\n                values[valuesById[5] = \"WPA2_ENTERPRISE\"] = 5;\n                values[valuesById[255] = \"UNKNOWN\"] = 255;\n                return values;\n            })();\n    \n            /**\n             * WiFiSecurityCipher enum.\n             * @name particle.ctrl.WiFiSecurityCipher\n             * @enum {number}\n             * @property {number} CIPHER_NONE=0 CIPHER_NONE value\n             * @property {number} AES=1 AES value\n             * @property {number} TKIP=2 TKIP value\n             * @property {number} AES_TKIP=3 AES_TKIP value\n             */\n            ctrl.WiFiSecurityCipher = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"CIPHER_NONE\"] = 0;\n                values[valuesById[1] = \"AES\"] = 1;\n                values[valuesById[2] = \"TKIP\"] = 2;\n                values[valuesById[3] = \"AES_TKIP\"] = 3;\n                return values;\n            })();\n    \n            /**\n             * EapType enum.\n             * @name particle.ctrl.EapType\n             * @enum {number}\n             * @property {number} EAP_TYPE_NONE=0 EAP_TYPE_NONE value\n             * @property {number} TLS=13 TLS value\n             * @property {number} PEAP=25 PEAP value\n             */\n            ctrl.EapType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"EAP_TYPE_NONE\"] = 0;\n                values[valuesById[13] = \"TLS\"] = 13;\n                values[valuesById[25] = \"PEAP\"] = 25;\n                return values;\n            })();\n    \n            ctrl.WiFiAccessPoint = (function() {\n    \n                /**\n                 * Properties of a WiFiAccessPoint.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiAccessPoint\n                 * @property {string|null} [ssid] WiFiAccessPoint ssid\n                 * @property {Uint8Array|null} [bssid] WiFiAccessPoint bssid\n                 * @property {particle.ctrl.WiFiSecurityType|null} [security] WiFiAccessPoint security\n                 * @property {particle.ctrl.WiFiSecurityCipher|null} [cipher] WiFiAccessPoint cipher\n                 * @property {number|null} [channel] WiFiAccessPoint channel\n                 * @property {number|null} [maxDataRate] WiFiAccessPoint maxDataRate\n                 * @property {number|null} [rssi] WiFiAccessPoint rssi\n                 * @property {string|null} [password] WiFiAccessPoint password\n                 * @property {particle.ctrl.EapType|null} [eapType] WiFiAccessPoint eapType\n                 * @property {string|null} [innerIdentity] WiFiAccessPoint innerIdentity\n                 * @property {string|null} [outerIdentity] WiFiAccessPoint outerIdentity\n                 * @property {Uint8Array|null} [privateKey] WiFiAccessPoint privateKey\n                 * @property {Uint8Array|null} [clientCertificate] WiFiAccessPoint clientCertificate\n                 * @property {Uint8Array|null} [caCertificate] WiFiAccessPoint caCertificate\n                 */\n    \n                /**\n                 * Constructs a new WiFiAccessPoint.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiAccessPoint.\n                 * @implements IWiFiAccessPoint\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set\n                 */\n                function WiFiAccessPoint(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiAccessPoint ssid.\n                 * @member {string} ssid\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.ssid = \"\";\n    \n                /**\n                 * WiFiAccessPoint bssid.\n                 * @member {Uint8Array} bssid\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.bssid = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint security.\n                 * @member {particle.ctrl.WiFiSecurityType} security\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.security = 0;\n    \n                /**\n                 * WiFiAccessPoint cipher.\n                 * @member {particle.ctrl.WiFiSecurityCipher} cipher\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.cipher = 0;\n    \n                /**\n                 * WiFiAccessPoint channel.\n                 * @member {number} channel\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.channel = 0;\n    \n                /**\n                 * WiFiAccessPoint maxDataRate.\n                 * @member {number} maxDataRate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.maxDataRate = 0;\n    \n                /**\n                 * WiFiAccessPoint rssi.\n                 * @member {number} rssi\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.rssi = 0;\n    \n                /**\n                 * WiFiAccessPoint password.\n                 * @member {string} password\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.password = \"\";\n    \n                /**\n                 * WiFiAccessPoint eapType.\n                 * @member {particle.ctrl.EapType} eapType\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.eapType = 0;\n    \n                /**\n                 * WiFiAccessPoint innerIdentity.\n                 * @member {string} innerIdentity\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.innerIdentity = \"\";\n    \n                /**\n                 * WiFiAccessPoint outerIdentity.\n                 * @member {string} outerIdentity\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.outerIdentity = \"\";\n    \n                /**\n                 * WiFiAccessPoint privateKey.\n                 * @member {Uint8Array} privateKey\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.privateKey = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint clientCertificate.\n                 * @member {Uint8Array} clientCertificate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.clientCertificate = $util.newBuffer([]);\n    \n                /**\n                 * WiFiAccessPoint caCertificate.\n                 * @member {Uint8Array} caCertificate\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @instance\n                 */\n                WiFiAccessPoint.prototype.caCertificate = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new WiFiAccessPoint instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPoint=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint instance\n                 */\n                WiFiAccessPoint.create = function create(properties) {\n                    return new WiFiAccessPoint(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiAccessPoint message. Does not implicitly {@link particle.ctrl.WiFiAccessPoint.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPoint} message WiFiAccessPoint message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiAccessPoint.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                    if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                    if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                    if (message.cipher != null && Object.hasOwnProperty.call(message, \"cipher\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cipher);\n                    if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.channel);\n                    if (message.maxDataRate != null && Object.hasOwnProperty.call(message, \"maxDataRate\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.maxDataRate);\n                    if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rssi);\n                    if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.password);\n                    if (message.eapType != null && Object.hasOwnProperty.call(message, \"eapType\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.eapType);\n                    if (message.innerIdentity != null && Object.hasOwnProperty.call(message, \"innerIdentity\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.innerIdentity);\n                    if (message.outerIdentity != null && Object.hasOwnProperty.call(message, \"outerIdentity\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.outerIdentity);\n                    if (message.privateKey != null && Object.hasOwnProperty.call(message, \"privateKey\"))\n                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.privateKey);\n                    if (message.clientCertificate != null && Object.hasOwnProperty.call(message, \"clientCertificate\"))\n                        writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.clientCertificate);\n                    if (message.caCertificate != null && Object.hasOwnProperty.call(message, \"caCertificate\"))\n                        writer.uint32(/* id 14, wireType 2 =*/114).bytes(message.caCertificate);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiAccessPoint message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiAccessPoint\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiAccessPoint} WiFiAccessPoint\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiAccessPoint.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPoint();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ssid = reader.string();\n                            break;\n                        case 2:\n                            message.bssid = reader.bytes();\n                            break;\n                        case 3:\n                            message.security = reader.int32();\n                            break;\n                        case 4:\n                            message.cipher = reader.int32();\n                            break;\n                        case 5:\n                            message.channel = reader.uint32();\n                            break;\n                        case 6:\n                            message.maxDataRate = reader.int32();\n                            break;\n                        case 7:\n                            message.rssi = reader.int32();\n                            break;\n                        case 8:\n                            message.password = reader.string();\n                            break;\n                        case 9:\n                            message.eapType = reader.int32();\n                            break;\n                        case 10:\n                            message.innerIdentity = reader.string();\n                            break;\n                        case 11:\n                            message.outerIdentity = reader.string();\n                            break;\n                        case 12:\n                            message.privateKey = reader.bytes();\n                            break;\n                        case 13:\n                            message.clientCertificate = reader.bytes();\n                            break;\n                        case 14:\n                            message.caCertificate = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiAccessPoint;\n            })();\n    \n            ctrl.WiFiAccessPointList = (function() {\n    \n                /**\n                 * Properties of a WiFiAccessPointList.\n                 * @memberof particle.ctrl\n                 * @interface IWiFiAccessPointList\n                 * @property {Array.<particle.ctrl.IWiFiAccessPoint>|null} [aps] WiFiAccessPointList aps\n                 */\n    \n                /**\n                 * Constructs a new WiFiAccessPointList.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WiFiAccessPointList.\n                 * @implements IWiFiAccessPointList\n                 * @constructor\n                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set\n                 */\n                function WiFiAccessPointList(properties) {\n                    this.aps = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WiFiAccessPointList aps.\n                 * @member {Array.<particle.ctrl.IWiFiAccessPoint>} aps\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @instance\n                 */\n                WiFiAccessPointList.prototype.aps = $util.emptyArray;\n    \n                /**\n                 * Creates a new WiFiAccessPointList instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPointList=} [properties] Properties to set\n                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList instance\n                 */\n                WiFiAccessPointList.create = function create(properties) {\n                    return new WiFiAccessPointList(properties);\n                };\n    \n                /**\n                 * Encodes the specified WiFiAccessPointList message. Does not implicitly {@link particle.ctrl.WiFiAccessPointList.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {particle.ctrl.IWiFiAccessPointList} message WiFiAccessPointList message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WiFiAccessPointList.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.aps != null && message.aps.length)\n                        for (var i = 0; i < message.aps.length; ++i)\n                            $root.particle.ctrl.WiFiAccessPoint.encode(message.aps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WiFiAccessPointList message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WiFiAccessPointList\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WiFiAccessPointList} WiFiAccessPointList\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WiFiAccessPointList.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WiFiAccessPointList();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.aps && message.aps.length))\n                                message.aps = [];\n                            message.aps.push($root.particle.ctrl.WiFiAccessPoint.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WiFiAccessPointList;\n            })();\n    \n            ctrl.NetworkGetStatusRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkGetStatusRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetStatusRequest\n                 * @property {number|null} [\"interface\"] NetworkGetStatusRequest interface\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetStatusRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetStatusRequest.\n                 * @implements INetworkGetStatusRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set\n                 */\n                function NetworkGetStatusRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetStatusRequest interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @instance\n                 */\n                NetworkGetStatusRequest.prototype[\"interface\"] = 0;\n    \n                /**\n                 * Creates a new NetworkGetStatusRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest instance\n                 */\n                NetworkGetStatusRequest.create = function create(properties) {\n                    return new NetworkGetStatusRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetStatusRequest message. Does not implicitly {@link particle.ctrl.NetworkGetStatusRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusRequest} message NetworkGetStatusRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetStatusRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetStatusRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetStatusRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetStatusRequest} NetworkGetStatusRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetStatusRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetStatusRequest;\n            })();\n    \n            ctrl.NetworkGetStatusReply = (function() {\n    \n                /**\n                 * Properties of a NetworkGetStatusReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetStatusReply\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetStatusReply config\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetStatusReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetStatusReply.\n                 * @implements INetworkGetStatusReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set\n                 */\n                function NetworkGetStatusReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetStatusReply config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @instance\n                 */\n                NetworkGetStatusReply.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkGetStatusReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply instance\n                 */\n                NetworkGetStatusReply.create = function create(properties) {\n                    return new NetworkGetStatusReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetStatusReply message. Does not implicitly {@link particle.ctrl.NetworkGetStatusReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetStatusReply} message NetworkGetStatusReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetStatusReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetStatusReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetStatusReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetStatusReply} NetworkGetStatusReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetStatusReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetStatusReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetStatusReply;\n            })();\n    \n            ctrl.NetworkGetConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkGetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetConfigurationRequest\n                 * @property {number|null} [\"interface\"] NetworkGetConfigurationRequest interface\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetConfigurationRequest.\n                 * @implements INetworkGetConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set\n                 */\n                function NetworkGetConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetConfigurationRequest interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @instance\n                 */\n                NetworkGetConfigurationRequest.prototype[\"interface\"] = 0;\n    \n                /**\n                 * Creates a new NetworkGetConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest instance\n                 */\n                NetworkGetConfigurationRequest.create = function create(properties) {\n                    return new NetworkGetConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationRequest} message NetworkGetConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetConfigurationRequest} NetworkGetConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkGetConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a NetworkGetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkGetConfigurationReply\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkGetConfigurationReply config\n                 */\n    \n                /**\n                 * Constructs a new NetworkGetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkGetConfigurationReply.\n                 * @implements INetworkGetConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set\n                 */\n                function NetworkGetConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkGetConfigurationReply config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @instance\n                 */\n                NetworkGetConfigurationReply.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkGetConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply instance\n                 */\n                NetworkGetConfigurationReply.create = function create(properties) {\n                    return new NetworkGetConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkGetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkGetConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkGetConfigurationReply} message NetworkGetConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkGetConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkGetConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkGetConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkGetConfigurationReply} NetworkGetConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkGetConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkGetConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkGetConfigurationReply;\n            })();\n    \n            ctrl.NetworkSetConfigurationRequest = (function() {\n    \n                /**\n                 * Properties of a NetworkSetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @interface INetworkSetConfigurationRequest\n                 * @property {particle.ctrl.INetworkConfiguration|null} [config] NetworkSetConfigurationRequest config\n                 */\n    \n                /**\n                 * Constructs a new NetworkSetConfigurationRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkSetConfigurationRequest.\n                 * @implements INetworkSetConfigurationRequest\n                 * @constructor\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set\n                 */\n                function NetworkSetConfigurationRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkSetConfigurationRequest config.\n                 * @member {particle.ctrl.INetworkConfiguration|null|undefined} config\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @instance\n                 */\n                NetworkSetConfigurationRequest.prototype.config = null;\n    \n                /**\n                 * Creates a new NetworkSetConfigurationRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest instance\n                 */\n                NetworkSetConfigurationRequest.create = function create(properties) {\n                    return new NetworkSetConfigurationRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkSetConfigurationRequest message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationRequest} message NetworkSetConfigurationRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkSetConfigurationRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.config != null && Object.hasOwnProperty.call(message, \"config\"))\n                        $root.particle.ctrl.NetworkConfiguration.encode(message.config, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkSetConfigurationRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkSetConfigurationRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkSetConfigurationRequest} NetworkSetConfigurationRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkSetConfigurationRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.config = $root.particle.ctrl.NetworkConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkSetConfigurationRequest;\n            })();\n    \n            ctrl.NetworkSetConfigurationReply = (function() {\n    \n                /**\n                 * Properties of a NetworkSetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @interface INetworkSetConfigurationReply\n                 */\n    \n                /**\n                 * Constructs a new NetworkSetConfigurationReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkSetConfigurationReply.\n                 * @implements INetworkSetConfigurationReply\n                 * @constructor\n                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set\n                 */\n                function NetworkSetConfigurationReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new NetworkSetConfigurationReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply instance\n                 */\n                NetworkSetConfigurationReply.create = function create(properties) {\n                    return new NetworkSetConfigurationReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkSetConfigurationReply message. Does not implicitly {@link particle.ctrl.NetworkSetConfigurationReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {particle.ctrl.INetworkSetConfigurationReply} message NetworkSetConfigurationReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkSetConfigurationReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkSetConfigurationReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkSetConfigurationReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkSetConfigurationReply} NetworkSetConfigurationReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkSetConfigurationReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkSetConfigurationReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkSetConfigurationReply;\n            })();\n    \n            /**\n             * NetworkState enum.\n             * @name particle.ctrl.NetworkState\n             * @enum {number}\n             * @property {number} NETWORK_STATUS_NONE=0 NETWORK_STATUS_NONE value\n             * @property {number} DOWN=1 DOWN value\n             * @property {number} UP=2 UP value\n             */\n            ctrl.NetworkState = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NETWORK_STATUS_NONE\"] = 0;\n                values[valuesById[1] = \"DOWN\"] = 1;\n                values[valuesById[2] = \"UP\"] = 2;\n                return values;\n            })();\n    \n            ctrl.IPConfiguration = (function() {\n    \n                /**\n                 * Properties of a IPConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface IIPConfiguration\n                 * @property {particle.ctrl.IPConfiguration.Type|null} [type] IPConfiguration type\n                 * @property {particle.ctrl.IIPAddress|null} [address] IPConfiguration address\n                 * @property {particle.ctrl.IIPAddress|null} [netmask] IPConfiguration netmask\n                 * @property {particle.ctrl.IIPAddress|null} [gateway] IPConfiguration gateway\n                 * @property {particle.ctrl.IIPAddress|null} [dhcpServer] IPConfiguration dhcpServer\n                 * @property {string|null} [hostname] IPConfiguration hostname\n                 */\n    \n                /**\n                 * Constructs a new IPConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a IPConfiguration.\n                 * @implements IIPConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set\n                 */\n                function IPConfiguration(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * IPConfiguration type.\n                 * @member {particle.ctrl.IPConfiguration.Type} type\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.type = 0;\n    \n                /**\n                 * IPConfiguration address.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} address\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.address = null;\n    \n                /**\n                 * IPConfiguration netmask.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} netmask\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.netmask = null;\n    \n                /**\n                 * IPConfiguration gateway.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} gateway\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.gateway = null;\n    \n                /**\n                 * IPConfiguration dhcpServer.\n                 * @member {particle.ctrl.IIPAddress|null|undefined} dhcpServer\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.dhcpServer = null;\n    \n                /**\n                 * IPConfiguration hostname.\n                 * @member {string} hostname\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @instance\n                 */\n                IPConfiguration.prototype.hostname = \"\";\n    \n                /**\n                 * Creates a new IPConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {particle.ctrl.IIPConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration instance\n                 */\n                IPConfiguration.create = function create(properties) {\n                    return new IPConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified IPConfiguration message. Does not implicitly {@link particle.ctrl.IPConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {particle.ctrl.IIPConfiguration} message IPConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                IPConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        $root.particle.ctrl.IPAddress.encode(message.address, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.netmask != null && Object.hasOwnProperty.call(message, \"netmask\"))\n                        $root.particle.ctrl.IPAddress.encode(message.netmask, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.gateway != null && Object.hasOwnProperty.call(message, \"gateway\"))\n                        $root.particle.ctrl.IPAddress.encode(message.gateway, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.dhcpServer != null && Object.hasOwnProperty.call(message, \"dhcpServer\"))\n                        $root.particle.ctrl.IPAddress.encode(message.dhcpServer, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.hostname != null && Object.hasOwnProperty.call(message, \"hostname\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.hostname);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a IPConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.IPConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.IPConfiguration} IPConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                IPConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.IPConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.type = reader.int32();\n                            break;\n                        case 2:\n                            message.address = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.netmask = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 4:\n                            message.gateway = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.dhcpServer = $root.particle.ctrl.IPAddress.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.hostname = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Type enum.\n                 * @name particle.ctrl.IPConfiguration.Type\n                 * @enum {number}\n                 * @property {number} NONE=0 NONE value\n                 * @property {number} DHCP=1 DHCP value\n                 * @property {number} STATIC=2 STATIC value\n                 */\n                IPConfiguration.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NONE\"] = 0;\n                    values[valuesById[1] = \"DHCP\"] = 1;\n                    values[valuesById[2] = \"STATIC\"] = 2;\n                    return values;\n                })();\n    \n                return IPConfiguration;\n            })();\n    \n            ctrl.DNSConfiguration = (function() {\n    \n                /**\n                 * Properties of a DNSConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface IDNSConfiguration\n                 * @property {Array.<particle.ctrl.IIPAddress>|null} [servers] DNSConfiguration servers\n                 */\n    \n                /**\n                 * Constructs a new DNSConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DNSConfiguration.\n                 * @implements IDNSConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set\n                 */\n                function DNSConfiguration(properties) {\n                    this.servers = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DNSConfiguration servers.\n                 * @member {Array.<particle.ctrl.IIPAddress>} servers\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @instance\n                 */\n                DNSConfiguration.prototype.servers = $util.emptyArray;\n    \n                /**\n                 * Creates a new DNSConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {particle.ctrl.IDNSConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration instance\n                 */\n                DNSConfiguration.create = function create(properties) {\n                    return new DNSConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified DNSConfiguration message. Does not implicitly {@link particle.ctrl.DNSConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {particle.ctrl.IDNSConfiguration} message DNSConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DNSConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.servers != null && message.servers.length)\n                        for (var i = 0; i < message.servers.length; ++i)\n                            $root.particle.ctrl.IPAddress.encode(message.servers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DNSConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DNSConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DNSConfiguration} DNSConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DNSConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DNSConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.servers && message.servers.length))\n                                message.servers = [];\n                            message.servers.push($root.particle.ctrl.IPAddress.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DNSConfiguration;\n            })();\n    \n            ctrl.NetworkConfiguration = (function() {\n    \n                /**\n                 * Properties of a NetworkConfiguration.\n                 * @memberof particle.ctrl\n                 * @interface INetworkConfiguration\n                 * @property {number|null} [\"interface\"] NetworkConfiguration interface\n                 * @property {particle.ctrl.NetworkState|null} [state] NetworkConfiguration state\n                 * @property {string|null} [name] NetworkConfiguration name\n                 * @property {Uint8Array|null} [mac] NetworkConfiguration mac\n                 * @property {particle.ctrl.IIPConfiguration|null} [ipconfig] NetworkConfiguration ipconfig\n                 * @property {particle.ctrl.IDNSConfiguration|null} [dnsconfig] NetworkConfiguration dnsconfig\n                 */\n    \n                /**\n                 * Constructs a new NetworkConfiguration.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a NetworkConfiguration.\n                 * @implements INetworkConfiguration\n                 * @constructor\n                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set\n                 */\n                function NetworkConfiguration(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * NetworkConfiguration interface.\n                 * @member {number} interface\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype[\"interface\"] = 0;\n    \n                /**\n                 * NetworkConfiguration state.\n                 * @member {particle.ctrl.NetworkState} state\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.state = 0;\n    \n                /**\n                 * NetworkConfiguration name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.name = \"\";\n    \n                /**\n                 * NetworkConfiguration mac.\n                 * @member {Uint8Array} mac\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.mac = $util.newBuffer([]);\n    \n                /**\n                 * NetworkConfiguration ipconfig.\n                 * @member {particle.ctrl.IIPConfiguration|null|undefined} ipconfig\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.ipconfig = null;\n    \n                /**\n                 * NetworkConfiguration dnsconfig.\n                 * @member {particle.ctrl.IDNSConfiguration|null|undefined} dnsconfig\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @instance\n                 */\n                NetworkConfiguration.prototype.dnsconfig = null;\n    \n                /**\n                 * Creates a new NetworkConfiguration instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {particle.ctrl.INetworkConfiguration=} [properties] Properties to set\n                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration instance\n                 */\n                NetworkConfiguration.create = function create(properties) {\n                    return new NetworkConfiguration(properties);\n                };\n    \n                /**\n                 * Encodes the specified NetworkConfiguration message. Does not implicitly {@link particle.ctrl.NetworkConfiguration.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {particle.ctrl.INetworkConfiguration} message NetworkConfiguration message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                NetworkConfiguration.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message[\"interface\"]);\n                    if (message.state != null && Object.hasOwnProperty.call(message, \"state\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.state);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);\n                    if (message.mac != null && Object.hasOwnProperty.call(message, \"mac\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.mac);\n                    if (message.ipconfig != null && Object.hasOwnProperty.call(message, \"ipconfig\"))\n                        $root.particle.ctrl.IPConfiguration.encode(message.ipconfig, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.dnsconfig != null && Object.hasOwnProperty.call(message, \"dnsconfig\"))\n                        $root.particle.ctrl.DNSConfiguration.encode(message.dnsconfig, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a NetworkConfiguration message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.NetworkConfiguration\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.NetworkConfiguration} NetworkConfiguration\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NetworkConfiguration.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.NetworkConfiguration();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = reader.int32();\n                            break;\n                        case 2:\n                            message.state = reader.int32();\n                            break;\n                        case 3:\n                            message.name = reader.string();\n                            break;\n                        case 4:\n                            message.mac = reader.bytes();\n                            break;\n                        case 5:\n                            message.ipconfig = $root.particle.ctrl.IPConfiguration.decode(reader, reader.uint32());\n                            break;\n                        case 6:\n                            message.dnsconfig = $root.particle.ctrl.DNSConfiguration.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return NetworkConfiguration;\n            })();\n    \n            ctrl.InterfaceAddress = (function() {\n    \n                /**\n                 * Properties of an InterfaceAddress.\n                 * @memberof particle.ctrl\n                 * @interface IInterfaceAddress\n                 * @property {particle.ctrl.IIpAddress|null} [address] InterfaceAddress address\n                 * @property {number|null} [prefixLength] InterfaceAddress prefixLength\n                 */\n    \n                /**\n                 * Constructs a new InterfaceAddress.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an InterfaceAddress.\n                 * @implements IInterfaceAddress\n                 * @constructor\n                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set\n                 */\n                function InterfaceAddress(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * InterfaceAddress address.\n                 * @member {particle.ctrl.IIpAddress|null|undefined} address\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @instance\n                 */\n                InterfaceAddress.prototype.address = null;\n    \n                /**\n                 * InterfaceAddress prefixLength.\n                 * @member {number} prefixLength\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @instance\n                 */\n                InterfaceAddress.prototype.prefixLength = 0;\n    \n                /**\n                 * Creates a new InterfaceAddress instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {particle.ctrl.IInterfaceAddress=} [properties] Properties to set\n                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress instance\n                 */\n                InterfaceAddress.create = function create(properties) {\n                    return new InterfaceAddress(properties);\n                };\n    \n                /**\n                 * Encodes the specified InterfaceAddress message. Does not implicitly {@link particle.ctrl.InterfaceAddress.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {particle.ctrl.IInterfaceAddress} message InterfaceAddress message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                InterfaceAddress.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.address != null && Object.hasOwnProperty.call(message, \"address\"))\n                        $root.particle.ctrl.IpAddress.encode(message.address, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.prefixLength != null && Object.hasOwnProperty.call(message, \"prefixLength\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an InterfaceAddress message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.InterfaceAddress\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.InterfaceAddress} InterfaceAddress\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                InterfaceAddress.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceAddress();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.address = $root.particle.ctrl.IpAddress.decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            message.prefixLength = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return InterfaceAddress;\n            })();\n    \n            ctrl.Ipv4Config = (function() {\n    \n                /**\n                 * Properties of an Ipv4Config.\n                 * @memberof particle.ctrl\n                 * @interface IIpv4Config\n                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv4Config addresses\n                 * @property {particle.ctrl.IIpv4Address|null} [peer] Ipv4Config peer\n                 * @property {particle.ctrl.IIpv4Address|null} [gateway] Ipv4Config gateway\n                 */\n    \n                /**\n                 * Constructs a new Ipv4Config.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv4Config.\n                 * @implements IIpv4Config\n                 * @constructor\n                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set\n                 */\n                function Ipv4Config(properties) {\n                    this.addresses = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv4Config addresses.\n                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.addresses = $util.emptyArray;\n    \n                /**\n                 * Ipv4Config peer.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} peer\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.peer = null;\n    \n                /**\n                 * Ipv4Config gateway.\n                 * @member {particle.ctrl.IIpv4Address|null|undefined} gateway\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @instance\n                 */\n                Ipv4Config.prototype.gateway = null;\n    \n                /**\n                 * Creates a new Ipv4Config instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {particle.ctrl.IIpv4Config=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config instance\n                 */\n                Ipv4Config.create = function create(properties) {\n                    return new Ipv4Config(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv4Config message. Does not implicitly {@link particle.ctrl.Ipv4Config.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {particle.ctrl.IIpv4Config} message Ipv4Config message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv4Config.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.addresses != null && message.addresses.length)\n                        for (var i = 0; i < message.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.peer != null && Object.hasOwnProperty.call(message, \"peer\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.peer, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.gateway != null && Object.hasOwnProperty.call(message, \"gateway\"))\n                        $root.particle.ctrl.Ipv4Address.encode(message.gateway, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv4Config message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv4Config\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv4Config} Ipv4Config\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv4Config.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv4Config();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.addresses && message.addresses.length))\n                                message.addresses = [];\n                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));\n                            break;\n                        case 2:\n                            message.peer = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.gateway = $root.particle.ctrl.Ipv4Address.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv4Config;\n            })();\n    \n            ctrl.Ipv6Config = (function() {\n    \n                /**\n                 * Properties of an Ipv6Config.\n                 * @memberof particle.ctrl\n                 * @interface IIpv6Config\n                 * @property {Array.<particle.ctrl.IInterfaceAddress>|null} [addresses] Ipv6Config addresses\n                 */\n    \n                /**\n                 * Constructs a new Ipv6Config.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Ipv6Config.\n                 * @implements IIpv6Config\n                 * @constructor\n                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set\n                 */\n                function Ipv6Config(properties) {\n                    this.addresses = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Ipv6Config addresses.\n                 * @member {Array.<particle.ctrl.IInterfaceAddress>} addresses\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @instance\n                 */\n                Ipv6Config.prototype.addresses = $util.emptyArray;\n    \n                /**\n                 * Creates a new Ipv6Config instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {particle.ctrl.IIpv6Config=} [properties] Properties to set\n                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config instance\n                 */\n                Ipv6Config.create = function create(properties) {\n                    return new Ipv6Config(properties);\n                };\n    \n                /**\n                 * Encodes the specified Ipv6Config message. Does not implicitly {@link particle.ctrl.Ipv6Config.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {particle.ctrl.IIpv6Config} message Ipv6Config message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Ipv6Config.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.addresses != null && message.addresses.length)\n                        for (var i = 0; i < message.addresses.length; ++i)\n                            $root.particle.ctrl.InterfaceAddress.encode(message.addresses[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Ipv6Config message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Ipv6Config\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Ipv6Config} Ipv6Config\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Ipv6Config.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Ipv6Config();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.addresses && message.addresses.length))\n                                message.addresses = [];\n                            message.addresses.push($root.particle.ctrl.InterfaceAddress.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Ipv6Config;\n            })();\n    \n            /**\n             * InterfaceFlag enum.\n             * @name particle.ctrl.InterfaceFlag\n             * @enum {number}\n             * @property {number} IFF_NONE=0 IFF_NONE value\n             * @property {number} IFF_UP=1 IFF_UP value\n             * @property {number} IFF_BROADCAST=2 IFF_BROADCAST value\n             * @property {number} IFF_DEBUG=4 IFF_DEBUG value\n             * @property {number} IFF_LOOPBACK=8 IFF_LOOPBACK value\n             * @property {number} IFF_POINTTOPOINT=16 IFF_POINTTOPOINT value\n             * @property {number} IFF_RUNNING=64 IFF_RUNNING value\n             * @property {number} IFF_LOWER_UP=64 IFF_LOWER_UP value\n             * @property {number} IFF_NOARP=128 IFF_NOARP value\n             * @property {number} IFF_PROMISC=256 IFF_PROMISC value\n             * @property {number} IFF_ALLMULTI=512 IFF_ALLMULTI value\n             * @property {number} IFF_MULTICAST=32768 IFF_MULTICAST value\n             * @property {number} IFF_NOND6=65536 IFF_NOND6 value\n             */\n            ctrl.InterfaceFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFF_NONE\"] = 0;\n                values[valuesById[1] = \"IFF_UP\"] = 1;\n                values[valuesById[2] = \"IFF_BROADCAST\"] = 2;\n                values[valuesById[4] = \"IFF_DEBUG\"] = 4;\n                values[valuesById[8] = \"IFF_LOOPBACK\"] = 8;\n                values[valuesById[16] = \"IFF_POINTTOPOINT\"] = 16;\n                values[valuesById[64] = \"IFF_RUNNING\"] = 64;\n                values[\"IFF_LOWER_UP\"] = 64;\n                values[valuesById[128] = \"IFF_NOARP\"] = 128;\n                values[valuesById[256] = \"IFF_PROMISC\"] = 256;\n                values[valuesById[512] = \"IFF_ALLMULTI\"] = 512;\n                values[valuesById[32768] = \"IFF_MULTICAST\"] = 32768;\n                values[valuesById[65536] = \"IFF_NOND6\"] = 65536;\n                return values;\n            })();\n    \n            /**\n             * InterfaceExtFlag enum.\n             * @name particle.ctrl.InterfaceExtFlag\n             * @enum {number}\n             * @property {number} IFXF_NONE=0 IFXF_NONE value\n             * @property {number} IFXF_WOL=16 IFXF_WOL value\n             * @property {number} IFXF_AUTOCONF6=32 IFXF_AUTOCONF6 value\n             * @property {number} IFXF_DHCP=65536 IFXF_DHCP value\n             * @property {number} IFXF_DHCP6=131072 IFXF_DHCP6 value\n             * @property {number} IFXF_AUTOIP=262144 IFXF_AUTOIP value\n             */\n            ctrl.InterfaceExtFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"IFXF_NONE\"] = 0;\n                values[valuesById[16] = \"IFXF_WOL\"] = 16;\n                values[valuesById[32] = \"IFXF_AUTOCONF6\"] = 32;\n                values[valuesById[65536] = \"IFXF_DHCP\"] = 65536;\n                values[valuesById[131072] = \"IFXF_DHCP6\"] = 131072;\n                values[valuesById[262144] = \"IFXF_AUTOIP\"] = 262144;\n                return values;\n            })();\n    \n            /**\n             * InterfaceType enum.\n             * @name particle.ctrl.InterfaceType\n             * @enum {number}\n             * @property {number} INVALID_INTERFACE_TYPE=0 INVALID_INTERFACE_TYPE value\n             * @property {number} LOOPBACK=1 LOOPBACK value\n             * @property {number} THREAD=2 THREAD value\n             * @property {number} ETHERNET=4 ETHERNET value\n             * @property {number} WIFI=8 WIFI value\n             * @property {number} PPP=16 PPP value\n             */\n            ctrl.InterfaceType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_INTERFACE_TYPE\"] = 0;\n                values[valuesById[1] = \"LOOPBACK\"] = 1;\n                values[valuesById[2] = \"THREAD\"] = 2;\n                values[valuesById[4] = \"ETHERNET\"] = 4;\n                values[valuesById[8] = \"WIFI\"] = 8;\n                values[valuesById[16] = \"PPP\"] = 16;\n                return values;\n            })();\n    \n            ctrl.Interface = (function() {\n    \n                /**\n                 * Properties of an Interface.\n                 * @memberof particle.ctrl\n                 * @interface IInterface\n                 * @property {number|null} [index] Interface index\n                 * @property {string|null} [name] Interface name\n                 * @property {particle.ctrl.InterfaceType|null} [type] Interface type\n                 * @property {number|null} [flags] Interface flags\n                 * @property {number|null} [extFlags] Interface extFlags\n                 * @property {particle.ctrl.IIpv4Config|null} [ipv4Config] Interface ipv4Config\n                 * @property {particle.ctrl.IIpv6Config|null} [ipv6Config] Interface ipv6Config\n                 * @property {Uint8Array|null} [hwAddress] Interface hwAddress\n                 * @property {number|null} [mtu] Interface mtu\n                 * @property {number|null} [metric] Interface metric\n                 */\n    \n                /**\n                 * Constructs a new Interface.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an Interface.\n                 * @implements IInterface\n                 * @constructor\n                 * @param {particle.ctrl.IInterface=} [properties] Properties to set\n                 */\n                function Interface(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Interface index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.index = 0;\n    \n                /**\n                 * Interface name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.name = \"\";\n    \n                /**\n                 * Interface type.\n                 * @member {particle.ctrl.InterfaceType} type\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.type = 0;\n    \n                /**\n                 * Interface flags.\n                 * @member {number} flags\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.flags = 0;\n    \n                /**\n                 * Interface extFlags.\n                 * @member {number} extFlags\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.extFlags = 0;\n    \n                /**\n                 * Interface ipv4Config.\n                 * @member {particle.ctrl.IIpv4Config|null|undefined} ipv4Config\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.ipv4Config = null;\n    \n                /**\n                 * Interface ipv6Config.\n                 * @member {particle.ctrl.IIpv6Config|null|undefined} ipv6Config\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.ipv6Config = null;\n    \n                /**\n                 * Interface hwAddress.\n                 * @member {Uint8Array} hwAddress\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.hwAddress = $util.newBuffer([]);\n    \n                /**\n                 * Interface mtu.\n                 * @member {number} mtu\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.mtu = 0;\n    \n                /**\n                 * Interface metric.\n                 * @member {number} metric\n                 * @memberof particle.ctrl.Interface\n                 * @instance\n                 */\n                Interface.prototype.metric = 0;\n    \n                /**\n                 * Creates a new Interface instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {particle.ctrl.IInterface=} [properties] Properties to set\n                 * @returns {particle.ctrl.Interface} Interface instance\n                 */\n                Interface.create = function create(properties) {\n                    return new Interface(properties);\n                };\n    \n                /**\n                 * Encodes the specified Interface message. Does not implicitly {@link particle.ctrl.Interface.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {particle.ctrl.IInterface} message Interface message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                Interface.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.flags);\n                    if (message.extFlags != null && Object.hasOwnProperty.call(message, \"extFlags\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.extFlags);\n                    if (message.ipv4Config != null && Object.hasOwnProperty.call(message, \"ipv4Config\"))\n                        $root.particle.ctrl.Ipv4Config.encode(message.ipv4Config, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.ipv6Config != null && Object.hasOwnProperty.call(message, \"ipv6Config\"))\n                        $root.particle.ctrl.Ipv6Config.encode(message.ipv6Config, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.hwAddress != null && Object.hasOwnProperty.call(message, \"hwAddress\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).bytes(message.hwAddress);\n                    if (message.mtu != null && Object.hasOwnProperty.call(message, \"mtu\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.mtu);\n                    if (message.metric != null && Object.hasOwnProperty.call(message, \"metric\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).uint32(message.metric);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an Interface message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.Interface\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.Interface} Interface\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Interface.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.Interface();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        case 2:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.type = reader.int32();\n                            break;\n                        case 4:\n                            message.flags = reader.uint32();\n                            break;\n                        case 5:\n                            message.extFlags = reader.uint32();\n                            break;\n                        case 6:\n                            message.ipv4Config = $root.particle.ctrl.Ipv4Config.decode(reader, reader.uint32());\n                            break;\n                        case 7:\n                            message.ipv6Config = $root.particle.ctrl.Ipv6Config.decode(reader, reader.uint32());\n                            break;\n                        case 8:\n                            message.hwAddress = reader.bytes();\n                            break;\n                        case 9:\n                            message.mtu = reader.uint32();\n                            break;\n                        case 10:\n                            message.metric = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return Interface;\n            })();\n    \n            ctrl.InterfaceEntry = (function() {\n    \n                /**\n                 * Properties of an InterfaceEntry.\n                 * @memberof particle.ctrl\n                 * @interface IInterfaceEntry\n                 * @property {number|null} [index] InterfaceEntry index\n                 * @property {string|null} [name] InterfaceEntry name\n                 * @property {particle.ctrl.InterfaceType|null} [type] InterfaceEntry type\n                 */\n    \n                /**\n                 * Constructs a new InterfaceEntry.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents an InterfaceEntry.\n                 * @implements IInterfaceEntry\n                 * @constructor\n                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set\n                 */\n                function InterfaceEntry(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * InterfaceEntry index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.index = 0;\n    \n                /**\n                 * InterfaceEntry name.\n                 * @member {string} name\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.name = \"\";\n    \n                /**\n                 * InterfaceEntry type.\n                 * @member {particle.ctrl.InterfaceType} type\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @instance\n                 */\n                InterfaceEntry.prototype.type = 0;\n    \n                /**\n                 * Creates a new InterfaceEntry instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {particle.ctrl.IInterfaceEntry=} [properties] Properties to set\n                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry instance\n                 */\n                InterfaceEntry.create = function create(properties) {\n                    return new InterfaceEntry(properties);\n                };\n    \n                /**\n                 * Encodes the specified InterfaceEntry message. Does not implicitly {@link particle.ctrl.InterfaceEntry.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {particle.ctrl.IInterfaceEntry} message InterfaceEntry message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                InterfaceEntry.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an InterfaceEntry message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.InterfaceEntry\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.InterfaceEntry} InterfaceEntry\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                InterfaceEntry.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.InterfaceEntry();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        case 2:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.type = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return InterfaceEntry;\n            })();\n    \n            ctrl.GetInterfaceListRequest = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceListRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceListRequest\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceListRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceListRequest.\n                 * @implements IGetInterfaceListRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set\n                 */\n                function GetInterfaceListRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetInterfaceListRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest instance\n                 */\n                GetInterfaceListRequest.create = function create(properties) {\n                    return new GetInterfaceListRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceListRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceListRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListRequest} message GetInterfaceListRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceListRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceListRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceListRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceListRequest} GetInterfaceListRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceListRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceListRequest;\n            })();\n    \n            ctrl.GetInterfaceListReply = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceListReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceListReply\n                 * @property {Array.<particle.ctrl.IInterfaceEntry>|null} [interfaces] GetInterfaceListReply interfaces\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceListReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceListReply.\n                 * @implements IGetInterfaceListReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set\n                 */\n                function GetInterfaceListReply(properties) {\n                    this.interfaces = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceListReply interfaces.\n                 * @member {Array.<particle.ctrl.IInterfaceEntry>} interfaces\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @instance\n                 */\n                GetInterfaceListReply.prototype.interfaces = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetInterfaceListReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply instance\n                 */\n                GetInterfaceListReply.create = function create(properties) {\n                    return new GetInterfaceListReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceListReply message. Does not implicitly {@link particle.ctrl.GetInterfaceListReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceListReply} message GetInterfaceListReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceListReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.interfaces != null && message.interfaces.length)\n                        for (var i = 0; i < message.interfaces.length; ++i)\n                            $root.particle.ctrl.InterfaceEntry.encode(message.interfaces[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceListReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceListReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceListReply} GetInterfaceListReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceListReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceListReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.interfaces && message.interfaces.length))\n                                message.interfaces = [];\n                            message.interfaces.push($root.particle.ctrl.InterfaceEntry.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceListReply;\n            })();\n    \n            ctrl.GetInterfaceRequest = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceRequest\n                 * @property {number|null} [index] GetInterfaceRequest index\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceRequest.\n                 * @implements IGetInterfaceRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set\n                 */\n                function GetInterfaceRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceRequest index.\n                 * @member {number} index\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @instance\n                 */\n                GetInterfaceRequest.prototype.index = 0;\n    \n                /**\n                 * Creates a new GetInterfaceRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest instance\n                 */\n                GetInterfaceRequest.create = function create(properties) {\n                    return new GetInterfaceRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceRequest message. Does not implicitly {@link particle.ctrl.GetInterfaceRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceRequest} message GetInterfaceRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceRequest} GetInterfaceRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.index = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceRequest;\n            })();\n    \n            ctrl.GetInterfaceReply = (function() {\n    \n                /**\n                 * Properties of a GetInterfaceReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetInterfaceReply\n                 * @property {particle.ctrl.IInterface|null} [\"interface\"] GetInterfaceReply interface\n                 */\n    \n                /**\n                 * Constructs a new GetInterfaceReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetInterfaceReply.\n                 * @implements IGetInterfaceReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set\n                 */\n                function GetInterfaceReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetInterfaceReply interface.\n                 * @member {particle.ctrl.IInterface|null|undefined} interface\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @instance\n                 */\n                GetInterfaceReply.prototype[\"interface\"] = null;\n    \n                /**\n                 * Creates a new GetInterfaceReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply instance\n                 */\n                GetInterfaceReply.create = function create(properties) {\n                    return new GetInterfaceReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetInterfaceReply message. Does not implicitly {@link particle.ctrl.GetInterfaceReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {particle.ctrl.IGetInterfaceReply} message GetInterfaceReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetInterfaceReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message[\"interface\"] != null && Object.hasOwnProperty.call(message, \"interface\"))\n                        $root.particle.ctrl.Interface.encode(message[\"interface\"], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetInterfaceReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetInterfaceReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetInterfaceReply} GetInterfaceReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetInterfaceReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetInterfaceReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message[\"interface\"] = $root.particle.ctrl.Interface.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetInterfaceReply;\n            })();\n    \n            ctrl.wifi = (function() {\n    \n                /**\n                 * Namespace wifi.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var wifi = {};\n    \n                /**\n                 * WiFi security types.\n                 * \n                 * Note: The values of this enum should match the values defined by the `WifiSecurity` enum in\n                 * the firmware.\n                 * @name particle.ctrl.wifi.Security\n                 * @enum {number}\n                 * @property {number} NO_SECURITY=0 NO_SECURITY value\n                 * @property {number} WEP=1 WEP value\n                 * @property {number} WPA_PSK=2 WPA_PSK value\n                 * @property {number} WPA2_PSK=3 WPA2_PSK value\n                 * @property {number} WPA_WPA2_PSK=4 WPA_WPA2_PSK value\n                 */\n                wifi.Security = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_SECURITY\"] = 0;\n                    values[valuesById[1] = \"WEP\"] = 1;\n                    values[valuesById[2] = \"WPA_PSK\"] = 2;\n                    values[valuesById[3] = \"WPA2_PSK\"] = 3;\n                    values[valuesById[4] = \"WPA_WPA2_PSK\"] = 4;\n                    return values;\n                })();\n    \n                /**\n                 * Network credential types.\n                 * \n                 * Note: The values of this enum should match the values defined by the `WiFiCredentials::Type` enum\n                 * in the firmware.\n                 * @name particle.ctrl.wifi.CredentialsType\n                 * @enum {number}\n                 * @property {number} NO_CREDENTIALS=0 NO_CREDENTIALS value\n                 * @property {number} PASSWORD=1 PASSWORD value\n                 */\n                wifi.CredentialsType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"NO_CREDENTIALS\"] = 0;\n                    values[valuesById[1] = \"PASSWORD\"] = 1;\n                    return values;\n                })();\n    \n                wifi.Credentials = (function() {\n    \n                    /**\n                     * Properties of a Credentials.\n                     * @memberof particle.ctrl.wifi\n                     * @interface ICredentials\n                     * @property {particle.ctrl.wifi.CredentialsType|null} [type] Credentials type\n                     * @property {string|null} [password] Credentials password\n                     */\n    \n                    /**\n                     * Constructs a new Credentials.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Network credentials.\n                     * @implements ICredentials\n                     * @constructor\n                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set\n                     */\n                    function Credentials(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Credentials type.\n                     * @member {particle.ctrl.wifi.CredentialsType} type\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @instance\n                     */\n                    Credentials.prototype.type = 0;\n    \n                    /**\n                     * Credentials password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @instance\n                     */\n                    Credentials.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new Credentials instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {particle.ctrl.wifi.ICredentials=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.Credentials} Credentials instance\n                     */\n                    Credentials.create = function create(properties) {\n                        return new Credentials(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Credentials message. Does not implicitly {@link particle.ctrl.wifi.Credentials.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {particle.ctrl.wifi.ICredentials} message Credentials message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Credentials.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Credentials message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.Credentials\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.Credentials} Credentials\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Credentials.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.Credentials();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Credentials;\n                })();\n    \n                wifi.JoinNewNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinNewNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinNewNetworkRequest\n                     * @property {string|null} [ssid] JoinNewNetworkRequest ssid\n                     * @property {Uint8Array|null} [bssid] JoinNewNetworkRequest bssid\n                     * @property {particle.ctrl.wifi.Security|null} [security] JoinNewNetworkRequest security\n                     * @property {particle.ctrl.wifi.ICredentials|null} [credentials] JoinNewNetworkRequest credentials\n                     */\n    \n                    /**\n                     * Constructs a new JoinNewNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Join a new network.\n                     * \n                     * On success, the network credentials get saved to a persistent storage.\n                     * @implements IJoinNewNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinNewNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinNewNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * JoinNewNetworkRequest bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * JoinNewNetworkRequest security.\n                     * @member {particle.ctrl.wifi.Security} security\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.security = 0;\n    \n                    /**\n                     * JoinNewNetworkRequest credentials.\n                     * @member {particle.ctrl.wifi.ICredentials|null|undefined} credentials\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @instance\n                     */\n                    JoinNewNetworkRequest.prototype.credentials = null;\n    \n                    /**\n                     * Creates a new JoinNewNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest instance\n                     */\n                    JoinNewNetworkRequest.create = function create(properties) {\n                        return new JoinNewNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNewNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkRequest} message JoinNewNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNewNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                        if (message.credentials != null && Object.hasOwnProperty.call(message, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(message.credentials, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNewNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkRequest} JoinNewNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNewNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.security = reader.int32();\n                                break;\n                            case 4:\n                                message.credentials = $root.particle.ctrl.wifi.Credentials.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNewNetworkRequest;\n                })();\n    \n                wifi.JoinNewNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinNewNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinNewNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinNewNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a JoinNewNetworkReply.\n                     * @implements IJoinNewNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinNewNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinNewNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply instance\n                     */\n                    JoinNewNetworkReply.create = function create(properties) {\n                        return new JoinNewNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNewNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinNewNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinNewNetworkReply} message JoinNewNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNewNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNewNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinNewNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinNewNetworkReply} JoinNewNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNewNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinNewNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNewNetworkReply;\n                })();\n    \n                wifi.JoinKnownNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinKnownNetworkRequest\n                     * @property {string|null} [ssid] JoinKnownNetworkRequest ssid\n                     */\n    \n                    /**\n                     * Constructs a new JoinKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Join a known network.\n                     * @implements IJoinKnownNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinKnownNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinKnownNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @instance\n                     */\n                    JoinKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * Creates a new JoinKnownNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest instance\n                     */\n                    JoinKnownNetworkRequest.create = function create(properties) {\n                        return new JoinKnownNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkRequest} message JoinKnownNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinKnownNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinKnownNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkRequest} JoinKnownNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinKnownNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinKnownNetworkRequest;\n                })();\n    \n                wifi.JoinKnownNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IJoinKnownNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a JoinKnownNetworkReply.\n                     * @implements IJoinKnownNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinKnownNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinKnownNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply instance\n                     */\n                    JoinKnownNetworkReply.create = function create(properties) {\n                        return new JoinKnownNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.JoinKnownNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IJoinKnownNetworkReply} message JoinKnownNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinKnownNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinKnownNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.JoinKnownNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.JoinKnownNetworkReply} JoinKnownNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinKnownNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.JoinKnownNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinKnownNetworkReply;\n                })();\n    \n                wifi.GetKnownNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a GetKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetKnownNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Get the list of known networks.\n                     * @implements IGetKnownNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set\n                     */\n                    function GetKnownNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetKnownNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest instance\n                     */\n                    GetKnownNetworksRequest.create = function create(properties) {\n                        return new GetKnownNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksRequest} message GetKnownNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetKnownNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetKnownNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksRequest} GetKnownNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetKnownNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetKnownNetworksRequest;\n                })();\n    \n                wifi.GetKnownNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a GetKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetKnownNetworksReply\n                     * @property {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>|null} [networks] GetKnownNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new GetKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a GetKnownNetworksReply.\n                     * @implements IGetKnownNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set\n                     */\n                    function GetKnownNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetKnownNetworksReply networks.\n                     * @member {Array.<particle.ctrl.wifi.GetKnownNetworksReply.INetwork>} networks\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @instance\n                     */\n                    GetKnownNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetKnownNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply instance\n                     */\n                    GetKnownNetworksReply.create = function create(properties) {\n                        return new GetKnownNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetKnownNetworksReply} message GetKnownNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetKnownNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.wifi.GetKnownNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetKnownNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetKnownNetworksReply} GetKnownNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetKnownNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.wifi.GetKnownNetworksReply.Network.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    GetKnownNetworksReply.Network = (function() {\n    \n                        /**\n                         * Properties of a Network.\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                         * @interface INetwork\n                         * @property {string|null} [ssid] Network ssid\n                         * @property {particle.ctrl.wifi.Security|null} [security] Network security\n                         * @property {particle.ctrl.wifi.CredentialsType|null} [credentialsType] Network credentialsType\n                         */\n    \n                        /**\n                         * Constructs a new Network.\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply\n                         * @classdesc Represents a Network.\n                         * @implements INetwork\n                         * @constructor\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set\n                         */\n                        function Network(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Network ssid.\n                         * @member {string} ssid\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.ssid = \"\";\n    \n                        /**\n                         * Network security.\n                         * @member {particle.ctrl.wifi.Security} security\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.security = 0;\n    \n                        /**\n                         * Network credentialsType.\n                         * @member {particle.ctrl.wifi.CredentialsType} credentialsType\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.credentialsType = 0;\n    \n                        /**\n                         * Creates a new Network instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork=} [properties] Properties to set\n                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network instance\n                         */\n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.GetKnownNetworksReply.Network.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.GetKnownNetworksReply.INetwork} message Network message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Network.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                            if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.security);\n                            if (message.credentialsType != null && Object.hasOwnProperty.call(message, \"credentialsType\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.credentialsType);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Network message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.wifi.GetKnownNetworksReply.Network\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.wifi.GetKnownNetworksReply.Network} Network\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Network.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetKnownNetworksReply.Network();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ssid = reader.string();\n                                    break;\n                                case 2:\n                                    message.security = reader.int32();\n                                    break;\n                                case 3:\n                                    message.credentialsType = reader.int32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return GetKnownNetworksReply;\n                })();\n    \n                wifi.RemoveKnownNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IRemoveKnownNetworkRequest\n                     * @property {string|null} [ssid] RemoveKnownNetworkRequest ssid\n                     */\n    \n                    /**\n                     * Constructs a new RemoveKnownNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Remove the network from the list of known networks.\n                     * @implements IRemoveKnownNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set\n                     */\n                    function RemoveKnownNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveKnownNetworkRequest ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @instance\n                     */\n                    RemoveKnownNetworkRequest.prototype.ssid = \"\";\n    \n                    /**\n                     * Creates a new RemoveKnownNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest instance\n                     */\n                    RemoveKnownNetworkRequest.create = function create(properties) {\n                        return new RemoveKnownNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveKnownNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkRequest} message RemoveKnownNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveKnownNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveKnownNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkRequest} RemoveKnownNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveKnownNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveKnownNetworkRequest;\n                })();\n    \n                wifi.RemoveKnownNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IRemoveKnownNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveKnownNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a RemoveKnownNetworkReply.\n                     * @implements IRemoveKnownNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set\n                     */\n                    function RemoveKnownNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveKnownNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply instance\n                     */\n                    RemoveKnownNetworkReply.create = function create(properties) {\n                        return new RemoveKnownNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveKnownNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.RemoveKnownNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IRemoveKnownNetworkReply} message RemoveKnownNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveKnownNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveKnownNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.RemoveKnownNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.RemoveKnownNetworkReply} RemoveKnownNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveKnownNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.RemoveKnownNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveKnownNetworkReply;\n                })();\n    \n                wifi.ClearKnownNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ClearKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IClearKnownNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new ClearKnownNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Remove all known networks.\n                     * @implements IClearKnownNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set\n                     */\n                    function ClearKnownNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ClearKnownNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest instance\n                     */\n                    ClearKnownNetworksRequest.create = function create(properties) {\n                        return new ClearKnownNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ClearKnownNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksRequest} message ClearKnownNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ClearKnownNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ClearKnownNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksRequest} ClearKnownNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ClearKnownNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ClearKnownNetworksRequest;\n                })();\n    \n                wifi.ClearKnownNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ClearKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IClearKnownNetworksReply\n                     */\n    \n                    /**\n                     * Constructs a new ClearKnownNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a ClearKnownNetworksReply.\n                     * @implements IClearKnownNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set\n                     */\n                    function ClearKnownNetworksReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ClearKnownNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply instance\n                     */\n                    ClearKnownNetworksReply.create = function create(properties) {\n                        return new ClearKnownNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ClearKnownNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ClearKnownNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IClearKnownNetworksReply} message ClearKnownNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ClearKnownNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ClearKnownNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ClearKnownNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ClearKnownNetworksReply} ClearKnownNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ClearKnownNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ClearKnownNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ClearKnownNetworksReply;\n                })();\n    \n                wifi.GetCurrentNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a GetCurrentNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetCurrentNetworkRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetCurrentNetworkRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Get the current network.\n                     * \n                     * This request gets the network which the device is currently connected to.\n                     * @implements IGetCurrentNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set\n                     */\n                    function GetCurrentNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetCurrentNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest instance\n                     */\n                    GetCurrentNetworkRequest.create = function create(properties) {\n                        return new GetCurrentNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetCurrentNetworkRequest message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkRequest} message GetCurrentNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetCurrentNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetCurrentNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkRequest} GetCurrentNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetCurrentNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetCurrentNetworkRequest;\n                })();\n    \n                wifi.GetCurrentNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a GetCurrentNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IGetCurrentNetworkReply\n                     * @property {string|null} [ssid] GetCurrentNetworkReply ssid\n                     * @property {Uint8Array|null} [bssid] GetCurrentNetworkReply bssid\n                     * @property {number|null} [channel] GetCurrentNetworkReply channel\n                     * @property {number|null} [rssi] GetCurrentNetworkReply rssi\n                     */\n    \n                    /**\n                     * Constructs a new GetCurrentNetworkReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a GetCurrentNetworkReply.\n                     * @implements IGetCurrentNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set\n                     */\n                    function GetCurrentNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetCurrentNetworkReply ssid.\n                     * @member {string} ssid\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.ssid = \"\";\n    \n                    /**\n                     * GetCurrentNetworkReply bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * GetCurrentNetworkReply channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.channel = 0;\n    \n                    /**\n                     * GetCurrentNetworkReply rssi.\n                     * @member {number} rssi\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @instance\n                     */\n                    GetCurrentNetworkReply.prototype.rssi = 0;\n    \n                    /**\n                     * Creates a new GetCurrentNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply instance\n                     */\n                    GetCurrentNetworkReply.create = function create(properties) {\n                        return new GetCurrentNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetCurrentNetworkReply message. Does not implicitly {@link particle.ctrl.wifi.GetCurrentNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IGetCurrentNetworkReply} message GetCurrentNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetCurrentNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.channel);\n                        if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.rssi);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetCurrentNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.GetCurrentNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.GetCurrentNetworkReply} GetCurrentNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetCurrentNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.GetCurrentNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.channel = reader.int32();\n                                break;\n                            case 4:\n                                message.rssi = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetCurrentNetworkReply;\n                })();\n    \n                wifi.ScanNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IScanNetworksRequest\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksRequest.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Scan for networks.\n                     * @implements IScanNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set\n                     */\n                    function ScanNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new ScanNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest instance\n                     */\n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ScanNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ScanNetworksRequest} ScanNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                wifi.ScanNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @interface IScanNetworksReply\n                     * @property {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>|null} [networks] ScanNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksReply.\n                     * @memberof particle.ctrl.wifi\n                     * @classdesc Represents a ScanNetworksReply.\n                     * @implements IScanNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set\n                     */\n                    function ScanNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksReply networks.\n                     * @member {Array.<particle.ctrl.wifi.ScanNetworksReply.INetwork>} networks\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @instance\n                     */\n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new ScanNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply instance\n                     */\n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.wifi.IScanNetworksReply} message ScanNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.wifi.ScanNetworksReply.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.wifi.ScanNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.wifi.ScanNetworksReply} ScanNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.wifi.ScanNetworksReply.Network.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    ScanNetworksReply.Network = (function() {\n    \n                        /**\n                         * Properties of a Network.\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply\n                         * @interface INetwork\n                         * @property {string|null} [ssid] Network ssid\n                         * @property {Uint8Array|null} [bssid] Network bssid\n                         * @property {particle.ctrl.wifi.Security|null} [security] Network security\n                         * @property {number|null} [channel] Network channel\n                         * @property {number|null} [rssi] Network rssi\n                         */\n    \n                        /**\n                         * Constructs a new Network.\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply\n                         * @classdesc Represents a Network.\n                         * @implements INetwork\n                         * @constructor\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set\n                         */\n                        function Network(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Network ssid.\n                         * @member {string} ssid\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.ssid = \"\";\n    \n                        /**\n                         * Network bssid.\n                         * @member {Uint8Array} bssid\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.bssid = $util.newBuffer([]);\n    \n                        /**\n                         * Network security.\n                         * @member {particle.ctrl.wifi.Security} security\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.security = 0;\n    \n                        /**\n                         * Network channel.\n                         * @member {number} channel\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.channel = 0;\n    \n                        /**\n                         * Network rssi.\n                         * @member {number} rssi\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @instance\n                         */\n                        Network.prototype.rssi = 0;\n    \n                        /**\n                         * Creates a new Network instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork=} [properties] Properties to set\n                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network instance\n                         */\n                        Network.create = function create(properties) {\n                            return new Network(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Network message. Does not implicitly {@link particle.ctrl.wifi.ScanNetworksReply.Network.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {particle.ctrl.wifi.ScanNetworksReply.INetwork} message Network message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Network.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                            if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                            if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                            if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.channel);\n                            if (message.rssi != null && Object.hasOwnProperty.call(message, \"rssi\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.rssi);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Network message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.wifi.ScanNetworksReply.Network\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.wifi.ScanNetworksReply.Network} Network\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Network.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.wifi.ScanNetworksReply.Network();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ssid = reader.string();\n                                    break;\n                                case 2:\n                                    message.bssid = reader.bytes();\n                                    break;\n                                case 3:\n                                    message.security = reader.int32();\n                                    break;\n                                case 4:\n                                    message.channel = reader.int32();\n                                    break;\n                                case 5:\n                                    message.rssi = reader.int32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Network;\n                    })();\n    \n                    return ScanNetworksReply;\n                })();\n    \n                return wifi;\n            })();\n    \n            ctrl.logging = (function() {\n    \n                /**\n                 * Namespace logging.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var logging = {};\n    \n                /**\n                 * Logging levels.\n                 * @name particle.ctrl.logging.LogLevel\n                 * @enum {number}\n                 * @property {number} INVALID_LOG_LEVEL=0 INVALID_LOG_LEVEL value\n                 * @property {number} ALL=1 ALL value\n                 * @property {number} TRACE=1 TRACE value\n                 * @property {number} INFO=30 INFO value\n                 * @property {number} WARN=40 WARN value\n                 * @property {number} ERROR=50 ERROR value\n                 * @property {number} NONE=70 NONE value\n                 */\n                logging.LogLevel = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_LEVEL\"] = 0;\n                    values[valuesById[1] = \"ALL\"] = 1;\n                    values[\"TRACE\"] = 1;\n                    values[valuesById[30] = \"INFO\"] = 30;\n                    values[valuesById[40] = \"WARN\"] = 40;\n                    values[valuesById[50] = \"ERROR\"] = 50;\n                    values[valuesById[70] = \"NONE\"] = 70;\n                    return values;\n                })();\n    \n                /**\n                 * Log handler types.\n                 * @name particle.ctrl.logging.LogHandlerType\n                 * @enum {number}\n                 * @property {number} INVALID_LOG_HANDLER_TYPE=0 INVALID_LOG_HANDLER_TYPE value\n                 * @property {number} DEFAULT_STREAM_HANDLER=1 DEFAULT_STREAM_HANDLER value\n                 * @property {number} JSON_STREAM_HANDLER=2 JSON_STREAM_HANDLER value\n                 */\n                logging.LogHandlerType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_LOG_HANDLER_TYPE\"] = 0;\n                    values[valuesById[1] = \"DEFAULT_STREAM_HANDLER\"] = 1;\n                    values[valuesById[2] = \"JSON_STREAM_HANDLER\"] = 2;\n                    return values;\n                })();\n    \n                /**\n                 * Stream types.\n                 * @name particle.ctrl.logging.StreamType\n                 * @enum {number}\n                 * @property {number} INVALID_STREAM_TYPE=0 INVALID_STREAM_TYPE value\n                 * @property {number} USB_SERIAL_STREAM=1 USB_SERIAL_STREAM value\n                 * @property {number} HW_SERIAL_STREAM=2 HW_SERIAL_STREAM value\n                 */\n                logging.StreamType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"INVALID_STREAM_TYPE\"] = 0;\n                    values[valuesById[1] = \"USB_SERIAL_STREAM\"] = 1;\n                    values[valuesById[2] = \"HW_SERIAL_STREAM\"] = 2;\n                    return values;\n                })();\n    \n                logging.LogFilter = (function() {\n    \n                    /**\n                     * Properties of a LogFilter.\n                     * @memberof particle.ctrl.logging\n                     * @interface ILogFilter\n                     * @property {string|null} [category] LogFilter category\n                     * @property {particle.ctrl.logging.LogLevel|null} [level] LogFilter level\n                     */\n    \n                    /**\n                     * Constructs a new LogFilter.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Category filter.\n                     * @implements ILogFilter\n                     * @constructor\n                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set\n                     */\n                    function LogFilter(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * LogFilter category.\n                     * @member {string} category\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @instance\n                     */\n                    LogFilter.prototype.category = \"\";\n    \n                    /**\n                     * LogFilter level.\n                     * @member {particle.ctrl.logging.LogLevel} level\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @instance\n                     */\n                    LogFilter.prototype.level = 0;\n    \n                    /**\n                     * Creates a new LogFilter instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {particle.ctrl.logging.ILogFilter=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.LogFilter} LogFilter instance\n                     */\n                    LogFilter.create = function create(properties) {\n                        return new LogFilter(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LogFilter message. Does not implicitly {@link particle.ctrl.logging.LogFilter.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {particle.ctrl.logging.ILogFilter} message LogFilter message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LogFilter.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.category != null && Object.hasOwnProperty.call(message, \"category\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.category);\n                        if (message.level != null && Object.hasOwnProperty.call(message, \"level\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LogFilter message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.LogFilter\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.LogFilter} LogFilter\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LogFilter.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.LogFilter();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.category = reader.string();\n                                break;\n                            case 2:\n                                message.level = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LogFilter;\n                })();\n    \n                logging.SerialStreamParams = (function() {\n    \n                    /**\n                     * Properties of a SerialStreamParams.\n                     * @memberof particle.ctrl.logging\n                     * @interface ISerialStreamParams\n                     * @property {number|null} [index] SerialStreamParams index\n                     * @property {number|null} [baudRate] SerialStreamParams baudRate\n                     */\n    \n                    /**\n                     * Constructs a new SerialStreamParams.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Serial stream parameters.\n                     * @implements ISerialStreamParams\n                     * @constructor\n                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set\n                     */\n                    function SerialStreamParams(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * SerialStreamParams index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @instance\n                     */\n                    SerialStreamParams.prototype.index = 0;\n    \n                    /**\n                     * SerialStreamParams baudRate.\n                     * @member {number} baudRate\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @instance\n                     */\n                    SerialStreamParams.prototype.baudRate = 0;\n    \n                    /**\n                     * Creates a new SerialStreamParams instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {particle.ctrl.logging.ISerialStreamParams=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams instance\n                     */\n                    SerialStreamParams.create = function create(properties) {\n                        return new SerialStreamParams(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified SerialStreamParams message. Does not implicitly {@link particle.ctrl.logging.SerialStreamParams.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {particle.ctrl.logging.ISerialStreamParams} message SerialStreamParams message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    SerialStreamParams.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.index);\n                        if (message.baudRate != null && Object.hasOwnProperty.call(message, \"baudRate\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.baudRate);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a SerialStreamParams message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.SerialStreamParams\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.SerialStreamParams} SerialStreamParams\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    SerialStreamParams.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.SerialStreamParams();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.index = reader.uint32();\n                                break;\n                            case 2:\n                                message.baudRate = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return SerialStreamParams;\n                })();\n    \n                logging.AddLogHandlerRequest = (function() {\n    \n                    /**\n                     * Properties of an AddLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IAddLogHandlerRequest\n                     * @property {string|null} [id] AddLogHandlerRequest id\n                     * @property {particle.ctrl.logging.LogHandlerType|null} [handlerType] AddLogHandlerRequest handlerType\n                     * @property {particle.ctrl.logging.LogLevel|null} [level] AddLogHandlerRequest level\n                     * @property {Array.<particle.ctrl.logging.ILogFilter>|null} [filters] AddLogHandlerRequest filters\n                     * @property {particle.ctrl.logging.StreamType|null} [streamType] AddLogHandlerRequest streamType\n                     * @property {particle.ctrl.logging.ISerialStreamParams|null} [serial] AddLogHandlerRequest serial\n                     */\n    \n                    /**\n                     * Constructs a new AddLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Add a log handler.\n                     * @implements IAddLogHandlerRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set\n                     */\n                    function AddLogHandlerRequest(properties) {\n                        this.filters = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AddLogHandlerRequest id.\n                     * @member {string} id\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.id = \"\";\n    \n                    /**\n                     * AddLogHandlerRequest handlerType.\n                     * @member {particle.ctrl.logging.LogHandlerType} handlerType\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.handlerType = 0;\n    \n                    /**\n                     * AddLogHandlerRequest level.\n                     * @member {particle.ctrl.logging.LogLevel} level\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.level = 0;\n    \n                    /**\n                     * AddLogHandlerRequest filters.\n                     * @member {Array.<particle.ctrl.logging.ILogFilter>} filters\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.filters = $util.emptyArray;\n    \n                    /**\n                     * AddLogHandlerRequest streamType.\n                     * @member {particle.ctrl.logging.StreamType} streamType\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.streamType = 0;\n    \n                    /**\n                     * AddLogHandlerRequest serial.\n                     * @member {particle.ctrl.logging.ISerialStreamParams|null|undefined} serial\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    AddLogHandlerRequest.prototype.serial = null;\n    \n                    // OneOf field names bound to virtual getters and setters\n                    var $oneOfFields;\n    \n                    /**\n                     * AddLogHandlerRequest streamParams.\n                     * @member {\"serial\"|undefined} streamParams\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @instance\n                     */\n                    Object.defineProperty(AddLogHandlerRequest.prototype, \"streamParams\", {\n                        get: $util.oneOfGetter($oneOfFields = [\"serial\"]),\n                        set: $util.oneOfSetter($oneOfFields)\n                    });\n    \n                    /**\n                     * Creates a new AddLogHandlerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest instance\n                     */\n                    AddLogHandlerRequest.create = function create(properties) {\n                        return new AddLogHandlerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerRequest} message AddLogHandlerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddLogHandlerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                        if (message.handlerType != null && Object.hasOwnProperty.call(message, \"handlerType\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.handlerType);\n                        if (message.level != null && Object.hasOwnProperty.call(message, \"level\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);\n                        if (message.filters != null && message.filters.length)\n                            for (var i = 0; i < message.filters.length; ++i)\n                                $root.particle.ctrl.logging.LogFilter.encode(message.filters[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        if (message.streamType != null && Object.hasOwnProperty.call(message, \"streamType\"))\n                            writer.uint32(/* id 5, wireType 0 =*/40).int32(message.streamType);\n                        if (message.serial != null && Object.hasOwnProperty.call(message, \"serial\"))\n                            $root.particle.ctrl.logging.SerialStreamParams.encode(message.serial, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddLogHandlerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.AddLogHandlerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.AddLogHandlerRequest} AddLogHandlerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddLogHandlerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            case 2:\n                                message.handlerType = reader.int32();\n                                break;\n                            case 3:\n                                message.level = reader.int32();\n                                break;\n                            case 4:\n                                if (!(message.filters && message.filters.length))\n                                    message.filters = [];\n                                message.filters.push($root.particle.ctrl.logging.LogFilter.decode(reader, reader.uint32()));\n                                break;\n                            case 5:\n                                message.streamType = reader.int32();\n                                break;\n                            case 6:\n                                message.serial = $root.particle.ctrl.logging.SerialStreamParams.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddLogHandlerRequest;\n                })();\n    \n                logging.AddLogHandlerReply = (function() {\n    \n                    /**\n                     * Properties of an AddLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IAddLogHandlerReply\n                     */\n    \n                    /**\n                     * Constructs a new AddLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents an AddLogHandlerReply.\n                     * @implements IAddLogHandlerReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set\n                     */\n                    function AddLogHandlerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AddLogHandlerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply instance\n                     */\n                    AddLogHandlerReply.create = function create(properties) {\n                        return new AddLogHandlerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.AddLogHandlerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IAddLogHandlerReply} message AddLogHandlerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddLogHandlerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddLogHandlerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.AddLogHandlerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.AddLogHandlerReply} AddLogHandlerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddLogHandlerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.AddLogHandlerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddLogHandlerReply;\n                })();\n    \n                logging.RemoveLogHandlerRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IRemoveLogHandlerRequest\n                     * @property {string|null} [id] RemoveLogHandlerRequest id\n                     */\n    \n                    /**\n                     * Constructs a new RemoveLogHandlerRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Remove a log handler.\n                     * @implements IRemoveLogHandlerRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set\n                     */\n                    function RemoveLogHandlerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveLogHandlerRequest id.\n                     * @member {string} id\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @instance\n                     */\n                    RemoveLogHandlerRequest.prototype.id = \"\";\n    \n                    /**\n                     * Creates a new RemoveLogHandlerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest instance\n                     */\n                    RemoveLogHandlerRequest.create = function create(properties) {\n                        return new RemoveLogHandlerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveLogHandlerRequest message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerRequest} message RemoveLogHandlerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveLogHandlerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveLogHandlerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerRequest} RemoveLogHandlerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveLogHandlerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.id = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveLogHandlerRequest;\n                })();\n    \n                logging.RemoveLogHandlerReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IRemoveLogHandlerReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveLogHandlerReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents a RemoveLogHandlerReply.\n                     * @implements IRemoveLogHandlerReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set\n                     */\n                    function RemoveLogHandlerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveLogHandlerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply instance\n                     */\n                    RemoveLogHandlerReply.create = function create(properties) {\n                        return new RemoveLogHandlerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveLogHandlerReply message. Does not implicitly {@link particle.ctrl.logging.RemoveLogHandlerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {particle.ctrl.logging.IRemoveLogHandlerReply} message RemoveLogHandlerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveLogHandlerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveLogHandlerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.RemoveLogHandlerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.RemoveLogHandlerReply} RemoveLogHandlerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveLogHandlerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.RemoveLogHandlerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveLogHandlerReply;\n                })();\n    \n                logging.GetLogHandlersRequest = (function() {\n    \n                    /**\n                     * Properties of a GetLogHandlersRequest.\n                     * @memberof particle.ctrl.logging\n                     * @interface IGetLogHandlersRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetLogHandlersRequest.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Get the list of active log handlers.\n                     * @implements IGetLogHandlersRequest\n                     * @constructor\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set\n                     */\n                    function GetLogHandlersRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetLogHandlersRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest instance\n                     */\n                    GetLogHandlersRequest.create = function create(properties) {\n                        return new GetLogHandlersRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetLogHandlersRequest message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersRequest} message GetLogHandlersRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetLogHandlersRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetLogHandlersRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.GetLogHandlersRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.GetLogHandlersRequest} GetLogHandlersRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetLogHandlersRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetLogHandlersRequest;\n                })();\n    \n                logging.GetLogHandlersReply = (function() {\n    \n                    /**\n                     * Properties of a GetLogHandlersReply.\n                     * @memberof particle.ctrl.logging\n                     * @interface IGetLogHandlersReply\n                     * @property {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>|null} [handlers] GetLogHandlersReply handlers\n                     */\n    \n                    /**\n                     * Constructs a new GetLogHandlersReply.\n                     * @memberof particle.ctrl.logging\n                     * @classdesc Represents a GetLogHandlersReply.\n                     * @implements IGetLogHandlersReply\n                     * @constructor\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set\n                     */\n                    function GetLogHandlersReply(properties) {\n                        this.handlers = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetLogHandlersReply handlers.\n                     * @member {Array.<particle.ctrl.logging.GetLogHandlersReply.IHandler>} handlers\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @instance\n                     */\n                    GetLogHandlersReply.prototype.handlers = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetLogHandlersReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply instance\n                     */\n                    GetLogHandlersReply.create = function create(properties) {\n                        return new GetLogHandlersReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetLogHandlersReply message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {particle.ctrl.logging.IGetLogHandlersReply} message GetLogHandlersReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetLogHandlersReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.handlers != null && message.handlers.length)\n                            for (var i = 0; i < message.handlers.length; ++i)\n                                $root.particle.ctrl.logging.GetLogHandlersReply.Handler.encode(message.handlers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetLogHandlersReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.logging.GetLogHandlersReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.logging.GetLogHandlersReply} GetLogHandlersReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetLogHandlersReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.handlers && message.handlers.length))\n                                    message.handlers = [];\n                                message.handlers.push($root.particle.ctrl.logging.GetLogHandlersReply.Handler.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    GetLogHandlersReply.Handler = (function() {\n    \n                        /**\n                         * Properties of a Handler.\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply\n                         * @interface IHandler\n                         * @property {string|null} [id] Handler id\n                         */\n    \n                        /**\n                         * Constructs a new Handler.\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply\n                         * @classdesc Represents a Handler.\n                         * @implements IHandler\n                         * @constructor\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set\n                         */\n                        function Handler(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Handler id.\n                         * @member {string} id\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @instance\n                         */\n                        Handler.prototype.id = \"\";\n    \n                        /**\n                         * Creates a new Handler instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler=} [properties] Properties to set\n                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler instance\n                         */\n                        Handler.create = function create(properties) {\n                            return new Handler(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Handler message. Does not implicitly {@link particle.ctrl.logging.GetLogHandlersReply.Handler.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {particle.ctrl.logging.GetLogHandlersReply.IHandler} message Handler message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Handler.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.id != null && Object.hasOwnProperty.call(message, \"id\"))\n                                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Handler message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.logging.GetLogHandlersReply.Handler\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.logging.GetLogHandlersReply.Handler} Handler\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Handler.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.logging.GetLogHandlersReply.Handler();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.id = reader.string();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Handler;\n                    })();\n    \n                    return GetLogHandlersReply;\n                })();\n    \n                return logging;\n            })();\n    \n            ctrl.mesh = (function() {\n    \n                /**\n                 * Namespace mesh.\n                 * @memberof particle.ctrl\n                 * @namespace\n                 */\n                var mesh = {};\n    \n                mesh.NetworkInfo = (function() {\n    \n                    /**\n                     * Properties of a NetworkInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @interface INetworkInfo\n                     * @property {string|null} [name] NetworkInfo name\n                     * @property {string|null} [extPanId] NetworkInfo extPanId\n                     * @property {number|null} [panId] NetworkInfo panId\n                     * @property {number|null} [channel] NetworkInfo channel\n                     * @property {string|null} [networkId] NetworkInfo networkId\n                     */\n    \n                    /**\n                     * Constructs a new NetworkInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a NetworkInfo.\n                     * @implements INetworkInfo\n                     * @constructor\n                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set\n                     */\n                    function NetworkInfo(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * NetworkInfo name.\n                     * @member {string} name\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.name = \"\";\n    \n                    /**\n                     * NetworkInfo extPanId.\n                     * @member {string} extPanId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.extPanId = \"\";\n    \n                    /**\n                     * NetworkInfo panId.\n                     * @member {number} panId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.panId = 0;\n    \n                    /**\n                     * NetworkInfo channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.channel = 0;\n    \n                    /**\n                     * NetworkInfo networkId.\n                     * @member {string} networkId\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @instance\n                     */\n                    NetworkInfo.prototype.networkId = \"\";\n    \n                    /**\n                     * Creates a new NetworkInfo instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.INetworkInfo=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo instance\n                     */\n                    NetworkInfo.create = function create(properties) {\n                        return new NetworkInfo(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NetworkInfo message. Does not implicitly {@link particle.ctrl.mesh.NetworkInfo.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.INetworkInfo} message NetworkInfo message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NetworkInfo.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.extPanId != null && Object.hasOwnProperty.call(message, \"extPanId\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.extPanId);\n                        if (message.panId != null && Object.hasOwnProperty.call(message, \"panId\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.panId);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.channel);\n                        if (message.networkId != null && Object.hasOwnProperty.call(message, \"networkId\"))\n                            writer.uint32(/* id 5, wireType 2 =*/42).string(message.networkId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NetworkInfo message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.NetworkInfo\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.NetworkInfo} NetworkInfo\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NetworkInfo.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.NetworkInfo();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.extPanId = reader.string();\n                                break;\n                            case 3:\n                                message.panId = reader.uint32();\n                                break;\n                            case 4:\n                                message.channel = reader.uint32();\n                                break;\n                            case 5:\n                                message.networkId = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return NetworkInfo;\n                })();\n    \n                mesh.AuthRequest = (function() {\n    \n                    /**\n                     * Properties of an AuthRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAuthRequest\n                     * @property {string|null} [password] AuthRequest password\n                     */\n    \n                    /**\n                     * Constructs a new AuthRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AuthRequest.\n                     * @implements IAuthRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set\n                     */\n                    function AuthRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AuthRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @instance\n                     */\n                    AuthRequest.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new AuthRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest instance\n                     */\n                    AuthRequest.create = function create(properties) {\n                        return new AuthRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AuthRequest message. Does not implicitly {@link particle.ctrl.mesh.AuthRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthRequest} message AuthRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AuthRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AuthRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AuthRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AuthRequest} AuthRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AuthRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AuthRequest;\n                })();\n    \n                mesh.AuthReply = (function() {\n    \n                    /**\n                     * Properties of an AuthReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAuthReply\n                     */\n    \n                    /**\n                     * Constructs a new AuthReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AuthReply.\n                     * @implements IAuthReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set\n                     */\n                    function AuthReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AuthReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply instance\n                     */\n                    AuthReply.create = function create(properties) {\n                        return new AuthReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AuthReply message. Does not implicitly {@link particle.ctrl.mesh.AuthReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAuthReply} message AuthReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AuthReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AuthReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AuthReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AuthReply} AuthReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AuthReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AuthReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AuthReply;\n                })();\n    \n                mesh.CreateNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a CreateNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ICreateNetworkRequest\n                     * @property {string|null} [name] CreateNetworkRequest name\n                     * @property {string|null} [password] CreateNetworkRequest password\n                     * @property {number|null} [channel] CreateNetworkRequest channel\n                     * @property {string|null} [networkId] CreateNetworkRequest networkId\n                     */\n    \n                    /**\n                     * Constructs a new CreateNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a CreateNetworkRequest.\n                     * @implements ICreateNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set\n                     */\n                    function CreateNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * CreateNetworkRequest name.\n                     * @member {string} name\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.name = \"\";\n    \n                    /**\n                     * CreateNetworkRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.password = \"\";\n    \n                    /**\n                     * CreateNetworkRequest channel.\n                     * @member {number} channel\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.channel = 0;\n    \n                    /**\n                     * CreateNetworkRequest networkId.\n                     * @member {string} networkId\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @instance\n                     */\n                    CreateNetworkRequest.prototype.networkId = \"\";\n    \n                    /**\n                     * Creates a new CreateNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest instance\n                     */\n                    CreateNetworkRequest.create = function create(properties) {\n                        return new CreateNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified CreateNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkRequest} message CreateNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    CreateNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        if (message.channel != null && Object.hasOwnProperty.call(message, \"channel\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.channel);\n                        if (message.networkId != null && Object.hasOwnProperty.call(message, \"networkId\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.networkId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a CreateNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.CreateNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.CreateNetworkRequest} CreateNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    CreateNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.name = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            case 3:\n                                message.channel = reader.uint32();\n                                break;\n                            case 4:\n                                message.networkId = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return CreateNetworkRequest;\n                })();\n    \n                mesh.CreateNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a CreateNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ICreateNetworkReply\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] CreateNetworkReply network\n                     */\n    \n                    /**\n                     * Constructs a new CreateNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a CreateNetworkReply.\n                     * @implements ICreateNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set\n                     */\n                    function CreateNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * CreateNetworkReply network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @instance\n                     */\n                    CreateNetworkReply.prototype.network = null;\n    \n                    /**\n                     * Creates a new CreateNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply instance\n                     */\n                    CreateNetworkReply.create = function create(properties) {\n                        return new CreateNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified CreateNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.CreateNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ICreateNetworkReply} message CreateNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    CreateNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a CreateNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.CreateNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.CreateNetworkReply} CreateNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    CreateNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.CreateNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return CreateNetworkReply;\n                })();\n    \n                mesh.StartCommissionerRequest = (function() {\n    \n                    /**\n                     * Properties of a StartCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStartCommissionerRequest\n                     * @property {number|null} [timeout] StartCommissionerRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new StartCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StartCommissionerRequest.\n                     * @implements IStartCommissionerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set\n                     */\n                    function StartCommissionerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * StartCommissionerRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @instance\n                     */\n                    StartCommissionerRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new StartCommissionerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest instance\n                     */\n                    StartCommissionerRequest.create = function create(properties) {\n                        return new StartCommissionerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StartCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerRequest} message StartCommissionerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StartCommissionerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StartCommissionerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StartCommissionerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StartCommissionerRequest} StartCommissionerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StartCommissionerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StartCommissionerRequest;\n                })();\n    \n                mesh.StartCommissionerReply = (function() {\n    \n                    /**\n                     * Properties of a StartCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStartCommissionerReply\n                     */\n    \n                    /**\n                     * Constructs a new StartCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StartCommissionerReply.\n                     * @implements IStartCommissionerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set\n                     */\n                    function StartCommissionerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StartCommissionerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply instance\n                     */\n                    StartCommissionerReply.create = function create(properties) {\n                        return new StartCommissionerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StartCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StartCommissionerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStartCommissionerReply} message StartCommissionerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StartCommissionerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StartCommissionerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StartCommissionerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StartCommissionerReply} StartCommissionerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StartCommissionerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StartCommissionerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StartCommissionerReply;\n                })();\n    \n                mesh.StopCommissionerRequest = (function() {\n    \n                    /**\n                     * Properties of a StopCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStopCommissionerRequest\n                     */\n    \n                    /**\n                     * Constructs a new StopCommissionerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StopCommissionerRequest.\n                     * @implements IStopCommissionerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set\n                     */\n                    function StopCommissionerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StopCommissionerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest instance\n                     */\n                    StopCommissionerRequest.create = function create(properties) {\n                        return new StopCommissionerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StopCommissionerRequest message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerRequest} message StopCommissionerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StopCommissionerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StopCommissionerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StopCommissionerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StopCommissionerRequest} StopCommissionerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StopCommissionerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StopCommissionerRequest;\n                })();\n    \n                mesh.StopCommissionerReply = (function() {\n    \n                    /**\n                     * Properties of a StopCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IStopCommissionerReply\n                     */\n    \n                    /**\n                     * Constructs a new StopCommissionerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a StopCommissionerReply.\n                     * @implements IStopCommissionerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set\n                     */\n                    function StopCommissionerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new StopCommissionerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply instance\n                     */\n                    StopCommissionerReply.create = function create(properties) {\n                        return new StopCommissionerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified StopCommissionerReply message. Does not implicitly {@link particle.ctrl.mesh.StopCommissionerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IStopCommissionerReply} message StopCommissionerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    StopCommissionerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a StopCommissionerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.StopCommissionerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.StopCommissionerReply} StopCommissionerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    StopCommissionerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.StopCommissionerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return StopCommissionerReply;\n                })();\n    \n                mesh.PrepareJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of a PrepareJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IPrepareJoinerRequest\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] PrepareJoinerRequest network\n                     */\n    \n                    /**\n                     * Constructs a new PrepareJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a PrepareJoinerRequest.\n                     * @implements IPrepareJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set\n                     */\n                    function PrepareJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * PrepareJoinerRequest network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @instance\n                     */\n                    PrepareJoinerRequest.prototype.network = null;\n    \n                    /**\n                     * Creates a new PrepareJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest instance\n                     */\n                    PrepareJoinerRequest.create = function create(properties) {\n                        return new PrepareJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified PrepareJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerRequest} message PrepareJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    PrepareJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a PrepareJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.PrepareJoinerRequest} PrepareJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    PrepareJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return PrepareJoinerRequest;\n                })();\n    \n                mesh.PrepareJoinerReply = (function() {\n    \n                    /**\n                     * Properties of a PrepareJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IPrepareJoinerReply\n                     * @property {string|null} [eui64] PrepareJoinerReply eui64\n                     * @property {string|null} [password] PrepareJoinerReply password\n                     */\n    \n                    /**\n                     * Constructs a new PrepareJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a PrepareJoinerReply.\n                     * @implements IPrepareJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set\n                     */\n                    function PrepareJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * PrepareJoinerReply eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @instance\n                     */\n                    PrepareJoinerReply.prototype.eui64 = \"\";\n    \n                    /**\n                     * PrepareJoinerReply password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @instance\n                     */\n                    PrepareJoinerReply.prototype.password = \"\";\n    \n                    /**\n                     * Creates a new PrepareJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply instance\n                     */\n                    PrepareJoinerReply.create = function create(properties) {\n                        return new PrepareJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified PrepareJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.PrepareJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IPrepareJoinerReply} message PrepareJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    PrepareJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a PrepareJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.PrepareJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.PrepareJoinerReply} PrepareJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    PrepareJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.PrepareJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return PrepareJoinerReply;\n                })();\n    \n                mesh.AddJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of an AddJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAddJoinerRequest\n                     * @property {string|null} [eui64] AddJoinerRequest eui64\n                     * @property {string|null} [password] AddJoinerRequest password\n                     * @property {number|null} [timeout] AddJoinerRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new AddJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AddJoinerRequest.\n                     * @implements IAddJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set\n                     */\n                    function AddJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * AddJoinerRequest eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.eui64 = \"\";\n    \n                    /**\n                     * AddJoinerRequest password.\n                     * @member {string} password\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.password = \"\";\n    \n                    /**\n                     * AddJoinerRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @instance\n                     */\n                    AddJoinerRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new AddJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest instance\n                     */\n                    AddJoinerRequest.create = function create(properties) {\n                        return new AddJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerRequest} message AddJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        if (message.password != null && Object.hasOwnProperty.call(message, \"password\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.password);\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AddJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AddJoinerRequest} AddJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            case 2:\n                                message.password = reader.string();\n                                break;\n                            case 3:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddJoinerRequest;\n                })();\n    \n                mesh.AddJoinerReply = (function() {\n    \n                    /**\n                     * Properties of an AddJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IAddJoinerReply\n                     */\n    \n                    /**\n                     * Constructs a new AddJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents an AddJoinerReply.\n                     * @implements IAddJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set\n                     */\n                    function AddJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new AddJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply instance\n                     */\n                    AddJoinerReply.create = function create(properties) {\n                        return new AddJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified AddJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.AddJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IAddJoinerReply} message AddJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    AddJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an AddJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.AddJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.AddJoinerReply} AddJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    AddJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.AddJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return AddJoinerReply;\n                })();\n    \n                mesh.RemoveJoinerRequest = (function() {\n    \n                    /**\n                     * Properties of a RemoveJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IRemoveJoinerRequest\n                     * @property {string|null} [eui64] RemoveJoinerRequest eui64\n                     */\n    \n                    /**\n                     * Constructs a new RemoveJoinerRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a RemoveJoinerRequest.\n                     * @implements IRemoveJoinerRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set\n                     */\n                    function RemoveJoinerRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * RemoveJoinerRequest eui64.\n                     * @member {string} eui64\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @instance\n                     */\n                    RemoveJoinerRequest.prototype.eui64 = \"\";\n    \n                    /**\n                     * Creates a new RemoveJoinerRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest instance\n                     */\n                    RemoveJoinerRequest.create = function create(properties) {\n                        return new RemoveJoinerRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveJoinerRequest message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerRequest} message RemoveJoinerRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveJoinerRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.eui64 != null && Object.hasOwnProperty.call(message, \"eui64\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.eui64);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveJoinerRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.RemoveJoinerRequest} RemoveJoinerRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveJoinerRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.eui64 = reader.string();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveJoinerRequest;\n                })();\n    \n                mesh.RemoveJoinerReply = (function() {\n    \n                    /**\n                     * Properties of a RemoveJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IRemoveJoinerReply\n                     */\n    \n                    /**\n                     * Constructs a new RemoveJoinerReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a RemoveJoinerReply.\n                     * @implements IRemoveJoinerReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set\n                     */\n                    function RemoveJoinerReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new RemoveJoinerReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply instance\n                     */\n                    RemoveJoinerReply.create = function create(properties) {\n                        return new RemoveJoinerReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified RemoveJoinerReply message. Does not implicitly {@link particle.ctrl.mesh.RemoveJoinerReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IRemoveJoinerReply} message RemoveJoinerReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    RemoveJoinerReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a RemoveJoinerReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.RemoveJoinerReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.RemoveJoinerReply} RemoveJoinerReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    RemoveJoinerReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.RemoveJoinerReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return RemoveJoinerReply;\n                })();\n    \n                mesh.JoinNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a JoinNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IJoinNetworkRequest\n                     * @property {number|null} [timeout] JoinNetworkRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new JoinNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a JoinNetworkRequest.\n                     * @implements IJoinNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set\n                     */\n                    function JoinNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * JoinNetworkRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @instance\n                     */\n                    JoinNetworkRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new JoinNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest instance\n                     */\n                    JoinNetworkRequest.create = function create(properties) {\n                        return new JoinNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkRequest} message JoinNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.JoinNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.JoinNetworkRequest} JoinNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNetworkRequest;\n                })();\n    \n                mesh.JoinNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a JoinNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IJoinNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new JoinNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a JoinNetworkReply.\n                     * @implements IJoinNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set\n                     */\n                    function JoinNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new JoinNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply instance\n                     */\n                    JoinNetworkReply.create = function create(properties) {\n                        return new JoinNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified JoinNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.JoinNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IJoinNetworkReply} message JoinNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    JoinNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a JoinNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.JoinNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.JoinNetworkReply} JoinNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    JoinNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.JoinNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return JoinNetworkReply;\n                })();\n    \n                mesh.LeaveNetworkRequest = (function() {\n    \n                    /**\n                     * Properties of a LeaveNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ILeaveNetworkRequest\n                     */\n    \n                    /**\n                     * Constructs a new LeaveNetworkRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a LeaveNetworkRequest.\n                     * @implements ILeaveNetworkRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set\n                     */\n                    function LeaveNetworkRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new LeaveNetworkRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest instance\n                     */\n                    LeaveNetworkRequest.create = function create(properties) {\n                        return new LeaveNetworkRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LeaveNetworkRequest message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkRequest} message LeaveNetworkRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LeaveNetworkRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LeaveNetworkRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.LeaveNetworkRequest} LeaveNetworkRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LeaveNetworkRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LeaveNetworkRequest;\n                })();\n    \n                mesh.LeaveNetworkReply = (function() {\n    \n                    /**\n                     * Properties of a LeaveNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface ILeaveNetworkReply\n                     */\n    \n                    /**\n                     * Constructs a new LeaveNetworkReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a LeaveNetworkReply.\n                     * @implements ILeaveNetworkReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set\n                     */\n                    function LeaveNetworkReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new LeaveNetworkReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply instance\n                     */\n                    LeaveNetworkReply.create = function create(properties) {\n                        return new LeaveNetworkReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified LeaveNetworkReply message. Does not implicitly {@link particle.ctrl.mesh.LeaveNetworkReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {particle.ctrl.mesh.ILeaveNetworkReply} message LeaveNetworkReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    LeaveNetworkReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a LeaveNetworkReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.LeaveNetworkReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.LeaveNetworkReply} LeaveNetworkReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    LeaveNetworkReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.LeaveNetworkReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return LeaveNetworkReply;\n                })();\n    \n                mesh.GetNetworkInfoRequest = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkInfoRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkInfoRequest\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkInfoRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkInfoRequest.\n                     * @implements IGetNetworkInfoRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set\n                     */\n                    function GetNetworkInfoRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Creates a new GetNetworkInfoRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest instance\n                     */\n                    GetNetworkInfoRequest.create = function create(properties) {\n                        return new GetNetworkInfoRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkInfoRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoRequest} message GetNetworkInfoRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkInfoRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkInfoRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoRequest} GetNetworkInfoRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkInfoRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkInfoRequest;\n                })();\n    \n                mesh.GetNetworkInfoReply = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkInfoReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkInfoReply\n                     * @property {particle.ctrl.mesh.INetworkInfo|null} [network] GetNetworkInfoReply network\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkInfoReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkInfoReply.\n                     * @implements IGetNetworkInfoReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set\n                     */\n                    function GetNetworkInfoReply(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkInfoReply network.\n                     * @member {particle.ctrl.mesh.INetworkInfo|null|undefined} network\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @instance\n                     */\n                    GetNetworkInfoReply.prototype.network = null;\n    \n                    /**\n                     * Creates a new GetNetworkInfoReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply instance\n                     */\n                    GetNetworkInfoReply.create = function create(properties) {\n                        return new GetNetworkInfoReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkInfoReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkInfoReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkInfoReply} message GetNetworkInfoReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkInfoReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.network != null && Object.hasOwnProperty.call(message, \"network\"))\n                            $root.particle.ctrl.mesh.NetworkInfo.encode(message.network, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkInfoReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkInfoReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkInfoReply} GetNetworkInfoReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkInfoReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkInfoReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.network = $root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkInfoReply;\n                })();\n    \n                mesh.ScanNetworksRequest = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IScanNetworksRequest\n                     * @property {number|null} [duration] ScanNetworksRequest duration\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a ScanNetworksRequest.\n                     * @implements IScanNetworksRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set\n                     */\n                    function ScanNetworksRequest(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksRequest duration.\n                     * @member {number} duration\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @instance\n                     */\n                    ScanNetworksRequest.prototype.duration = 0;\n    \n                    /**\n                     * Creates a new ScanNetworksRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest instance\n                     */\n                    ScanNetworksRequest.create = function create(properties) {\n                        return new ScanNetworksRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksRequest message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksRequest} message ScanNetworksRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.duration != null && Object.hasOwnProperty.call(message, \"duration\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.duration);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.ScanNetworksRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.ScanNetworksRequest} ScanNetworksRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.duration = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksRequest;\n                })();\n    \n                mesh.ScanNetworksReply = (function() {\n    \n                    /**\n                     * Properties of a ScanNetworksReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IScanNetworksReply\n                     * @property {Array.<particle.ctrl.mesh.INetworkInfo>|null} [networks] ScanNetworksReply networks\n                     */\n    \n                    /**\n                     * Constructs a new ScanNetworksReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a ScanNetworksReply.\n                     * @implements IScanNetworksReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set\n                     */\n                    function ScanNetworksReply(properties) {\n                        this.networks = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ScanNetworksReply networks.\n                     * @member {Array.<particle.ctrl.mesh.INetworkInfo>} networks\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @instance\n                     */\n                    ScanNetworksReply.prototype.networks = $util.emptyArray;\n    \n                    /**\n                     * Creates a new ScanNetworksReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply instance\n                     */\n                    ScanNetworksReply.create = function create(properties) {\n                        return new ScanNetworksReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ScanNetworksReply message. Does not implicitly {@link particle.ctrl.mesh.ScanNetworksReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IScanNetworksReply} message ScanNetworksReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ScanNetworksReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.networks != null && message.networks.length)\n                            for (var i = 0; i < message.networks.length; ++i)\n                                $root.particle.ctrl.mesh.NetworkInfo.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ScanNetworksReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.ScanNetworksReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.ScanNetworksReply} ScanNetworksReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ScanNetworksReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.ScanNetworksReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.networks && message.networks.length))\n                                    message.networks = [];\n                                message.networks.push($root.particle.ctrl.mesh.NetworkInfo.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ScanNetworksReply;\n                })();\n    \n                /**\n                 * DiagnosticType enum.\n                 * @name particle.ctrl.mesh.DiagnosticType\n                 * @enum {number}\n                 * @property {number} MAC_EXTENDED_ADDRESS=0 MAC_EXTENDED_ADDRESS value\n                 * @property {number} RLOC=1 RLOC value\n                 * @property {number} MAC_ADDRESS=1 MAC_ADDRESS value\n                 * @property {number} MODE=2 MODE value\n                 * @property {number} TIMEOUT=3 TIMEOUT value\n                 * @property {number} CONNECTIVITY=4 CONNECTIVITY value\n                 * @property {number} ROUTE64=5 ROUTE64 value\n                 * @property {number} LEADER_DATA=6 LEADER_DATA value\n                 * @property {number} NETWORK_DATA=7 NETWORK_DATA value\n                 * @property {number} IPV6_ADDRESS_LIST=8 IPV6_ADDRESS_LIST value\n                 * @property {number} MAC_COUNTERS=9 MAC_COUNTERS value\n                 * @property {number} BATTERY_LEVEL=14 BATTERY_LEVEL value\n                 * @property {number} SUPPLY_VOLTAGE=15 SUPPLY_VOLTAGE value\n                 * @property {number} CHILD_TABLE=16 CHILD_TABLE value\n                 * @property {number} CHANNEL_PAGES=17 CHANNEL_PAGES value\n                 * @property {number} TYPE_LIST=18 TYPE_LIST value\n                 * @property {number} MAX_CHILD_TIMEOUT=19 MAX_CHILD_TIMEOUT value\n                 */\n                mesh.DiagnosticType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"MAC_EXTENDED_ADDRESS\"] = 0;\n                    values[valuesById[1] = \"RLOC\"] = 1;\n                    values[\"MAC_ADDRESS\"] = 1;\n                    values[valuesById[2] = \"MODE\"] = 2;\n                    values[valuesById[3] = \"TIMEOUT\"] = 3;\n                    values[valuesById[4] = \"CONNECTIVITY\"] = 4;\n                    values[valuesById[5] = \"ROUTE64\"] = 5;\n                    values[valuesById[6] = \"LEADER_DATA\"] = 6;\n                    values[valuesById[7] = \"NETWORK_DATA\"] = 7;\n                    values[valuesById[8] = \"IPV6_ADDRESS_LIST\"] = 8;\n                    values[valuesById[9] = \"MAC_COUNTERS\"] = 9;\n                    values[valuesById[14] = \"BATTERY_LEVEL\"] = 14;\n                    values[valuesById[15] = \"SUPPLY_VOLTAGE\"] = 15;\n                    values[valuesById[16] = \"CHILD_TABLE\"] = 16;\n                    values[valuesById[17] = \"CHANNEL_PAGES\"] = 17;\n                    values[valuesById[18] = \"TYPE_LIST\"] = 18;\n                    values[valuesById[19] = \"MAX_CHILD_TIMEOUT\"] = 19;\n                    return values;\n                })();\n    \n                mesh.DiagnosticInfo = (function() {\n    \n                    /**\n                     * Properties of a DiagnosticInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IDiagnosticInfo\n                     * @property {Uint8Array|null} [extMacAddress] DiagnosticInfo extMacAddress\n                     * @property {number|null} [rloc] DiagnosticInfo rloc\n                     * @property {number|null} [mode] DiagnosticInfo mode\n                     * @property {number|null} [timeout] DiagnosticInfo timeout\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null} [connectivity] DiagnosticInfo connectivity\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null} [route64] DiagnosticInfo route64\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null} [leaderData] DiagnosticInfo leaderData\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null} [networkData] DiagnosticInfo networkData\n                     * @property {Array.<particle.ctrl.IIpv6Address>|null} [ipv6AddressList] DiagnosticInfo ipv6AddressList\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null} [macCounters] DiagnosticInfo macCounters\n                     * @property {number|null} [batteryLevel] DiagnosticInfo batteryLevel\n                     * @property {number|null} [supplyVoltage] DiagnosticInfo supplyVoltage\n                     * @property {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null} [childTable] DiagnosticInfo childTable\n                     * @property {Uint8Array|null} [channelPages] DiagnosticInfo channelPages\n                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [typeList] DiagnosticInfo typeList\n                     * @property {number|null} [maxChildTimeout] DiagnosticInfo maxChildTimeout\n                     * @property {Uint8Array|null} [deviceId] DiagnosticInfo deviceId\n                     */\n    \n                    /**\n                     * Constructs a new DiagnosticInfo.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a DiagnosticInfo.\n                     * @implements IDiagnosticInfo\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set\n                     */\n                    function DiagnosticInfo(properties) {\n                        this.ipv6AddressList = [];\n                        this.typeList = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * DiagnosticInfo extMacAddress.\n                     * @member {Uint8Array} extMacAddress\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.extMacAddress = $util.newBuffer([]);\n    \n                    /**\n                     * DiagnosticInfo rloc.\n                     * @member {number} rloc\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.rloc = 0;\n    \n                    /**\n                     * DiagnosticInfo mode.\n                     * @member {number} mode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.mode = 0;\n    \n                    /**\n                     * DiagnosticInfo timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.timeout = 0;\n    \n                    /**\n                     * DiagnosticInfo connectivity.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IConnectivity|null|undefined} connectivity\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.connectivity = null;\n    \n                    /**\n                     * DiagnosticInfo route64.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IRoute64|null|undefined} route64\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.route64 = null;\n    \n                    /**\n                     * DiagnosticInfo leaderData.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.ILeaderData|null|undefined} leaderData\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.leaderData = null;\n    \n                    /**\n                     * DiagnosticInfo networkData.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.INetworkData|null|undefined} networkData\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.networkData = null;\n    \n                    /**\n                     * DiagnosticInfo ipv6AddressList.\n                     * @member {Array.<particle.ctrl.IIpv6Address>} ipv6AddressList\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.ipv6AddressList = $util.emptyArray;\n    \n                    /**\n                     * DiagnosticInfo macCounters.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IMacCounters|null|undefined} macCounters\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.macCounters = null;\n    \n                    /**\n                     * DiagnosticInfo batteryLevel.\n                     * @member {number} batteryLevel\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.batteryLevel = 0;\n    \n                    /**\n                     * DiagnosticInfo supplyVoltage.\n                     * @member {number} supplyVoltage\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.supplyVoltage = 0;\n    \n                    /**\n                     * DiagnosticInfo childTable.\n                     * @member {particle.ctrl.mesh.DiagnosticInfo.IChildTable|null|undefined} childTable\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.childTable = null;\n    \n                    /**\n                     * DiagnosticInfo channelPages.\n                     * @member {Uint8Array} channelPages\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.channelPages = $util.newBuffer([]);\n    \n                    /**\n                     * DiagnosticInfo typeList.\n                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} typeList\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.typeList = $util.emptyArray;\n    \n                    /**\n                     * DiagnosticInfo maxChildTimeout.\n                     * @member {number} maxChildTimeout\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.maxChildTimeout = 0;\n    \n                    /**\n                     * DiagnosticInfo deviceId.\n                     * @member {Uint8Array} deviceId\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @instance\n                     */\n                    DiagnosticInfo.prototype.deviceId = $util.newBuffer([]);\n    \n                    /**\n                     * Creates a new DiagnosticInfo instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo instance\n                     */\n                    DiagnosticInfo.create = function create(properties) {\n                        return new DiagnosticInfo(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified DiagnosticInfo message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {particle.ctrl.mesh.IDiagnosticInfo} message DiagnosticInfo message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    DiagnosticInfo.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.extMacAddress != null && Object.hasOwnProperty.call(message, \"extMacAddress\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.extMacAddress);\n                        if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.rloc);\n                        if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.timeout);\n                        if (message.connectivity != null && Object.hasOwnProperty.call(message, \"connectivity\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.encode(message.connectivity, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                        if (message.route64 != null && Object.hasOwnProperty.call(message, \"route64\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.Route64.encode(message.route64, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        if (message.leaderData != null && Object.hasOwnProperty.call(message, \"leaderData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.encode(message.leaderData, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                        if (message.networkData != null && Object.hasOwnProperty.call(message, \"networkData\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.encode(message.networkData, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                        if (message.ipv6AddressList != null && message.ipv6AddressList.length)\n                            for (var i = 0; i < message.ipv6AddressList.length; ++i)\n                                $root.particle.ctrl.Ipv6Address.encode(message.ipv6AddressList[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                        if (message.macCounters != null && Object.hasOwnProperty.call(message, \"macCounters\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.encode(message.macCounters, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();\n                        if (message.batteryLevel != null && Object.hasOwnProperty.call(message, \"batteryLevel\"))\n                            writer.uint32(/* id 15, wireType 0 =*/120).uint32(message.batteryLevel);\n                        if (message.supplyVoltage != null && Object.hasOwnProperty.call(message, \"supplyVoltage\"))\n                            writer.uint32(/* id 16, wireType 0 =*/128).uint32(message.supplyVoltage);\n                        if (message.childTable != null && Object.hasOwnProperty.call(message, \"childTable\"))\n                            $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.encode(message.childTable, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();\n                        if (message.channelPages != null && Object.hasOwnProperty.call(message, \"channelPages\"))\n                            writer.uint32(/* id 18, wireType 2 =*/146).bytes(message.channelPages);\n                        if (message.typeList != null && message.typeList.length) {\n                            writer.uint32(/* id 19, wireType 2 =*/154).fork();\n                            for (var i = 0; i < message.typeList.length; ++i)\n                                writer.int32(message.typeList[i]);\n                            writer.ldelim();\n                        }\n                        if (message.maxChildTimeout != null && Object.hasOwnProperty.call(message, \"maxChildTimeout\"))\n                            writer.uint32(/* id 20, wireType 0 =*/160).uint32(message.maxChildTimeout);\n                        if (message.deviceId != null && Object.hasOwnProperty.call(message, \"deviceId\"))\n                            writer.uint32(/* id 100, wireType 2 =*/802).bytes(message.deviceId);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a DiagnosticInfo message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.DiagnosticInfo\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.DiagnosticInfo} DiagnosticInfo\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    DiagnosticInfo.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.extMacAddress = reader.bytes();\n                                break;\n                            case 2:\n                                message.rloc = reader.uint32();\n                                break;\n                            case 3:\n                                message.mode = reader.uint32();\n                                break;\n                            case 4:\n                                message.timeout = reader.uint32();\n                                break;\n                            case 5:\n                                message.connectivity = $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity.decode(reader, reader.uint32());\n                                break;\n                            case 6:\n                                message.route64 = $root.particle.ctrl.mesh.DiagnosticInfo.Route64.decode(reader, reader.uint32());\n                                break;\n                            case 7:\n                                message.leaderData = $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData.decode(reader, reader.uint32());\n                                break;\n                            case 8:\n                                message.networkData = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.decode(reader, reader.uint32());\n                                break;\n                            case 9:\n                                if (!(message.ipv6AddressList && message.ipv6AddressList.length))\n                                    message.ipv6AddressList = [];\n                                message.ipv6AddressList.push($root.particle.ctrl.Ipv6Address.decode(reader, reader.uint32()));\n                                break;\n                            case 10:\n                                message.macCounters = $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters.decode(reader, reader.uint32());\n                                break;\n                            case 15:\n                                message.batteryLevel = reader.uint32();\n                                break;\n                            case 16:\n                                message.supplyVoltage = reader.uint32();\n                                break;\n                            case 17:\n                                message.childTable = $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.decode(reader, reader.uint32());\n                                break;\n                            case 18:\n                                message.channelPages = reader.bytes();\n                                break;\n                            case 19:\n                                if (!(message.typeList && message.typeList.length))\n                                    message.typeList = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.typeList.push(reader.int32());\n                                } else\n                                    message.typeList.push(reader.int32());\n                                break;\n                            case 20:\n                                message.maxChildTimeout = reader.uint32();\n                                break;\n                            case 100:\n                                message.deviceId = reader.bytes();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    /**\n                     * Mode enum.\n                     * @name particle.ctrl.mesh.DiagnosticInfo.Mode\n                     * @enum {number}\n                     * @property {number} INVALID=0 INVALID value\n                     * @property {number} RECEIVER_ON_WHEN_IDLE=16 RECEIVER_ON_WHEN_IDLE value\n                     * @property {number} SECURE_DATA_REQUESTS=32 SECURE_DATA_REQUESTS value\n                     * @property {number} DEVICE_TYPE=48 DEVICE_TYPE value\n                     * @property {number} DEVICE_TYPE_FTD=48 DEVICE_TYPE_FTD value\n                     * @property {number} NETWORK_DATA=64 NETWORK_DATA value\n                     * @property {number} NETWORK_DATA_FULL=64 NETWORK_DATA_FULL value\n                     */\n                    DiagnosticInfo.Mode = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[16] = \"RECEIVER_ON_WHEN_IDLE\"] = 16;\n                        values[valuesById[32] = \"SECURE_DATA_REQUESTS\"] = 32;\n                        values[valuesById[48] = \"DEVICE_TYPE\"] = 48;\n                        values[\"DEVICE_TYPE_FTD\"] = 48;\n                        values[valuesById[64] = \"NETWORK_DATA\"] = 64;\n                        values[\"NETWORK_DATA_FULL\"] = 64;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.Connectivity = (function() {\n    \n                        /**\n                         * Properties of a Connectivity.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IConnectivity\n                         * @property {number|null} [parentPriority] Connectivity parentPriority\n                         * @property {number|null} [linkQuality_1] Connectivity linkQuality_1\n                         * @property {number|null} [linkQuality_2] Connectivity linkQuality_2\n                         * @property {number|null} [linkQuality_3] Connectivity linkQuality_3\n                         * @property {number|null} [leaderCost] Connectivity leaderCost\n                         * @property {number|null} [idSequence] Connectivity idSequence\n                         * @property {number|null} [activeRouters] Connectivity activeRouters\n                         * @property {number|null} [sedBufferSize] Connectivity sedBufferSize\n                         * @property {number|null} [sedDatagramCount] Connectivity sedDatagramCount\n                         */\n    \n                        /**\n                         * Constructs a new Connectivity.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a Connectivity.\n                         * @implements IConnectivity\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set\n                         */\n                        function Connectivity(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Connectivity parentPriority.\n                         * @member {number} parentPriority\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.parentPriority = 0;\n    \n                        /**\n                         * Connectivity linkQuality_1.\n                         * @member {number} linkQuality_1\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_1 = 0;\n    \n                        /**\n                         * Connectivity linkQuality_2.\n                         * @member {number} linkQuality_2\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_2 = 0;\n    \n                        /**\n                         * Connectivity linkQuality_3.\n                         * @member {number} linkQuality_3\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.linkQuality_3 = 0;\n    \n                        /**\n                         * Connectivity leaderCost.\n                         * @member {number} leaderCost\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.leaderCost = 0;\n    \n                        /**\n                         * Connectivity idSequence.\n                         * @member {number} idSequence\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.idSequence = 0;\n    \n                        /**\n                         * Connectivity activeRouters.\n                         * @member {number} activeRouters\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.activeRouters = 0;\n    \n                        /**\n                         * Connectivity sedBufferSize.\n                         * @member {number} sedBufferSize\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.sedBufferSize = 0;\n    \n                        /**\n                         * Connectivity sedDatagramCount.\n                         * @member {number} sedDatagramCount\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @instance\n                         */\n                        Connectivity.prototype.sedDatagramCount = 0;\n    \n                        /**\n                         * Creates a new Connectivity instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity instance\n                         */\n                        Connectivity.create = function create(properties) {\n                            return new Connectivity(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Connectivity message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Connectivity.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IConnectivity} message Connectivity message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Connectivity.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.parentPriority != null && Object.hasOwnProperty.call(message, \"parentPriority\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.parentPriority);\n                            if (message.linkQuality_1 != null && Object.hasOwnProperty.call(message, \"linkQuality_1\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQuality_1);\n                            if (message.linkQuality_2 != null && Object.hasOwnProperty.call(message, \"linkQuality_2\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQuality_2);\n                            if (message.linkQuality_3 != null && Object.hasOwnProperty.call(message, \"linkQuality_3\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.linkQuality_3);\n                            if (message.leaderCost != null && Object.hasOwnProperty.call(message, \"leaderCost\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderCost);\n                            if (message.idSequence != null && Object.hasOwnProperty.call(message, \"idSequence\"))\n                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.idSequence);\n                            if (message.activeRouters != null && Object.hasOwnProperty.call(message, \"activeRouters\"))\n                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.activeRouters);\n                            if (message.sedBufferSize != null && Object.hasOwnProperty.call(message, \"sedBufferSize\"))\n                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.sedBufferSize);\n                            if (message.sedDatagramCount != null && Object.hasOwnProperty.call(message, \"sedDatagramCount\"))\n                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.sedDatagramCount);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Connectivity message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Connectivity\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Connectivity} Connectivity\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Connectivity.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Connectivity();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.parentPriority = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.linkQuality_1 = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.linkQuality_2 = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.linkQuality_3 = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.leaderCost = reader.uint32();\n                                    break;\n                                case 6:\n                                    message.idSequence = reader.uint32();\n                                    break;\n                                case 7:\n                                    message.activeRouters = reader.uint32();\n                                    break;\n                                case 8:\n                                    message.sedBufferSize = reader.uint32();\n                                    break;\n                                case 9:\n                                    message.sedDatagramCount = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return Connectivity;\n                    })();\n    \n                    DiagnosticInfo.Route64 = (function() {\n    \n                        /**\n                         * Properties of a Route64.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IRoute64\n                         * @property {number|null} [idSequence] Route64 idSequence\n                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>|null} [routes] Route64 routes\n                         */\n    \n                        /**\n                         * Constructs a new Route64.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a Route64.\n                         * @implements IRoute64\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set\n                         */\n                        function Route64(properties) {\n                            this.routes = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * Route64 idSequence.\n                         * @member {number} idSequence\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @instance\n                         */\n                        Route64.prototype.idSequence = 0;\n    \n                        /**\n                         * Route64 routes.\n                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData>} routes\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @instance\n                         */\n                        Route64.prototype.routes = $util.emptyArray;\n    \n                        /**\n                         * Creates a new Route64 instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64 instance\n                         */\n                        Route64.create = function create(properties) {\n                            return new Route64(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified Route64 message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IRoute64} message Route64 message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        Route64.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.idSequence != null && Object.hasOwnProperty.call(message, \"idSequence\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.idSequence);\n                            if (message.routes != null && message.routes.length)\n                                for (var i = 0; i < message.routes.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.encode(message.routes[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a Route64 message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64} Route64\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        Route64.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.idSequence = reader.uint32();\n                                    break;\n                                case 2:\n                                    if (!(message.routes && message.routes.length))\n                                        message.routes = [];\n                                    message.routes.push($root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.decode(reader, reader.uint32()));\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        Route64.RouteData = (function() {\n    \n                            /**\n                             * Properties of a RouteData.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                             * @interface IRouteData\n                             * @property {number|null} [routerRloc] RouteData routerRloc\n                             * @property {number|null} [linkQualityOut] RouteData linkQualityOut\n                             * @property {number|null} [linkQualityIn] RouteData linkQualityIn\n                             * @property {number|null} [routeCost] RouteData routeCost\n                             */\n    \n                            /**\n                             * Constructs a new RouteData.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64\n                             * @classdesc Represents a RouteData.\n                             * @implements IRouteData\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set\n                             */\n                            function RouteData(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * RouteData routerRloc.\n                             * @member {number} routerRloc\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.routerRloc = 0;\n    \n                            /**\n                             * RouteData linkQualityOut.\n                             * @member {number} linkQualityOut\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.linkQualityOut = 0;\n    \n                            /**\n                             * RouteData linkQualityIn.\n                             * @member {number} linkQualityIn\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.linkQualityIn = 0;\n    \n                            /**\n                             * RouteData routeCost.\n                             * @member {number} routeCost\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @instance\n                             */\n                            RouteData.prototype.routeCost = 0;\n    \n                            /**\n                             * Creates a new RouteData instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData instance\n                             */\n                            RouteData.create = function create(properties) {\n                                return new RouteData(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified RouteData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.Route64.IRouteData} message RouteData message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            RouteData.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.routerRloc != null && Object.hasOwnProperty.call(message, \"routerRloc\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.routerRloc);\n                                if (message.linkQualityOut != null && Object.hasOwnProperty.call(message, \"linkQualityOut\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.linkQualityOut);\n                                if (message.linkQualityIn != null && Object.hasOwnProperty.call(message, \"linkQualityIn\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.linkQualityIn);\n                                if (message.routeCost != null && Object.hasOwnProperty.call(message, \"routeCost\"))\n                                    writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.routeCost);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a RouteData message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData} RouteData\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            RouteData.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.Route64.RouteData();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.routerRloc = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.linkQualityOut = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.linkQualityIn = reader.uint32();\n                                        break;\n                                    case 4:\n                                        message.routeCost = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return RouteData;\n                        })();\n    \n                        return Route64;\n                    })();\n    \n                    DiagnosticInfo.LeaderData = (function() {\n    \n                        /**\n                         * Properties of a LeaderData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface ILeaderData\n                         * @property {number|null} [partitionId] LeaderData partitionId\n                         * @property {number|null} [weighting] LeaderData weighting\n                         * @property {number|null} [dataVersion] LeaderData dataVersion\n                         * @property {number|null} [stableDataVersion] LeaderData stableDataVersion\n                         * @property {number|null} [leaderRloc] LeaderData leaderRloc\n                         */\n    \n                        /**\n                         * Constructs a new LeaderData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a LeaderData.\n                         * @implements ILeaderData\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set\n                         */\n                        function LeaderData(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * LeaderData partitionId.\n                         * @member {number} partitionId\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.partitionId = 0;\n    \n                        /**\n                         * LeaderData weighting.\n                         * @member {number} weighting\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.weighting = 0;\n    \n                        /**\n                         * LeaderData dataVersion.\n                         * @member {number} dataVersion\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.dataVersion = 0;\n    \n                        /**\n                         * LeaderData stableDataVersion.\n                         * @member {number} stableDataVersion\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.stableDataVersion = 0;\n    \n                        /**\n                         * LeaderData leaderRloc.\n                         * @member {number} leaderRloc\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @instance\n                         */\n                        LeaderData.prototype.leaderRloc = 0;\n    \n                        /**\n                         * Creates a new LeaderData instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData instance\n                         */\n                        LeaderData.create = function create(properties) {\n                            return new LeaderData(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified LeaderData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.LeaderData.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.ILeaderData} message LeaderData message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        LeaderData.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.partitionId != null && Object.hasOwnProperty.call(message, \"partitionId\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.partitionId);\n                            if (message.weighting != null && Object.hasOwnProperty.call(message, \"weighting\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.weighting);\n                            if (message.dataVersion != null && Object.hasOwnProperty.call(message, \"dataVersion\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.dataVersion);\n                            if (message.stableDataVersion != null && Object.hasOwnProperty.call(message, \"stableDataVersion\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.stableDataVersion);\n                            if (message.leaderRloc != null && Object.hasOwnProperty.call(message, \"leaderRloc\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.leaderRloc);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a LeaderData message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.LeaderData\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.LeaderData} LeaderData\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        LeaderData.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.LeaderData();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.partitionId = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.weighting = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.dataVersion = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.stableDataVersion = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.leaderRloc = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return LeaderData;\n                    })();\n    \n                    /**\n                     * RoutePreference enum.\n                     * @name particle.ctrl.mesh.DiagnosticInfo.RoutePreference\n                     * @enum {number}\n                     * @property {number} MEDIUM=0 MEDIUM value\n                     * @property {number} HIGH=1 HIGH value\n                     * @property {number} LOW=-1 LOW value\n                     */\n                    DiagnosticInfo.RoutePreference = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"MEDIUM\"] = 0;\n                        values[valuesById[1] = \"HIGH\"] = 1;\n                        values[valuesById[-1] = \"LOW\"] = -1;\n                        return values;\n                    })();\n    \n                    DiagnosticInfo.NetworkData = (function() {\n    \n                        /**\n                         * Properties of a NetworkData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface INetworkData\n                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [stable] NetworkData stable\n                         * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null} [temporary] NetworkData temporary\n                         */\n    \n                        /**\n                         * Constructs a new NetworkData.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a NetworkData.\n                         * @implements INetworkData\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set\n                         */\n                        function NetworkData(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * NetworkData stable.\n                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} stable\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @instance\n                         */\n                        NetworkData.prototype.stable = null;\n    \n                        /**\n                         * NetworkData temporary.\n                         * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData|null|undefined} temporary\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @instance\n                         */\n                        NetworkData.prototype.temporary = null;\n    \n                        /**\n                         * Creates a new NetworkData instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData instance\n                         */\n                        NetworkData.create = function create(properties) {\n                            return new NetworkData(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified NetworkData message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.INetworkData} message NetworkData message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        NetworkData.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.stable != null && Object.hasOwnProperty.call(message, \"stable\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.stable, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            if (message.temporary != null && Object.hasOwnProperty.call(message, \"temporary\"))\n                                $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.encode(message.temporary, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a NetworkData message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData} NetworkData\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        NetworkData.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.stable = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());\n                                    break;\n                                case 2:\n                                    message.temporary = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.decode(reader, reader.uint32());\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        NetworkData.HasRoute = (function() {\n    \n                            /**\n                             * Properties of a HasRoute.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IHasRoute\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>|null} [entries] HasRoute entries\n                             */\n    \n                            /**\n                             * Constructs a new HasRoute.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a HasRoute.\n                             * @implements IHasRoute\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set\n                             */\n                            function HasRoute(properties) {\n                                this.entries = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * HasRoute entries.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry>} entries\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @instance\n                             */\n                            HasRoute.prototype.entries = $util.emptyArray;\n    \n                            /**\n                             * Creates a new HasRoute instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute instance\n                             */\n                            HasRoute.create = function create(properties) {\n                                return new HasRoute(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified HasRoute message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute} message HasRoute message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            HasRoute.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.entries != null && message.entries.length)\n                                    for (var i = 0; i < message.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a HasRoute message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute} HasRoute\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            HasRoute.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.entries && message.entries.length))\n                                            message.entries = [];\n                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            HasRoute.HasRouteEntry = (function() {\n    \n                                /**\n                                 * Properties of a HasRouteEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                                 * @interface IHasRouteEntry\n                                 * @property {number|null} [rloc] HasRouteEntry rloc\n                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] HasRouteEntry preference\n                                 */\n    \n                                /**\n                                 * Constructs a new HasRouteEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute\n                                 * @classdesc Represents a HasRouteEntry.\n                                 * @implements IHasRouteEntry\n                                 * @constructor\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set\n                                 */\n                                function HasRouteEntry(properties) {\n                                    if (properties)\n                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                            if (properties[keys[i]] != null)\n                                                this[keys[i]] = properties[keys[i]];\n                                }\n    \n                                /**\n                                 * HasRouteEntry rloc.\n                                 * @member {number} rloc\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @instance\n                                 */\n                                HasRouteEntry.prototype.rloc = 0;\n    \n                                /**\n                                 * HasRouteEntry preference.\n                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @instance\n                                 */\n                                HasRouteEntry.prototype.preference = 0;\n    \n                                /**\n                                 * Creates a new HasRouteEntry instance using the specified properties.\n                                 * @function create\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry=} [properties] Properties to set\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry instance\n                                 */\n                                HasRouteEntry.create = function create(properties) {\n                                    return new HasRouteEntry(properties);\n                                };\n    \n                                /**\n                                 * Encodes the specified HasRouteEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry.verify|verify} messages.\n                                 * @function encode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.IHasRouteEntry} message HasRouteEntry message or plain object to encode\n                                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                                 * @returns {$protobuf.Writer} Writer\n                                 */\n                                HasRouteEntry.encode = function encode(message, writer) {\n                                    if (!writer)\n                                        writer = $Writer.create();\n                                    if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                    if (message.preference != null && Object.hasOwnProperty.call(message, \"preference\"))\n                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);\n                                    return writer;\n                                };\n    \n                                /**\n                                 * Decodes a HasRouteEntry message from the specified reader or buffer.\n                                 * @function decode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry\n                                 * @static\n                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                                 * @param {number} [length] Message length if known beforehand\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry} HasRouteEntry\n                                 * @throws {Error} If the payload is not a reader or valid buffer\n                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                                 */\n                                HasRouteEntry.decode = function decode(reader, length) {\n                                    if (!(reader instanceof $Reader))\n                                        reader = $Reader.create(reader);\n                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.HasRouteEntry();\n                                    while (reader.pos < end) {\n                                        var tag = reader.uint32();\n                                        switch (tag >>> 3) {\n                                        case 1:\n                                            message.rloc = reader.uint32();\n                                            break;\n                                        case 2:\n                                            message.preference = reader.int32();\n                                            break;\n                                        default:\n                                            reader.skipType(tag & 7);\n                                            break;\n                                        }\n                                    }\n                                    return message;\n                                };\n    \n                                return HasRouteEntry;\n                            })();\n    \n                            return HasRoute;\n                        })();\n    \n                        NetworkData.BorderRouter = (function() {\n    \n                            /**\n                             * Properties of a BorderRouter.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IBorderRouter\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>|null} [entries] BorderRouter entries\n                             */\n    \n                            /**\n                             * Constructs a new BorderRouter.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a BorderRouter.\n                             * @implements IBorderRouter\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set\n                             */\n                            function BorderRouter(properties) {\n                                this.entries = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * BorderRouter entries.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry>} entries\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @instance\n                             */\n                            BorderRouter.prototype.entries = $util.emptyArray;\n    \n                            /**\n                             * Creates a new BorderRouter instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter instance\n                             */\n                            BorderRouter.create = function create(properties) {\n                                return new BorderRouter(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified BorderRouter message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter} message BorderRouter message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            BorderRouter.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.entries != null && message.entries.length)\n                                    for (var i = 0; i < message.entries.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.encode(message.entries[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a BorderRouter message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter} BorderRouter\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            BorderRouter.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.entries && message.entries.length))\n                                            message.entries = [];\n                                        message.entries.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            BorderRouter.BorderRouterEntry = (function() {\n    \n                                /**\n                                 * Properties of a BorderRouterEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                                 * @interface IBorderRouterEntry\n                                 * @property {number|null} [rloc] BorderRouterEntry rloc\n                                 * @property {particle.ctrl.mesh.DiagnosticInfo.RoutePreference|null} [preference] BorderRouterEntry preference\n                                 * @property {number|null} [flags] BorderRouterEntry flags\n                                 */\n    \n                                /**\n                                 * Constructs a new BorderRouterEntry.\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter\n                                 * @classdesc Represents a BorderRouterEntry.\n                                 * @implements IBorderRouterEntry\n                                 * @constructor\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set\n                                 */\n                                function BorderRouterEntry(properties) {\n                                    if (properties)\n                                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                            if (properties[keys[i]] != null)\n                                                this[keys[i]] = properties[keys[i]];\n                                }\n    \n                                /**\n                                 * BorderRouterEntry rloc.\n                                 * @member {number} rloc\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.rloc = 0;\n    \n                                /**\n                                 * BorderRouterEntry preference.\n                                 * @member {particle.ctrl.mesh.DiagnosticInfo.RoutePreference} preference\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.preference = 0;\n    \n                                /**\n                                 * BorderRouterEntry flags.\n                                 * @member {number} flags\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @instance\n                                 */\n                                BorderRouterEntry.prototype.flags = 0;\n    \n                                /**\n                                 * Creates a new BorderRouterEntry instance using the specified properties.\n                                 * @function create\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry=} [properties] Properties to set\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry instance\n                                 */\n                                BorderRouterEntry.create = function create(properties) {\n                                    return new BorderRouterEntry(properties);\n                                };\n    \n                                /**\n                                 * Encodes the specified BorderRouterEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.verify|verify} messages.\n                                 * @function encode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.IBorderRouterEntry} message BorderRouterEntry message or plain object to encode\n                                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                                 * @returns {$protobuf.Writer} Writer\n                                 */\n                                BorderRouterEntry.encode = function encode(message, writer) {\n                                    if (!writer)\n                                        writer = $Writer.create();\n                                    if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                    if (message.preference != null && Object.hasOwnProperty.call(message, \"preference\"))\n                                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.preference);\n                                    if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);\n                                    return writer;\n                                };\n    \n                                /**\n                                 * Decodes a BorderRouterEntry message from the specified reader or buffer.\n                                 * @function decode\n                                 * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry\n                                 * @static\n                                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                                 * @param {number} [length] Message length if known beforehand\n                                 * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry} BorderRouterEntry\n                                 * @throws {Error} If the payload is not a reader or valid buffer\n                                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                                 */\n                                BorderRouterEntry.decode = function decode(reader, length) {\n                                    if (!(reader instanceof $Reader))\n                                        reader = $Reader.create(reader);\n                                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry();\n                                    while (reader.pos < end) {\n                                        var tag = reader.uint32();\n                                        switch (tag >>> 3) {\n                                        case 1:\n                                            message.rloc = reader.uint32();\n                                            break;\n                                        case 2:\n                                            message.preference = reader.int32();\n                                            break;\n                                        case 3:\n                                            message.flags = reader.uint32();\n                                            break;\n                                        default:\n                                            reader.skipType(tag & 7);\n                                            break;\n                                        }\n                                    }\n                                    return message;\n                                };\n    \n                                /**\n                                 * Flags enum.\n                                 * @name particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.BorderRouterEntry.Flags\n                                 * @enum {number}\n                                 * @property {number} NONE=0 NONE value\n                                 * @property {number} PREFERRED=1 PREFERRED value\n                                 * @property {number} SLAAC=2 SLAAC value\n                                 * @property {number} DHCP=4 DHCP value\n                                 * @property {number} CONFIGURE=8 CONFIGURE value\n                                 * @property {number} DEFAULT_ROUTE=16 DEFAULT_ROUTE value\n                                 * @property {number} ON_MESH=32 ON_MESH value\n                                 * @property {number} ND_DNS=64 ND_DNS value\n                                 */\n                                BorderRouterEntry.Flags = (function() {\n                                    var valuesById = {}, values = Object.create(valuesById);\n                                    values[valuesById[0] = \"NONE\"] = 0;\n                                    values[valuesById[1] = \"PREFERRED\"] = 1;\n                                    values[valuesById[2] = \"SLAAC\"] = 2;\n                                    values[valuesById[4] = \"DHCP\"] = 4;\n                                    values[valuesById[8] = \"CONFIGURE\"] = 8;\n                                    values[valuesById[16] = \"DEFAULT_ROUTE\"] = 16;\n                                    values[valuesById[32] = \"ON_MESH\"] = 32;\n                                    values[valuesById[64] = \"ND_DNS\"] = 64;\n                                    return values;\n                                })();\n    \n                                return BorderRouterEntry;\n                            })();\n    \n                            return BorderRouter;\n                        })();\n    \n                        NetworkData.Context = (function() {\n    \n                            /**\n                             * Properties of a Context.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IContext\n                             * @property {number|null} [cid] Context cid\n                             * @property {boolean|null} [compress] Context compress\n                             * @property {number|null} [contextLength] Context contextLength\n                             */\n    \n                            /**\n                             * Constructs a new Context.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Context.\n                             * @implements IContext\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set\n                             */\n                            function Context(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Context cid.\n                             * @member {number} cid\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.cid = 0;\n    \n                            /**\n                             * Context compress.\n                             * @member {boolean} compress\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.compress = false;\n    \n                            /**\n                             * Context contextLength.\n                             * @member {number} contextLength\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @instance\n                             */\n                            Context.prototype.contextLength = 0;\n    \n                            /**\n                             * Creates a new Context instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context instance\n                             */\n                            Context.create = function create(properties) {\n                                return new Context(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Context message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext} message Context message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Context.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.cid != null && Object.hasOwnProperty.call(message, \"cid\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.cid);\n                                if (message.compress != null && Object.hasOwnProperty.call(message, \"compress\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.compress);\n                                if (message.contextLength != null && Object.hasOwnProperty.call(message, \"contextLength\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.contextLength);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Context message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context} Context\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Context.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.cid = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.compress = reader.bool();\n                                        break;\n                                    case 3:\n                                        message.contextLength = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Context;\n                        })();\n    \n                        NetworkData.Prefix = (function() {\n    \n                            /**\n                             * Properties of a Prefix.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IPrefix\n                             * @property {number|null} [domainId] Prefix domainId\n                             * @property {number|null} [prefixLength] Prefix prefixLength\n                             * @property {Uint8Array|null} [prefix] Prefix prefix\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>|null} [context] Prefix context\n                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null} [hasRoute] Prefix hasRoute\n                             * @property {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null} [borderRouter] Prefix borderRouter\n                             */\n    \n                            /**\n                             * Constructs a new Prefix.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Prefix.\n                             * @implements IPrefix\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set\n                             */\n                            function Prefix(properties) {\n                                this.context = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Prefix domainId.\n                             * @member {number} domainId\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.domainId = 0;\n    \n                            /**\n                             * Prefix prefixLength.\n                             * @member {number} prefixLength\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.prefixLength = 0;\n    \n                            /**\n                             * Prefix prefix.\n                             * @member {Uint8Array} prefix\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.prefix = $util.newBuffer([]);\n    \n                            /**\n                             * Prefix context.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IContext>} context\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.context = $util.emptyArray;\n    \n                            /**\n                             * Prefix hasRoute.\n                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IHasRoute|null|undefined} hasRoute\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.hasRoute = null;\n    \n                            /**\n                             * Prefix borderRouter.\n                             * @member {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IBorderRouter|null|undefined} borderRouter\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @instance\n                             */\n                            Prefix.prototype.borderRouter = null;\n    \n                            /**\n                             * Creates a new Prefix instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix instance\n                             */\n                            Prefix.create = function create(properties) {\n                                return new Prefix(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Prefix message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix} message Prefix message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Prefix.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.domainId != null && Object.hasOwnProperty.call(message, \"domainId\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.domainId);\n                                if (message.prefixLength != null && Object.hasOwnProperty.call(message, \"prefixLength\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.prefixLength);\n                                if (message.prefix != null && Object.hasOwnProperty.call(message, \"prefix\"))\n                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.prefix);\n                                if (message.context != null && message.context.length)\n                                    for (var i = 0; i < message.context.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.encode(message.context[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                                if (message.hasRoute != null && Object.hasOwnProperty.call(message, \"hasRoute\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.encode(message.hasRoute, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                                if (message.borderRouter != null && Object.hasOwnProperty.call(message, \"borderRouter\"))\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.encode(message.borderRouter, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Prefix message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix} Prefix\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Prefix.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.domainId = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.prefixLength = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.prefix = reader.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(message.context && message.context.length))\n                                            message.context = [];\n                                        message.context.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Context.decode(reader, reader.uint32()));\n                                        break;\n                                    case 5:\n                                        message.hasRoute = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.HasRoute.decode(reader, reader.uint32());\n                                        break;\n                                    case 6:\n                                        message.borderRouter = $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.BorderRouter.decode(reader, reader.uint32());\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Prefix;\n                        })();\n    \n                        NetworkData.Server = (function() {\n    \n                            /**\n                             * Properties of a Server.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IServer\n                             * @property {number|null} [rloc] Server rloc\n                             * @property {Uint8Array|null} [data] Server data\n                             */\n    \n                            /**\n                             * Constructs a new Server.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Server.\n                             * @implements IServer\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set\n                             */\n                            function Server(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Server rloc.\n                             * @member {number} rloc\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @instance\n                             */\n                            Server.prototype.rloc = 0;\n    \n                            /**\n                             * Server data.\n                             * @member {Uint8Array} data\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @instance\n                             */\n                            Server.prototype.data = $util.newBuffer([]);\n    \n                            /**\n                             * Creates a new Server instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server instance\n                             */\n                            Server.create = function create(properties) {\n                                return new Server(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Server message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer} message Server message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Server.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.rloc != null && Object.hasOwnProperty.call(message, \"rloc\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.rloc);\n                                if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Server message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server} Server\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Server.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.rloc = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.data = reader.bytes();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Server;\n                        })();\n    \n                        NetworkData.Service = (function() {\n    \n                            /**\n                             * Properties of a Service.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IService\n                             * @property {number|null} [sid] Service sid\n                             * @property {number|null} [enterpriseNumber] Service enterpriseNumber\n                             * @property {Uint8Array|null} [data] Service data\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>|null} [servers] Service servers\n                             */\n    \n                            /**\n                             * Constructs a new Service.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Service.\n                             * @implements IService\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set\n                             */\n                            function Service(properties) {\n                                this.servers = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Service sid.\n                             * @member {number} sid\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.sid = 0;\n    \n                            /**\n                             * Service enterpriseNumber.\n                             * @member {number} enterpriseNumber\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.enterpriseNumber = 0;\n    \n                            /**\n                             * Service data.\n                             * @member {Uint8Array} data\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.data = $util.newBuffer([]);\n    \n                            /**\n                             * Service servers.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IServer>} servers\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @instance\n                             */\n                            Service.prototype.servers = $util.emptyArray;\n    \n                            /**\n                             * Creates a new Service instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service instance\n                             */\n                            Service.create = function create(properties) {\n                                return new Service(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Service message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService} message Service message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Service.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.sid != null && Object.hasOwnProperty.call(message, \"sid\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.sid);\n                                if (message.enterpriseNumber != null && Object.hasOwnProperty.call(message, \"enterpriseNumber\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.enterpriseNumber);\n                                if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.data);\n                                if (message.servers != null && message.servers.length)\n                                    for (var i = 0; i < message.servers.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.encode(message.servers[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Service message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service} Service\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Service.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.sid = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.enterpriseNumber = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.data = reader.bytes();\n                                        break;\n                                    case 4:\n                                        if (!(message.servers && message.servers.length))\n                                            message.servers = [];\n                                        message.servers.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Server.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Service;\n                        })();\n    \n                        NetworkData.Data = (function() {\n    \n                            /**\n                             * Properties of a Data.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @interface IData\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>|null} [prefixes] Data prefixes\n                             * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>|null} [services] Data services\n                             */\n    \n                            /**\n                             * Constructs a new Data.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData\n                             * @classdesc Represents a Data.\n                             * @implements IData\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set\n                             */\n                            function Data(properties) {\n                                this.prefixes = [];\n                                this.services = [];\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * Data prefixes.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IPrefix>} prefixes\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @instance\n                             */\n                            Data.prototype.prefixes = $util.emptyArray;\n    \n                            /**\n                             * Data services.\n                             * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.NetworkData.IService>} services\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @instance\n                             */\n                            Data.prototype.services = $util.emptyArray;\n    \n                            /**\n                             * Creates a new Data instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data instance\n                             */\n                            Data.create = function create(properties) {\n                                return new Data(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified Data message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.NetworkData.IData} message Data message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            Data.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.prefixes != null && message.prefixes.length)\n                                    for (var i = 0; i < message.prefixes.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.encode(message.prefixes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                                if (message.services != null && message.services.length)\n                                    for (var i = 0; i < message.services.length; ++i)\n                                        $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.encode(message.services[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a Data message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data} Data\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            Data.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Data();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        if (!(message.prefixes && message.prefixes.length))\n                                            message.prefixes = [];\n                                        message.prefixes.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Prefix.decode(reader, reader.uint32()));\n                                        break;\n                                    case 2:\n                                        if (!(message.services && message.services.length))\n                                            message.services = [];\n                                        message.services.push($root.particle.ctrl.mesh.DiagnosticInfo.NetworkData.Service.decode(reader, reader.uint32()));\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return Data;\n                        })();\n    \n                        return NetworkData;\n                    })();\n    \n                    DiagnosticInfo.MacCounters = (function() {\n    \n                        /**\n                         * Properties of a MacCounters.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IMacCounters\n                         * @property {number|null} [ifInUnknownProtos] MacCounters ifInUnknownProtos\n                         * @property {number|null} [ifInErrors] MacCounters ifInErrors\n                         * @property {number|null} [ifOutErrors] MacCounters ifOutErrors\n                         * @property {number|null} [ifInUcastPkts] MacCounters ifInUcastPkts\n                         * @property {number|null} [ifInBroadcastPkts] MacCounters ifInBroadcastPkts\n                         * @property {number|null} [ifInDiscards] MacCounters ifInDiscards\n                         * @property {number|null} [ifOutUcastPkts] MacCounters ifOutUcastPkts\n                         * @property {number|null} [ifOutBroadcastPkts] MacCounters ifOutBroadcastPkts\n                         * @property {number|null} [ifOutDiscards] MacCounters ifOutDiscards\n                         */\n    \n                        /**\n                         * Constructs a new MacCounters.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a MacCounters.\n                         * @implements IMacCounters\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set\n                         */\n                        function MacCounters(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * MacCounters ifInUnknownProtos.\n                         * @member {number} ifInUnknownProtos\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInUnknownProtos = 0;\n    \n                        /**\n                         * MacCounters ifInErrors.\n                         * @member {number} ifInErrors\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInErrors = 0;\n    \n                        /**\n                         * MacCounters ifOutErrors.\n                         * @member {number} ifOutErrors\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutErrors = 0;\n    \n                        /**\n                         * MacCounters ifInUcastPkts.\n                         * @member {number} ifInUcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInUcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifInBroadcastPkts.\n                         * @member {number} ifInBroadcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInBroadcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifInDiscards.\n                         * @member {number} ifInDiscards\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifInDiscards = 0;\n    \n                        /**\n                         * MacCounters ifOutUcastPkts.\n                         * @member {number} ifOutUcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutUcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifOutBroadcastPkts.\n                         * @member {number} ifOutBroadcastPkts\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutBroadcastPkts = 0;\n    \n                        /**\n                         * MacCounters ifOutDiscards.\n                         * @member {number} ifOutDiscards\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @instance\n                         */\n                        MacCounters.prototype.ifOutDiscards = 0;\n    \n                        /**\n                         * Creates a new MacCounters instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters instance\n                         */\n                        MacCounters.create = function create(properties) {\n                            return new MacCounters(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified MacCounters message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.MacCounters.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IMacCounters} message MacCounters message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        MacCounters.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.ifInUnknownProtos != null && Object.hasOwnProperty.call(message, \"ifInUnknownProtos\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.ifInUnknownProtos);\n                            if (message.ifInErrors != null && Object.hasOwnProperty.call(message, \"ifInErrors\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.ifInErrors);\n                            if (message.ifOutErrors != null && Object.hasOwnProperty.call(message, \"ifOutErrors\"))\n                                writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.ifOutErrors);\n                            if (message.ifInUcastPkts != null && Object.hasOwnProperty.call(message, \"ifInUcastPkts\"))\n                                writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.ifInUcastPkts);\n                            if (message.ifInBroadcastPkts != null && Object.hasOwnProperty.call(message, \"ifInBroadcastPkts\"))\n                                writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.ifInBroadcastPkts);\n                            if (message.ifInDiscards != null && Object.hasOwnProperty.call(message, \"ifInDiscards\"))\n                                writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.ifInDiscards);\n                            if (message.ifOutUcastPkts != null && Object.hasOwnProperty.call(message, \"ifOutUcastPkts\"))\n                                writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.ifOutUcastPkts);\n                            if (message.ifOutBroadcastPkts != null && Object.hasOwnProperty.call(message, \"ifOutBroadcastPkts\"))\n                                writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.ifOutBroadcastPkts);\n                            if (message.ifOutDiscards != null && Object.hasOwnProperty.call(message, \"ifOutDiscards\"))\n                                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.ifOutDiscards);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a MacCounters message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.MacCounters\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.MacCounters} MacCounters\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        MacCounters.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.MacCounters();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.ifInUnknownProtos = reader.uint32();\n                                    break;\n                                case 2:\n                                    message.ifInErrors = reader.uint32();\n                                    break;\n                                case 3:\n                                    message.ifOutErrors = reader.uint32();\n                                    break;\n                                case 4:\n                                    message.ifInUcastPkts = reader.uint32();\n                                    break;\n                                case 5:\n                                    message.ifInBroadcastPkts = reader.uint32();\n                                    break;\n                                case 6:\n                                    message.ifInDiscards = reader.uint32();\n                                    break;\n                                case 7:\n                                    message.ifOutUcastPkts = reader.uint32();\n                                    break;\n                                case 8:\n                                    message.ifOutBroadcastPkts = reader.uint32();\n                                    break;\n                                case 9:\n                                    message.ifOutDiscards = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return MacCounters;\n                    })();\n    \n                    DiagnosticInfo.ChildTable = (function() {\n    \n                        /**\n                         * Properties of a ChildTable.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @interface IChildTable\n                         * @property {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>|null} [children] ChildTable children\n                         */\n    \n                        /**\n                         * Constructs a new ChildTable.\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo\n                         * @classdesc Represents a ChildTable.\n                         * @implements IChildTable\n                         * @constructor\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set\n                         */\n                        function ChildTable(properties) {\n                            this.children = [];\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * ChildTable children.\n                         * @member {Array.<particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry>} children\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @instance\n                         */\n                        ChildTable.prototype.children = $util.emptyArray;\n    \n                        /**\n                         * Creates a new ChildTable instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable=} [properties] Properties to set\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable instance\n                         */\n                        ChildTable.create = function create(properties) {\n                            return new ChildTable(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified ChildTable message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {particle.ctrl.mesh.DiagnosticInfo.IChildTable} message ChildTable message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        ChildTable.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.children != null && message.children.length)\n                                for (var i = 0; i < message.children.length; ++i)\n                                    $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.encode(message.children[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a ChildTable message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable} ChildTable\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        ChildTable.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    if (!(message.children && message.children.length))\n                                        message.children = [];\n                                    message.children.push($root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.decode(reader, reader.uint32()));\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        ChildTable.ChildEntry = (function() {\n    \n                            /**\n                             * Properties of a ChildEntry.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                             * @interface IChildEntry\n                             * @property {number|null} [timeout] ChildEntry timeout\n                             * @property {number|null} [childId] ChildEntry childId\n                             * @property {number|null} [mode] ChildEntry mode\n                             */\n    \n                            /**\n                             * Constructs a new ChildEntry.\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable\n                             * @classdesc Represents a ChildEntry.\n                             * @implements IChildEntry\n                             * @constructor\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set\n                             */\n                            function ChildEntry(properties) {\n                                if (properties)\n                                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                        if (properties[keys[i]] != null)\n                                            this[keys[i]] = properties[keys[i]];\n                            }\n    \n                            /**\n                             * ChildEntry timeout.\n                             * @member {number} timeout\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.timeout = 0;\n    \n                            /**\n                             * ChildEntry childId.\n                             * @member {number} childId\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.childId = 0;\n    \n                            /**\n                             * ChildEntry mode.\n                             * @member {number} mode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @instance\n                             */\n                            ChildEntry.prototype.mode = 0;\n    \n                            /**\n                             * Creates a new ChildEntry instance using the specified properties.\n                             * @function create\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry=} [properties] Properties to set\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry instance\n                             */\n                            ChildEntry.create = function create(properties) {\n                                return new ChildEntry(properties);\n                            };\n    \n                            /**\n                             * Encodes the specified ChildEntry message. Does not implicitly {@link particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry.verify|verify} messages.\n                             * @function encode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {particle.ctrl.mesh.DiagnosticInfo.ChildTable.IChildEntry} message ChildEntry message or plain object to encode\n                             * @param {$protobuf.Writer} [writer] Writer to encode to\n                             * @returns {$protobuf.Writer} Writer\n                             */\n                            ChildEntry.encode = function encode(message, writer) {\n                                if (!writer)\n                                    writer = $Writer.create();\n                                if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.timeout);\n                                if (message.childId != null && Object.hasOwnProperty.call(message, \"childId\"))\n                                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.childId);\n                                if (message.mode != null && Object.hasOwnProperty.call(message, \"mode\"))\n                                    writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.mode);\n                                return writer;\n                            };\n    \n                            /**\n                             * Decodes a ChildEntry message from the specified reader or buffer.\n                             * @function decode\n                             * @memberof particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry\n                             * @static\n                             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                             * @param {number} [length] Message length if known beforehand\n                             * @returns {particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry} ChildEntry\n                             * @throws {Error} If the payload is not a reader or valid buffer\n                             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                             */\n                            ChildEntry.decode = function decode(reader, length) {\n                                if (!(reader instanceof $Reader))\n                                    reader = $Reader.create(reader);\n                                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.DiagnosticInfo.ChildTable.ChildEntry();\n                                while (reader.pos < end) {\n                                    var tag = reader.uint32();\n                                    switch (tag >>> 3) {\n                                    case 1:\n                                        message.timeout = reader.uint32();\n                                        break;\n                                    case 2:\n                                        message.childId = reader.uint32();\n                                        break;\n                                    case 3:\n                                        message.mode = reader.uint32();\n                                        break;\n                                    default:\n                                        reader.skipType(tag & 7);\n                                        break;\n                                    }\n                                }\n                                return message;\n                            };\n    \n                            return ChildEntry;\n                        })();\n    \n                        return ChildTable;\n                    })();\n    \n                    return DiagnosticInfo;\n                })();\n    \n                mesh.GetNetworkDiagnosticsRequest = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkDiagnosticsRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkDiagnosticsRequest\n                     * @property {number|null} [flags] GetNetworkDiagnosticsRequest flags\n                     * @property {Array.<particle.ctrl.mesh.DiagnosticType>|null} [diagnosticTypes] GetNetworkDiagnosticsRequest diagnosticTypes\n                     * @property {number|null} [timeout] GetNetworkDiagnosticsRequest timeout\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkDiagnosticsRequest.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkDiagnosticsRequest.\n                     * @implements IGetNetworkDiagnosticsRequest\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set\n                     */\n                    function GetNetworkDiagnosticsRequest(properties) {\n                        this.diagnosticTypes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.flags = 0;\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest diagnosticTypes.\n                     * @member {Array.<particle.ctrl.mesh.DiagnosticType>} diagnosticTypes\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.diagnosticTypes = $util.emptyArray;\n    \n                    /**\n                     * GetNetworkDiagnosticsRequest timeout.\n                     * @member {number} timeout\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsRequest.prototype.timeout = 0;\n    \n                    /**\n                     * Creates a new GetNetworkDiagnosticsRequest instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest instance\n                     */\n                    GetNetworkDiagnosticsRequest.create = function create(properties) {\n                        return new GetNetworkDiagnosticsRequest(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkDiagnosticsRequest message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsRequest.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsRequest} message GetNetworkDiagnosticsRequest message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkDiagnosticsRequest.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.flags);\n                        if (message.diagnosticTypes != null && message.diagnosticTypes.length) {\n                            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                            for (var i = 0; i < message.diagnosticTypes.length; ++i)\n                                writer.int32(message.diagnosticTypes[i]);\n                            writer.ldelim();\n                        }\n                        if (message.timeout != null && Object.hasOwnProperty.call(message, \"timeout\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.timeout);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkDiagnosticsRequest message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsRequest\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsRequest} GetNetworkDiagnosticsRequest\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkDiagnosticsRequest.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsRequest();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.flags = reader.uint32();\n                                break;\n                            case 2:\n                                if (!(message.diagnosticTypes && message.diagnosticTypes.length))\n                                    message.diagnosticTypes = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.diagnosticTypes.push(reader.int32());\n                                } else\n                                    message.diagnosticTypes.push(reader.int32());\n                                break;\n                            case 3:\n                                message.timeout = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    /**\n                     * Flags enum.\n                     * @name particle.ctrl.mesh.GetNetworkDiagnosticsRequest.Flags\n                     * @enum {number}\n                     * @property {number} INVALID=0 INVALID value\n                     * @property {number} QUERY_CHILDREN=1 QUERY_CHILDREN value\n                     * @property {number} RESOLVE_DEVICE_ID=2 RESOLVE_DEVICE_ID value\n                     */\n                    GetNetworkDiagnosticsRequest.Flags = (function() {\n                        var valuesById = {}, values = Object.create(valuesById);\n                        values[valuesById[0] = \"INVALID\"] = 0;\n                        values[valuesById[1] = \"QUERY_CHILDREN\"] = 1;\n                        values[valuesById[2] = \"RESOLVE_DEVICE_ID\"] = 2;\n                        return values;\n                    })();\n    \n                    return GetNetworkDiagnosticsRequest;\n                })();\n    \n                mesh.GetNetworkDiagnosticsReply = (function() {\n    \n                    /**\n                     * Properties of a GetNetworkDiagnosticsReply.\n                     * @memberof particle.ctrl.mesh\n                     * @interface IGetNetworkDiagnosticsReply\n                     * @property {Array.<particle.ctrl.mesh.IDiagnosticInfo>|null} [nodes] GetNetworkDiagnosticsReply nodes\n                     */\n    \n                    /**\n                     * Constructs a new GetNetworkDiagnosticsReply.\n                     * @memberof particle.ctrl.mesh\n                     * @classdesc Represents a GetNetworkDiagnosticsReply.\n                     * @implements IGetNetworkDiagnosticsReply\n                     * @constructor\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set\n                     */\n                    function GetNetworkDiagnosticsReply(properties) {\n                        this.nodes = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * GetNetworkDiagnosticsReply nodes.\n                     * @member {Array.<particle.ctrl.mesh.IDiagnosticInfo>} nodes\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @instance\n                     */\n                    GetNetworkDiagnosticsReply.prototype.nodes = $util.emptyArray;\n    \n                    /**\n                     * Creates a new GetNetworkDiagnosticsReply instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply=} [properties] Properties to set\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply instance\n                     */\n                    GetNetworkDiagnosticsReply.create = function create(properties) {\n                        return new GetNetworkDiagnosticsReply(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified GetNetworkDiagnosticsReply message. Does not implicitly {@link particle.ctrl.mesh.GetNetworkDiagnosticsReply.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {particle.ctrl.mesh.IGetNetworkDiagnosticsReply} message GetNetworkDiagnosticsReply message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    GetNetworkDiagnosticsReply.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.nodes != null && message.nodes.length)\n                            for (var i = 0; i < message.nodes.length; ++i)\n                                $root.particle.ctrl.mesh.DiagnosticInfo.encode(message.nodes[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a GetNetworkDiagnosticsReply message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.mesh.GetNetworkDiagnosticsReply\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.mesh.GetNetworkDiagnosticsReply} GetNetworkDiagnosticsReply\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    GetNetworkDiagnosticsReply.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.mesh.GetNetworkDiagnosticsReply();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.nodes && message.nodes.length))\n                                    message.nodes = [];\n                                message.nodes.push($root.particle.ctrl.mesh.DiagnosticInfo.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return GetNetworkDiagnosticsReply;\n                })();\n    \n                return mesh;\n            })();\n    \n            /**\n             * StorageType enum.\n             * @name particle.ctrl.StorageType\n             * @enum {number}\n             * @property {number} INVALID_STORAGE=0 INVALID_STORAGE value\n             * @property {number} INTERNAL=1 INTERNAL value\n             */\n            ctrl.StorageType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_STORAGE\"] = 0;\n                values[valuesById[1] = \"INTERNAL\"] = 1;\n                return values;\n            })();\n    \n            /**\n             * SectionType enum.\n             * @name particle.ctrl.SectionType\n             * @enum {number}\n             * @property {number} INVALID_SECTION=0 INVALID_SECTION value\n             * @property {number} FIRMWARE=1 FIRMWARE value\n             * @property {number} OTA_BACKUP=2 OTA_BACKUP value\n             * @property {number} FACTORY_BACKUP=3 FACTORY_BACKUP value\n             * @property {number} CONFIG=4 CONFIG value\n             * @property {number} EEPROM=5 EEPROM value\n             */\n            ctrl.SectionType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_SECTION\"] = 0;\n                values[valuesById[1] = \"FIRMWARE\"] = 1;\n                values[valuesById[2] = \"OTA_BACKUP\"] = 2;\n                values[valuesById[3] = \"FACTORY_BACKUP\"] = 3;\n                values[valuesById[4] = \"CONFIG\"] = 4;\n                values[valuesById[5] = \"EEPROM\"] = 5;\n                return values;\n            })();\n    \n            /**\n             * FirmwareModuleType enum.\n             * @name particle.ctrl.FirmwareModuleType\n             * @enum {number}\n             * @property {number} INVALID_FIRMWARE_MODULE=0 INVALID_FIRMWARE_MODULE value\n             * @property {number} BOOTLOADER=1 BOOTLOADER value\n             * @property {number} SYSTEM_PART=2 SYSTEM_PART value\n             * @property {number} USER_PART=3 USER_PART value\n             * @property {number} MONO_FIRMWARE=4 MONO_FIRMWARE value\n             * @property {number} NCP_FIRMWARE=5 NCP_FIRMWARE value\n             * @property {number} RADIO_STACK=6 RADIO_STACK value\n             */\n            ctrl.FirmwareModuleType = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"INVALID_FIRMWARE_MODULE\"] = 0;\n                values[valuesById[1] = \"BOOTLOADER\"] = 1;\n                values[valuesById[2] = \"SYSTEM_PART\"] = 2;\n                values[valuesById[3] = \"USER_PART\"] = 3;\n                values[valuesById[4] = \"MONO_FIRMWARE\"] = 4;\n                values[valuesById[5] = \"NCP_FIRMWARE\"] = 5;\n                values[valuesById[6] = \"RADIO_STACK\"] = 6;\n                return values;\n            })();\n    \n            /**\n             * FirmwareModuleValidityFlag enum.\n             * @name particle.ctrl.FirmwareModuleValidityFlag\n             * @enum {number}\n             * @property {number} NO_VALIDATION_ERRORS=0 NO_VALIDATION_ERRORS value\n             * @property {number} INTEGRITY_CHECK_FAILED=1 INTEGRITY_CHECK_FAILED value\n             * @property {number} DEPENDENCY_CHECK_FAILED=2 DEPENDENCY_CHECK_FAILED value\n             */\n            ctrl.FirmwareModuleValidityFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_VALIDATION_ERRORS\"] = 0;\n                values[valuesById[1] = \"INTEGRITY_CHECK_FAILED\"] = 1;\n                values[valuesById[2] = \"DEPENDENCY_CHECK_FAILED\"] = 2;\n                return values;\n            })();\n    \n            /**\n             * SectionFlag enum.\n             * @name particle.ctrl.SectionFlag\n             * @enum {number}\n             * @property {number} NO_SECTION_FLAGS=0 NO_SECTION_FLAGS value\n             * @property {number} CAN_READ=1 CAN_READ value\n             * @property {number} CAN_WRITE=2 CAN_WRITE value\n             * @property {number} CAN_CLEAR=4 CAN_CLEAR value\n             * @property {number} CAN_GET_SIZE=8 CAN_GET_SIZE value\n             * @property {number} NEED_CLEAR=16 NEED_CLEAR value\n             */\n            ctrl.SectionFlag = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"NO_SECTION_FLAGS\"] = 0;\n                values[valuesById[1] = \"CAN_READ\"] = 1;\n                values[valuesById[2] = \"CAN_WRITE\"] = 2;\n                values[valuesById[4] = \"CAN_CLEAR\"] = 4;\n                values[valuesById[8] = \"CAN_GET_SIZE\"] = 8;\n                values[valuesById[16] = \"NEED_CLEAR\"] = 16;\n                return values;\n            })();\n    \n            /**\n             * FileFormat enum.\n             * @name particle.ctrl.FileFormat\n             * @enum {number}\n             * @property {number} BIN=0 BIN value\n             * @property {number} MINIZ=1 MINIZ value\n             */\n            ctrl.FileFormat = (function() {\n                var valuesById = {}, values = Object.create(valuesById);\n                values[valuesById[0] = \"BIN\"] = 0;\n                values[valuesById[1] = \"MINIZ\"] = 1;\n                return values;\n            })();\n    \n            ctrl.StartFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a StartFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface IStartFirmwareUpdateRequest\n                 * @property {number|null} [size] StartFirmwareUpdateRequest size\n                 * @property {particle.ctrl.FileFormat|null} [format] StartFirmwareUpdateRequest format\n                 */\n    \n                /**\n                 * Constructs a new StartFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartFirmwareUpdateRequest.\n                 * @implements IStartFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function StartFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * StartFirmwareUpdateRequest size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @instance\n                 */\n                StartFirmwareUpdateRequest.prototype.size = 0;\n    \n                /**\n                 * StartFirmwareUpdateRequest format.\n                 * @member {particle.ctrl.FileFormat} format\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @instance\n                 */\n                StartFirmwareUpdateRequest.prototype.format = 0;\n    \n                /**\n                 * Creates a new StartFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest instance\n                 */\n                StartFirmwareUpdateRequest.create = function create(properties) {\n                    return new StartFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateRequest} message StartFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);\n                    if (message.format != null && Object.hasOwnProperty.call(message, \"format\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.format);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartFirmwareUpdateRequest} StartFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.size = reader.uint32();\n                            break;\n                        case 2:\n                            message.format = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartFirmwareUpdateRequest;\n            })();\n    \n            ctrl.StartFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a StartFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface IStartFirmwareUpdateReply\n                 * @property {number|null} [chunkSize] StartFirmwareUpdateReply chunkSize\n                 */\n    \n                /**\n                 * Constructs a new StartFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a StartFirmwareUpdateReply.\n                 * @implements IStartFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function StartFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * StartFirmwareUpdateReply chunkSize.\n                 * @member {number} chunkSize\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @instance\n                 */\n                StartFirmwareUpdateReply.prototype.chunkSize = 0;\n    \n                /**\n                 * Creates a new StartFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply instance\n                 */\n                StartFirmwareUpdateReply.create = function create(properties) {\n                    return new StartFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified StartFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.StartFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IStartFirmwareUpdateReply} message StartFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                StartFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.chunkSize != null && Object.hasOwnProperty.call(message, \"chunkSize\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.chunkSize);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a StartFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.StartFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.StartFirmwareUpdateReply} StartFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                StartFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.StartFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.chunkSize = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return StartFirmwareUpdateReply;\n            })();\n    \n            ctrl.FinishFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a FinishFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface IFinishFirmwareUpdateRequest\n                 * @property {boolean|null} [validateOnly] FinishFirmwareUpdateRequest validateOnly\n                 */\n    \n                /**\n                 * Constructs a new FinishFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FinishFirmwareUpdateRequest.\n                 * @implements IFinishFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function FinishFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FinishFirmwareUpdateRequest validateOnly.\n                 * @member {boolean} validateOnly\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @instance\n                 */\n                FinishFirmwareUpdateRequest.prototype.validateOnly = false;\n    \n                /**\n                 * Creates a new FinishFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest instance\n                 */\n                FinishFirmwareUpdateRequest.create = function create(properties) {\n                    return new FinishFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified FinishFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateRequest} message FinishFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FinishFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.validateOnly != null && Object.hasOwnProperty.call(message, \"validateOnly\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.validateOnly);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FinishFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FinishFirmwareUpdateRequest} FinishFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FinishFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.validateOnly = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FinishFirmwareUpdateRequest;\n            })();\n    \n            ctrl.FinishFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a FinishFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface IFinishFirmwareUpdateReply\n                 */\n    \n                /**\n                 * Constructs a new FinishFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FinishFirmwareUpdateReply.\n                 * @implements IFinishFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function FinishFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new FinishFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply instance\n                 */\n                FinishFirmwareUpdateReply.create = function create(properties) {\n                    return new FinishFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified FinishFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.FinishFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.IFinishFirmwareUpdateReply} message FinishFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FinishFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FinishFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FinishFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FinishFirmwareUpdateReply} FinishFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FinishFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FinishFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FinishFirmwareUpdateReply;\n            })();\n    \n            ctrl.CancelFirmwareUpdateRequest = (function() {\n    \n                /**\n                 * Properties of a CancelFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @interface ICancelFirmwareUpdateRequest\n                 */\n    \n                /**\n                 * Constructs a new CancelFirmwareUpdateRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a CancelFirmwareUpdateRequest.\n                 * @implements ICancelFirmwareUpdateRequest\n                 * @constructor\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set\n                 */\n                function CancelFirmwareUpdateRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new CancelFirmwareUpdateRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest instance\n                 */\n                CancelFirmwareUpdateRequest.create = function create(properties) {\n                    return new CancelFirmwareUpdateRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified CancelFirmwareUpdateRequest message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateRequest} message CancelFirmwareUpdateRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                CancelFirmwareUpdateRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a CancelFirmwareUpdateRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.CancelFirmwareUpdateRequest} CancelFirmwareUpdateRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                CancelFirmwareUpdateRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return CancelFirmwareUpdateRequest;\n            })();\n    \n            ctrl.CancelFirmwareUpdateReply = (function() {\n    \n                /**\n                 * Properties of a CancelFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @interface ICancelFirmwareUpdateReply\n                 */\n    \n                /**\n                 * Constructs a new CancelFirmwareUpdateReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a CancelFirmwareUpdateReply.\n                 * @implements ICancelFirmwareUpdateReply\n                 * @constructor\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set\n                 */\n                function CancelFirmwareUpdateReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new CancelFirmwareUpdateReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply instance\n                 */\n                CancelFirmwareUpdateReply.create = function create(properties) {\n                    return new CancelFirmwareUpdateReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified CancelFirmwareUpdateReply message. Does not implicitly {@link particle.ctrl.CancelFirmwareUpdateReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {particle.ctrl.ICancelFirmwareUpdateReply} message CancelFirmwareUpdateReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                CancelFirmwareUpdateReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a CancelFirmwareUpdateReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.CancelFirmwareUpdateReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.CancelFirmwareUpdateReply} CancelFirmwareUpdateReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                CancelFirmwareUpdateReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.CancelFirmwareUpdateReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return CancelFirmwareUpdateReply;\n            })();\n    \n            ctrl.FirmwareUpdateDataRequest = (function() {\n    \n                /**\n                 * Properties of a FirmwareUpdateDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IFirmwareUpdateDataRequest\n                 * @property {Uint8Array|null} [data] FirmwareUpdateDataRequest data\n                 */\n    \n                /**\n                 * Constructs a new FirmwareUpdateDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FirmwareUpdateDataRequest.\n                 * @implements IFirmwareUpdateDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set\n                 */\n                function FirmwareUpdateDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FirmwareUpdateDataRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @instance\n                 */\n                FirmwareUpdateDataRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new FirmwareUpdateDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest instance\n                 */\n                FirmwareUpdateDataRequest.create = function create(properties) {\n                    return new FirmwareUpdateDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareUpdateDataRequest message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataRequest} message FirmwareUpdateDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareUpdateDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareUpdateDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FirmwareUpdateDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FirmwareUpdateDataRequest} FirmwareUpdateDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareUpdateDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareUpdateDataRequest;\n            })();\n    \n            ctrl.FirmwareUpdateDataReply = (function() {\n    \n                /**\n                 * Properties of a FirmwareUpdateDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IFirmwareUpdateDataReply\n                 */\n    \n                /**\n                 * Constructs a new FirmwareUpdateDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a FirmwareUpdateDataReply.\n                 * @implements IFirmwareUpdateDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set\n                 */\n                function FirmwareUpdateDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new FirmwareUpdateDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply instance\n                 */\n                FirmwareUpdateDataReply.create = function create(properties) {\n                    return new FirmwareUpdateDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified FirmwareUpdateDataReply message. Does not implicitly {@link particle.ctrl.FirmwareUpdateDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {particle.ctrl.IFirmwareUpdateDataReply} message FirmwareUpdateDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FirmwareUpdateDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FirmwareUpdateDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.FirmwareUpdateDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.FirmwareUpdateDataReply} FirmwareUpdateDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FirmwareUpdateDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.FirmwareUpdateDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FirmwareUpdateDataReply;\n            })();\n    \n            ctrl.DescribeStorageRequest = (function() {\n    \n                /**\n                 * Properties of a DescribeStorageRequest.\n                 * @memberof particle.ctrl\n                 * @interface IDescribeStorageRequest\n                 */\n    \n                /**\n                 * Constructs a new DescribeStorageRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DescribeStorageRequest.\n                 * @implements IDescribeStorageRequest\n                 * @constructor\n                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set\n                 */\n                function DescribeStorageRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new DescribeStorageRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest instance\n                 */\n                DescribeStorageRequest.create = function create(properties) {\n                    return new DescribeStorageRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescribeStorageRequest message. Does not implicitly {@link particle.ctrl.DescribeStorageRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageRequest} message DescribeStorageRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescribeStorageRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescribeStorageRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DescribeStorageRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DescribeStorageRequest} DescribeStorageRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescribeStorageRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return DescribeStorageRequest;\n            })();\n    \n            ctrl.DescribeStorageReply = (function() {\n    \n                /**\n                 * Properties of a DescribeStorageReply.\n                 * @memberof particle.ctrl\n                 * @interface IDescribeStorageReply\n                 * @property {Array.<particle.ctrl.DescribeStorageReply.IStorage>|null} [storage] DescribeStorageReply storage\n                 */\n    \n                /**\n                 * Constructs a new DescribeStorageReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a DescribeStorageReply.\n                 * @implements IDescribeStorageReply\n                 * @constructor\n                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set\n                 */\n                function DescribeStorageReply(properties) {\n                    this.storage = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DescribeStorageReply storage.\n                 * @member {Array.<particle.ctrl.DescribeStorageReply.IStorage>} storage\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @instance\n                 */\n                DescribeStorageReply.prototype.storage = $util.emptyArray;\n    \n                /**\n                 * Creates a new DescribeStorageReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply instance\n                 */\n                DescribeStorageReply.create = function create(properties) {\n                    return new DescribeStorageReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescribeStorageReply message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {particle.ctrl.IDescribeStorageReply} message DescribeStorageReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescribeStorageReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && message.storage.length)\n                        for (var i = 0; i < message.storage.length; ++i)\n                            $root.particle.ctrl.DescribeStorageReply.Storage.encode(message.storage[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescribeStorageReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.DescribeStorageReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.DescribeStorageReply} DescribeStorageReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescribeStorageReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.storage && message.storage.length))\n                                message.storage = [];\n                            message.storage.push($root.particle.ctrl.DescribeStorageReply.Storage.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                DescribeStorageReply.Section = (function() {\n    \n                    /**\n                     * Properties of a Section.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @interface ISection\n                     * @property {particle.ctrl.SectionType|null} [type] Section type\n                     * @property {number|null} [size] Section size\n                     * @property {number|null} [flags] Section flags\n                     * @property {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null} [firmwareModule] Section firmwareModule\n                     */\n    \n                    /**\n                     * Constructs a new Section.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @classdesc Represents a Section.\n                     * @implements ISection\n                     * @constructor\n                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set\n                     */\n                    function Section(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Section type.\n                     * @member {particle.ctrl.SectionType} type\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.type = 0;\n    \n                    /**\n                     * Section size.\n                     * @member {number} size\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.size = 0;\n    \n                    /**\n                     * Section flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.flags = 0;\n    \n                    /**\n                     * Section firmwareModule.\n                     * @member {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule|null|undefined} firmwareModule\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @instance\n                     */\n                    Section.prototype.firmwareModule = null;\n    \n                    /**\n                     * Creates a new Section instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.ISection=} [properties] Properties to set\n                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section instance\n                     */\n                    Section.create = function create(properties) {\n                        return new Section(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Section message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.ISection} message Section message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Section.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.size);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.flags);\n                        if (message.firmwareModule != null && Object.hasOwnProperty.call(message, \"firmwareModule\"))\n                            $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.encode(message.firmwareModule, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Section message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.DescribeStorageReply.Section\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.DescribeStorageReply.Section} Section\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Section.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.size = reader.uint32();\n                                break;\n                            case 3:\n                                message.flags = reader.uint32();\n                                break;\n                            case 4:\n                                message.firmwareModule = $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    Section.FirmwareModule = (function() {\n    \n                        /**\n                         * Properties of a FirmwareModule.\n                         * @memberof particle.ctrl.DescribeStorageReply.Section\n                         * @interface IFirmwareModule\n                         * @property {particle.ctrl.FirmwareModuleType|null} [type] FirmwareModule type\n                         * @property {number|null} [index] FirmwareModule index\n                         */\n    \n                        /**\n                         * Constructs a new FirmwareModule.\n                         * @memberof particle.ctrl.DescribeStorageReply.Section\n                         * @classdesc Represents a FirmwareModule.\n                         * @implements IFirmwareModule\n                         * @constructor\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set\n                         */\n                        function FirmwareModule(properties) {\n                            if (properties)\n                                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                    if (properties[keys[i]] != null)\n                                        this[keys[i]] = properties[keys[i]];\n                        }\n    \n                        /**\n                         * FirmwareModule type.\n                         * @member {particle.ctrl.FirmwareModuleType} type\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @instance\n                         */\n                        FirmwareModule.prototype.type = 0;\n    \n                        /**\n                         * FirmwareModule index.\n                         * @member {number} index\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @instance\n                         */\n                        FirmwareModule.prototype.index = 0;\n    \n                        /**\n                         * Creates a new FirmwareModule instance using the specified properties.\n                         * @function create\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule=} [properties] Properties to set\n                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule instance\n                         */\n                        FirmwareModule.create = function create(properties) {\n                            return new FirmwareModule(properties);\n                        };\n    \n                        /**\n                         * Encodes the specified FirmwareModule message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Section.FirmwareModule.verify|verify} messages.\n                         * @function encode\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {particle.ctrl.DescribeStorageReply.Section.IFirmwareModule} message FirmwareModule message or plain object to encode\n                         * @param {$protobuf.Writer} [writer] Writer to encode to\n                         * @returns {$protobuf.Writer} Writer\n                         */\n                        FirmwareModule.encode = function encode(message, writer) {\n                            if (!writer)\n                                writer = $Writer.create();\n                            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                            if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                                writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                            return writer;\n                        };\n    \n                        /**\n                         * Decodes a FirmwareModule message from the specified reader or buffer.\n                         * @function decode\n                         * @memberof particle.ctrl.DescribeStorageReply.Section.FirmwareModule\n                         * @static\n                         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                         * @param {number} [length] Message length if known beforehand\n                         * @returns {particle.ctrl.DescribeStorageReply.Section.FirmwareModule} FirmwareModule\n                         * @throws {Error} If the payload is not a reader or valid buffer\n                         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                         */\n                        FirmwareModule.decode = function decode(reader, length) {\n                            if (!(reader instanceof $Reader))\n                                reader = $Reader.create(reader);\n                            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Section.FirmwareModule();\n                            while (reader.pos < end) {\n                                var tag = reader.uint32();\n                                switch (tag >>> 3) {\n                                case 1:\n                                    message.type = reader.int32();\n                                    break;\n                                case 2:\n                                    message.index = reader.uint32();\n                                    break;\n                                default:\n                                    reader.skipType(tag & 7);\n                                    break;\n                                }\n                            }\n                            return message;\n                        };\n    \n                        return FirmwareModule;\n                    })();\n    \n                    return Section;\n                })();\n    \n                DescribeStorageReply.Storage = (function() {\n    \n                    /**\n                     * Properties of a Storage.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @interface IStorage\n                     * @property {particle.ctrl.StorageType|null} [type] Storage type\n                     * @property {number|null} [flags] Storage flags\n                     * @property {Array.<particle.ctrl.DescribeStorageReply.ISection>|null} [sections] Storage sections\n                     */\n    \n                    /**\n                     * Constructs a new Storage.\n                     * @memberof particle.ctrl.DescribeStorageReply\n                     * @classdesc Represents a Storage.\n                     * @implements IStorage\n                     * @constructor\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set\n                     */\n                    function Storage(properties) {\n                        this.sections = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Storage type.\n                     * @member {particle.ctrl.StorageType} type\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.type = 0;\n    \n                    /**\n                     * Storage flags.\n                     * @member {number} flags\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.flags = 0;\n    \n                    /**\n                     * Storage sections.\n                     * @member {Array.<particle.ctrl.DescribeStorageReply.ISection>} sections\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @instance\n                     */\n                    Storage.prototype.sections = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Storage instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage=} [properties] Properties to set\n                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage instance\n                     */\n                    Storage.create = function create(properties) {\n                        return new Storage(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Storage message. Does not implicitly {@link particle.ctrl.DescribeStorageReply.Storage.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {particle.ctrl.DescribeStorageReply.IStorage} message Storage message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Storage.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.flags != null && Object.hasOwnProperty.call(message, \"flags\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.flags);\n                        if (message.sections != null && message.sections.length)\n                            for (var i = 0; i < message.sections.length; ++i)\n                                $root.particle.ctrl.DescribeStorageReply.Section.encode(message.sections[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Storage message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.DescribeStorageReply.Storage\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.DescribeStorageReply.Storage} Storage\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Storage.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.DescribeStorageReply.Storage();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.flags = reader.uint32();\n                                break;\n                            case 3:\n                                if (!(message.sections && message.sections.length))\n                                    message.sections = [];\n                                message.sections.push($root.particle.ctrl.DescribeStorageReply.Section.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Storage;\n                })();\n    \n                return DescribeStorageReply;\n            })();\n    \n            ctrl.ReadSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a ReadSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IReadSectionDataRequest\n                 * @property {number|null} [storage] ReadSectionDataRequest storage\n                 * @property {number|null} [section] ReadSectionDataRequest section\n                 * @property {number|null} [offset] ReadSectionDataRequest offset\n                 * @property {number|null} [size] ReadSectionDataRequest size\n                 */\n    \n                /**\n                 * Constructs a new ReadSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ReadSectionDataRequest.\n                 * @implements IReadSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set\n                 */\n                function ReadSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ReadSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * ReadSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * ReadSectionDataRequest offset.\n                 * @member {number} offset\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.offset = 0;\n    \n                /**\n                 * ReadSectionDataRequest size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @instance\n                 */\n                ReadSectionDataRequest.prototype.size = 0;\n    \n                /**\n                 * Creates a new ReadSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest instance\n                 */\n                ReadSectionDataRequest.create = function create(properties) {\n                    return new ReadSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified ReadSectionDataRequest message. Does not implicitly {@link particle.ctrl.ReadSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataRequest} message ReadSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ReadSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ReadSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ReadSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ReadSectionDataRequest} ReadSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ReadSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        case 3:\n                            message.offset = reader.uint32();\n                            break;\n                        case 4:\n                            message.size = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ReadSectionDataRequest;\n            })();\n    \n            ctrl.ReadSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a ReadSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IReadSectionDataReply\n                 * @property {Uint8Array|null} [data] ReadSectionDataReply data\n                 */\n    \n                /**\n                 * Constructs a new ReadSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ReadSectionDataReply.\n                 * @implements IReadSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set\n                 */\n                function ReadSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ReadSectionDataReply data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @instance\n                 */\n                ReadSectionDataReply.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new ReadSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply instance\n                 */\n                ReadSectionDataReply.create = function create(properties) {\n                    return new ReadSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified ReadSectionDataReply message. Does not implicitly {@link particle.ctrl.ReadSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IReadSectionDataReply} message ReadSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ReadSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ReadSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ReadSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ReadSectionDataReply} ReadSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ReadSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ReadSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ReadSectionDataReply;\n            })();\n    \n            ctrl.WriteSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a WriteSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IWriteSectionDataRequest\n                 * @property {number|null} [storage] WriteSectionDataRequest storage\n                 * @property {number|null} [section] WriteSectionDataRequest section\n                 * @property {number|null} [offset] WriteSectionDataRequest offset\n                 * @property {Uint8Array|null} [data] WriteSectionDataRequest data\n                 */\n    \n                /**\n                 * Constructs a new WriteSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WriteSectionDataRequest.\n                 * @implements IWriteSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set\n                 */\n                function WriteSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WriteSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * WriteSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * WriteSectionDataRequest offset.\n                 * @member {number} offset\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.offset = 0;\n    \n                /**\n                 * WriteSectionDataRequest data.\n                 * @member {Uint8Array} data\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @instance\n                 */\n                WriteSectionDataRequest.prototype.data = $util.newBuffer([]);\n    \n                /**\n                 * Creates a new WriteSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest instance\n                 */\n                WriteSectionDataRequest.create = function create(properties) {\n                    return new WriteSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified WriteSectionDataRequest message. Does not implicitly {@link particle.ctrl.WriteSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataRequest} message WriteSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WriteSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    if (message.offset != null && Object.hasOwnProperty.call(message, \"offset\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.offset);\n                    if (message.data != null && Object.hasOwnProperty.call(message, \"data\"))\n                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.data);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WriteSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WriteSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WriteSectionDataRequest} WriteSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WriteSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        case 3:\n                            message.offset = reader.uint32();\n                            break;\n                        case 4:\n                            message.data = reader.bytes();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WriteSectionDataRequest;\n            })();\n    \n            ctrl.WriteSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a WriteSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IWriteSectionDataReply\n                 */\n    \n                /**\n                 * Constructs a new WriteSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a WriteSectionDataReply.\n                 * @implements IWriteSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set\n                 */\n                function WriteSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new WriteSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply instance\n                 */\n                WriteSectionDataReply.create = function create(properties) {\n                    return new WriteSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified WriteSectionDataReply message. Does not implicitly {@link particle.ctrl.WriteSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IWriteSectionDataReply} message WriteSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WriteSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WriteSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.WriteSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.WriteSectionDataReply} WriteSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WriteSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.WriteSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return WriteSectionDataReply;\n            })();\n    \n            ctrl.ClearSectionDataRequest = (function() {\n    \n                /**\n                 * Properties of a ClearSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @interface IClearSectionDataRequest\n                 * @property {number|null} [storage] ClearSectionDataRequest storage\n                 * @property {number|null} [section] ClearSectionDataRequest section\n                 */\n    \n                /**\n                 * Constructs a new ClearSectionDataRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ClearSectionDataRequest.\n                 * @implements IClearSectionDataRequest\n                 * @constructor\n                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set\n                 */\n                function ClearSectionDataRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ClearSectionDataRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @instance\n                 */\n                ClearSectionDataRequest.prototype.storage = 0;\n    \n                /**\n                 * ClearSectionDataRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @instance\n                 */\n                ClearSectionDataRequest.prototype.section = 0;\n    \n                /**\n                 * Creates a new ClearSectionDataRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest instance\n                 */\n                ClearSectionDataRequest.create = function create(properties) {\n                    return new ClearSectionDataRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified ClearSectionDataRequest message. Does not implicitly {@link particle.ctrl.ClearSectionDataRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataRequest} message ClearSectionDataRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClearSectionDataRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ClearSectionDataRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ClearSectionDataRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ClearSectionDataRequest} ClearSectionDataRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClearSectionDataRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ClearSectionDataRequest;\n            })();\n    \n            ctrl.ClearSectionDataReply = (function() {\n    \n                /**\n                 * Properties of a ClearSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @interface IClearSectionDataReply\n                 */\n    \n                /**\n                 * Constructs a new ClearSectionDataReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a ClearSectionDataReply.\n                 * @implements IClearSectionDataReply\n                 * @constructor\n                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set\n                 */\n                function ClearSectionDataReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new ClearSectionDataReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply instance\n                 */\n                ClearSectionDataReply.create = function create(properties) {\n                    return new ClearSectionDataReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified ClearSectionDataReply message. Does not implicitly {@link particle.ctrl.ClearSectionDataReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {particle.ctrl.IClearSectionDataReply} message ClearSectionDataReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ClearSectionDataReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ClearSectionDataReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.ClearSectionDataReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.ClearSectionDataReply} ClearSectionDataReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ClearSectionDataReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.ClearSectionDataReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ClearSectionDataReply;\n            })();\n    \n            ctrl.GetSectionDataSizeRequest = (function() {\n    \n                /**\n                 * Properties of a GetSectionDataSizeRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetSectionDataSizeRequest\n                 * @property {number|null} [storage] GetSectionDataSizeRequest storage\n                 * @property {number|null} [section] GetSectionDataSizeRequest section\n                 */\n    \n                /**\n                 * Constructs a new GetSectionDataSizeRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSectionDataSizeRequest.\n                 * @implements IGetSectionDataSizeRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set\n                 */\n                function GetSectionDataSizeRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSectionDataSizeRequest storage.\n                 * @member {number} storage\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @instance\n                 */\n                GetSectionDataSizeRequest.prototype.storage = 0;\n    \n                /**\n                 * GetSectionDataSizeRequest section.\n                 * @member {number} section\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @instance\n                 */\n                GetSectionDataSizeRequest.prototype.section = 0;\n    \n                /**\n                 * Creates a new GetSectionDataSizeRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest instance\n                 */\n                GetSectionDataSizeRequest.create = function create(properties) {\n                    return new GetSectionDataSizeRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSectionDataSizeRequest message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeRequest} message GetSectionDataSizeRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSectionDataSizeRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.storage != null && Object.hasOwnProperty.call(message, \"storage\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.storage);\n                    if (message.section != null && Object.hasOwnProperty.call(message, \"section\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.section);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSectionDataSizeRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSectionDataSizeRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSectionDataSizeRequest} GetSectionDataSizeRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSectionDataSizeRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.storage = reader.uint32();\n                            break;\n                        case 2:\n                            message.section = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSectionDataSizeRequest;\n            })();\n    \n            ctrl.GetSectionDataSizeReply = (function() {\n    \n                /**\n                 * Properties of a GetSectionDataSizeReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetSectionDataSizeReply\n                 * @property {number|null} [size] GetSectionDataSizeReply size\n                 */\n    \n                /**\n                 * Constructs a new GetSectionDataSizeReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetSectionDataSizeReply.\n                 * @implements IGetSectionDataSizeReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set\n                 */\n                function GetSectionDataSizeReply(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetSectionDataSizeReply size.\n                 * @member {number} size\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @instance\n                 */\n                GetSectionDataSizeReply.prototype.size = 0;\n    \n                /**\n                 * Creates a new GetSectionDataSizeReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply instance\n                 */\n                GetSectionDataSizeReply.create = function create(properties) {\n                    return new GetSectionDataSizeReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetSectionDataSizeReply message. Does not implicitly {@link particle.ctrl.GetSectionDataSizeReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {particle.ctrl.IGetSectionDataSizeReply} message GetSectionDataSizeReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetSectionDataSizeReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.size);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetSectionDataSizeReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetSectionDataSizeReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetSectionDataSizeReply} GetSectionDataSizeReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetSectionDataSizeReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetSectionDataSizeReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.size = reader.uint32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetSectionDataSizeReply;\n            })();\n    \n            ctrl.GetModuleInfoRequest = (function() {\n    \n                /**\n                 * Properties of a GetModuleInfoRequest.\n                 * @memberof particle.ctrl\n                 * @interface IGetModuleInfoRequest\n                 */\n    \n                /**\n                 * Constructs a new GetModuleInfoRequest.\n                 * @memberof particle.ctrl\n                 * @classdesc Get firmware module info.\n                 * @implements IGetModuleInfoRequest\n                 * @constructor\n                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set\n                 */\n                function GetModuleInfoRequest(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * Creates a new GetModuleInfoRequest instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoRequest=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest instance\n                 */\n                GetModuleInfoRequest.create = function create(properties) {\n                    return new GetModuleInfoRequest(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetModuleInfoRequest message. Does not implicitly {@link particle.ctrl.GetModuleInfoRequest.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoRequest} message GetModuleInfoRequest message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetModuleInfoRequest.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetModuleInfoRequest message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetModuleInfoRequest\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetModuleInfoRequest} GetModuleInfoRequest\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetModuleInfoRequest.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoRequest();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return GetModuleInfoRequest;\n            })();\n    \n            ctrl.GetModuleInfoReply = (function() {\n    \n                /**\n                 * Properties of a GetModuleInfoReply.\n                 * @memberof particle.ctrl\n                 * @interface IGetModuleInfoReply\n                 * @property {Array.<particle.ctrl.GetModuleInfoReply.IModule>|null} [modules] GetModuleInfoReply modules\n                 */\n    \n                /**\n                 * Constructs a new GetModuleInfoReply.\n                 * @memberof particle.ctrl\n                 * @classdesc Represents a GetModuleInfoReply.\n                 * @implements IGetModuleInfoReply\n                 * @constructor\n                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set\n                 */\n                function GetModuleInfoReply(properties) {\n                    this.modules = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GetModuleInfoReply modules.\n                 * @member {Array.<particle.ctrl.GetModuleInfoReply.IModule>} modules\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @instance\n                 */\n                GetModuleInfoReply.prototype.modules = $util.emptyArray;\n    \n                /**\n                 * Creates a new GetModuleInfoReply instance using the specified properties.\n                 * @function create\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoReply=} [properties] Properties to set\n                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply instance\n                 */\n                GetModuleInfoReply.create = function create(properties) {\n                    return new GetModuleInfoReply(properties);\n                };\n    \n                /**\n                 * Encodes the specified GetModuleInfoReply message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {particle.ctrl.IGetModuleInfoReply} message GetModuleInfoReply message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GetModuleInfoReply.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.modules != null && message.modules.length)\n                        for (var i = 0; i < message.modules.length; ++i)\n                            $root.particle.ctrl.GetModuleInfoReply.Module.encode(message.modules[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GetModuleInfoReply message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.ctrl.GetModuleInfoReply\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.ctrl.GetModuleInfoReply} GetModuleInfoReply\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GetModuleInfoReply.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.modules && message.modules.length))\n                                message.modules = [];\n                            message.modules.push($root.particle.ctrl.GetModuleInfoReply.Module.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                GetModuleInfoReply.Dependency = (function() {\n    \n                    /**\n                     * Properties of a Dependency.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @interface IDependency\n                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Dependency type\n                     * @property {number|null} [index] Dependency index\n                     * @property {number|null} [version] Dependency version\n                     */\n    \n                    /**\n                     * Constructs a new Dependency.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @classdesc Represents a Dependency.\n                     * @implements IDependency\n                     * @constructor\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set\n                     */\n                    function Dependency(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Dependency type.\n                     * @member {particle.ctrl.FirmwareModuleType} type\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.type = 0;\n    \n                    /**\n                     * Dependency index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.index = 0;\n    \n                    /**\n                     * Dependency version.\n                     * @member {number} version\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @instance\n                     */\n                    Dependency.prototype.version = 0;\n    \n                    /**\n                     * Creates a new Dependency instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency=} [properties] Properties to set\n                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency instance\n                     */\n                    Dependency.create = function create(properties) {\n                        return new Dependency(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Dependency message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Dependency.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IDependency} message Dependency message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Dependency.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Dependency message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Dependency\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.GetModuleInfoReply.Dependency} Dependency\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Dependency.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Dependency();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.index = reader.uint32();\n                                break;\n                            case 3:\n                                message.version = reader.uint32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Dependency;\n                })();\n    \n                GetModuleInfoReply.Module = (function() {\n    \n                    /**\n                     * Properties of a Module.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @interface IModule\n                     * @property {particle.ctrl.FirmwareModuleType|null} [type] Module type\n                     * @property {number|null} [index] Module index\n                     * @property {number|null} [version] Module version\n                     * @property {number|null} [size] Module size\n                     * @property {number|null} [validity] Module validity\n                     * @property {Array.<particle.ctrl.GetModuleInfoReply.IDependency>|null} [dependencies] Module dependencies\n                     */\n    \n                    /**\n                     * Constructs a new Module.\n                     * @memberof particle.ctrl.GetModuleInfoReply\n                     * @classdesc Represents a Module.\n                     * @implements IModule\n                     * @constructor\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set\n                     */\n                    function Module(properties) {\n                        this.dependencies = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Module type.\n                     * @member {particle.ctrl.FirmwareModuleType} type\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.type = 0;\n    \n                    /**\n                     * Module index.\n                     * @member {number} index\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.index = 0;\n    \n                    /**\n                     * Module version.\n                     * @member {number} version\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.version = 0;\n    \n                    /**\n                     * Module size.\n                     * @member {number} size\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.size = 0;\n    \n                    /**\n                     * Module validity.\n                     * @member {number} validity\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.validity = 0;\n    \n                    /**\n                     * Module dependencies.\n                     * @member {Array.<particle.ctrl.GetModuleInfoReply.IDependency>} dependencies\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @instance\n                     */\n                    Module.prototype.dependencies = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Module instance using the specified properties.\n                     * @function create\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule=} [properties] Properties to set\n                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module instance\n                     */\n                    Module.create = function create(properties) {\n                        return new Module(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Module message. Does not implicitly {@link particle.ctrl.GetModuleInfoReply.Module.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {particle.ctrl.GetModuleInfoReply.IModule} message Module message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Module.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);\n                        if (message.index != null && Object.hasOwnProperty.call(message, \"index\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.index);\n                        if (message.version != null && Object.hasOwnProperty.call(message, \"version\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.version);\n                        if (message.size != null && Object.hasOwnProperty.call(message, \"size\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).uint32(message.size);\n                        if (message.validity != null && Object.hasOwnProperty.call(message, \"validity\"))\n                            writer.uint32(/* id 5, wireType 0 =*/40).uint32(message.validity);\n                        if (message.dependencies != null && message.dependencies.length)\n                            for (var i = 0; i < message.dependencies.length; ++i)\n                                $root.particle.ctrl.GetModuleInfoReply.Dependency.encode(message.dependencies[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Module message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.ctrl.GetModuleInfoReply.Module\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.ctrl.GetModuleInfoReply.Module} Module\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Module.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.ctrl.GetModuleInfoReply.Module();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.type = reader.int32();\n                                break;\n                            case 2:\n                                message.index = reader.uint32();\n                                break;\n                            case 3:\n                                message.version = reader.uint32();\n                                break;\n                            case 4:\n                                message.size = reader.uint32();\n                                break;\n                            case 5:\n                                message.validity = reader.uint32();\n                                break;\n                            case 6:\n                                if (!(message.dependencies && message.dependencies.length))\n                                    message.dependencies = [];\n                                message.dependencies.push($root.particle.ctrl.GetModuleInfoReply.Dependency.decode(reader, reader.uint32()));\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Module;\n                })();\n    \n                return GetModuleInfoReply;\n            })();\n    \n            return ctrl;\n        })();\n    \n        particle.firmware = (function() {\n    \n            /**\n             * Namespace firmware.\n             * @memberof particle\n             * @namespace\n             */\n            var firmware = {};\n    \n            firmware.WifiConfig = (function() {\n    \n                /**\n                 * Properties of a WifiConfig.\n                 * @memberof particle.firmware\n                 * @interface IWifiConfig\n                 * @property {Array.<particle.firmware.WifiConfig.INetwork>|null} [networks] WifiConfig networks\n                 */\n    \n                /**\n                 * Constructs a new WifiConfig.\n                 * @memberof particle.firmware\n                 * @classdesc Represents a WifiConfig.\n                 * @implements IWifiConfig\n                 * @constructor\n                 * @param {particle.firmware.IWifiConfig=} [properties] Properties to set\n                 */\n                function WifiConfig(properties) {\n                    this.networks = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * WifiConfig networks.\n                 * @member {Array.<particle.firmware.WifiConfig.INetwork>} networks\n                 * @memberof particle.firmware.WifiConfig\n                 * @instance\n                 */\n                WifiConfig.prototype.networks = $util.emptyArray;\n    \n                /**\n                 * Creates a new WifiConfig instance using the specified properties.\n                 * @function create\n                 * @memberof particle.firmware.WifiConfig\n                 * @static\n                 * @param {particle.firmware.IWifiConfig=} [properties] Properties to set\n                 * @returns {particle.firmware.WifiConfig} WifiConfig instance\n                 */\n                WifiConfig.create = function create(properties) {\n                    return new WifiConfig(properties);\n                };\n    \n                /**\n                 * Encodes the specified WifiConfig message. Does not implicitly {@link particle.firmware.WifiConfig.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.firmware.WifiConfig\n                 * @static\n                 * @param {particle.firmware.IWifiConfig} message WifiConfig message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                WifiConfig.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.networks != null && message.networks.length)\n                        for (var i = 0; i < message.networks.length; ++i)\n                            $root.particle.firmware.WifiConfig.Network.encode(message.networks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a WifiConfig message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.firmware.WifiConfig\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.firmware.WifiConfig} WifiConfig\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                WifiConfig.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.firmware.WifiConfig();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.networks && message.networks.length))\n                                message.networks = [];\n                            message.networks.push($root.particle.firmware.WifiConfig.Network.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                WifiConfig.Network = (function() {\n    \n                    /**\n                     * Properties of a Network.\n                     * @memberof particle.firmware.WifiConfig\n                     * @interface INetwork\n                     * @property {string|null} [ssid] Network ssid\n                     * @property {Uint8Array|null} [bssid] Network bssid\n                     * @property {particle.ctrl.wifi.Security|null} [security] Network security\n                     * @property {particle.ctrl.wifi.ICredentials|null} [credentials] Network credentials\n                     */\n    \n                    /**\n                     * Constructs a new Network.\n                     * @memberof particle.firmware.WifiConfig\n                     * @classdesc Represents a Network.\n                     * @implements INetwork\n                     * @constructor\n                     * @param {particle.firmware.WifiConfig.INetwork=} [properties] Properties to set\n                     */\n                    function Network(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Network ssid.\n                     * @member {string} ssid\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @instance\n                     */\n                    Network.prototype.ssid = \"\";\n    \n                    /**\n                     * Network bssid.\n                     * @member {Uint8Array} bssid\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @instance\n                     */\n                    Network.prototype.bssid = $util.newBuffer([]);\n    \n                    /**\n                     * Network security.\n                     * @member {particle.ctrl.wifi.Security} security\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @instance\n                     */\n                    Network.prototype.security = 0;\n    \n                    /**\n                     * Network credentials.\n                     * @member {particle.ctrl.wifi.ICredentials|null|undefined} credentials\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @instance\n                     */\n                    Network.prototype.credentials = null;\n    \n                    /**\n                     * Creates a new Network instance using the specified properties.\n                     * @function create\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @static\n                     * @param {particle.firmware.WifiConfig.INetwork=} [properties] Properties to set\n                     * @returns {particle.firmware.WifiConfig.Network} Network instance\n                     */\n                    Network.create = function create(properties) {\n                        return new Network(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Network message. Does not implicitly {@link particle.firmware.WifiConfig.Network.verify|verify} messages.\n                     * @function encode\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @static\n                     * @param {particle.firmware.WifiConfig.INetwork} message Network message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Network.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.ssid != null && Object.hasOwnProperty.call(message, \"ssid\"))\n                            writer.uint32(/* id 1, wireType 2 =*/10).string(message.ssid);\n                        if (message.bssid != null && Object.hasOwnProperty.call(message, \"bssid\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.bssid);\n                        if (message.security != null && Object.hasOwnProperty.call(message, \"security\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.security);\n                        if (message.credentials != null && Object.hasOwnProperty.call(message, \"credentials\"))\n                            $root.particle.ctrl.wifi.Credentials.encode(message.credentials, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Network message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof particle.firmware.WifiConfig.Network\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {particle.firmware.WifiConfig.Network} Network\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Network.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.firmware.WifiConfig.Network();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.ssid = reader.string();\n                                break;\n                            case 2:\n                                message.bssid = reader.bytes();\n                                break;\n                            case 3:\n                                message.security = reader.int32();\n                                break;\n                            case 4:\n                                message.credentials = $root.particle.ctrl.wifi.Credentials.decode(reader, reader.uint32());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Network;\n                })();\n    \n                return WifiConfig;\n            })();\n    \n            firmware.CellularConfig = (function() {\n    \n                /**\n                 * Properties of a CellularConfig.\n                 * @memberof particle.firmware\n                 * @interface ICellularConfig\n                 * @property {particle.ctrl.cellular.IAccessPoint|null} [internalSim] CellularConfig internalSim\n                 * @property {particle.ctrl.cellular.IAccessPoint|null} [externalSim] CellularConfig externalSim\n                 * @property {particle.ctrl.cellular.SimType|null} [activeSim] CellularConfig activeSim\n                 */\n    \n                /**\n                 * Constructs a new CellularConfig.\n                 * @memberof particle.firmware\n                 * @classdesc Represents a CellularConfig.\n                 * @implements ICellularConfig\n                 * @constructor\n                 * @param {particle.firmware.ICellularConfig=} [properties] Properties to set\n                 */\n                function CellularConfig(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * CellularConfig internalSim.\n                 * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} internalSim\n                 * @memberof particle.firmware.CellularConfig\n                 * @instance\n                 */\n                CellularConfig.prototype.internalSim = null;\n    \n                /**\n                 * CellularConfig externalSim.\n                 * @member {particle.ctrl.cellular.IAccessPoint|null|undefined} externalSim\n                 * @memberof particle.firmware.CellularConfig\n                 * @instance\n                 */\n                CellularConfig.prototype.externalSim = null;\n    \n                /**\n                 * CellularConfig activeSim.\n                 * @member {particle.ctrl.cellular.SimType} activeSim\n                 * @memberof particle.firmware.CellularConfig\n                 * @instance\n                 */\n                CellularConfig.prototype.activeSim = 0;\n    \n                /**\n                 * Creates a new CellularConfig instance using the specified properties.\n                 * @function create\n                 * @memberof particle.firmware.CellularConfig\n                 * @static\n                 * @param {particle.firmware.ICellularConfig=} [properties] Properties to set\n                 * @returns {particle.firmware.CellularConfig} CellularConfig instance\n                 */\n                CellularConfig.create = function create(properties) {\n                    return new CellularConfig(properties);\n                };\n    \n                /**\n                 * Encodes the specified CellularConfig message. Does not implicitly {@link particle.firmware.CellularConfig.verify|verify} messages.\n                 * @function encode\n                 * @memberof particle.firmware.CellularConfig\n                 * @static\n                 * @param {particle.firmware.ICellularConfig} message CellularConfig message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                CellularConfig.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.internalSim != null && Object.hasOwnProperty.call(message, \"internalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(message.internalSim, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    if (message.externalSim != null && Object.hasOwnProperty.call(message, \"externalSim\"))\n                        $root.particle.ctrl.cellular.AccessPoint.encode(message.externalSim, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.activeSim != null && Object.hasOwnProperty.call(message, \"activeSim\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.activeSim);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a CellularConfig message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof particle.firmware.CellularConfig\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {particle.firmware.CellularConfig} CellularConfig\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                CellularConfig.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.particle.firmware.CellularConfig();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.internalSim = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                            break;\n                        case 2:\n                            message.externalSim = $root.particle.ctrl.cellular.AccessPoint.decode(reader, reader.uint32());\n                            break;\n                        case 3:\n                            message.activeSim = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return CellularConfig;\n            })();\n    \n            return firmware;\n        })();\n    \n        return particle;\n    })();\n    \n    $root.google = (function() {\n    \n        /**\n         * Namespace google.\n         * @exports google\n         * @namespace\n         */\n        var google = {};\n    \n        google.protobuf = (function() {\n    \n            /**\n             * Namespace protobuf.\n             * @memberof google\n             * @namespace\n             */\n            var protobuf = {};\n    \n            protobuf.FileDescriptorSet = (function() {\n    \n                /**\n                 * Properties of a FileDescriptorSet.\n                 * @memberof google.protobuf\n                 * @interface IFileDescriptorSet\n                 * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file\n                 */\n    \n                /**\n                 * Constructs a new FileDescriptorSet.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileDescriptorSet.\n                 * @implements IFileDescriptorSet\n                 * @constructor\n                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n                 */\n                function FileDescriptorSet(properties) {\n                    this.file = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileDescriptorSet file.\n                 * @member {Array.<google.protobuf.IFileDescriptorProto>} file\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @instance\n                 */\n                FileDescriptorSet.prototype.file = $util.emptyArray;\n    \n                /**\n                 * Creates a new FileDescriptorSet instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance\n                 */\n                FileDescriptorSet.create = function create(properties) {\n                    return new FileDescriptorSet(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileDescriptorSet.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.file != null && message.file.length)\n                        for (var i = 0; i < message.file.length; ++i)\n                            $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileDescriptorSet message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileDescriptorSet\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileDescriptorSet.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.file && message.file.length))\n                                message.file = [];\n                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FileDescriptorSet;\n            })();\n    \n            protobuf.FileDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a FileDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IFileDescriptorProto\n                 * @property {string|null} [name] FileDescriptorProto name\n                 * @property {string|null} [\"package\"] FileDescriptorProto package\n                 * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency\n                 * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency\n                 * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency\n                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType\n                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType\n                 * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension\n                 * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options\n                 * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo\n                 * @property {string|null} [syntax] FileDescriptorProto syntax\n                 */\n    \n                /**\n                 * Constructs a new FileDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileDescriptorProto.\n                 * @implements IFileDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n                 */\n                function FileDescriptorProto(properties) {\n                    this.dependency = [];\n                    this.publicDependency = [];\n                    this.weakDependency = [];\n                    this.messageType = [];\n                    this.enumType = [];\n                    this.service = [];\n                    this.extension = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * FileDescriptorProto package.\n                 * @member {string} package\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype[\"package\"] = \"\";\n    \n                /**\n                 * FileDescriptorProto dependency.\n                 * @member {Array.<string>} dependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.dependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto publicDependency.\n                 * @member {Array.<number>} publicDependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto weakDependency.\n                 * @member {Array.<number>} weakDependency\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto messageType.\n                 * @member {Array.<google.protobuf.IDescriptorProto>} messageType\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.messageType = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto enumType.\n                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.enumType = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto service.\n                 * @member {Array.<google.protobuf.IServiceDescriptorProto>} service\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.service = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto extension.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.extension = $util.emptyArray;\n    \n                /**\n                 * FileDescriptorProto options.\n                 * @member {google.protobuf.IFileOptions|null|undefined} options\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.options = null;\n    \n                /**\n                 * FileDescriptorProto sourceCodeInfo.\n                 * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.sourceCodeInfo = null;\n    \n                /**\n                 * FileDescriptorProto syntax.\n                 * @member {string} syntax\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @instance\n                 */\n                FileDescriptorProto.prototype.syntax = \"\";\n    \n                /**\n                 * Creates a new FileDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance\n                 */\n                FileDescriptorProto.create = function create(properties) {\n                    return new FileDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message[\"package\"] != null && Object.hasOwnProperty.call(message, \"package\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message[\"package\"]);\n                    if (message.dependency != null && message.dependency.length)\n                        for (var i = 0; i < message.dependency.length; ++i)\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);\n                    if (message.messageType != null && message.messageType.length)\n                        for (var i = 0; i < message.messageType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.enumType != null && message.enumType.length)\n                        for (var i = 0; i < message.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.service != null && message.service.length)\n                        for (var i = 0; i < message.service.length; ++i)\n                            $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.extension != null && message.extension.length)\n                        for (var i = 0; i < message.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, \"sourceCodeInfo\"))\n                        $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.publicDependency != null && message.publicDependency.length)\n                        for (var i = 0; i < message.publicDependency.length; ++i)\n                            writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);\n                    if (message.weakDependency != null && message.weakDependency.length)\n                        for (var i = 0; i < message.weakDependency.length; ++i)\n                            writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);\n                    if (message.syntax != null && Object.hasOwnProperty.call(message, \"syntax\"))\n                        writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message[\"package\"] = reader.string();\n                            break;\n                        case 3:\n                            if (!(message.dependency && message.dependency.length))\n                                message.dependency = [];\n                            message.dependency.push(reader.string());\n                            break;\n                        case 10:\n                            if (!(message.publicDependency && message.publicDependency.length))\n                                message.publicDependency = [];\n                            if ((tag & 7) === 2) {\n                                var end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.publicDependency.push(reader.int32());\n                            } else\n                                message.publicDependency.push(reader.int32());\n                            break;\n                        case 11:\n                            if (!(message.weakDependency && message.weakDependency.length))\n                                message.weakDependency = [];\n                            if ((tag & 7) === 2) {\n                                var end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.weakDependency.push(reader.int32());\n                            } else\n                                message.weakDependency.push(reader.int32());\n                            break;\n                        case 4:\n                            if (!(message.messageType && message.messageType.length))\n                                message.messageType = [];\n                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.service && message.service.length))\n                                message.service = [];\n                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());\n                            break;\n                        case 12:\n                            message.syntax = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return FileDescriptorProto;\n            })();\n    \n            protobuf.DescriptorProto = (function() {\n    \n                /**\n                 * Properties of a DescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IDescriptorProto\n                 * @property {string|null} [name] DescriptorProto name\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field\n                 * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension\n                 * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType\n                 * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType\n                 * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange\n                 * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl\n                 * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options\n                 * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange\n                 * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName\n                 */\n    \n                /**\n                 * Constructs a new DescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a DescriptorProto.\n                 * @implements IDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n                 */\n                function DescriptorProto(properties) {\n                    this.field = [];\n                    this.extension = [];\n                    this.nestedType = [];\n                    this.enumType = [];\n                    this.extensionRange = [];\n                    this.oneofDecl = [];\n                    this.reservedRange = [];\n                    this.reservedName = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * DescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * DescriptorProto field.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} field\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.field = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto extension.\n                 * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.extension = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto nestedType.\n                 * @member {Array.<google.protobuf.IDescriptorProto>} nestedType\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.nestedType = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto enumType.\n                 * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.enumType = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto extensionRange.\n                 * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.extensionRange = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto oneofDecl.\n                 * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto options.\n                 * @member {google.protobuf.IMessageOptions|null|undefined} options\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.options = null;\n    \n                /**\n                 * DescriptorProto reservedRange.\n                 * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.reservedRange = $util.emptyArray;\n    \n                /**\n                 * DescriptorProto reservedName.\n                 * @member {Array.<string>} reservedName\n                 * @memberof google.protobuf.DescriptorProto\n                 * @instance\n                 */\n                DescriptorProto.prototype.reservedName = $util.emptyArray;\n    \n                /**\n                 * Creates a new DescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.DescriptorProto} DescriptorProto instance\n                 */\n                DescriptorProto.create = function create(properties) {\n                    return new DescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                DescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.field != null && message.field.length)\n                        for (var i = 0; i < message.field.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.nestedType != null && message.nestedType.length)\n                        for (var i = 0; i < message.nestedType.length; ++i)\n                            $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    if (message.enumType != null && message.enumType.length)\n                        for (var i = 0; i < message.enumType.length; ++i)\n                            $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.extensionRange != null && message.extensionRange.length)\n                        for (var i = 0; i < message.extensionRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();\n                    if (message.extension != null && message.extension.length)\n                        for (var i = 0; i < message.extension.length; ++i)\n                            $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();\n                    if (message.oneofDecl != null && message.oneofDecl.length)\n                        for (var i = 0; i < message.oneofDecl.length; ++i)\n                            $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.reservedRange != null && message.reservedRange.length)\n                        for (var i = 0; i < message.reservedRange.length; ++i)\n                            $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();\n                    if (message.reservedName != null && message.reservedName.length)\n                        for (var i = 0; i < message.reservedName.length; ++i)\n                            writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a DescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.DescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.DescriptorProto} DescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                DescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.field && message.field.length))\n                                message.field = [];\n                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            if (!(message.nestedType && message.nestedType.length))\n                                message.nestedType = [];\n                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 4:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.extensionRange && message.extensionRange.length))\n                                message.extensionRange = [];\n                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            if (!(message.oneofDecl && message.oneofDecl.length))\n                                message.oneofDecl = [];\n                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            if (!(message.reservedRange && message.reservedRange.length))\n                                message.reservedRange = [];\n                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));\n                            break;\n                        case 10:\n                            if (!(message.reservedName && message.reservedName.length))\n                                message.reservedName = [];\n                            message.reservedName.push(reader.string());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                DescriptorProto.ExtensionRange = (function() {\n    \n                    /**\n                     * Properties of an ExtensionRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @interface IExtensionRange\n                     * @property {number|null} [start] ExtensionRange start\n                     * @property {number|null} [end] ExtensionRange end\n                     */\n    \n                    /**\n                     * Constructs a new ExtensionRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @classdesc Represents an ExtensionRange.\n                     * @implements IExtensionRange\n                     * @constructor\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n                     */\n                    function ExtensionRange(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ExtensionRange start.\n                     * @member {number} start\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @instance\n                     */\n                    ExtensionRange.prototype.start = 0;\n    \n                    /**\n                     * ExtensionRange end.\n                     * @member {number} end\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @instance\n                     */\n                    ExtensionRange.prototype.end = 0;\n    \n                    /**\n                     * Creates a new ExtensionRange instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance\n                     */\n                    ExtensionRange.create = function create(properties) {\n                        return new ExtensionRange(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ExtensionRange.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.start != null && Object.hasOwnProperty.call(message, \"start\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an ExtensionRange message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ExtensionRange.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ExtensionRange;\n                })();\n    \n                DescriptorProto.ReservedRange = (function() {\n    \n                    /**\n                     * Properties of a ReservedRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @interface IReservedRange\n                     * @property {number|null} [start] ReservedRange start\n                     * @property {number|null} [end] ReservedRange end\n                     */\n    \n                    /**\n                     * Constructs a new ReservedRange.\n                     * @memberof google.protobuf.DescriptorProto\n                     * @classdesc Represents a ReservedRange.\n                     * @implements IReservedRange\n                     * @constructor\n                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n                     */\n                    function ReservedRange(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * ReservedRange start.\n                     * @member {number} start\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @instance\n                     */\n                    ReservedRange.prototype.start = 0;\n    \n                    /**\n                     * ReservedRange end.\n                     * @member {number} end\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @instance\n                     */\n                    ReservedRange.prototype.end = 0;\n    \n                    /**\n                     * Creates a new ReservedRange instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance\n                     */\n                    ReservedRange.create = function create(properties) {\n                        return new ReservedRange(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    ReservedRange.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.start != null && Object.hasOwnProperty.call(message, \"start\"))\n                            writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a ReservedRange message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.DescriptorProto.ReservedRange\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    ReservedRange.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return ReservedRange;\n                })();\n    \n                return DescriptorProto;\n            })();\n    \n            protobuf.FieldDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a FieldDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IFieldDescriptorProto\n                 * @property {string|null} [name] FieldDescriptorProto name\n                 * @property {number|null} [number] FieldDescriptorProto number\n                 * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label\n                 * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type\n                 * @property {string|null} [typeName] FieldDescriptorProto typeName\n                 * @property {string|null} [extendee] FieldDescriptorProto extendee\n                 * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue\n                 * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex\n                 * @property {string|null} [jsonName] FieldDescriptorProto jsonName\n                 * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new FieldDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FieldDescriptorProto.\n                 * @implements IFieldDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n                 */\n                function FieldDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FieldDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * FieldDescriptorProto number.\n                 * @member {number} number\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.number = 0;\n    \n                /**\n                 * FieldDescriptorProto label.\n                 * @member {google.protobuf.FieldDescriptorProto.Label} label\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.label = 1;\n    \n                /**\n                 * FieldDescriptorProto type.\n                 * @member {google.protobuf.FieldDescriptorProto.Type} type\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.type = 1;\n    \n                /**\n                 * FieldDescriptorProto typeName.\n                 * @member {string} typeName\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.typeName = \"\";\n    \n                /**\n                 * FieldDescriptorProto extendee.\n                 * @member {string} extendee\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.extendee = \"\";\n    \n                /**\n                 * FieldDescriptorProto defaultValue.\n                 * @member {string} defaultValue\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.defaultValue = \"\";\n    \n                /**\n                 * FieldDescriptorProto oneofIndex.\n                 * @member {number} oneofIndex\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.oneofIndex = 0;\n    \n                /**\n                 * FieldDescriptorProto jsonName.\n                 * @member {string} jsonName\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.jsonName = \"\";\n    \n                /**\n                 * FieldDescriptorProto options.\n                 * @member {google.protobuf.IFieldOptions|null|undefined} options\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @instance\n                 */\n                FieldDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new FieldDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance\n                 */\n                FieldDescriptorProto.create = function create(properties) {\n                    return new FieldDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FieldDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.extendee != null && Object.hasOwnProperty.call(message, \"extendee\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);\n                    if (message.number != null && Object.hasOwnProperty.call(message, \"number\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);\n                    if (message.label != null && Object.hasOwnProperty.call(message, \"label\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);\n                    if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);\n                    if (message.typeName != null && Object.hasOwnProperty.call(message, \"typeName\"))\n                        writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);\n                    if (message.defaultValue != null && Object.hasOwnProperty.call(message, \"defaultValue\"))\n                        writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();\n                    if (message.oneofIndex != null && Object.hasOwnProperty.call(message, \"oneofIndex\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);\n                    if (message.jsonName != null && Object.hasOwnProperty.call(message, \"jsonName\"))\n                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FieldDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FieldDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FieldDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.number = reader.int32();\n                            break;\n                        case 4:\n                            message.label = reader.int32();\n                            break;\n                        case 5:\n                            message.type = reader.int32();\n                            break;\n                        case 6:\n                            message.typeName = reader.string();\n                            break;\n                        case 2:\n                            message.extendee = reader.string();\n                            break;\n                        case 7:\n                            message.defaultValue = reader.string();\n                            break;\n                        case 9:\n                            message.oneofIndex = reader.int32();\n                            break;\n                        case 10:\n                            message.jsonName = reader.string();\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * Type enum.\n                 * @name google.protobuf.FieldDescriptorProto.Type\n                 * @enum {number}\n                 * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value\n                 * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value\n                 * @property {number} TYPE_INT64=3 TYPE_INT64 value\n                 * @property {number} TYPE_UINT64=4 TYPE_UINT64 value\n                 * @property {number} TYPE_INT32=5 TYPE_INT32 value\n                 * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value\n                 * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value\n                 * @property {number} TYPE_BOOL=8 TYPE_BOOL value\n                 * @property {number} TYPE_STRING=9 TYPE_STRING value\n                 * @property {number} TYPE_GROUP=10 TYPE_GROUP value\n                 * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value\n                 * @property {number} TYPE_BYTES=12 TYPE_BYTES value\n                 * @property {number} TYPE_UINT32=13 TYPE_UINT32 value\n                 * @property {number} TYPE_ENUM=14 TYPE_ENUM value\n                 * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value\n                 * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value\n                 * @property {number} TYPE_SINT32=17 TYPE_SINT32 value\n                 * @property {number} TYPE_SINT64=18 TYPE_SINT64 value\n                 */\n                FieldDescriptorProto.Type = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n                    values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n                    values[valuesById[3] = \"TYPE_INT64\"] = 3;\n                    values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n                    values[valuesById[5] = \"TYPE_INT32\"] = 5;\n                    values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n                    values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n                    values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n                    values[valuesById[9] = \"TYPE_STRING\"] = 9;\n                    values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n                    values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n                    values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n                    values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n                    values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n                    values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n                    values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n                    values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n                    values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n                    return values;\n                })();\n    \n                /**\n                 * Label enum.\n                 * @name google.protobuf.FieldDescriptorProto.Label\n                 * @enum {number}\n                 * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value\n                 * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value\n                 * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value\n                 */\n                FieldDescriptorProto.Label = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n                    values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n                    values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n                    return values;\n                })();\n    \n                return FieldDescriptorProto;\n            })();\n    \n            protobuf.OneofDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an OneofDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IOneofDescriptorProto\n                 * @property {string|null} [name] OneofDescriptorProto name\n                 * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new OneofDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an OneofDescriptorProto.\n                 * @implements IOneofDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n                 */\n                function OneofDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * OneofDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @instance\n                 */\n                OneofDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * OneofDescriptorProto options.\n                 * @member {google.protobuf.IOneofOptions|null|undefined} options\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @instance\n                 */\n                OneofDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new OneofDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance\n                 */\n                OneofDescriptorProto.create = function create(properties) {\n                    return new OneofDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                OneofDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an OneofDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.OneofDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                OneofDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return OneofDescriptorProto;\n            })();\n    \n            protobuf.EnumDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an EnumDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IEnumDescriptorProto\n                 * @property {string|null} [name] EnumDescriptorProto name\n                 * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value\n                 * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new EnumDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumDescriptorProto.\n                 * @implements IEnumDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n                 */\n                function EnumDescriptorProto(properties) {\n                    this.value = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * EnumDescriptorProto value.\n                 * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.value = $util.emptyArray;\n    \n                /**\n                 * EnumDescriptorProto options.\n                 * @member {google.protobuf.IEnumOptions|null|undefined} options\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @instance\n                 */\n                EnumDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new EnumDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance\n                 */\n                EnumDescriptorProto.create = function create(properties) {\n                    return new EnumDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.value != null && message.value.length)\n                        for (var i = 0; i < message.value.length; ++i)\n                            $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.value && message.value.length))\n                                message.value = [];\n                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumDescriptorProto;\n            })();\n    \n            protobuf.EnumValueDescriptorProto = (function() {\n    \n                /**\n                 * Properties of an EnumValueDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IEnumValueDescriptorProto\n                 * @property {string|null} [name] EnumValueDescriptorProto name\n                 * @property {number|null} [number] EnumValueDescriptorProto number\n                 * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new EnumValueDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumValueDescriptorProto.\n                 * @implements IEnumValueDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n                 */\n                function EnumValueDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumValueDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * EnumValueDescriptorProto number.\n                 * @member {number} number\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.number = 0;\n    \n                /**\n                 * EnumValueDescriptorProto options.\n                 * @member {google.protobuf.IEnumValueOptions|null|undefined} options\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @instance\n                 */\n                EnumValueDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new EnumValueDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance\n                 */\n                EnumValueDescriptorProto.create = function create(properties) {\n                    return new EnumValueDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumValueDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.number != null && Object.hasOwnProperty.call(message, \"number\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumValueDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumValueDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.number = reader.int32();\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumValueDescriptorProto;\n            })();\n    \n            protobuf.ServiceDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a ServiceDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IServiceDescriptorProto\n                 * @property {string|null} [name] ServiceDescriptorProto name\n                 * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method\n                 * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options\n                 */\n    \n                /**\n                 * Constructs a new ServiceDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a ServiceDescriptorProto.\n                 * @implements IServiceDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n                 */\n                function ServiceDescriptorProto(properties) {\n                    this.method = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ServiceDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * ServiceDescriptorProto method.\n                 * @member {Array.<google.protobuf.IMethodDescriptorProto>} method\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.method = $util.emptyArray;\n    \n                /**\n                 * ServiceDescriptorProto options.\n                 * @member {google.protobuf.IServiceOptions|null|undefined} options\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @instance\n                 */\n                ServiceDescriptorProto.prototype.options = null;\n    \n                /**\n                 * Creates a new ServiceDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance\n                 */\n                ServiceDescriptorProto.create = function create(properties) {\n                    return new ServiceDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServiceDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.method != null && message.method.length)\n                        for (var i = 0; i < message.method.length; ++i)\n                            $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServiceDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.ServiceDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServiceDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.method && message.method.length))\n                                message.method = [];\n                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServiceDescriptorProto;\n            })();\n    \n            protobuf.MethodDescriptorProto = (function() {\n    \n                /**\n                 * Properties of a MethodDescriptorProto.\n                 * @memberof google.protobuf\n                 * @interface IMethodDescriptorProto\n                 * @property {string|null} [name] MethodDescriptorProto name\n                 * @property {string|null} [inputType] MethodDescriptorProto inputType\n                 * @property {string|null} [outputType] MethodDescriptorProto outputType\n                 * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options\n                 * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming\n                 * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming\n                 */\n    \n                /**\n                 * Constructs a new MethodDescriptorProto.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MethodDescriptorProto.\n                 * @implements IMethodDescriptorProto\n                 * @constructor\n                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n                 */\n                function MethodDescriptorProto(properties) {\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MethodDescriptorProto name.\n                 * @member {string} name\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.name = \"\";\n    \n                /**\n                 * MethodDescriptorProto inputType.\n                 * @member {string} inputType\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.inputType = \"\";\n    \n                /**\n                 * MethodDescriptorProto outputType.\n                 * @member {string} outputType\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.outputType = \"\";\n    \n                /**\n                 * MethodDescriptorProto options.\n                 * @member {google.protobuf.IMethodOptions|null|undefined} options\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.options = null;\n    \n                /**\n                 * MethodDescriptorProto clientStreaming.\n                 * @member {boolean} clientStreaming\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.clientStreaming = false;\n    \n                /**\n                 * MethodDescriptorProto serverStreaming.\n                 * @member {boolean} serverStreaming\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @instance\n                 */\n                MethodDescriptorProto.prototype.serverStreaming = false;\n    \n                /**\n                 * Creates a new MethodDescriptorProto instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance\n                 */\n                MethodDescriptorProto.create = function create(properties) {\n                    return new MethodDescriptorProto(properties);\n                };\n    \n                /**\n                 * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MethodDescriptorProto.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && Object.hasOwnProperty.call(message, \"name\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);\n                    if (message.inputType != null && Object.hasOwnProperty.call(message, \"inputType\"))\n                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);\n                    if (message.outputType != null && Object.hasOwnProperty.call(message, \"outputType\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);\n                    if (message.options != null && Object.hasOwnProperty.call(message, \"options\"))\n                        $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();\n                    if (message.clientStreaming != null && Object.hasOwnProperty.call(message, \"clientStreaming\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);\n                    if (message.serverStreaming != null && Object.hasOwnProperty.call(message, \"serverStreaming\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MethodDescriptorProto message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MethodDescriptorProto\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MethodDescriptorProto.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.inputType = reader.string();\n                            break;\n                        case 3:\n                            message.outputType = reader.string();\n                            break;\n                        case 4:\n                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.clientStreaming = reader.bool();\n                            break;\n                        case 6:\n                            message.serverStreaming = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MethodDescriptorProto;\n            })();\n    \n            protobuf.FileOptions = (function() {\n    \n                /**\n                 * Properties of a FileOptions.\n                 * @memberof google.protobuf\n                 * @interface IFileOptions\n                 * @property {string|null} [javaPackage] FileOptions javaPackage\n                 * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname\n                 * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles\n                 * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash\n                 * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8\n                 * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor\n                 * @property {string|null} [goPackage] FileOptions goPackage\n                 * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices\n                 * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices\n                 * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices\n                 * @property {boolean|null} [deprecated] FileOptions deprecated\n                 * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas\n                 * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix\n                 * @property {string|null} [csharpNamespace] FileOptions csharpNamespace\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopbFileopt\"] FileOptions .nanopbFileopt\n                 */\n    \n                /**\n                 * Constructs a new FileOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FileOptions.\n                 * @implements IFileOptions\n                 * @constructor\n                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n                 */\n                function FileOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FileOptions javaPackage.\n                 * @member {string} javaPackage\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaPackage = \"\";\n    \n                /**\n                 * FileOptions javaOuterClassname.\n                 * @member {string} javaOuterClassname\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaOuterClassname = \"\";\n    \n                /**\n                 * FileOptions javaMultipleFiles.\n                 * @member {boolean} javaMultipleFiles\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaMultipleFiles = false;\n    \n                /**\n                 * FileOptions javaGenerateEqualsAndHash.\n                 * @member {boolean} javaGenerateEqualsAndHash\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaGenerateEqualsAndHash = false;\n    \n                /**\n                 * FileOptions javaStringCheckUtf8.\n                 * @member {boolean} javaStringCheckUtf8\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaStringCheckUtf8 = false;\n    \n                /**\n                 * FileOptions optimizeFor.\n                 * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.optimizeFor = 1;\n    \n                /**\n                 * FileOptions goPackage.\n                 * @member {string} goPackage\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.goPackage = \"\";\n    \n                /**\n                 * FileOptions ccGenericServices.\n                 * @member {boolean} ccGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.ccGenericServices = false;\n    \n                /**\n                 * FileOptions javaGenericServices.\n                 * @member {boolean} javaGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.javaGenericServices = false;\n    \n                /**\n                 * FileOptions pyGenericServices.\n                 * @member {boolean} pyGenericServices\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.pyGenericServices = false;\n    \n                /**\n                 * FileOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.deprecated = false;\n    \n                /**\n                 * FileOptions ccEnableArenas.\n                 * @member {boolean} ccEnableArenas\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.ccEnableArenas = false;\n    \n                /**\n                 * FileOptions objcClassPrefix.\n                 * @member {string} objcClassPrefix\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.objcClassPrefix = \"\";\n    \n                /**\n                 * FileOptions csharpNamespace.\n                 * @member {string} csharpNamespace\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.csharpNamespace = \"\";\n    \n                /**\n                 * FileOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * FileOptions .nanopbFileopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbFileopt\n                 * @memberof google.protobuf.FileOptions\n                 * @instance\n                 */\n                FileOptions.prototype[\".nanopbFileopt\"] = null;\n    \n                /**\n                 * Creates a new FileOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.FileOptions} FileOptions instance\n                 */\n                FileOptions.create = function create(properties) {\n                    return new FileOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FileOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.javaPackage != null && Object.hasOwnProperty.call(message, \"javaPackage\"))\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);\n                    if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, \"javaOuterClassname\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);\n                    if (message.optimizeFor != null && Object.hasOwnProperty.call(message, \"optimizeFor\"))\n                        writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);\n                    if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, \"javaMultipleFiles\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);\n                    if (message.goPackage != null && Object.hasOwnProperty.call(message, \"goPackage\"))\n                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);\n                    if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, \"ccGenericServices\"))\n                        writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);\n                    if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, \"javaGenericServices\"))\n                        writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);\n                    if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, \"pyGenericServices\"))\n                        writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);\n                    if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, \"javaGenerateEqualsAndHash\"))\n                        writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);\n                    if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, \"javaStringCheckUtf8\"))\n                        writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);\n                    if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, \"ccEnableArenas\"))\n                        writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);\n                    if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, \"objcClassPrefix\"))\n                        writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);\n                    if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, \"csharpNamespace\"))\n                        writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbFileopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbFileopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbFileopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FileOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FileOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FileOptions} FileOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FileOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.javaPackage = reader.string();\n                            break;\n                        case 8:\n                            message.javaOuterClassname = reader.string();\n                            break;\n                        case 10:\n                            message.javaMultipleFiles = reader.bool();\n                            break;\n                        case 20:\n                            message.javaGenerateEqualsAndHash = reader.bool();\n                            break;\n                        case 27:\n                            message.javaStringCheckUtf8 = reader.bool();\n                            break;\n                        case 9:\n                            message.optimizeFor = reader.int32();\n                            break;\n                        case 11:\n                            message.goPackage = reader.string();\n                            break;\n                        case 16:\n                            message.ccGenericServices = reader.bool();\n                            break;\n                        case 17:\n                            message.javaGenericServices = reader.bool();\n                            break;\n                        case 18:\n                            message.pyGenericServices = reader.bool();\n                            break;\n                        case 23:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 31:\n                            message.ccEnableArenas = reader.bool();\n                            break;\n                        case 36:\n                            message.objcClassPrefix = reader.string();\n                            break;\n                        case 37:\n                            message.csharpNamespace = reader.string();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopbFileopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * OptimizeMode enum.\n                 * @name google.protobuf.FileOptions.OptimizeMode\n                 * @enum {number}\n                 * @property {number} SPEED=1 SPEED value\n                 * @property {number} CODE_SIZE=2 CODE_SIZE value\n                 * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value\n                 */\n                FileOptions.OptimizeMode = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[1] = \"SPEED\"] = 1;\n                    values[valuesById[2] = \"CODE_SIZE\"] = 2;\n                    values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n                    return values;\n                })();\n    \n                return FileOptions;\n            })();\n    \n            protobuf.MessageOptions = (function() {\n    \n                /**\n                 * Properties of a MessageOptions.\n                 * @memberof google.protobuf\n                 * @interface IMessageOptions\n                 * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat\n                 * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor\n                 * @property {boolean|null} [deprecated] MessageOptions deprecated\n                 * @property {boolean|null} [mapEntry] MessageOptions mapEntry\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption\n                 * @property {number|null} [\".typeId\"] MessageOptions .typeId\n                 * @property {INanoPBOptions|null} [\".nanopbMsgopt\"] MessageOptions .nanopbMsgopt\n                 */\n    \n                /**\n                 * Constructs a new MessageOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MessageOptions.\n                 * @implements IMessageOptions\n                 * @constructor\n                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n                 */\n                function MessageOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MessageOptions messageSetWireFormat.\n                 * @member {boolean} messageSetWireFormat\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.messageSetWireFormat = false;\n    \n                /**\n                 * MessageOptions noStandardDescriptorAccessor.\n                 * @member {boolean} noStandardDescriptorAccessor\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.noStandardDescriptorAccessor = false;\n    \n                /**\n                 * MessageOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.deprecated = false;\n    \n                /**\n                 * MessageOptions mapEntry.\n                 * @member {boolean} mapEntry\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.mapEntry = false;\n    \n                /**\n                 * MessageOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * MessageOptions .typeId.\n                 * @member {number} .typeId\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype[\".typeId\"] = 0;\n    \n                /**\n                 * MessageOptions .nanopbMsgopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbMsgopt\n                 * @memberof google.protobuf.MessageOptions\n                 * @instance\n                 */\n                MessageOptions.prototype[\".nanopbMsgopt\"] = null;\n    \n                /**\n                 * Creates a new MessageOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.MessageOptions} MessageOptions instance\n                 */\n                MessageOptions.create = function create(properties) {\n                    return new MessageOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MessageOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, \"messageSetWireFormat\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);\n                    if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, \"noStandardDescriptorAccessor\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.mapEntry != null && Object.hasOwnProperty.call(message, \"mapEntry\"))\n                        writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbMsgopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbMsgopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbMsgopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    if (message[\".typeId\"] != null && Object.hasOwnProperty.call(message, \".typeId\"))\n                        writer.uint32(/* id 50001, wireType 0 =*/400008).int32(message[\".typeId\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MessageOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MessageOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MessageOptions} MessageOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MessageOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.messageSetWireFormat = reader.bool();\n                            break;\n                        case 2:\n                            message.noStandardDescriptorAccessor = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 7:\n                            message.mapEntry = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 50001:\n                            message[\".typeId\"] = reader.int32();\n                            break;\n                        case 1010:\n                            message[\".nanopbMsgopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MessageOptions;\n            })();\n    \n            protobuf.FieldOptions = (function() {\n    \n                /**\n                 * Properties of a FieldOptions.\n                 * @memberof google.protobuf\n                 * @interface IFieldOptions\n                 * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n                 * @property {boolean|null} [packed] FieldOptions packed\n                 * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n                 * @property {boolean|null} [lazy] FieldOptions lazy\n                 * @property {boolean|null} [deprecated] FieldOptions deprecated\n                 * @property {boolean|null} [weak] FieldOptions weak\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopb\"] FieldOptions .nanopb\n                 */\n    \n                /**\n                 * Constructs a new FieldOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a FieldOptions.\n                 * @implements IFieldOptions\n                 * @constructor\n                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n                 */\n                function FieldOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * FieldOptions ctype.\n                 * @member {google.protobuf.FieldOptions.CType} ctype\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.ctype = 0;\n    \n                /**\n                 * FieldOptions packed.\n                 * @member {boolean} packed\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.packed = false;\n    \n                /**\n                 * FieldOptions jstype.\n                 * @member {google.protobuf.FieldOptions.JSType} jstype\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.jstype = 0;\n    \n                /**\n                 * FieldOptions lazy.\n                 * @member {boolean} lazy\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.lazy = false;\n    \n                /**\n                 * FieldOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.deprecated = false;\n    \n                /**\n                 * FieldOptions weak.\n                 * @member {boolean} weak\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.weak = false;\n    \n                /**\n                 * FieldOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * FieldOptions .nanopb.\n                 * @member {INanoPBOptions|null|undefined} .nanopb\n                 * @memberof google.protobuf.FieldOptions\n                 * @instance\n                 */\n                FieldOptions.prototype[\".nanopb\"] = null;\n    \n                /**\n                 * Creates a new FieldOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.FieldOptions} FieldOptions instance\n                 */\n                FieldOptions.create = function create(properties) {\n                    return new FieldOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                FieldOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.ctype != null && Object.hasOwnProperty.call(message, \"ctype\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);\n                    if (message.packed != null && Object.hasOwnProperty.call(message, \"packed\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.lazy != null && Object.hasOwnProperty.call(message, \"lazy\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);\n                    if (message.jstype != null && Object.hasOwnProperty.call(message, \"jstype\"))\n                        writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);\n                    if (message.weak != null && Object.hasOwnProperty.call(message, \"weak\"))\n                        writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopb\"] != null && Object.hasOwnProperty.call(message, \".nanopb\"))\n                        $root.NanoPBOptions.encode(message[\".nanopb\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a FieldOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.FieldOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.FieldOptions} FieldOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                FieldOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.ctype = reader.int32();\n                            break;\n                        case 2:\n                            message.packed = reader.bool();\n                            break;\n                        case 6:\n                            message.jstype = reader.int32();\n                            break;\n                        case 5:\n                            message.lazy = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 10:\n                            message.weak = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopb\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                /**\n                 * CType enum.\n                 * @name google.protobuf.FieldOptions.CType\n                 * @enum {number}\n                 * @property {number} STRING=0 STRING value\n                 * @property {number} CORD=1 CORD value\n                 * @property {number} STRING_PIECE=2 STRING_PIECE value\n                 */\n                FieldOptions.CType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"STRING\"] = 0;\n                    values[valuesById[1] = \"CORD\"] = 1;\n                    values[valuesById[2] = \"STRING_PIECE\"] = 2;\n                    return values;\n                })();\n    \n                /**\n                 * JSType enum.\n                 * @name google.protobuf.FieldOptions.JSType\n                 * @enum {number}\n                 * @property {number} JS_NORMAL=0 JS_NORMAL value\n                 * @property {number} JS_STRING=1 JS_STRING value\n                 * @property {number} JS_NUMBER=2 JS_NUMBER value\n                 */\n                FieldOptions.JSType = (function() {\n                    var valuesById = {}, values = Object.create(valuesById);\n                    values[valuesById[0] = \"JS_NORMAL\"] = 0;\n                    values[valuesById[1] = \"JS_STRING\"] = 1;\n                    values[valuesById[2] = \"JS_NUMBER\"] = 2;\n                    return values;\n                })();\n    \n                return FieldOptions;\n            })();\n    \n            protobuf.OneofOptions = (function() {\n    \n                /**\n                 * Properties of an OneofOptions.\n                 * @memberof google.protobuf\n                 * @interface IOneofOptions\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new OneofOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an OneofOptions.\n                 * @implements IOneofOptions\n                 * @constructor\n                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n                 */\n                function OneofOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * OneofOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.OneofOptions\n                 * @instance\n                 */\n                OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new OneofOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.OneofOptions} OneofOptions instance\n                 */\n                OneofOptions.create = function create(properties) {\n                    return new OneofOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                OneofOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an OneofOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.OneofOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.OneofOptions} OneofOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                OneofOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return OneofOptions;\n            })();\n    \n            protobuf.EnumOptions = (function() {\n    \n                /**\n                 * Properties of an EnumOptions.\n                 * @memberof google.protobuf\n                 * @interface IEnumOptions\n                 * @property {boolean|null} [allowAlias] EnumOptions allowAlias\n                 * @property {boolean|null} [deprecated] EnumOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption\n                 * @property {INanoPBOptions|null} [\".nanopbEnumopt\"] EnumOptions .nanopbEnumopt\n                 */\n    \n                /**\n                 * Constructs a new EnumOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumOptions.\n                 * @implements IEnumOptions\n                 * @constructor\n                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n                 */\n                function EnumOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumOptions allowAlias.\n                 * @member {boolean} allowAlias\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.allowAlias = false;\n    \n                /**\n                 * EnumOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.deprecated = false;\n    \n                /**\n                 * EnumOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * EnumOptions .nanopbEnumopt.\n                 * @member {INanoPBOptions|null|undefined} .nanopbEnumopt\n                 * @memberof google.protobuf.EnumOptions\n                 * @instance\n                 */\n                EnumOptions.prototype[\".nanopbEnumopt\"] = null;\n    \n                /**\n                 * Creates a new EnumOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumOptions} EnumOptions instance\n                 */\n                EnumOptions.create = function create(properties) {\n                    return new EnumOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.allowAlias != null && Object.hasOwnProperty.call(message, \"allowAlias\"))\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".nanopbEnumopt\"] != null && Object.hasOwnProperty.call(message, \".nanopbEnumopt\"))\n                        $root.NanoPBOptions.encode(message[\".nanopbEnumopt\"], writer.uint32(/* id 1010, wireType 2 =*/8082).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumOptions} EnumOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 2:\n                            message.allowAlias = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 1010:\n                            message[\".nanopbEnumopt\"] = $root.NanoPBOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumOptions;\n            })();\n    \n            protobuf.EnumValueOptions = (function() {\n    \n                /**\n                 * Properties of an EnumValueOptions.\n                 * @memberof google.protobuf\n                 * @interface IEnumValueOptions\n                 * @property {boolean|null} [deprecated] EnumValueOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption\n                 * @property {number|null} [\".intValue\"] EnumValueOptions .intValue\n                 */\n    \n                /**\n                 * Constructs a new EnumValueOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an EnumValueOptions.\n                 * @implements IEnumValueOptions\n                 * @constructor\n                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n                 */\n                function EnumValueOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * EnumValueOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype.deprecated = false;\n    \n                /**\n                 * EnumValueOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * EnumValueOptions .intValue.\n                 * @member {number} .intValue\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @instance\n                 */\n                EnumValueOptions.prototype[\".intValue\"] = 0;\n    \n                /**\n                 * Creates a new EnumValueOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance\n                 */\n                EnumValueOptions.create = function create(properties) {\n                    return new EnumValueOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                EnumValueOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    if (message[\".intValue\"] != null && Object.hasOwnProperty.call(message, \".intValue\"))\n                        writer.uint32(/* id 50002, wireType 0 =*/400016).int32(message[\".intValue\"]);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an EnumValueOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.EnumValueOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                EnumValueOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 50002:\n                            message[\".intValue\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return EnumValueOptions;\n            })();\n    \n            protobuf.ServiceOptions = (function() {\n    \n                /**\n                 * Properties of a ServiceOptions.\n                 * @memberof google.protobuf\n                 * @interface IServiceOptions\n                 * @property {boolean|null} [deprecated] ServiceOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new ServiceOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a ServiceOptions.\n                 * @implements IServiceOptions\n                 * @constructor\n                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n                 */\n                function ServiceOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * ServiceOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.ServiceOptions\n                 * @instance\n                 */\n                ServiceOptions.prototype.deprecated = false;\n    \n                /**\n                 * ServiceOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.ServiceOptions\n                 * @instance\n                 */\n                ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new ServiceOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.ServiceOptions} ServiceOptions instance\n                 */\n                ServiceOptions.create = function create(properties) {\n                    return new ServiceOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                ServiceOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a ServiceOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.ServiceOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.ServiceOptions} ServiceOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ServiceOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return ServiceOptions;\n            })();\n    \n            protobuf.MethodOptions = (function() {\n    \n                /**\n                 * Properties of a MethodOptions.\n                 * @memberof google.protobuf\n                 * @interface IMethodOptions\n                 * @property {boolean|null} [deprecated] MethodOptions deprecated\n                 * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption\n                 */\n    \n                /**\n                 * Constructs a new MethodOptions.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a MethodOptions.\n                 * @implements IMethodOptions\n                 * @constructor\n                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n                 */\n                function MethodOptions(properties) {\n                    this.uninterpretedOption = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * MethodOptions deprecated.\n                 * @member {boolean} deprecated\n                 * @memberof google.protobuf.MethodOptions\n                 * @instance\n                 */\n                MethodOptions.prototype.deprecated = false;\n    \n                /**\n                 * MethodOptions uninterpretedOption.\n                 * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n                 * @memberof google.protobuf.MethodOptions\n                 * @instance\n                 */\n                MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n    \n                /**\n                 * Creates a new MethodOptions instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n                 * @returns {google.protobuf.MethodOptions} MethodOptions instance\n                 */\n                MethodOptions.create = function create(properties) {\n                    return new MethodOptions(properties);\n                };\n    \n                /**\n                 * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                MethodOptions.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.deprecated != null && Object.hasOwnProperty.call(message, \"deprecated\"))\n                        writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);\n                    if (message.uninterpretedOption != null && message.uninterpretedOption.length)\n                        for (var i = 0; i < message.uninterpretedOption.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a MethodOptions message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.MethodOptions\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.MethodOptions} MethodOptions\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                MethodOptions.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption && message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                return MethodOptions;\n            })();\n    \n            protobuf.UninterpretedOption = (function() {\n    \n                /**\n                 * Properties of an UninterpretedOption.\n                 * @memberof google.protobuf\n                 * @interface IUninterpretedOption\n                 * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name\n                 * @property {string|null} [identifierValue] UninterpretedOption identifierValue\n                 * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue\n                 * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue\n                 * @property {number|null} [doubleValue] UninterpretedOption doubleValue\n                 * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue\n                 * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue\n                 */\n    \n                /**\n                 * Constructs a new UninterpretedOption.\n                 * @memberof google.protobuf\n                 * @classdesc Represents an UninterpretedOption.\n                 * @implements IUninterpretedOption\n                 * @constructor\n                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n                 */\n                function UninterpretedOption(properties) {\n                    this.name = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * UninterpretedOption name.\n                 * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.name = $util.emptyArray;\n    \n                /**\n                 * UninterpretedOption identifierValue.\n                 * @member {string} identifierValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.identifierValue = \"\";\n    \n                /**\n                 * UninterpretedOption positiveIntValue.\n                 * @member {number|Long} positiveIntValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n    \n                /**\n                 * UninterpretedOption negativeIntValue.\n                 * @member {number|Long} negativeIntValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n    \n                /**\n                 * UninterpretedOption doubleValue.\n                 * @member {number} doubleValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.doubleValue = 0;\n    \n                /**\n                 * UninterpretedOption stringValue.\n                 * @member {Uint8Array} stringValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n    \n                /**\n                 * UninterpretedOption aggregateValue.\n                 * @member {string} aggregateValue\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @instance\n                 */\n                UninterpretedOption.prototype.aggregateValue = \"\";\n    \n                /**\n                 * Creates a new UninterpretedOption instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance\n                 */\n                UninterpretedOption.create = function create(properties) {\n                    return new UninterpretedOption(properties);\n                };\n    \n                /**\n                 * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                UninterpretedOption.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.name != null && message.name.length)\n                        for (var i = 0; i < message.name.length; ++i)\n                            $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();\n                    if (message.identifierValue != null && Object.hasOwnProperty.call(message, \"identifierValue\"))\n                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);\n                    if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, \"positiveIntValue\"))\n                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);\n                    if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, \"negativeIntValue\"))\n                        writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);\n                    if (message.doubleValue != null && Object.hasOwnProperty.call(message, \"doubleValue\"))\n                        writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);\n                    if (message.stringValue != null && Object.hasOwnProperty.call(message, \"stringValue\"))\n                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);\n                    if (message.aggregateValue != null && Object.hasOwnProperty.call(message, \"aggregateValue\"))\n                        writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);\n                    return writer;\n                };\n    \n                /**\n                 * Decodes an UninterpretedOption message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                UninterpretedOption.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 2:\n                            if (!(message.name && message.name.length))\n                                message.name = [];\n                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.identifierValue = reader.string();\n                            break;\n                        case 4:\n                            message.positiveIntValue = reader.uint64();\n                            break;\n                        case 5:\n                            message.negativeIntValue = reader.int64();\n                            break;\n                        case 6:\n                            message.doubleValue = reader.double();\n                            break;\n                        case 7:\n                            message.stringValue = reader.bytes();\n                            break;\n                        case 8:\n                            message.aggregateValue = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                UninterpretedOption.NamePart = (function() {\n    \n                    /**\n                     * Properties of a NamePart.\n                     * @memberof google.protobuf.UninterpretedOption\n                     * @interface INamePart\n                     * @property {string} namePart NamePart namePart\n                     * @property {boolean} isExtension NamePart isExtension\n                     */\n    \n                    /**\n                     * Constructs a new NamePart.\n                     * @memberof google.protobuf.UninterpretedOption\n                     * @classdesc Represents a NamePart.\n                     * @implements INamePart\n                     * @constructor\n                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n                     */\n                    function NamePart(properties) {\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * NamePart namePart.\n                     * @member {string} namePart\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @instance\n                     */\n                    NamePart.prototype.namePart = \"\";\n    \n                    /**\n                     * NamePart isExtension.\n                     * @member {boolean} isExtension\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @instance\n                     */\n                    NamePart.prototype.isExtension = false;\n    \n                    /**\n                     * Creates a new NamePart instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance\n                     */\n                    NamePart.create = function create(properties) {\n                        return new NamePart(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    NamePart.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);\n                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a NamePart message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.UninterpretedOption.NamePart\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    NamePart.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                message.namePart = reader.string();\n                                break;\n                            case 2:\n                                message.isExtension = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        if (!message.hasOwnProperty(\"namePart\"))\n                            throw $util.ProtocolError(\"missing required 'namePart'\", { instance: message });\n                        if (!message.hasOwnProperty(\"isExtension\"))\n                            throw $util.ProtocolError(\"missing required 'isExtension'\", { instance: message });\n                        return message;\n                    };\n    \n                    return NamePart;\n                })();\n    \n                return UninterpretedOption;\n            })();\n    \n            protobuf.SourceCodeInfo = (function() {\n    \n                /**\n                 * Properties of a SourceCodeInfo.\n                 * @memberof google.protobuf\n                 * @interface ISourceCodeInfo\n                 * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location\n                 */\n    \n                /**\n                 * Constructs a new SourceCodeInfo.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a SourceCodeInfo.\n                 * @implements ISourceCodeInfo\n                 * @constructor\n                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n                 */\n                function SourceCodeInfo(properties) {\n                    this.location = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * SourceCodeInfo location.\n                 * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @instance\n                 */\n                SourceCodeInfo.prototype.location = $util.emptyArray;\n    \n                /**\n                 * Creates a new SourceCodeInfo instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance\n                 */\n                SourceCodeInfo.create = function create(properties) {\n                    return new SourceCodeInfo(properties);\n                };\n    \n                /**\n                 * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                SourceCodeInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.location != null && message.location.length)\n                        for (var i = 0; i < message.location.length; ++i)\n                            $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a SourceCodeInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                SourceCodeInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.location && message.location.length))\n                                message.location = [];\n                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                SourceCodeInfo.Location = (function() {\n    \n                    /**\n                     * Properties of a Location.\n                     * @memberof google.protobuf.SourceCodeInfo\n                     * @interface ILocation\n                     * @property {Array.<number>|null} [path] Location path\n                     * @property {Array.<number>|null} [span] Location span\n                     * @property {string|null} [leadingComments] Location leadingComments\n                     * @property {string|null} [trailingComments] Location trailingComments\n                     * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments\n                     */\n    \n                    /**\n                     * Constructs a new Location.\n                     * @memberof google.protobuf.SourceCodeInfo\n                     * @classdesc Represents a Location.\n                     * @implements ILocation\n                     * @constructor\n                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n                     */\n                    function Location(properties) {\n                        this.path = [];\n                        this.span = [];\n                        this.leadingDetachedComments = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Location path.\n                     * @member {Array.<number>} path\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.path = $util.emptyArray;\n    \n                    /**\n                     * Location span.\n                     * @member {Array.<number>} span\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.span = $util.emptyArray;\n    \n                    /**\n                     * Location leadingComments.\n                     * @member {string} leadingComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.leadingComments = \"\";\n    \n                    /**\n                     * Location trailingComments.\n                     * @member {string} trailingComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.trailingComments = \"\";\n    \n                    /**\n                     * Location leadingDetachedComments.\n                     * @member {Array.<string>} leadingDetachedComments\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @instance\n                     */\n                    Location.prototype.leadingDetachedComments = $util.emptyArray;\n    \n                    /**\n                     * Creates a new Location instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n                     * @returns {google.protobuf.SourceCodeInfo.Location} Location instance\n                     */\n                    Location.create = function create(properties) {\n                        return new Location(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Location.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.path != null && message.path.length) {\n                            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                            for (var i = 0; i < message.path.length; ++i)\n                                writer.int32(message.path[i]);\n                            writer.ldelim();\n                        }\n                        if (message.span != null && message.span.length) {\n                            writer.uint32(/* id 2, wireType 2 =*/18).fork();\n                            for (var i = 0; i < message.span.length; ++i)\n                                writer.int32(message.span[i]);\n                            writer.ldelim();\n                        }\n                        if (message.leadingComments != null && Object.hasOwnProperty.call(message, \"leadingComments\"))\n                            writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);\n                        if (message.trailingComments != null && Object.hasOwnProperty.call(message, \"trailingComments\"))\n                            writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);\n                        if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)\n                            for (var i = 0; i < message.leadingDetachedComments.length; ++i)\n                                writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes a Location message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.SourceCodeInfo.Location\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.SourceCodeInfo.Location} Location\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Location.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                } else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                if (!(message.span && message.span.length))\n                                    message.span = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.span.push(reader.int32());\n                                } else\n                                    message.span.push(reader.int32());\n                                break;\n                            case 3:\n                                message.leadingComments = reader.string();\n                                break;\n                            case 4:\n                                message.trailingComments = reader.string();\n                                break;\n                            case 6:\n                                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))\n                                    message.leadingDetachedComments = [];\n                                message.leadingDetachedComments.push(reader.string());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Location;\n                })();\n    \n                return SourceCodeInfo;\n            })();\n    \n            protobuf.GeneratedCodeInfo = (function() {\n    \n                /**\n                 * Properties of a GeneratedCodeInfo.\n                 * @memberof google.protobuf\n                 * @interface IGeneratedCodeInfo\n                 * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation\n                 */\n    \n                /**\n                 * Constructs a new GeneratedCodeInfo.\n                 * @memberof google.protobuf\n                 * @classdesc Represents a GeneratedCodeInfo.\n                 * @implements IGeneratedCodeInfo\n                 * @constructor\n                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n                 */\n                function GeneratedCodeInfo(properties) {\n                    this.annotation = [];\n                    if (properties)\n                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n    \n                /**\n                 * GeneratedCodeInfo annotation.\n                 * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @instance\n                 */\n                GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n    \n                /**\n                 * Creates a new GeneratedCodeInfo instance using the specified properties.\n                 * @function create\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance\n                 */\n                GeneratedCodeInfo.create = function create(properties) {\n                    return new GeneratedCodeInfo(properties);\n                };\n    \n                /**\n                 * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.\n                 * @function encode\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode\n                 * @param {$protobuf.Writer} [writer] Writer to encode to\n                 * @returns {$protobuf.Writer} Writer\n                 */\n                GeneratedCodeInfo.encode = function encode(message, writer) {\n                    if (!writer)\n                        writer = $Writer.create();\n                    if (message.annotation != null && message.annotation.length)\n                        for (var i = 0; i < message.annotation.length; ++i)\n                            $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();\n                    return writer;\n                };\n    \n                /**\n                 * Decodes a GeneratedCodeInfo message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                GeneratedCodeInfo.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();\n                    while (reader.pos < end) {\n                        var tag = reader.uint32();\n                        switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.annotation && message.annotation.length))\n                                message.annotation = [];\n                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                        }\n                    }\n                    return message;\n                };\n    \n                GeneratedCodeInfo.Annotation = (function() {\n    \n                    /**\n                     * Properties of an Annotation.\n                     * @memberof google.protobuf.GeneratedCodeInfo\n                     * @interface IAnnotation\n                     * @property {Array.<number>|null} [path] Annotation path\n                     * @property {string|null} [sourceFile] Annotation sourceFile\n                     * @property {number|null} [begin] Annotation begin\n                     * @property {number|null} [end] Annotation end\n                     */\n    \n                    /**\n                     * Constructs a new Annotation.\n                     * @memberof google.protobuf.GeneratedCodeInfo\n                     * @classdesc Represents an Annotation.\n                     * @implements IAnnotation\n                     * @constructor\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n                     */\n                    function Annotation(properties) {\n                        this.path = [];\n                        if (properties)\n                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                                if (properties[keys[i]] != null)\n                                    this[keys[i]] = properties[keys[i]];\n                    }\n    \n                    /**\n                     * Annotation path.\n                     * @member {Array.<number>} path\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.path = $util.emptyArray;\n    \n                    /**\n                     * Annotation sourceFile.\n                     * @member {string} sourceFile\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.sourceFile = \"\";\n    \n                    /**\n                     * Annotation begin.\n                     * @member {number} begin\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.begin = 0;\n    \n                    /**\n                     * Annotation end.\n                     * @member {number} end\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @instance\n                     */\n                    Annotation.prototype.end = 0;\n    \n                    /**\n                     * Creates a new Annotation instance using the specified properties.\n                     * @function create\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance\n                     */\n                    Annotation.create = function create(properties) {\n                        return new Annotation(properties);\n                    };\n    \n                    /**\n                     * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.\n                     * @function encode\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode\n                     * @param {$protobuf.Writer} [writer] Writer to encode to\n                     * @returns {$protobuf.Writer} Writer\n                     */\n                    Annotation.encode = function encode(message, writer) {\n                        if (!writer)\n                            writer = $Writer.create();\n                        if (message.path != null && message.path.length) {\n                            writer.uint32(/* id 1, wireType 2 =*/10).fork();\n                            for (var i = 0; i < message.path.length; ++i)\n                                writer.int32(message.path[i]);\n                            writer.ldelim();\n                        }\n                        if (message.sourceFile != null && Object.hasOwnProperty.call(message, \"sourceFile\"))\n                            writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);\n                        if (message.begin != null && Object.hasOwnProperty.call(message, \"begin\"))\n                            writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);\n                        if (message.end != null && Object.hasOwnProperty.call(message, \"end\"))\n                            writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);\n                        return writer;\n                    };\n    \n                    /**\n                     * Decodes an Annotation message from the specified reader or buffer.\n                     * @function decode\n                     * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                     * @static\n                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                     * @param {number} [length] Message length if known beforehand\n                     * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n                     * @throws {Error} If the payload is not a reader or valid buffer\n                     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                     */\n                    Annotation.decode = function decode(reader, length) {\n                        if (!(reader instanceof $Reader))\n                            reader = $Reader.create(reader);\n                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n                        while (reader.pos < end) {\n                            var tag = reader.uint32();\n                            switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    var end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                } else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                message.sourceFile = reader.string();\n                                break;\n                            case 3:\n                                message.begin = reader.int32();\n                                break;\n                            case 4:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                            }\n                        }\n                        return message;\n                    };\n    \n                    return Annotation;\n                })();\n    \n                return GeneratedCodeInfo;\n            })();\n    \n            return protobuf;\n        })();\n    \n        return google;\n    })();\n    \n    $root.NanoPBOptions = (function() {\n    \n        /**\n         * Properties of a NanoPBOptions.\n         * @exports INanoPBOptions\n         * @interface INanoPBOptions\n         * @property {number|null} [maxSize] NanoPBOptions maxSize\n         * @property {number|null} [maxLength] NanoPBOptions maxLength\n         * @property {number|null} [maxCount] NanoPBOptions maxCount\n         * @property {IntSize|null} [intSize] NanoPBOptions intSize\n         * @property {FieldType|null} [type] NanoPBOptions type\n         * @property {boolean|null} [longNames] NanoPBOptions longNames\n         * @property {boolean|null} [packedStruct] NanoPBOptions packedStruct\n         * @property {boolean|null} [packedEnum] NanoPBOptions packedEnum\n         * @property {boolean|null} [skipMessage] NanoPBOptions skipMessage\n         * @property {boolean|null} [noUnions] NanoPBOptions noUnions\n         * @property {number|null} [msgid] NanoPBOptions msgid\n         * @property {boolean|null} [anonymousOneof] NanoPBOptions anonymousOneof\n         * @property {boolean|null} [proto3] NanoPBOptions proto3\n         * @property {boolean|null} [enumToString] NanoPBOptions enumToString\n         * @property {boolean|null} [fixedLength] NanoPBOptions fixedLength\n         * @property {boolean|null} [fixedCount] NanoPBOptions fixedCount\n         */\n    \n        /**\n         * Constructs a new NanoPBOptions.\n         * @exports NanoPBOptions\n         * @classdesc Represents a NanoPBOptions.\n         * @implements INanoPBOptions\n         * @constructor\n         * @param {INanoPBOptions=} [properties] Properties to set\n         */\n        function NanoPBOptions(properties) {\n            if (properties)\n                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n    \n        /**\n         * NanoPBOptions maxSize.\n         * @member {number} maxSize\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxSize = 0;\n    \n        /**\n         * NanoPBOptions maxLength.\n         * @member {number} maxLength\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxLength = 0;\n    \n        /**\n         * NanoPBOptions maxCount.\n         * @member {number} maxCount\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.maxCount = 0;\n    \n        /**\n         * NanoPBOptions intSize.\n         * @member {IntSize} intSize\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.intSize = 0;\n    \n        /**\n         * NanoPBOptions type.\n         * @member {FieldType} type\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.type = 0;\n    \n        /**\n         * NanoPBOptions longNames.\n         * @member {boolean} longNames\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.longNames = true;\n    \n        /**\n         * NanoPBOptions packedStruct.\n         * @member {boolean} packedStruct\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.packedStruct = false;\n    \n        /**\n         * NanoPBOptions packedEnum.\n         * @member {boolean} packedEnum\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.packedEnum = false;\n    \n        /**\n         * NanoPBOptions skipMessage.\n         * @member {boolean} skipMessage\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.skipMessage = false;\n    \n        /**\n         * NanoPBOptions noUnions.\n         * @member {boolean} noUnions\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.noUnions = false;\n    \n        /**\n         * NanoPBOptions msgid.\n         * @member {number} msgid\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.msgid = 0;\n    \n        /**\n         * NanoPBOptions anonymousOneof.\n         * @member {boolean} anonymousOneof\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.anonymousOneof = false;\n    \n        /**\n         * NanoPBOptions proto3.\n         * @member {boolean} proto3\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.proto3 = false;\n    \n        /**\n         * NanoPBOptions enumToString.\n         * @member {boolean} enumToString\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.enumToString = false;\n    \n        /**\n         * NanoPBOptions fixedLength.\n         * @member {boolean} fixedLength\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.fixedLength = false;\n    \n        /**\n         * NanoPBOptions fixedCount.\n         * @member {boolean} fixedCount\n         * @memberof NanoPBOptions\n         * @instance\n         */\n        NanoPBOptions.prototype.fixedCount = false;\n    \n        /**\n         * Creates a new NanoPBOptions instance using the specified properties.\n         * @function create\n         * @memberof NanoPBOptions\n         * @static\n         * @param {INanoPBOptions=} [properties] Properties to set\n         * @returns {NanoPBOptions} NanoPBOptions instance\n         */\n        NanoPBOptions.create = function create(properties) {\n            return new NanoPBOptions(properties);\n        };\n    \n        /**\n         * Encodes the specified NanoPBOptions message. Does not implicitly {@link NanoPBOptions.verify|verify} messages.\n         * @function encode\n         * @memberof NanoPBOptions\n         * @static\n         * @param {INanoPBOptions} message NanoPBOptions message or plain object to encode\n         * @param {$protobuf.Writer} [writer] Writer to encode to\n         * @returns {$protobuf.Writer} Writer\n         */\n        NanoPBOptions.encode = function encode(message, writer) {\n            if (!writer)\n                writer = $Writer.create();\n            if (message.maxSize != null && Object.hasOwnProperty.call(message, \"maxSize\"))\n                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.maxSize);\n            if (message.maxCount != null && Object.hasOwnProperty.call(message, \"maxCount\"))\n                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.maxCount);\n            if (message.type != null && Object.hasOwnProperty.call(message, \"type\"))\n                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);\n            if (message.longNames != null && Object.hasOwnProperty.call(message, \"longNames\"))\n                writer.uint32(/* id 4, wireType 0 =*/32).bool(message.longNames);\n            if (message.packedStruct != null && Object.hasOwnProperty.call(message, \"packedStruct\"))\n                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.packedStruct);\n            if (message.skipMessage != null && Object.hasOwnProperty.call(message, \"skipMessage\"))\n                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.skipMessage);\n            if (message.intSize != null && Object.hasOwnProperty.call(message, \"intSize\"))\n                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.intSize);\n            if (message.noUnions != null && Object.hasOwnProperty.call(message, \"noUnions\"))\n                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.noUnions);\n            if (message.msgid != null && Object.hasOwnProperty.call(message, \"msgid\"))\n                writer.uint32(/* id 9, wireType 0 =*/72).uint32(message.msgid);\n            if (message.packedEnum != null && Object.hasOwnProperty.call(message, \"packedEnum\"))\n                writer.uint32(/* id 10, wireType 0 =*/80).bool(message.packedEnum);\n            if (message.anonymousOneof != null && Object.hasOwnProperty.call(message, \"anonymousOneof\"))\n                writer.uint32(/* id 11, wireType 0 =*/88).bool(message.anonymousOneof);\n            if (message.proto3 != null && Object.hasOwnProperty.call(message, \"proto3\"))\n                writer.uint32(/* id 12, wireType 0 =*/96).bool(message.proto3);\n            if (message.enumToString != null && Object.hasOwnProperty.call(message, \"enumToString\"))\n                writer.uint32(/* id 13, wireType 0 =*/104).bool(message.enumToString);\n            if (message.maxLength != null && Object.hasOwnProperty.call(message, \"maxLength\"))\n                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.maxLength);\n            if (message.fixedLength != null && Object.hasOwnProperty.call(message, \"fixedLength\"))\n                writer.uint32(/* id 15, wireType 0 =*/120).bool(message.fixedLength);\n            if (message.fixedCount != null && Object.hasOwnProperty.call(message, \"fixedCount\"))\n                writer.uint32(/* id 16, wireType 0 =*/128).bool(message.fixedCount);\n            return writer;\n        };\n    \n        /**\n         * Decodes a NanoPBOptions message from the specified reader or buffer.\n         * @function decode\n         * @memberof NanoPBOptions\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {NanoPBOptions} NanoPBOptions\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        NanoPBOptions.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.NanoPBOptions();\n            while (reader.pos < end) {\n                var tag = reader.uint32();\n                switch (tag >>> 3) {\n                case 1:\n                    message.maxSize = reader.int32();\n                    break;\n                case 14:\n                    message.maxLength = reader.int32();\n                    break;\n                case 2:\n                    message.maxCount = reader.int32();\n                    break;\n                case 7:\n                    message.intSize = reader.int32();\n                    break;\n                case 3:\n                    message.type = reader.int32();\n                    break;\n                case 4:\n                    message.longNames = reader.bool();\n                    break;\n                case 5:\n                    message.packedStruct = reader.bool();\n                    break;\n                case 10:\n                    message.packedEnum = reader.bool();\n                    break;\n                case 6:\n                    message.skipMessage = reader.bool();\n                    break;\n                case 8:\n                    message.noUnions = reader.bool();\n                    break;\n                case 9:\n                    message.msgid = reader.uint32();\n                    break;\n                case 11:\n                    message.anonymousOneof = reader.bool();\n                    break;\n                case 12:\n                    message.proto3 = reader.bool();\n                    break;\n                case 13:\n                    message.enumToString = reader.bool();\n                    break;\n                case 15:\n                    message.fixedLength = reader.bool();\n                    break;\n                case 16:\n                    message.fixedCount = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n                }\n            }\n            return message;\n        };\n    \n        return NanoPBOptions;\n    })();\n    \n    /**\n     * FieldType enum.\n     * @exports FieldType\n     * @enum {number}\n     * @property {number} FT_DEFAULT=0 FT_DEFAULT value\n     * @property {number} FT_CALLBACK=1 FT_CALLBACK value\n     * @property {number} FT_POINTER=4 FT_POINTER value\n     * @property {number} FT_STATIC=2 FT_STATIC value\n     * @property {number} FT_IGNORE=3 FT_IGNORE value\n     * @property {number} FT_INLINE=5 FT_INLINE value\n     */\n    $root.FieldType = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"FT_DEFAULT\"] = 0;\n        values[valuesById[1] = \"FT_CALLBACK\"] = 1;\n        values[valuesById[4] = \"FT_POINTER\"] = 4;\n        values[valuesById[2] = \"FT_STATIC\"] = 2;\n        values[valuesById[3] = \"FT_IGNORE\"] = 3;\n        values[valuesById[5] = \"FT_INLINE\"] = 5;\n        return values;\n    })();\n    \n    /**\n     * IntSize enum.\n     * @exports IntSize\n     * @enum {number}\n     * @property {number} IS_DEFAULT=0 IS_DEFAULT value\n     * @property {number} IS_8=8 IS_8 value\n     * @property {number} IS_16=16 IS_16 value\n     * @property {number} IS_32=32 IS_32 value\n     * @property {number} IS_64=64 IS_64 value\n     */\n    $root.IntSize = (function() {\n        var valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"IS_DEFAULT\"] = 0;\n        values[valuesById[8] = \"IS_8\"] = 8;\n        values[valuesById[16] = \"IS_16\"] = 16;\n        values[valuesById[32] = \"IS_32\"] = 32;\n        values[valuesById[64] = \"IS_64\"] = 64;\n        return values;\n    })();\n\n    return $root;\n});\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof __webpack_require__.g !== \"undefined\"\n                   && __webpack_require__.g\n                   && __webpack_require__.g.process\n                   && __webpack_require__.g.process.versions\n                   && __webpack_require__.g.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && __webpack_require__.g\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./src/cellular-device.js":
/*!********************************!*\
  !*** ./src/cellular-device.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\n/**\n * Cellular device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CellularDevice = base => class extends base {\n\t/**\n\t * Get ICCID of the active SIM card.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getIccid({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.CELLULAR_GET_ICCID, null /* msg */, { timeout });\n\t\treturn r.iccid;\n\t}\n\n\t/**\n\t * Set to `true` if this is a cellular device.\n\t */\n\tget isCellularDevice() {\n\t\treturn true;\n\t}\n};\n\nmodule.exports = {\n\tCellularDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cellular-device.js?");

/***/ }),

/***/ "./src/cloud-device.js":
/*!*****************************!*\
  !*** ./src/cloud-device.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst usbProto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nconst proto = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n/**\n * Cloud connection status.\n *\n * @enum {String}\n */\nconst CloudConnectionStatus = fromProtobufEnum(proto.cloud.ConnectionStatus, {\n\t/** Disconnected. */\n\tDISCONNECTED: 'DISCONNECTED',\n\t/** Connecting. */\n\tCONNECTING: 'CONNECTING',\n\t/** Connected. */\n\tCONNECTED: 'CONNECTED',\n\t/** Disconnecting. */\n\tDISCONNECTING: 'DISCONNECTING'\n});\n\n/**\n * Server protocol types.\n *\n * @enum {String}\n */\nconst ServerProtocol = fromProtobufEnum(proto.ServerProtocolType, {\n\t/** TCP. */\n\tTCP: 'TCP_PROTOCOL',\n\t/** UDP. */\n\tUDP: 'UDP_PROTOCOL'\n});\n\n/**\n * Cloud-enabled device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst CloudDevice = base => class extends base {\n\t/**\n\t * Connect to the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually connect to the cloud and\n\t *        return immediately.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync connectToCloud({ dontWait = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(Request.CLOUD_CONNECT);\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(Request.CLOUD_STATUS);\n\t\t\t\t\tif (r.status === proto.cloud.ConnectionStatus.CONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Disconnect from the cloud.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.dontWait] Do wait for the device to actually disconnect from the cloud\n\t *        and return immediately.\n\t * @param {Boolean} [options.force] Disconnect immediately, even if the device is busy performing\n\t *        some operation with the cloud.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync disconnectFromCloud({ dontWait = false, force = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (force) {\n\t\t\tconst setup = {\n\t\t\t\tbmRequestType: usbProto.BmRequestType.HOST_TO_DEVICE,\n\t\t\t\tbRequest: usbProto.PARTICLE_BREQUEST,\n\t\t\t\twIndex: Request.CLOUD_DISCONNECT.id,\n\t\t\t\twValue: 0\n\t\t\t};\n\t\t\tawait this.usbDevice.transferOut(setup);\n\t\t\tif (dontWait) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait this.timeout(timeout, async (s) => {\n\t\t\tif (!force) {\n\t\t\t\tawait s.sendRequest(Request.CLOUD_DISCONNECT);\n\t\t\t}\n\t\t\tif (!dontWait) {\n\t\t\t\tfor (;;) {\n\t\t\t\t\tconst r = await s.sendRequest(Request.CLOUD_STATUS);\n\t\t\t\t\tif (r.status === proto.cloud.ConnectionStatus.DISCONNECTED) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the cloud connection status.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<CloudConnectionStatus>}\n\t */\n\tasync getCloudConnectionStatus({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.CLOUD_STATUS, null /* msg */, { timeout });\n\t\treturn CloudConnectionStatus.fromProtobuf(r.status);\n\t}\n\n\t/**\n\t * Set the claim code.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {String} code Claim code.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tsetClaimCode(code, { timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.SET_CLAIM_CODE, { code }, { timeout });\n\t}\n\n\t/**\n\t * Check if the device is claimed.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<Boolean>}\n\t */\n\tisClaimed({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.IS_CLAIMED, null /* msg */, { timeout }).then(rep => rep.claimed);\n\t}\n\n\t/**\n\t * Set the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePrivateKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PRIVATE_KEY : proto.SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device private key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePrivateKey(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PRIVATE_KEY : proto.SecurityKeyType.TCP_DEVICE_PRIVATE_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PUBLIC_KEY : proto.SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the device public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetDevicePublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_DEVICE_PUBLIC_KEY : proto.SecurityKeyType.TCP_DEVICE_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Key data.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_SERVER_PUBLIC_KEY : proto.SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._setSecurityKey(keyType, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get the server public key.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetServerPublicKey(data, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\tconst keyType = (protocol === proto.ServerProtocolType.UDP_PROTOCOL ?\n\t\t\t\tproto.SecurityKeyType.UDP_SERVER_PUBLIC_KEY : proto.SecurityKeyType.TCP_SERVER_PUBLIC_KEY);\n\t\t\treturn this._getSecurityKey(keyType);\n\t\t});\n\t}\n\n\t/**\n\t * Set the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} data Host address.\n\t * @param {Number} port Port number.\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerAddress(address, port, protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(Request.SET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol,\n\t\t\t\taddress: address,\n\t\t\t\tport: port // TODO: Make port number optional\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get the server address.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} [protocol] Server protocol.\n\t * @return {Promise<Object>}\n\t */\n\tgetServerAddress(protocol) {\n\t\treturn this._getServerProtocol(protocol).then(protocol => {\n\t\t\treturn this.sendRequest(Request.GET_SERVER_ADDRESS, {\n\t\t\t\tprotocol: protocol\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Set the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} protocol Server protocol.\n\t * @return {Promise}\n\t */\n\tsetServerProtocol(protocol) {\n\t\treturn this.sendRequest(Request.SET_SERVER_PROTOCOL, {\n\t\t\tprotocol: ServerProtocol.toProtobuf(protocol)\n\t\t});\n\t}\n\n\t/**\n\t * Get the server protocol.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetServerProtocol() {\n\t\treturn this._getServerProtocol().then(protocol => ServerProtocol.fromProtobuf(protocol));\n\t}\n\n\t_setSecurityKey(type, data) {\n\t\treturn this.sendRequest(Request.SET_SECURITY_KEY, { type: type, data: data });\n\t}\n\n\t_getSecurityKey(type) {\n\t\treturn this.sendRequest(Request.GET_SECURITY_KEY, { type: type }).then(rep => rep.data);\n\t}\n\n\t_getServerProtocol(protocol) {\n\t\tif (protocol) {\n\t\t\treturn Promise.resolve(ServerProtocol.toProtobuf(protocol));\n\t\t}\n\t\treturn this.sendRequest(Request.GET_SERVER_PROTOCOL).then(rep => rep.protocol);\n\t}\n};\n\nmodule.exports = {\n\tCloudConnectionStatus,\n\tServerProtocol,\n\tCloudDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/cloud-device.js?");

/***/ }),

/***/ "./src/config.js":
/*!***********************!*\
  !*** ./src/config.js ***!
  \***********************/
/***/ ((module) => {

eval("// Global configuration\nconst globalOptions = {\n\t// Request timeout\n\trequestTimeout: 60000,\n\t// Logger instance\n\tlog: {\n\t\ttrace: () => {},\n\t\tinfo: () => {},\n\t\twarn: () => {},\n\t\terror: () => {}\n\t}\n};\n\n/**\n * Set global options.\n *\n * @param {Object} [options] Options.\n * @param {Number} [options.requestTimeout=60000] Default request timeout (milliseconds).\n * @param {Object} [options.log] Logger instance. The logger is expected to have the following methods:\n *                 `trace(String)`, `info(String)`, `warn(String)`, `error(String)`.\n * @return {Object} Current options.\n */\nfunction config(options) {\n\treturn Object.assign(globalOptions, options);\n}\n\nmodule.exports = {\n\tglobalOptions,\n\tconfig\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/config.js?");

/***/ }),

/***/ "./src/device-base.js":
/*!****************************!*\
  !*** ./src/device-base.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { getUsbDevices, UsbDevice, MAX_CONTROL_TRANSFER_DATA_SIZE } = __webpack_require__(/*! ./usb-device-node */ \"./src/usb-device-webusb.js\");\nconst proto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { PLATFORMS } = __webpack_require__(/*! ./platforms */ \"./src/platforms.js\");\nconst { DeviceError, NotFoundError, StateError, TimeoutError, MemoryError, ProtocolError, assert } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { Dfu } = __webpack_require__(/*! ./dfu */ \"./src/dfu.js\");\n\nconst EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\n\n// Platforms arranged by vendor/product IDs\nconst PLATFORM_USB_IDS = PLATFORMS.reduce((obj, platform) => {\n\tconst addMapping = (obj, { vendorId, productId, quirks }, dfu) => {\n\t\tif (!vendorId) {\n\t\t\treturn;\n\t\t}\n\t\tif (!obj[vendorId]) {\n\t\t\tobj[vendorId] = {};\n\t\t}\n\t\tobj[vendorId][productId] = {\n\t\t\ttype: platform.name,\n\t\t\tid: platform.id,\n\t\t\tvendorId,\n\t\t\tproductId,\n\t\t\tdfu,\n\t\t\tquirks\n\t\t};\n\t};\n\n\tif (platform.usb) {\n\t\taddMapping(obj, platform.usb, false);\n\t}\n\tif (platform.dfu) {\n\t\taddMapping(obj, platform.dfu, true);\n\t}\n\treturn obj;\n}, {});\n\nfunction platformForUsbIds(vendorId, productId) {\n\treturn (PLATFORM_USB_IDS[vendorId] || {})[productId];\n}\n\n// Default backoff intervals for the CHECK service request\nconst DEFAULT_CHECK_INTERVALS = [50, 50, 100, 100, 250, 250, 500, 500, 1000];\n\nfunction checkInterval(attempts, intervals) {\n\tif (attempts < intervals.length) {\n\t\treturn intervals[attempts];\n\t}\n\treturn intervals[intervals.length - 1];\n}\n\n/**\n * Predefined polling policies.\n *\n * @enum {Function}\n */\nconst PollingPolicy = {\n\t/** Default polling policy. */\n\tDEFAULT: n => checkInterval(n, DEFAULT_CHECK_INTERVALS)\n};\n\n// Device state\nconst DeviceState = {\n\tCLOSED: 0,\n\tOPENING: 1,\n\tOPEN: 2,\n\tCLOSING: 3\n};\n\n// Low-level vendor requests as defined by the firmware's ctrl_request_type enum\nconst VendorRequest = {\n\tSYSTEM_VERSION: 30 // Get system version\n};\n\n// Dummy callback function\nfunction ignore() {\n}\n\n/**\n * Base class for a Particle USB device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass DeviceBase extends EventEmitter {\n\tconstructor(dev, info) {\n\t\tsuper();\n\t\tthis._dev = dev; // USB device handle\n\t\tthis._info = info; // Device info\n\t\tthis._log = globalOptions.log; // Logger instance\n\t\tthis._state = DeviceState.CLOSED; // Device state\n\t\tthis._reqs = new Map(); // All known requests\n\t\tthis._reqQueue = []; // Unprocessed requests\n\t\tthis._checkQueue = []; // Active requests that need to be checked\n\t\tthis._resetQueue = []; // Active requests that need to be reset\n\t\tthis._activeReqs = 0; // Number of active requests\n\t\tthis._maxActiveReqs = null; // Maximum number of active requests\n\t\tthis._lastReqId = 0; // Last used request ID\n\t\tthis._closeTimer = null; // Timer for the closing operation\n\t\tthis._wantClose = false; // Set to true if the device needs to be closed\n\t\tthis._resetAllReqs = false; // Set to true if all requests need to be reset\n\t\tthis._busy = false; // Set to true if there's an activity on the USB connection\n\t\tthis._fwVer = null; // Firmware version\n\t\tthis._id = null; // Device ID\n\t\tthis._dfu = null; // DFU class implementation\n\t}\n\n\t/**\n\t * Open the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.concurrentRequests] Maximum number of requests that can be sent to the\n\t *        device concurrently. Requests that exceed this limit are queued. By default, this parameter\n\t *        is set to the maximum number of concurrent requests supported by the device.\n\t * @return {Promise}\n\t */\n\topen(options) {\n\t\t// Apply device quirks\n\t\tthis._dev.quirks = this._info.quirks;\n\n\t\toptions = Object.assign({\n\t\t\tconcurrentRequests: null // The maximum number of concurrent requests is limited by the device\n\t\t}, options);\n\t\tif (this._state !== DeviceState.CLOSED) {\n\t\t\treturn Promise.reject(new StateError('Device is already open'));\n\t\t}\n\t\t// Open USB device\n\t\tthis._log.trace('Opening device');\n\t\tthis._state = DeviceState.OPENING;\n\t\tlet devOpen = false;\n\t\treturn this._dev.open().then(() => {\n\t\t\tdevOpen = true;\n\t\t\t// Normalize the device ID string\n\t\t\tthis._id = this._dev.serialNumber.replace(/[^\\x20-\\x7e]/g, '').toLowerCase();\n\t\t\tthis._log.trace(`Device ID: ${this._id}`);\n\n\t\t\t// Get firmware version\n\t\t\treturn this._getFirmwareVersion().then(ver => {\n\t\t\t\tthis._fwVer = ver;\n\t\t\t\tthis._log.trace(`Firmware version: ${this._fwVer}`);\n\t\t\t}).catch(err => {\n\t\t\t\t// Pre-0.6.0 firmwares and devices in DFU mode don't support the firmware version request\n\t\t\t\tif (!this._info.dfu) {\n\t\t\t\t\tthis._log.trace(`Unable to get firmware version: ${err.message}`);\n\t\t\t\t}\n\t\t\t});\n\t\t}).then(() => {\n\t\t\tif (this._info.dfu) {\n\t\t\t\tthis._dfu = new Dfu(this._dev, this._log);\n\t\t\t\treturn this._dfu.open(options);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tthis._log.trace('Device is open');\n\t\t\tthis._maxActiveReqs = options.concurrentRequests;\n\t\t\tif (!this._dfu) {\n\t\t\t\tthis._resetAllReqs = true; // Reset all requests remaining from a previous session\n\t\t\t}\n\t\t\tthis._state = DeviceState.OPEN;\n\t\t\tthis.emit('open');\n\t\t\tthis._process();\n\t\t}).catch(err => {\n\t\t\tif (!devOpen) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\treturn this._close(err).catch(ignore).then(() => {\n\t\t\t\tthrow err;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Close the device.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.processPendingRequests=true] Whether to complete processing of the\n\t *        pending requests before closing the device.\n\t * @param {Number} [options.timeout] Timeout for processing pending requests (milliseconds).\n\t *        By default, the device is kept open until all requests are processed.\n\t * @return {Promise}\n\t */\n\tclose(options) {\n\t\toptions = Object.assign({\n\t\t\tprocessPendingRequests: true, // Process pending requests before closing the device\n\t\t\ttimeout: null // Wait until all requests are processed\n\t\t}, options);\n\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t\t// Check if pending requests need to be processed before closing the device\n\t\tif (!options.processPendingRequests) {\n\t\t\tthis._rejectAllRequests(new StateError('Device is being closed'));\n\t\t\tif (this._closeTimer) {\n\t\t\t\tclearTimeout(this._closeTimer);\n\t\t\t\tthis._closeTimer = null;\n\t\t\t}\n\t\t} else if (options.timeout && !this._wantClose) { // Timeout cannot be overriden\n\t\t\tthis._closeTimer = setTimeout(() => {\n\t\t\t\tthis._rejectAllRequests(new StateError('Device is being closed'));\n\t\t\t\tthis._process();\n\t\t\t}, options.timeout);\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\t// Use EventEmitter's queue to resolve the promise\n\t\t\tthis.once('closed', () => {\n\t\t\t\tresolve();\n\t\t\t});\n\t\t\tthis._wantClose = true;\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Send a control request to the device.\n\t *\n\t * @param {Number} type Request type.\n\t * @param {Buffer|String} data Request data.\n\t * @param {Object} [options] Request options.\n\t * @param {Function|Number} [options.pollingPolicy=PollingPolicy.DEFAULT] Request polling policy.\n\t *        This parameter specifies how frequently the device will be polled to determine the result\n\t *        of the request. The argument can either be a function that returns the number of milliseconds\n\t *        to wait before polling the device again or a number that specifies a fixed interval.\n\t * @param {Number} [options.timeout] Request timeout. The default timeout can be configured via\n\t *        {@link config}.\n\t * @return {Promise<Object>} Response object.\n\t */\n\tsendControlRequest(type, data, options) {\n\t\toptions = Object.assign({\n\t\t\tpollingPolicy: PollingPolicy.DEFAULT, // Polling policy\n\t\t\ttimeout: globalOptions.requestTimeout // Request timeout\n\t\t}, options);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this._state === DeviceState.CLOSED) {\n\t\t\t\tthrow new StateError('Device is not open');\n\t\t\t}\n\t\t\tif (this._state === DeviceState.CLOSING || this._wantClose) {\n\t\t\t\tthrow new StateError('Device is being closed');\n\t\t\t}\n\t\t\tif (type < 0 || type > proto.MAX_REQUEST_TYPE) {\n\t\t\t\tthrow new RangeError('Invalid request type');\n\t\t\t}\n\t\t\tconst dataIsStr = (typeof data === 'string');\n\t\t\tif (dataIsStr) {\n\t\t\t\tdata = Buffer.from(data);\n\t\t\t}\n\t\t\tif (data && data.length > proto.MAX_PAYLOAD_SIZE) {\n\t\t\t\tthrow new RangeError('Request data is too large');\n\t\t\t}\n\t\t\tconst req = {\n\t\t\t\tid: ++this._lastReqId, // Internal request ID\n\t\t\t\ttype: type,\n\t\t\t\tdata: data,\n\t\t\t\tdataIsStr: dataIsStr,\n\t\t\t\tdataSent: false,\n\t\t\t\tprotoId: null, // Protocol request ID\n\t\t\t\tcheckInterval: options.pollingPolicy,\n\t\t\t\tcheckIntervalIsFunc: (typeof options.pollingPolicy === 'function'),\n\t\t\t\tcheckTimer: null,\n\t\t\t\tcheckCount: 0,\n\t\t\t\treqTimer: null,\n\t\t\t\tresolve: resolve,\n\t\t\t\treject: reject,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t\tif (options.timeout) {\n\t\t\t\t// Start request timer\n\t\t\t\treq.reqTimer = setTimeout(() => {\n\t\t\t\t\tthis._rejectRequest(req, new TimeoutError('Request timeout'));\n\t\t\t\t\tthis._process();\n\t\t\t\t}, options.timeout);\n\t\t\t}\n\t\t\tthis._reqs.set(req.id, req);\n\t\t\tthis._reqQueue.push(req);\n\t\t\tthis._log.trace(`Request ${req.id}: Enqueued`);\n\t\t\tthis._process();\n\t\t});\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * This method only works in DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync reset() {\n\t\tif (this._dfu) {\n\t\t\treturn this._dfu.leave();\n\t\t}\n\t\tthrow new StateError();\n\t}\n\n\t/**\n\t * Set to `true` if the device is open.\n\t */\n\tget isOpen() {\n\t\treturn (this._state !== DeviceState.CLOSED);\n\t}\n\n\t/**\n\t * Device ID.\n\t *\n\t * This property is set to `null` if the device is closed.\n\t */\n\tget id() {\n\t\treturn this._id;\n\t}\n\n\t/**\n\t * Device OS system version.\n\t *\n\t * This property is set to `null` if the device is closed or the version could not be determined.\n\t */\n\tget firmwareVersion() {\n\t\treturn this._fwVer;\n\t}\n\n\t/**\n\t * Device type (photon, boron, tracker, etc)\n\t */\n\tget type() {\n\t\treturn this._info.type;\n\t}\n\n\t/**\n\t * Platform ID\n\t */\n\tget platformId() {\n\t\treturn this._info.id;\n\t}\n\n\t/**\n\t * USB vendor ID.\n\t */\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\t/**\n\t * USB product ID.\n\t */\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\t/**\n\t * Set to `true` if this device is in the DFU mode.\n\t */\n\tget isInDfuMode() {\n\t\treturn this._info.dfu;\n\t}\n\n\t/**\n\t * Internal USB device handle.\n\t */\n\tget usbDevice() {\n\t\treturn this._dev;\n\t}\n\n\t/**\n\t * Device USB quirks\n\t */\n\tget quirks() {\n\t\treturn this._info.quirks;\n\t}\n\n\t_process() {\n\t\tif (this._state === DeviceState.CLOSED || this._state === DeviceState.OPENING || this._busy) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._wantClose && this._state !== DeviceState.CLOSING) {\n\t\t\tthis._log.trace('Closing device');\n\t\t\tthis._state = DeviceState.CLOSING;\n\t\t}\n\t\tif (this._resetAllRequests()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._resetNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._checkNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._sendNextRequest()) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._state === DeviceState.CLOSING && this._activeReqs === 0) {\n\t\t\tthis._close();\n\t\t\t// Prevent the underlying device handle from being closed concurrently\n\t\t\tthis._busy = true;\n\t\t}\n\t}\n\n\t_resetAllRequests() {\n\t\tif (!this._resetAllReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace('Sending RESET');\n\t\tassert(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = proto.resetRequest();\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tthis._resetAllReqs = false;\n\t\t\tthis._activeReqs = 0;\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_resetNextRequest() {\n\t\tif (this._resetQueue.length === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst req = this._resetQueue.shift();\n\t\tthis._log.trace(`Request ${req.id}: Sending RESET`);\n\t\tassert(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = proto.resetRequest(req.protoId);\n\t\tthis._sendServiceRequest(setup).catch(ignore).then(() => { // Ignore result\n\t\t\tassert(--this._activeReqs >= 0);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_checkNextRequest() {\n\t\tlet req = null;\n\t\twhile (this._checkQueue.length !== 0) {\n\t\t\tconst r = this._checkQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending CHECK (${req.checkCount})`);\n\t\tassert(!this._busy && req.protoId);\n\t\tthis._busy = true;\n\t\tconst setup = proto.checkRequest(req.protoId);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase proto.Status.OK: {\n\t\t\t\t\tif (req.dataSent) {\n\t\t\t\t\t\t// Request processing is completed\n\t\t\t\t\t\tconst rep = {\n\t\t\t\t\t\t\tresult: srep.result\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (srep.size) {\n\t\t\t\t\t\t\t// Receive payload data\n\t\t\t\t\t\t\treturn this._recvReplyData(req, srep.size).then(data => {\n\t\t\t\t\t\t\t\trep.data = req.dataIsStr ? data.toString() : data;\n\t\t\t\t\t\t\t\tthis._resolveRequest(req, rep);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveRequest(req, rep); // No reply data\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Buffer allocation is completed, send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\treq.checkCount = 0; // Reset check counter\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.PENDING: {\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NO_MEMORY: {\n\t\t\t\t\tthrow new MemoryError('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NOT_FOUND: {\n\t\t\t\t\tthrow new DeviceError('Request was cancelled');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new ProtocolError(`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendNextRequest() {\n\t\tif (this._maxActiveReqs && this._activeReqs >= this._maxActiveReqs) {\n\t\t\treturn false;\n\t\t}\n\t\tlet req = null;\n\t\twhile (this._reqQueue.length !== 0) {\n\t\t\tconst r = this._reqQueue.shift();\n\t\t\tif (!r.done) { // Skip cancelled requests\n\t\t\t\treq = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!req) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Sending INIT`);\n\t\tassert(!this._busy);\n\t\tthis._busy = true;\n\t\tconst setup = proto.initRequest(req.type, req.data ? req.data.length : 0);\n\t\tthis._sendServiceRequest(setup).then(srep => {\n\t\t\tthis._log.trace(`Request ${req.id}: Status: ${srep.status}`);\n\t\t\tif (srep.status === proto.Status.OK || srep.status === proto.Status.PENDING) {\n\t\t\t\treq.protoId = srep.id;\n\t\t\t\t++this._activeReqs;\n\t\t\t\tthis._log.trace(`Request ${req.id}: Protocol ID: ${req.protoId}`);\n\t\t\t}\n\t\t\tswitch (srep.status) {\n\t\t\t\tcase proto.Status.OK: {\n\t\t\t\t\tif (req.data && req.data.length > 0) {\n\t\t\t\t\t\t// Send payload data\n\t\t\t\t\t\treturn this._sendRequestData(req).then(() => {\n\t\t\t\t\t\t\treq.dataSent = true;\n\t\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treq.dataSent = true; // No payload data\n\t\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.PENDING: {\n\t\t\t\t\tif (!req.data || req.data.length === 0) {\n\t\t\t\t\t\tthrow new ProtocolError(`Unexpected status code: ${srep.status}`);\n\t\t\t\t\t}\n\t\t\t\t\t// Buffer allocation is pending\n\t\t\t\t\tthis._startCheckTimer(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.BUSY: {\n\t\t\t\t\t// Update maximum number of active requests\n\t\t\t\t\tthis._maxActiveReqs = this._activeReqs;\n\t\t\t\t\t// Return the request back to queue\n\t\t\t\t\tthis._reqQueue.unshift(req);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase proto.Status.NO_MEMORY: {\n\t\t\t\t\tthrow new MemoryError('Memory allocation error');\n\t\t\t\t}\n\t\t\t\tdefault: {\n\t\t\t\t\tthrow new ProtocolError(`Unknown status code: ${srep.status}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t}).finally(() => {\n\t\t\tthis._busy = false;\n\t\t\tthis._process();\n\t\t});\n\t\treturn true;\n\t}\n\n\t_sendRequestData(req) {\n\t\tassert(req.data && req.data.length > 0);\n\t\tlet offs = 0;\n\t\tconst sendNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(MAX_CONTROL_TRANSFER_DATA_SIZE, req.data.length - offs);\n\t\t\tconst chunk = req.data.slice(offs, offs + chunkSize);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending SEND`);\n\t\t\tconst setup = proto.sendRequest(req.protoId, chunkSize);\n\t\t\treturn this._dev.transferOut(setup, chunk).then(() => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Sent ${chunkSize} bytes`);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < req.data.length) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn sendNextChunk();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\treturn sendNextChunk();\n\t}\n\n\t_recvReplyData(req, size) {\n\t\tassert(size > 0);\n\t\tconst buf = Buffer.alloc(size);\n\t\tlet offs = 0;\n\t\tconst recvNextChunk = () => {\n\t\t\tconst chunkSize = Math.min(MAX_CONTROL_TRANSFER_DATA_SIZE, size - offs);\n\t\t\tthis._log.trace(`Request ${req.id}: Sending RECV`);\n\t\t\tconst setup = proto.recvRequest(req.protoId, chunkSize);\n\t\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\t\tthis._log.trace(`Request ${req.id}: Received ${data.length} bytes`);\n\t\t\t\tif (data.length !== chunkSize) {\n\t\t\t\t\tthrow new Error('Unexpected size of the control transfer');\n\t\t\t\t}\n\t\t\t\tdata.copy(buf, offs);\n\t\t\t\toffs += chunkSize;\n\t\t\t\tif (offs < size) {\n\t\t\t\t\tif (req.done) {\n\t\t\t\t\t\tthrow new Error('Control transfer cancelled');\n\t\t\t\t\t}\n\t\t\t\t\treturn recvNextChunk();\n\t\t\t\t}\n\t\t\t\treturn buf;\n\t\t\t});\n\t\t};\n\t\treturn recvNextChunk();\n\t}\n\n\t_close(err = null) {\n\t\tassert(!this._busy);\n\t\t// Cancel all requests\n\t\tif (this._reqs.size !== 0) {\n\t\t\tif (!err) {\n\t\t\t\terr = new StateError('Device has been closed');\n\t\t\t}\n\t\t\tthis._rejectAllRequests(err);\n\t\t}\n\t\tthis._activeReqs = 0;\n\t\tthis._resetAllReqs = false;\n\t\t// Cancel timers\n\t\tif (this._closeTimer) {\n\t\t\tclearTimeout(this._closeTimer);\n\t\t\tthis._closeTimer = null;\n\t\t}\n\n\t\tlet p = Promise.resolve();\n\t\tif (this._dfu) {\n\t\t\tp = p.then(() => this._dfu.close()).catch(err => {\n\t\t\t\tthis._log.warn(`Unable to close DFU interface: ${err.message}`);\n\t\t\t});\n\t\t}\n\t\t// Close USB device\n\t\treturn p.then(() => this._dev.close()).catch(err => {\n\t\t\tthis._log.warn(`Unable to close USB device: ${err.message}`);\n\t\t}).then(() => {\n\t\t\t// Reset device state\n\t\t\tconst emitEvent = (this._state === DeviceState.CLOSING);\n\t\t\tthis._state = DeviceState.CLOSED;\n\t\t\tthis._wantClose = false;\n\t\t\tthis._busy = false;\n\t\t\tthis._maxActiveReqs = null;\n\t\t\tthis._dfu = null;\n\t\t\tthis._fwVer = null;\n\t\t\tthis._id = null;\n\t\t\tif (emitEvent) {\n\t\t\t\tthis.emit('closed');\n\t\t\t}\n\t\t});\n\t}\n\n\t_rejectAllRequests(err) {\n\t\tthis._reqs.forEach(req => {\n\t\t\tthis._rejectRequest(req, err);\n\t\t});\n\t\tthis._reqQueue = [];\n\t\tthis._checkQueue = [];\n\t\tthis._resetQueue = [];\n\t\tif (this._activeReqs > 0) {\n\t\t\tthis._resetAllReqs = true;\n\t\t}\n\t}\n\n\t_rejectRequest(req, err) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Failed: ${err.message}`);\n\t\tthis._clearRequest(req);\n\t\tif (req.protoId) {\n\t\t\tthis._resetQueue.push(req);\n\t\t}\n\t\treq.reject(err);\n\t}\n\n\t_resolveRequest(req, rep) {\n\t\tif (req.done) {\n\t\t\treturn;\n\t\t}\n\t\tthis._log.trace(`Request ${req.id}: Completed`);\n\t\tthis._clearRequest(req);\n\t\tassert(--this._activeReqs >= 0);\n\t\treq.resolve(rep);\n\t}\n\n\t_clearRequest(req) {\n\t\tif (req.checkTimer) {\n\t\t\tclearTimeout(req.checkTimer);\n\t\t\treq.checkTimer = null;\n\t\t}\n\t\tif (req.reqTimer) {\n\t\t\tclearTimeout(req.reqTimer);\n\t\t\treq.reqTimer = null;\n\t\t}\n\t\tthis._reqs.delete(req.id);\n\t\treq.done = true;\n\t}\n\n\t_startCheckTimer(req) {\n\t\tlet timeout = req.checkInterval;\n\t\tif (req.checkIntervalIsFunc) {\n\t\t\ttimeout = timeout(req.checkCount);\n\t\t}\n\t\t++req.checkCount;\n\t\tsetTimeout(() => {\n\t\t\tthis._checkQueue.push(req);\n\t\t\tthis._process();\n\t\t}, timeout);\n\t}\n\n\t_getFirmwareVersion() {\n\t\tconst setup = {\n\t\t\tbmRequestType: proto.BmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: proto.PARTICLE_BREQUEST,\n\t\t\twIndex: VendorRequest.SYSTEM_VERSION,\n\t\t\twValue: 0,\n\t\t\twLength: proto.MIN_WLENGTH\n\t\t};\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\t// filter out null bytes\n\t\t\tconst nullPos = data.indexOf(0);\n\t\t\treturn (nullPos === -1 ? data : data.slice(0, nullPos)).toString();\n\t\t});\n\t}\n\n\t// Sends a service request and parses the reply data\n\t_sendServiceRequest(setup) {\n\t\treturn this._dev.transferIn(setup).then(data => {\n\t\t\treturn proto.parseReply(data);\n\t\t});\n\t}\n}\n\nasync function getDevices({ types = [], includeDfu = true } = {}) {\n\ttypes = types.map(type => type.toLowerCase());\n\tconst filters = [];\n\tPLATFORMS.forEach((platform) => {\n\t\tif (types.length === 0 || types.includes(platform.name)) {\n\t\t\tif (platform.usb.vendorId) {\n\t\t\t\tfilters.push(platform.usb);\n\t\t\t}\n\t\t\tif (includeDfu && platform.dfu.vendorId) {\n\t\t\t\tfilters.push(platform.dfu);\n\t\t\t}\n\t\t}\n\t});\n\tif (filters.length === 0) {\n\t\treturn [];\n\t}\n\tconst devs = await getUsbDevices(filters);\n\treturn devs.map(dev => {\n\t\tconst platform = platformForUsbIds(dev.vendorId, dev.productId);\n\t\tassert(platform);\n\t\treturn new DeviceBase(dev, platform);\n\t});\n}\n\nasync function openDeviceById(id, options = null) {\n\tconst log = globalOptions.log;\n\tconst filters = [];\n\tPLATFORMS.forEach((platform) => {\n\t\tif (platform.usb.vendorId) {\n\t\t\tfilters.push(Object.assign({ serialNumber: id }, platform.usb));\n\t\t}\n\t\tif (platform.dfu.vendorId) {\n\t\t\tfilters.push(Object.assign({ serialNumber: id }, platform.dfu));\n\t\t}\n\t});\n\tconst devs = await getUsbDevices(filters);\n\tif (devs.length === 0) {\n\t\tthrow new NotFoundError('Device is not found');\n\t}\n\tif (devs.length !== 1) {\n\t\tlog.warn(`Found multiple devices with the same ID: ${id}`); // lol\n\t}\n\tlet dev = devs[0];\n\tconst platform = platformForUsbIds(dev.vendorId, dev.productId);\n\tassert(platform);\n\tdev = new DeviceBase(dev, platform);\n\tawait dev.open(options);\n\treturn dev;\n}\n\nasync function openNativeUsbDevice(nativeUsbDevice, options = null) {\n\n\tconst usbDevice = new UsbDevice(nativeUsbDevice);\n\n\tconst platform = platformForUsbIds(usbDevice.vendorId, usbDevice.productId);\n\tif (!platform) {\n\t\tthrow new NotFoundError('Unsupported device type');\n\t}\n\tconst dev = new DeviceBase(usbDevice, platform);\n\n\tawait dev.open(options);\n\n\treturn dev;\n}\n\nmodule.exports = {\n\tPollingPolicy,\n\tDeviceBase,\n\tgetDevices,\n\topenDeviceById,\n\topenNativeUsbDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/device-base.js?");

/***/ }),

/***/ "./src/device.js":
/*!***********************!*\
  !*** ./src/device.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { DeviceBase, openDeviceById } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { Result, messageForResultCode } = __webpack_require__(/*! ./result */ \"./src/result.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\nconst usbProto = __webpack_require__(/*! ./usb-protocol */ \"./src/usb-protocol.js\");\nconst { RequestError, NotFoundError, TimeoutError, StateError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { globalOptions } = __webpack_require__(/*! ./config */ \"./src/config.js\");\n\nconst proto = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\nconst DeviceOSProtobuf = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\n\n/**\n * Firmware module types.\n *\n * @enum {String}\n */\nconst FirmwareModule = fromProtobufEnum(DeviceOSProtobuf.definitions.FirmwareModuleType, {\n\t/** Bootloader module. */\n\tBOOTLOADER: 'BOOTLOADER',\n\t/** System part module. */\n\tSYSTEM_PART: 'SYSTEM_PART',\n\t/** User part module. */\n\tUSER_PART: 'USER_PART',\n\t/** Monolithic firmware module. */\n\tMONO_FIRMWARE: 'MONO_FIRMWARE',\n\t/** Network co-processor firmware module */\n\tNCP_FIRMWARE: 'NCP_FIRMWARE',\n\t/** Radio stack module */\n\tRADIO_STACK: 'RADIO_STACK'\n});\n\n/**\n * Firmware module readable names\n *\n * @enum {String}\n */\nconst FirmwareModuleDisplayNames = {\n\t[FirmwareModule.BOOTLOADER]: 'Bootloader',\n\t[FirmwareModule.SYSTEM_PART]: 'System Part',\n\t[FirmwareModule.USER_PART]: 'User Part',\n\t[FirmwareModule.MONO_FIRMWARE]: 'Monolithic Firmware',\n\t[FirmwareModule.NCP_FIRMWARE]: 'Network Co-processor Firmware',\n\t[FirmwareModule.RADIO_STACK]: 'Radio Stack Module'\n};\n\n/**\n * Device modes.\n *\n * @enum {String}\n */\nconst DeviceMode = fromProtobufEnum(proto.DeviceMode, {\n\t/** Device is in normal mode. */\n\tNORMAL: 'NORMAL_MODE',\n\t/** Device is in listening mode. */\n\tLISTENING: 'LISTENING_MODE'\n});\n\n/**\n * Logging levels.\n *\n * @enum {String}\n */\nconst LogLevel = fromProtobufEnum(proto.logging.LogLevel, {\n\t/** Enables logging of all messages. */\n\tALL: 'ALL',\n\t/** Enables logging of trace messages. */\n\tTRACE: 'TRACE',\n\t/** Enables logging of info messages. */\n\tINFO: 'INFO',\n\t/** Enables logging of warning messages. */\n\tWARN: 'WARN',\n\t/** Enables logging of error messages. */\n\tERROR: 'ERROR',\n\t/** Disables logging of any messages. */\n\tNONE: 'NONE'\n});\n\nconst DEFAULT_FIRMWARE_UPDATE_TIMEOUT = 120000;\n\n// Helper class used by Device.timeout()\nclass RequestSender {\n\tconstructor(device, timeout) {\n\t\tthis.id = device.id;\n\t\tthis.device = device;\n\t\tthis._timeoutTime = Date.now() + timeout;\n\t}\n\n\tasync open(options) {\n\t\tthis.device = await openDeviceById(this.id, options);\n\t}\n\n\tasync close() {\n\t\tawait this.device.close();\n\t}\n\n\tasync sendRequest(req, msg, opts) {\n\t\tif (!opts || !opts.timeout) {\n\t\t\tconst t = this._timeoutTime - Date.now();\n\t\t\tif (t <= 0) {\n\t\t\t\tthrow new TimeoutError();\n\t\t\t}\n\t\t\topts = Object.assign({}, opts, { timeout: t });\n\t\t} else if (Date.now() + opts.timeout >= this._timeoutTime) {\n\t\t\tthrow new TimeoutError();\n\t\t}\n\t\treturn this.device.sendRequest(req, msg, opts);\n\t}\n\n\tasync delay(ms) {\n\t\tif (Date.now() + ms >= this._timeoutTime) {\n\t\t\tthrow new TimeoutError();\n\t\t}\n\t\treturn new Promise((resolve) => {\n\t\t\tsetTimeout(() => resolve(), ms);\n\t\t});\n\t}\n}\n\n/**\n * Basic functionality supported by most of Particle devices.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n */\nclass Device extends DeviceBase {\n\t/**\n\t * Get the device's serial number.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.5.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<String>}\n\t */\n\tasync getSerialNumber({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendProtobufRequest(\n\t\t\t'GetSerialNumberRequest',\n\t\t\tnull,\n\t\t\t{ timeout }\n\t\t);\n\t\treturn r.serial;\n\t}\n\n\t/**\n\t * Perform the system reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * The `force` option is supported since Device OS 2.0.0.\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.force] Reset the device immediately, even if it is busy performing\n\t *        some blocking operation, such as writing to flash.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tasync reset({ force = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn super.reset();\n\t\t}\n\t\tif (!force) {\n\t\t\treturn this.sendRequest(Request.RESET, null /* msg */, { timeout });\n\t\t}\n\t\tconst setup = {\n\t\t\tbmRequestType: usbProto.BmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: usbProto.PARTICLE_BREQUEST,\n\t\t\twIndex: Request.RESET.id,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this.usbDevice.transferOut(setup);\n\t}\n\n\t/**\n\t * Perform the factory reset.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tfactoryReset({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.FACTORY_RESET, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Reset and enter the DFU mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Boolean} [options.noReconnectWait] After entering DFU mode, do not attempt to connect to the device to make sure it's in DFU mode.\n\t *     This can be useful in a web browser because connecting to the device in DFU mode may prompt the user to authorize\n\t *     access to the device.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterDfuMode({ noReconnectWait = false, timeout = globalOptions.requestTimeout } = {}) {\n\t\tif (this.isInDfuMode) {\n\t\t\treturn;\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait s.sendRequest(Request.DFU_MODE);\n\t\t\tawait s.close();\n\t\t\tlet isInDfuMode;\n\n\t\t\tif (!noReconnectWait) {\n\t\t\t\twhile (!isInDfuMode) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait s.open({ includeDfu: true });\n\t\t\t\t\t\tisInDfuMode = s.device.isInDfuMode;\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t// device is reconnecting, ignore\n\t\t\t\t\t}\n\t\t\t\t\tawait s.close();\n\t\t\t\t\tawait s.delay(500);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\n\t/**\n\t * Reset and enter the safe mode.\n\t *\n\t * Note: The only safe operation that can be performed on the device instance after the device\n\t * resets is closing it via {@link DeviceBase#close}.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tenterSafeMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.SAFE_MODE, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Enter listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise} Resolves when either device is confirmed to be in listening mode, throws an error, or timeout exceeded.\n\t */\n\tasync enterListeningMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tawait this.sendProtobufRequest('StartListeningModeRequest', {}, { timeout });\n\n\t\t\t// Wait until the device enters the listening mode\n\t\t\twhile (true) { // eslint-disable-line no-constant-condition\n\t\t\t\t// GetDeviceModeRequest may not be supported by the device even if start listening mode does work, hence try/catch\n\t\t\t\ttry {\n\t\t\t\t\tconst getDeviceModeReply = await this.sendProtobufRequest('GetDeviceModeRequest', {}, { timeout });\n\n\t\t\t\t\tconst deviceModeEnum = DeviceOSProtobuf.getDefinition('DeviceMode').message;\n\t\t\t\t\t// break if in listening mode\n\t\t\t\t\tif (getDeviceModeReply.mode === deviceModeEnum.LISTENING_MODE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof RequestError) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tawait s.delay(500);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Leave the listening mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tleaveListeningMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.STOP_LISTENING, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Get the device mode.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 1.1.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise<DeviceMode>}\n\t */\n\tasync getDeviceMode({ timeout = globalOptions.requestTimeout } = {}) {\n\t\tconst r = await this.sendRequest(Request.GET_DEVICE_MODE, null /* msg */, { timeout });\n\t\treturn DeviceMode.fromProtobuf(r.mode);\n\t}\n\n\t/**\n\t * Start the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstartNyanSignal({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.START_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Stop the Nyan LED indication.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @return {Promise}\n\t */\n\tstopNyanSignal({ timeout = globalOptions.requestTimeout } = {}) {\n\t\treturn this.sendRequest(Request.STOP_NYAN_SIGNAL, null /* msg */, { timeout });\n\t}\n\n\t/**\n\t * Perform the firmware update.\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @param {Object} [options] Options.\n\t * @param {Number} [options.timeout] Timeout (milliseconds).\n\t * @param {Function} [options.progress] User's callback function to log progress of the flashing process.\n\t * @return {Promise}\n\t */\n\tasync updateFirmware(data, { timeout = DEFAULT_FIRMWARE_UPDATE_TIMEOUT, progress } = {}) {\n\t\tif (!data.length) {\n\t\t\tthrow new RangeError('Invalid firmware size');\n\t\t}\n\t\treturn this.timeout(timeout, async (s) => {\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'start-erase', bytes: data.length });\n\t\t\t}\n\t\t\tconst { chunkSize } = await s.sendRequest(Request.START_FIRMWARE_UPDATE, { size: data.length });\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'erased', bytes: data.length });\n\t\t\t\tprogress({ event: 'start-download', bytes: data.length });\n\t\t\t}\n\t\t\tlet offs = 0;\n\t\t\twhile (offs < data.length) {\n\t\t\t\tconst n = Math.min(chunkSize, data.length - offs);\n\t\t\t\tawait s.sendRequest(Request.FIRMWARE_UPDATE_DATA, { data: data.slice(offs, offs + n) });\n\t\t\t\tif (progress) {\n\t\t\t\t\tprogress({ event: 'downloaded', bytes: n });\n\t\t\t\t}\n\t\t\t\toffs += n;\n\t\t\t}\n\t\t\tawait s.sendRequest(Request.FINISH_FIRMWARE_UPDATE, { validateOnly: false });\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'complete-download', bytes: data.length });\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get firmware module data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} module Module type.\n\t * @param {Number} [index] Module index.\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFirmwareModule(module, index) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tconst section = storage.modules.find(section => {\n\t\t\t\treturn (section.moduleType === module && section.moduleIndex === index);\n\t\t\t});\n\t\t\tif (!section) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(section).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(section, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Get firmware module info.\n\t *\n\t *\n\t * Supported platforms:\n\t * - Gen 3 (since Device OS 0.9.0)\n\t * - Gen 2 (since Device OS 0.8.0)\n\t *\n\t * @return {Promise<Array>} List of modules installed into the device and their dependencies\n\t */\n\tasync getFirmwareModuleInfo() {\n\t\tif (this.isInDfuMode) {\n\t\t\tthrow new StateError('Cannot get information when the device is in DFU mode');\n\t\t}\n\n\t\tconst moduleInfoResponse = await this.sendProtobufRequest('GetModuleInfoRequest', null);\n\t\tconst { modules } = moduleInfoResponse;\n\n\t\treturn modules.map(module => {\n\t\t\tconst { index, type, dependencies, size, version } = module;\n\n\t\t\treturn {\n\t\t\t\ttype: FirmwareModule.fromProtobuf(type),\n\t\t\t\tindex,\n\t\t\t\tversion,\n\t\t\t\tsize,\n\t\t\t\tdependencies: dependencies.map(dependency => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tindex: dependency.index,\n\t\t\t\t\t\tversion: dependency.version,\n\t\t\t\t\t\ttype: FirmwareModule.fromProtobuf(dependency.type)\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Check if the device runs a modular firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Boolean>}\n\t */\n\thasModularFirmware() {\n\t\treturn this._getStorageInfo().then(storage => storage.hasModularFirmware);\n\t}\n\n\t/**\n\t * Set factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Buffer} data Firmware data.\n\t * @return {Promise}\n\t */\n\tsetFactoryFirmware(data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.factory, 0, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get factory firmware.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Buffer>}\n\t */\n\tgetFactoryFirmware() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.factory) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\t// Get size of the firmware module\n\t\t\treturn this._getSectionDataSize(storage.factory).then(size => {\n\t\t\t\t// Read firmware data\n\t\t\t\treturn this._readSectionData(storage.factory, 0, size);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Read configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadConfigData(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.config, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteConfigData(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.config, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the configuration data.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetConfigDataSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.config) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn storage.config.size;\n\t\t});\n\t}\n\n\t/**\n\t * Read from EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Number} size Data size.\n\t * @return {Promise<Buffer>}\n\t */\n\treadEeprom(address, size) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._readSectionData(storage.eeprom, address, size);\n\t\t});\n\t}\n\n\t/**\n\t * Write to EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Number} address Address.\n\t * @param {Buffer} data Data.\n\t * @return {Promise}\n\t */\n\twriteEeprom(address, data) {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._writeSectionData(storage.eeprom, address, data);\n\t\t});\n\t}\n\n\t/**\n\t * Clear EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearEeprom() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn this._clearSectionData(storage.eeprom);\n\t\t});\n\t}\n\n\t/**\n\t * Get size of the EEPROM.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Number>}\n\t */\n\tgetEepromSize() {\n\t\treturn this._getStorageInfo().then(storage => {\n\t\t\tif (!storage.eeprom) {\n\t\t\t\tthrow new NotFoundError();\n\t\t\t}\n\t\t\treturn storage.eeprom.size;\n\t\t});\n\t}\n\n\t/**\n\t * Add a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @param {String} options.stream Output stream: `Serial`, `Serial1`, `USBSerial1`, etc.\n\t * @param {String} [options.format] Message format: `default`, `json`.\n\t * @param {String} [options.level] Default logging level: `trace`, `info`, `warn`, `error`, `none`, `all`.\n\t * @param {Array} [options.filters] Category filters.\n\t * @param {Number} [options.baudRate] Baud rate.\n\t * @return {Promise}\n\t */\n\tasync addLogHandler({ id, stream, format, level, filters, baudRate }) {\n\t\tconst req = {\n\t\t\tid,\n\t\t\tlevel: LogLevel.toProtobuf(level || 'all')\n\t\t};\n\t\tswitch ((format || 'default').toLowerCase()) {\n\t\t\tcase 'default': {\n\t\t\t\treq.handlerType = proto.logging.LogHandlerType.DEFAULT_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'json': {\n\t\t\t\treq.handlerType = proto.logging.LogHandlerType.JSON_STREAM_HANDLER;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown message format: ${format}`);\n\t\t\t}\n\t\t}\n\t\tif (!stream) {\n\t\t\tthrow new RangeError('Output stream is not specified');\n\t\t}\n\t\tswitch (stream.toLowerCase()) {\n\t\t\tcase 'serial': {\n\t\t\t\treq.streamType = proto.logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 0\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'usbserial1': {\n\t\t\t\treq.streamType = proto.logging.StreamType.USB_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'serial1': {\n\t\t\t\treq.streamType = proto.logging.StreamType.HW_SERIAL_STREAM;\n\t\t\t\treq.serial = {\n\t\t\t\t\tindex: 1,\n\t\t\t\t\tbaudRate\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new RangeError(`Unknown output stream: ${stream}`);\n\t\t\t}\n\t\t}\n\t\tif (filters) {\n\t\t\treq.filters = filters.map(f => ({\n\t\t\t\tcategory: f.category,\n\t\t\t\tlevel: LogLevel.toProtobuf(f.level)\n\t\t\t}));\n\t\t}\n\t\treturn this.sendRequest(Request.ADD_LOG_HANDLER, req);\n\t}\n\n\t/**\n\t * Remove a log handler.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @param {Object} options Options.\n\t * @param {String} options.id Handler ID.\n\t * @return {Promise}\n\t */\n\tasync removeLogHandler({ id }) {\n\t\treturn this.sendRequest(Request.REMOVE_LOG_HANDLER, { id });\n\t}\n\n\t/**\n\t * Get the list of active log handlers.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * @return {Promise<Array<Object>>}\n\t */\n\tasync getLogHandlers() {\n\t\tconst rep = await this.sendRequest(Request.GET_LOG_HANDLERS);\n\t\treturn rep.handlers.map(h => ({\n\t\t\tid: h.id\n\t\t}));\n\t}\n\n\t/**\n\t * Sends a protobuf encoded request to Device and decodes response. Use higher level methods like getSerialNumber() than this if possible.\n\t * @param {String} protobufMessageName - The protobuf message name, see DeviceOSProtobuf.getDefinitions() for valid values.\n\t * @param {Object} protobufMessageData data that will be encoded into the protobuf request before sending to device\n\t * @param {*} opts See sendControlRequest(), same options are here.\n\t * @returns {Object} Depends on schema defined by `req.reply`\n\t * @throws {RequestError} thrown when message isn't supported by device or other USB related failures\n\t */\n\tasync sendProtobufRequest(protobufMessageName, protobufMessageData = {}, opts) {\n\t\tconst protobufDefinition = DeviceOSProtobuf.getDefinition(protobufMessageName);\n\t\tconst encodedProtobufBuffer = DeviceOSProtobuf.encode(protobufMessageName, protobufMessageData);\n\t\tconst rep = await this.sendControlRequest(\n\t\t\tprotobufDefinition.id,\n\t\t\tencodedProtobufBuffer,\n\t\t\topts\n\t\t);\n\n\t\tif (rep.result !== Result.OK) {\n\t\t\tthrow new RequestError(rep.result, messageForResultCode(rep.result));\n\t\t}\n\n\t\tif (rep.data) {\n\t\t\t// Parse the response message\n\t\t\treturn DeviceOSProtobuf.decode(\n\t\t\t\tprotobufDefinition.replyMessage,\n\t\t\t\trep.data\n\t\t\t);\n\t\t} else {\n\t\t\t// Create a message with default-initialized properties\n\t\t\treturn protobufDefinition.replyMessage.create();\n\t\t}\n\t}\n\n\tsendRequest(req, msg, opts) {\n\t\tlet buf = null;\n\t\tif (msg && req.request) {\n\t\t\tconst m = req.request.create(msg); // Protobuf message object\n\t\t\tbuf = req.request.encode(m).finish();\n\t\t}\n\t\treturn this.sendControlRequest(req.id, buf, opts).then(rep => {\n\t\t\tlet r = undefined;\n\n\t\t\t// Note: Nothing depends on opts.dontThrow anymore\n\t\t\tif (opts && opts.dontThrow) {\n\t\t\t\tr = { result: rep.result };\n\t\t\t} else if (rep.result !== Result.OK) {\n\t\t\t\tthrow new RequestError(rep.result, messageForResultCode(rep.result));\n\t\t\t}\n\t\t\tif (req.reply) {\n\t\t\t\tif (rep.data) {\n\t\t\t\t\t// Parse the response message\n\t\t\t\t\tr = Object.assign(req.reply.decode(rep.data), r);\n\t\t\t\t} else {\n\t\t\t\t\t// Create a message with default-initialized properties\n\t\t\t\t\tr = Object.assign(req.reply.create(), r);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn r;\n\t\t});\n\t}\n\n\t// This method is used to send multiple requests to the device. The overall execution time can be\n\t// limited via the `ms` argument (optional)\n\tasync timeout(ms, fn) {\n\t\tif (typeof ms === 'function') {\n\t\t\tfn = ms;\n\t\t\tms = undefined;\n\t\t}\n\t\tif (!ms) {\n\t\t\tms = globalOptions.requestTimeout; // Default timeout\n\t\t}\n\t\tconst s = new RequestSender(this, ms);\n\t\treturn fn(s);\n\t}\n\n\t_readSectionData(section, offset, size) {\n\t\tconst data = Buffer.alloc(size);\n\t\tlet chunkSize = 4096;\n\t\tlet chunkOffs = 0;\n\t\tconst readChunk = () => {\n\t\t\tif (chunkOffs + chunkSize > size) {\n\t\t\t\tchunkSize = size - chunkOffs;\n\t\t\t}\n\t\t\tif (chunkSize === 0) {\n\t\t\t\treturn Promise.resolve(data);\n\t\t\t}\n\t\t\treturn this.sendRequest(Request.READ_SECTION_DATA, {\n\t\t\t\tstorage: section.storageIndex,\n\t\t\t\tsection: section.sectionIndex,\n\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\tsize: chunkSize\n\t\t\t}).then(rep => {\n\t\t\t\trep.data.copy(data, chunkOffs);\n\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\treturn readChunk();\n\t\t\t});\n\t\t};\n\t\treturn readChunk();\n\t}\n\n\t_writeSectionData(section, offset, data) {\n\t\treturn Promise.resolve().then(() => {\n\t\t\tif (section.needClear) {\n\t\t\t\treturn this._clearSectionData(section);\n\t\t\t}\n\t\t}).then(() => {\n\t\t\tlet chunkSize = 4096;\n\t\t\tlet chunkOffs = 0;\n\t\t\tconst writeChunk = () => {\n\t\t\t\tif (chunkOffs + chunkSize > data.length) {\n\t\t\t\t\tchunkSize = data.length - chunkOffs;\n\t\t\t\t}\n\t\t\t\tif (chunkSize === 0) {\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t}\n\t\t\t\treturn this.sendRequest(Request.WRITE_SECTION_DATA, {\n\t\t\t\t\tstorage: section.storageIndex,\n\t\t\t\t\tsection: section.sectionIndex,\n\t\t\t\t\toffset: offset + chunkOffs,\n\t\t\t\t\tdata: data.slice(chunkOffs, chunkOffs + chunkSize)\n\t\t\t\t}).then(() => {\n\t\t\t\t\tchunkOffs += chunkSize;\n\t\t\t\t\treturn writeChunk();\n\t\t\t\t});\n\t\t\t};\n\t\t\treturn writeChunk();\n\t\t});\n\t}\n\n\t_clearSectionData(section) {\n\t\treturn this.sendRequest(Request.CLEAR_SECTION_DATA, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t});\n\t}\n\n\t_getSectionDataSize(section) {\n\t\treturn this.sendRequest(Request.GET_SECTION_DATA_SIZE, {\n\t\t\tstorage: section.storageIndex,\n\t\t\tsection: section.sectionIndex\n\t\t}).then(rep => rep.size);\n\t}\n\n\t_getStorageInfo() {\n\t\t// Check if there's a cached storage info\n\t\tif (this._storageInfo) {\n\t\t\treturn Promise.resolve(this._storageInfo);\n\t\t}\n\t\t// Request storage info from the device\n\t\treturn this.sendRequest(Request.DESCRIBE_STORAGE).then(rep => {\n\t\t\tconst storage = {\n\t\t\t\tmodules: [],\n\t\t\t\tfactory: null,\n\t\t\t\tconfig: null,\n\t\t\t\teeprom: null,\n\t\t\t\thasModularFirmware: true\n\t\t\t};\n\t\t\tfor (let storageIndex = 0; storageIndex < rep.storage.length; ++storageIndex) {\n\t\t\t\tconst pbStorage = rep.storage[storageIndex];\n\t\t\t\tfor (let sectionIndex = 0; sectionIndex < pbStorage.sections.length; ++sectionIndex) {\n\t\t\t\t\tconst pbSection = pbStorage.sections[sectionIndex];\n\t\t\t\t\tconst section = {\n\t\t\t\t\t\tstorageIndex: storageIndex,\n\t\t\t\t\t\tsectionIndex: sectionIndex,\n\t\t\t\t\t\tsize: pbSection.size,\n\t\t\t\t\t\tneedClear: !!(pbSection.flags & proto.SectionFlag.NEED_CLEAR)\n\t\t\t\t\t};\n\t\t\t\t\tswitch (pbSection.type) {\n\t\t\t\t\t\t// Firmware module\n\t\t\t\t\t\tcase proto.SectionType.FIRMWARE: {\n\t\t\t\t\t\t\tconst pbFirmwareModule = pbSection.firmwareModule;\n\t\t\t\t\t\t\tif (pbFirmwareModule.type === proto.FirmwareModuleType.MONO_FIRMWARE) {\n\t\t\t\t\t\t\t\tstorage.hasModularFirmware = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsection.moduleType = FirmwareModule.fromProtobuf(pbFirmwareModule.type);\n\t\t\t\t\t\t\tif (pbFirmwareModule.index) {\n\t\t\t\t\t\t\t\tsection.moduleIndex = pbFirmwareModule.index;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstorage.modules.push(section);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Factory firmware\n\t\t\t\t\t\tcase proto.SectionType.FACTORY_BACKUP: {\n\t\t\t\t\t\t\tstorage.factory = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Device configuration\n\t\t\t\t\t\tcase proto.SectionType.CONFIG: {\n\t\t\t\t\t\t\tstorage.config = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// EEPROM\n\t\t\t\t\t\tcase proto.SectionType.EEPROM: {\n\t\t\t\t\t\t\tstorage.eeprom = section;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._storageInfo = storage;\n\t\t\tthis.once('closed', () => {\n\t\t\t\tthis._storageInfo = null;\n\t\t\t});\n\t\t\treturn this._storageInfo;\n\t\t});\n\t}\n}\n\nmodule.exports = {\n\tFirmwareModule,\n\tFirmwareModuleDisplayNames,\n\tDeviceMode,\n\tLogLevel,\n\tDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/device.js?");

/***/ }),

/***/ "./src/dfu-device.js":
/*!***************************!*\
  !*** ./src/dfu-device.js ***!
  \***************************/
/***/ ((module) => {

eval("const DfuDevice = (base) => class extends base {\n\t/**\n\t * Flashes the firmware over DFU interface.\n\t *\n\t * @param {Buffer} data The binary firmware data to be flashed.\n\t * @param {Object} options Options.\n\t * @param {Number} options.altSetting The interface alternate setting.\n\t * @param {Number} options.startAddr The starting address where the firmware will be written.\n\t * @param {boolean} [options.noErase] - Skip erasing the device memory.\n\t * @param {boolean} [options.leave] - Leave DFU mode after download.\n\t * @param {Function} [options.progress] User's callback function to log progress of the flashing process.\n\t * @returns {Promise<void>} A Promise that resolves when the firmware is successfully flashed.\n\t */\n\tasync writeOverDfu(data, { altSetting, startAddr, noErase, leave, progress }) {\n\t\tawait this._dfu.setAltSetting(altSetting);\n\t\tawait this._dfu.doDownload({ startAddr, data, noErase, leave, progress });\n\t}\n\n\tasync readOverDfu({ altSetting, startAddr, size, progress }) {\n\t\tawait this._dfu.setAltSetting(altSetting);\n\t\tconst buffer = await this._dfu.doUpload({ startAddr, maxSize: size, progress });\n\t\treturn buffer;\n\t}\n};\n\nmodule.exports = {\n\tDfuDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/dfu-device.js?");

/***/ }),

/***/ "./src/dfu.js":
/*!********************!*\
  !*** ./src/dfu.js ***!
  \********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/*\n * dfu.js\n * Copyright (c) 2023, Particle\n *\n * Some functions are extracted from the web-dfu project:\n * Copyright (c) 2016, Devan Lai\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\nconst { DeviceError, UsbStallError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n/**\n * A generic DFU error.\n */\nclass DfuError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tError.captureStackTrace(this, this.constructor);\n\t}\n}\n\n// 3. Requests, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuRequestType = {\n\t// | wValue    | wIndex    | wLength | Data     |\n\t// +-----------+-----------+---------+----------+\n\tDFU_DETACH: 0, // | wTimeout  | Interface | Zero    | None     |\n\tDFU_DNLOAD: 1, // | wBlockNum | Interface | Length  | Firmware |\n\tDFU_UPLOAD: 2, // | Zero      | Interface | Length  | Firmware |\n\tDFU_GETSTATUS: 3, // | Zero      | Interface | 6       | Status   |\n\tDFU_CLRSTATUS: 4, // | Zero      | Interface | Zero    | None     |\n\tDFU_GETSTATE: 5, // | Zero      | Interface | 1       | State    |\n\tDFU_ABORT: 6 // | Zero      | Interface | Zero    | None     |\n};\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceStatus = {\n\t// No error condition is present.\n\tOK: 0x00,\n\t// File is not targeted for use by this device.\n\terrTARGET: 0x01,\n\t// File is for this device but fails some vendor-specific verification test.\n\terrFILE: 0x02,\n\t// Device is unable to write memory.\n\terrWRITE: 0x03,\n\t// Memory erase function failed.\n\terrERASE: 0x04,\n\t// Memory erase check failed.\n\terrCHECK_ERASED: 0x05,\n\t// Program memory function failed.\n\terrPROG: 0x06,\n\t// Programmed memory failed verification.\n\terrVERIFY: 0x07,\n\t// Cannot program memory due to received address that is out of range.\n\terrADDRESS: 0x08,\n\t// Received DFU_DNLOAD with wLength = 0, but device does not think it has all of the data yet.\n\terrNOTDONE: 0x09,\n\t// Devices firmware is corrupt. It cannot return to run-time (non-DFU) operations.\n\terrFIRMWARE: 0x0A,\n\t// iString indicates a vendor-specific error.\n\terrVENDOR: 0x0B,\n\t// Device detected unexpected USB reset signaling.\n\terrUSBR: 0x0C,\n\t// Device detected unexpected power on reset.\n\terrPOR: 0x0D,\n\t// Something went wrong, but the device does not know what it was.\n\terrUNKNOWN: 0x0E,\n\t// Device stalled an unexpected request.\n\terrSTALLEDPKT: 0x0F,\n};\n\nconst DfuDeviceStatusMap = Object.keys(DfuDeviceStatus).reduce((obj, key) => {\n\tobj[DfuDeviceStatus[key]] = key;\n\treturn obj;\n}, {});\n\n// 6.1.2 DFU_GETSTATUS Request, USB Device Firmware Upgrade Specification, Revision 1.1\nconst DfuDeviceState = {\n\t// Device is running its normal application.\n\tappIDLE: 0,\n\t// Device is running its normal application, has received the DFU_DETACH request, and is waiting\n\t// for a USB reset.\n\tappDETACH: 1,\n\t// Device is operating in the DFU mode and is waiting for requests.\n\tdfuIDLE: 2,\n\t// Device has received a block and is waiting for the host to solicit the status via DFU_GETSTATUS.\n\tdfuDNLOAD_SYNC: 3,\n\t// Device is programming a control-write block into its nonvolatile memories.\n\tdfuDNBUSY: 4,\n\t// Device is processing a download operation. Expecting DFU_DNLOAD requests.\n\tdfuDNLOAD_IDLE: 5,\n\t// Device has received the final block of firmware from the host and is waiting for receipt of\n\t// DFU_GETSTATUS to begin the Manifestation phase; or device has completed the Manifestation\n\t// phase and is waiting for receipt of DFU_GETSTATUS. (Devices that can enter this state after\n\t// the Manifestation phase set bmAttributes bit bitManifestationTolerant to 1.)\n\tdfuMANIFEST_SYNC: 6,\n\t// Device is in the Manifestation phase. (Not all devices will be able to respond to DFU_GETSTATUS\n\t// when in this state.)\n\tdfuMANIFEST: 7,\n\t// Device has programmed its memories and is waiting for a USB reset or a power on reset. (Devices\n\t// that must enter this state clear bitManifestationTolerant to 0.)\n\tdfuMANIFEST_WAIT_RESET: 8,\n\t// The device is processing an upload operation. Expecting DFU_UPLOAD requests.\n\tdfuUPLOAD_IDLE: 9,\n\t// An error has occurred. Awaiting the DFU_CLRSTATUS request.\n\tdfuERROR: 10\n};\n\nconst DfuDeviceStateMap = Object.keys(DfuDeviceState).reduce((obj, key) => {\n\tobj[DfuDeviceState[key]] = key;\n\treturn obj;\n}, {});\n\n/**\n * DFU with ST Microsystems extensions.\n *\n * AN3156: USB DFU protocol used in the STM32 bootloader.\n */\nconst DfuseCommand = {\n\tDFUSE_COMMAND_NONE: 0xff,\n\tDFUSE_COMMAND_GET_COMMAND: 0x00,\n\tDFUSE_COMMAND_SET_ADDRESS_POINTER: 0x21,\n\tDFUSE_COMMAND_ERASE: 0x41,\n\tDFUSE_COMMAND_READ_UNPROTECT: 0x92\n};\n\nconst DfuBmRequestType = {\n\tHOST_TO_DEVICE: 0x21,\n\tDEVICE_TO_HOST: 0xA1\n};\n\nconst DFU_STATUS_SIZE = 6;\n// FIXME:\nconst DEFAULT_INTERFACE = 0;\nconst DEFAULT_ALTERNATE = 0;\n\nconst DEFAULT_TRANSFER_SIZE = 1024;\n\nclass Dfu {\n\tconstructor(dev, logger) {\n\t\tthis._dev = dev;\n\t\tthis._log = logger;\n\t\tthis._interface = DEFAULT_INTERFACE;\n\t\tthis._alternate = DEFAULT_ALTERNATE;\n\t\tthis._claimed = false;\n\t\tthis._memoryInfo = null;\n\t\tthis._transferSize = DEFAULT_TRANSFER_SIZE;\n\t\tthis._allInterfaces = [];\n\t}\n\n\t/**\n\t * Open DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync open() {\n\t\tawait this._dev.claimInterface(this._interface);\n\t\tthis._claimed = true;\n\t\tawait this._dev.setAltSetting(this._interface, this._alternate);\n\t\tlet desc = await this._getConfigDescriptor(0); // Use the default config\n\t\tdesc = this._parseConfigDescriptor(desc);\n\t\tthis._allInterfaces = desc.interfaces;\n\t}\n\n\t/**\n\t * Close DFU interface.\n\t *\n\t * @return {Promise}\n\t */\n\tasync close() {\n\t\tif (this._claimed) {\n\t\t\treturn this._dev.releaseInterface(this._interface);\n\t\t}\n\t}\n\n\t/**\n\t * Leave DFU mode.\n\t *\n\t * @return {Promise}\n\t */\n\tasync leave() {\n\t\tawait this._goIntoDfuIdleOrDfuDnloadIdle();\n\n\t\tawait this._sendDnloadRequest(Buffer.alloc(0), 2);\n\n\t\tawait this._pollUntil(\n\t\t\t// Wait for dfuDNLOAD_IDLE in case of Gen2 and for dfuMANIFEST in case of Gen3 and above.\n\t\t\t// This is a workaround for Gen 2 DFU implementation where in order to please dfu-util\n\t\t\t// for some reason we are going off-standard and instead of reporting the actual dfuMANIFEST state\n\t\t\t// report dfuDNLOAD_IDLE :|\n\t\t\tstate => (state === DfuDeviceState.dfuMANIFEST || state === DfuDeviceState.dfuDNLOAD_IDLE));\n\t}\n\n\t/**\n\t * Set the alternate interface for DFU and initialize memory information.\n\t *\n\t * @param {number} setting - The alternate interface index to set.\n\t * @return {Promise}\n\t */\n\tasync setAltSetting(setting) {\n\t\tlet iface = null;\n\t\tlet xferSize = null;\n\t\tfor (const i of this._allInterfaces) {\n\t\t\tif (i.bInterfaceNumber === this._interface) {\n\t\t\t\tif (!iface && i.bAlternateSetting === setting) {\n\t\t\t\t\tiface = i;\n\t\t\t\t\tif (i.dfuFunctional) {\n\t\t\t\t\t\txferSize = i.dfuFunctional.wTransferSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (xferSize) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// DFU_FUNCTIONAL descriptor may not be available for each interface with the given number\n\t\t\t\tif (!xferSize && i.dfuFunctional) {\n\t\t\t\t\txferSize = i.dfuFunctional.wTransferSize;\n\t\t\t\t\tif (iface) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!iface) {\n\t\t\tthrow new Error('Invalid alternate setting');\n\t\t}\n\t\tif (!iface.iInterface) {\n\t\t\tthrow new Error('Missing string descriptor');\n\t\t}\n\t\tconst ifaceName = await this._getStringDescriptor(iface.iInterface);\n\t\tconst memInfo = this._parseMemoryDescriptor(ifaceName);\n\t\tawait this._dev.setAltSetting(this._interface, setting);\n\t\tthis._transferSize = xferSize || DEFAULT_TRANSFER_SIZE;\n\t\tthis._memoryInfo = memInfo;\n\t\tthis._alternate = setting;\n\t}\n\n\t/**\n\t * Perform DFU download of binary data to the device.\n\t *\n\t * @param {Object} options Options.\n\t * @param {number} options.startAddr - The starting address to write the data.\n\t * @param {Buffer} options.data - The binary data to write.\n\t * @param {boolean} [options.noErase] - Skip erasing the device memory.\n\t * @param {boolean} [options.leave] - Leave DFU mode after download.\n\t * @param {function} [options.progress] - Callback function used to log progress.\n\t * @return {Promise}\n\t */\n\tasync doDownload({ startAddr, data, noErase, leave, progress }) {\n\t\tif (!this._memoryInfo || !this._memoryInfo.segments) {\n\t\t\tthrow new Error('No memory map available');\n\t\t}\n\n\t\tconst startAddress = startAddr;\n\t\tif (this._getSegment(startAddress) === null) {\n\t\t\tthis._log.error(`Start address 0x${startAddress.toString(16)} outside of memory map bounds`);\n\t\t}\n\t\tconst expectedSize = data.byteLength;\n\n\t\tif (!noErase) {\n\t\t\tthis._log.info('Erasing DFU device memory');\n\t\t\tawait this._erase(startAddress, expectedSize, progress);\n\t\t}\n\n\t\tthis._log.info('Copying binary data to DFU device startAddress=' + startAddress + ' total_expected_size=' + expectedSize);\n\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-download', bytes: expectedSize });\n\t\t}\n\t\tlet bytesSent = 0;\n\t\tlet address = startAddress;\n\t\twhile (bytesSent < expectedSize) {\n\t\t\tconst bytesLeft = expectedSize - bytesSent;\n\t\t\tconst chunkSize = Math.min(bytesLeft, this._transferSize);\n\n\t\t\tlet dfuStatus;\n\t\t\ttry {\n\t\t\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_SET_ADDRESS_POINTER, address);\n\t\t\t\tthis._log.trace(`Set address to 0x${address.toString(16)}`);\n\t\t\t\tawait this._sendDnloadRequest(data.slice(bytesSent, bytesSent + chunkSize), 2);\n\t\t\t\tdfuStatus = await this._pollUntil(state => (state === DfuDeviceState.dfuDNLOAD_IDLE));\n\t\t\t\tthis._log.trace('Sent ' + chunkSize + ' bytes');\n\t\t\t\taddress += chunkSize;\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Error during DfuSe download: ' + error);\n\t\t\t}\n\n\t\t\tif (dfuStatus.status !== DfuDeviceStatus.OK) {\n\t\t\t\tif (progress) {\n\t\t\t\t\tprogress({ event: 'failed-download' });\n\t\t\t\t}\n\t\t\t\tthrow new Error(`DFU DOWNLOAD failed state=${dfuStatus.state}, status=${dfuStatus.status}`);\n\t\t\t}\n\n\t\t\tthis._log.trace('Wrote ' + chunkSize + ' bytes');\n\t\t\tbytesSent += chunkSize;\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'downloaded', bytes: chunkSize });\n\t\t\t}\n\t\t}\n\t\tthis._log.info(`Wrote ${bytesSent} bytes total`);\n\t\tif (progress) {\n\t\t\tprogress({ event: 'complete-download', bytes: bytesSent });\n\t\t}\n\n\t\tif (leave) {\n\t\t\tthis._log.info('Manifesting new firmware');\n\t\t\ttry {\n\t\t\t\tawait this.leave();\n\t\t\t} catch (error) {\n\t\t\t\tthrow new Error('Error during Dfu manifestation: ' + error);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _goIntoDfuIdleOrDfuDnloadIdle() {\n\t\ttry {\n\t\t\tconst state = await this._getStatus();\n\t\t\tif (state.state === DfuDeviceState.dfuERROR) {\n\t\t\t\t// If we are in dfuERROR state, simply issue DFU_CLRSTATUS and we'll go into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\n\t\t\tif (state.state !== DfuDeviceState.dfuIDLE && state.state !== DfuDeviceState.dfuDNLOAD_IDLE) {\n\t\t\t\t// If we are in some kind of an unknown state, issue DFU_CLRSTATUS, which may fail,\n\t\t\t\t// but the device will go into dfuERROR state, so a subsequent DFU_CLRSTATUS will get us\n\t\t\t\t// into dfuIDLE\n\t\t\t\tawait this._clearStatus();\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t// DFU_GETSTATUS or DFU_CLRSTATUS failed, we are most likely in dfuERROR state, clear it\n\t\t\tawait this._clearStatus();\n\t\t}\n\n\t\t// Confirm we are in dfuIDLE or dfuDNLOAD_IDLE\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== DfuDeviceState.dfuIDLE && state.state !== DfuDeviceState.dfuDNLOAD_IDLE) {\n\t\t\tthrow new DfuError('Invalid state');\n\t\t}\n\t\treturn state;\n\t}\n\n\t/**\n\t * Sends a download request to the DFU device with the specified request and value.\n\t * This request is sent via nodeusb or webusb\n\t *\n\t * @param {Buffer} req The request data buffer to be sent to the device.\n\t * @param {number} wValue The value to be sent as part of the request.\n\t */\n\tasync _sendDnloadRequest(data, wValue) {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_DNLOAD,\n\t\t\twIndex: this._interface,\n\t\t\twValue: wValue\n\t\t};\n\t\treturn this._dev.transferOut(setup, data);\n\t}\n\n\tasync _sendUploadReqest(length, value) {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: DfuRequestType.DFU_UPLOAD,\n\t\t\twIndex: this._interface,\n\t\t\twValue: value,\n\t\t\twLength: length\n\t\t};\n\t\treturn this._dev.transferIn(setup);\n\t}\n\n\tasync _sendAbortRequest() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_ABORT,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this._dev.transferOut(setup, Buffer.alloc(0));\n\t}\n\n\t/**\n\t * Retrieves the status from the DFU (Device Firmware Upgrade) device.\n\t *\n\t * @returns {Promise<object>} A Promise that resolves with the status object containing status, pollTimeout, and state.\n\t * @throws {DfuError} If parsing the DFU_GETSTATUS response fails or the status/state is invalid.\n\t */\n\tasync _getStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.DEVICE_TO_HOST,\n\t\t\tbRequest: DfuRequestType.DFU_GETSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0,\n\t\t\twLength: DFU_STATUS_SIZE\n\t\t};\n\t\tconst data = await this._dev.transferIn(setup);\n\t\tif (!data || data.length !== DFU_STATUS_SIZE) {\n\t\t\tthrow new DfuError('Could not parse DFU_GETSTATUS response');\n\t\t}\n\t\tlet bStatusWithPollTimeout = data.readUInt32LE(0);\n\n\t\tconst bStatus = (bStatusWithPollTimeout & 0xff);\n\t\tbStatusWithPollTimeout >>= 8;\n\t\tconst bState = data.readUInt8(4);\n\n\t\treturn {\n\t\t\tstatus: bStatus,\n\t\t\tpollTimeout: bStatusWithPollTimeout,\n\t\t\tstate: bState\n\t\t};\n\t}\n\n\t/**\n\t * Poll until the given statePredicate is true or the device goes into dfuERROR state.\n\t *\n\t * @param {function} statePredicate - The function to check the device state.\n\t * @return {object} - The DFU status object after polling.\n\t */\n\tasync _pollUntil(statePredicate) {\n\t\tlet dfuStatus = await this._getStatus();\n\n\t\tfunction asyncSleep(durationMs) {\n\t\t\treturn new Promise((resolve) => {\n\t\t\t\t// this._log.trace('Sleeping for ' + durationMs + 'ms');\n\t\t\t\tsetTimeout(resolve, durationMs);\n\t\t\t});\n\t\t}\n\n\t\twhile (!statePredicate(dfuStatus.state) && dfuStatus.state !== DfuDeviceState.dfuERROR) {\n\t\t\tawait asyncSleep(dfuStatus.pollTimeout);\n\t\t\tdfuStatus = await this._getStatus();\n\t\t}\n\n\t\treturn dfuStatus;\n\t}\n\n\t/**\n\t * Sends the DFU_CLRSTATUS request to the DFU device to clear any error status.\n\t */\n\tasync _clearStatus() {\n\t\tconst setup = {\n\t\t\tbmRequestType: DfuBmRequestType.HOST_TO_DEVICE,\n\t\t\tbRequest: DfuRequestType.DFU_CLRSTATUS,\n\t\t\twIndex: this._interface,\n\t\t\twValue: 0\n\t\t};\n\t\treturn this._dev.transferOut(setup, Buffer.alloc(0));\n\t}\n\n\t/**\n\t * Parse the memory descriptor string and create a memory map.\n\t *\n\t * @param {string} desc - The memory descriptor string.\n\t * @return {object} - Memory map information.\n\t */\n\t_parseMemoryDescriptor(desc) {\n\t\tconst nameEndIndex = desc.indexOf('/');\n\t\tif (!desc.startsWith('@') || nameEndIndex === -1) {\n\t\t\tthrow new Error(`Not a DfuSe memory descriptor: \"${desc}\"`);\n\t\t}\n\n\t\tconst name = desc.substring(1, nameEndIndex).trim();\n\t\tconst segmentString = desc.substring(nameEndIndex);\n\n\t\tconst segments = [];\n\n\t\tconst sectorMultipliers = {\n\t\t\t' ': 1,\n\t\t\t'B': 1,\n\t\t\t'K': 1024,\n\t\t\t'M': 1048576\n\t\t};\n\n\t\tconst rgx = /\\/\\s*(0x[0-9a-fA-F]{1,8})\\s*\\/(\\s*[0-9]+\\s*\\*\\s*[0-9]+\\s?[ BKM]\\s*[abcdefg]\\s*,?\\s*)+/g;\n\t\tlet contiguousSegmentMatch;\n\t\twhile ((contiguousSegmentMatch = rgx.exec(segmentString)) !== null) {\n\t\t\tconst segmentRegex = /([0-9]+)\\s*\\*\\s*([0-9]+)\\s?([ BKM])\\s*([abcdefg])\\s*,?\\s*/g;\n\t\t\tlet startAddress = parseInt(contiguousSegmentMatch[1], 16);\n\t\t\tlet segmentMatch;\n\t\t\twhile ((segmentMatch = segmentRegex.exec(contiguousSegmentMatch[0])) !== null) {\n\t\t\t\tconst segment = {};\n\t\t\t\tconst sectorCount = parseInt(segmentMatch[1], 10);\n\t\t\t\tconst sectorSize = parseInt(segmentMatch[2]) * sectorMultipliers[segmentMatch[3]];\n\t\t\t\tconst properties = segmentMatch[4].charCodeAt(0) - 'a'.charCodeAt(0) + 1;\n\t\t\t\tsegment.start = startAddress;\n\t\t\t\tsegment.sectorSize = sectorSize;\n\t\t\t\tsegment.end = startAddress + sectorSize * sectorCount;\n\t\t\t\tsegment.readable = (properties & 0x1) !== 0;\n\t\t\t\tsegment.erasable = (properties & 0x2) !== 0;\n\t\t\t\tsegment.writable = (properties & 0x4) !== 0;\n\t\t\t\tsegments.push(segment);\n\n\t\t\t\tstartAddress += sectorSize * sectorCount;\n\t\t\t}\n\t\t}\n\n\t\treturn { 'name': name, 'segments': segments };\n\t}\n\n\t/**\n\t * Send a DfuSe command to the DFU device.\n\t *\n\t * @param {number} command - The DfuSe command to send.\n\t * @param {number} param - Optional. The parameter for the command.\n\t * @param {number} len - Optional. The length of the command payload.\n\t * @return {Promise}\n\t */\n\tasync _dfuseCommand(command, param) {\n\t\tif (typeof param === 'undefined') {\n\t\t\tparam = 0x00;\n\t\t}\n\n\t\tconst commandNames = {\n\t\t\t0x00: 'GET_COMMANDS',\n\t\t\t0x21: 'SET_ADDRESS',\n\t\t\t0x41: 'ERASE_SECTOR'\n\t\t};\n\n\t\tconst payload = Buffer.alloc(5);\n\t\tpayload.writeUInt8(command, 0);\n\t\tpayload.writeUInt32LE(param, 1);\n\n\t\tfor (let triesLeft = 4; triesLeft >= 0; triesLeft--) {\n\t\t\ttry {\n\t\t\t\tawait this._sendDnloadRequest(payload, 0);\n\t\t\t\tbreak;\n\t\t\t} catch (error) {\n\t\t\t\tif (triesLeft === 0 || !(error instanceof UsbStallError)) {\n\t\t\t\t\tthrow new Error('Error during special DfuSe command ' + commandNames[command] + ':' + error);\n\t\t\t\t}\n\t\t\t\tthis._log.trace('dfuse error, retrying', error);\n\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, 1000));\n\n\t\t\t}\n\t\t}\n\n\t\tconst status = await this._pollUntil(state => (state !== DfuDeviceState.dfuDNBUSY));\n\t\tif (status.status !== DfuDeviceStatus.OK) {\n\t\t\tthrow new Error('Special DfuSe command failed');\n\t\t}\n\t}\n\n\t/**\n\t * Get the memory segment that contains the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding memory segment.\n\t * @return {object|null} - The memory segment containing the address, or null if not found.\n\t */\n\t_getSegment(addr) {\n\t\tif (!this._memoryInfo || !this._memoryInfo.segments) {\n\t\t\tthrow new Error('No memory map information available');\n\t\t}\n\n\t\tfor (const segment of this._memoryInfo.segments) {\n\t\t\tif (segment.start <= addr && addr < segment.end) {\n\t\t\t\treturn segment;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get the start address of the sector containing the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding sector start address.\n\t * @param {object} segment - Optional. The memory segment containing the address. If not provided, it will be looked up.\n\t * @return {number} - The start address of the sector.\n\t */\n\t_getSectorStart(addr, segment) {\n\t\tif (typeof segment === 'undefined') {\n\t\t\tsegment = this._getSegment(addr);\n\t\t}\n\n\t\tif (!segment) {\n\t\t\tthrow new Error(`Address ${addr.toString(16)} outside of memory map`);\n\t\t}\n\n\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\treturn segment.start + sectorIndex * segment.sectorSize;\n\t}\n\n\t/**\n\t * Get the end address of the sector containing the given address.\n\t *\n\t * @param {number} addr - The address to find the corresponding sector end address.\n\t * @param {object} segment - Optional. The memory segment containing the address. If not provided, it will be looked up.\n\t * @return {number} - The end address of the sector.\n\t */\n\t_getSectorEnd(addr, segment) {\n\t\tif (typeof segment === 'undefined') {\n\t\t\tsegment = this._getSegment(addr);\n\t\t}\n\n\t\tif (!segment) {\n\t\t\tthrow new Error(`Address ${addr.toString(16)} outside of memory map`);\n\t\t}\n\n\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\treturn segment.start + (sectorIndex + 1) * segment.sectorSize;\n\t}\n\n\t/**\n\t * Erases the memory of the DFU device starting from the specified address and for the given length.\n\t * This method erases memory sectors that are marked as erasable in the memory map.\n\t *\n\t * @param {number} startAddr The starting address of the memory range to be erased.\n\t * @param {number} length The length of the memory range to be erased in bytes.\n\t * @throws {Error} If the start address or the length is outside the memory map bounds, or if erasing fails.\n\t */\n\tasync _erase(startAddr, length, progress) {\n\t\tlet segment = this._getSegment(startAddr);\n\t\tlet addr = this._getSectorStart(startAddr, segment);\n\t\tconst endAddr = this._getSectorEnd(startAddr + length - 1);\n\n\t\tlet bytesErased = 0;\n\t\tconst bytesToErase = endAddr - addr;\n\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-erase', bytes: bytesToErase });\n\t\t}\n\t\twhile (addr < endAddr) {\n\t\t\tif (segment.end <= addr) {\n\t\t\t\tsegment = this._getSegment(addr);\n\t\t\t}\n\t\t\tif (!segment.erasable) {\n\t\t\t\t// Skip over the non-erasable section\n\t\t\t\tbytesErased = Math.min(bytesErased + segment.end - addr, bytesToErase);\n\t\t\t\tif (progress) {\n\t\t\t\t\t// include a progress event for the skipped section to ensure total matches\n\t\t\t\t\tprogress({ event: 'erased', bytes: segment.end - addr });\n\t\t\t\t}\n\t\t\t\taddr = segment.end;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst sectorIndex = Math.floor((addr - segment.start) / segment.sectorSize);\n\t\t\tconst sectorAddr = segment.start + sectorIndex * segment.sectorSize;\n\t\t\tthis._log.trace(`Erasing ${segment.sectorSize}B at 0x${sectorAddr.toString(16)}`);\n\t\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_ERASE, sectorAddr);\n\t\t\taddr = sectorAddr + segment.sectorSize;\n\t\t\tbytesErased += segment.sectorSize;\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'erased', bytes: segment.sectorSize });\n\t\t\t}\n\t\t}\n\t}\n\n\tasync _getStringDescriptor(index) {\n\t\t// Read the size of the descriptor\n\t\tlet d = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06, // GET_DESCRIPTOR\n\t\t\twValue: (0x03 /* STRING */ << 8) | (index & 0xff),\n\t\t\twIndex: 0x0409, // English (US)\n\t\t\twLength: 1\n\t\t});\n\t\tconst len = d.readUInt8(0); // bLength\n\t\t// Read the descriptor\n\t\td = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06,\n\t\t\twValue: (0x03 << 8) | (index & 0xff),\n\t\t\twIndex: 0x0409,\n\t\t\twLength: len\n\t\t});\n\t\t// Decode the UTF-16 data\n\t\tconst utf16 = [];\n\t\tlet offs = 2; // Skip bLength and bDescriptorType\n\t\twhile (offs < d.length) {\n\t\t\tutf16.push(d.readUInt16LE(offs));\n\t\t\toffs += 2;\n\t\t}\n\t\treturn String.fromCharCode(...utf16);\n\t}\n\n\tasync _getConfigDescriptor(index) {\n\t\t// Read the total size of the descriptors\n\t\tconst d = await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06, // GET_DESCRIPTOR\n\t\t\twValue: (0x02 /* CONFIGURATION */ << 8) | (index & 0xff),\n\t\t\twIndex: 0,\n\t\t\twLength: 4\n\t\t});\n\t\tconst len = d.readUInt16LE(2); // wTotalLength\n\t\t// Read the descriptors\n\t\treturn await this._dev.transferIn({\n\t\t\tbmRequestType: 0x80, // Direction: device-to-host; type: standard; recipient: device\n\t\t\tbRequest: 0x06,\n\t\t\twValue: (0x02 << 8) | (index & 0xff),\n\t\t\twIndex: 0,\n\t\t\twLength: len\n\t\t});\n\t}\n\n\t_parseConfigDescriptor(data) {\n\t\t// https://www.beyondlogic.org/usbnutshell/usb5.shtml#ConfigurationDescriptors\n\t\tif (data.length < 9) {\n\t\t\tthrow new Error('Invalid descriptor size');\n\t\t}\n\t\tconst type = data.readUInt8(1); // bDescriptorType\n\t\tif (type !== 0x02) { // CONFIGURATION\n\t\t\tthrow new Error('Invalid descriptor type');\n\t\t}\n\t\tconst desc = {\n\t\t\tinterfaces: []\n\t\t};\n\t\tlet curIface = null;\n\t\tlet dfuExpected = false;\n\t\tlet offs = 9;\n\t\twhile (offs < data.length) {\n\t\t\tconst len = data.readUInt8(offs); // bLength\n\t\t\tconst type = data.readUInt8(offs + 1); // bDescriptorType\n\t\t\t// Only parse the interface descriptors for now\n\t\t\tswitch (type) {\n\t\t\t\tcase 0x04: { // INTERFACE\n\t\t\t\t\tconst cls = data.readUInt8(offs + 5); // bInterfaceClass\n\t\t\t\t\tconst subclass = data.readUInt8(offs + 6); // bInterfaceSubClass\n\t\t\t\t\tcurIface = {\n\t\t\t\t\t\tbLength: len,\n\t\t\t\t\t\tbDescriptorType: type,\n\t\t\t\t\t\tbInterfaceNumber: data.readUInt8(offs + 2),\n\t\t\t\t\t\tbAlternateSetting: data.readUInt8(offs + 3),\n\t\t\t\t\t\tbNumEndpoints: data.readUInt8(offs + 4),\n\t\t\t\t\t\tbInterfaceClass: cls,\n\t\t\t\t\t\tbInterfaceSubClass: subclass,\n\t\t\t\t\t\tbInterfaceProtocol: data.readUInt8(offs + 7),\n\t\t\t\t\t\tiInterface: data.readUInt8(offs + 8)\n\t\t\t\t\t};\n\t\t\t\t\tdesc.interfaces.push(curIface);\n\t\t\t\t\tdfuExpected = cls === 0xfe && subclass === 0x01; // 4.1.2 Run-Time DFU Interface Descriptor\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 0x21: { // DFU_FUNCTIONAL\n\t\t\t\t\tif (!dfuExpected) {\n\t\t\t\t\t\tthrow new Error('Unexpected descriptor');\n\t\t\t\t\t}\n\t\t\t\t\tcurIface.dfuFunctional = {\n\t\t\t\t\t\tbLength: len,\n\t\t\t\t\t\tbDescriptorType: type,\n\t\t\t\t\t\tbmAttributes: data.readUInt8(offs + 2),\n\t\t\t\t\t\twDetachTimeOut: data.readUInt16LE(offs + 3),\n\t\t\t\t\t\twTransferSize: data.readUInt16LE(offs + 5),\n\t\t\t\t\t\tbcdDFUVersion: data.readUInt16LE(offs + 7)\n\t\t\t\t\t};\n\t\t\t\t\tdfuExpected = false; // 4.1 Run-Time Descriptor Set\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toffs += len;\n\t\t}\n\t\treturn desc;\n\t}\n\n\tasync doUpload({ startAddr, maxSize, progress }) {\n\t\tif (typeof startAddr !== 'number') {\n\t\t\tstartAddr = this._memoryInfo.segments[0].start;\n\t\t\tthis._log.warn('Using inferred start address 0x' + startAddr.toString(16));\n\t\t} else if (this._getSegment(startAddr) === null) {\n\t\t\tthis._log.warn(`Start address 0x${startAddr.toString(16)} outside of memory map bounds`);\n\t\t}\n\n\t\tthis._log.trace(`Reading up to 0x${maxSize.toString(16)} bytes starting at 0x${startAddr.toString(16)}`);\n\t\tconst state = await this._getStatus();\n\t\tif (state.state !== DfuDeviceState.dfuIDLE) {\n\t\t\tawait this._clearStatus(); // suggested by dfu-util\n\t\t\tawait this.abortToIdle();\n\t\t}\n\t\tawait this._dfuseCommand(DfuseCommand.DFUSE_COMMAND_SET_ADDRESS_POINTER, startAddr);\n\t\tawait this.abortToIdle();\n\n\t\t// DfuSe encodes the read address based on the transfer size,\n\t\t// the block number - 2, and the SET_ADDRESS pointer.\n\t\tconst data = await this._doUploadImpl(maxSize, 2, progress);\n\t\treturn data;\n\t}\n\n\tasync _doUploadImpl(maxSize = Infinity, firstBlock = 0, progress) {\n\t\tlet transaction = firstBlock;\n\t\tconst blocks = [];\n\t\tlet bytesRead = 0;\n\n\t\tthis._log.trace('Copying data from DFU device to browser');\n\t\tif (progress) {\n\t\t\tprogress({ event: 'start-upload', bytes: maxSize });\n\t\t}\n\n\t\tlet result;\n\t\tlet bytesToRead;\n\t\tdo {\n\t\t\tbytesToRead = Math.min(this._transferSize, maxSize - bytesRead);\n\t\t\tresult = await this._sendUploadReqest(bytesToRead, transaction++);\n\t\t\tthis._log.trace('Read ' + result.byteLength + ' bytes');\n\t\t\tif (result.byteLength > 0) {\n\t\t\t\tblocks.push(Buffer.from(result));\n\t\t\t\tbytesRead += result.byteLength;\n\t\t\t}\n\t\t\tif (progress) {\n\t\t\t\tprogress({ event: 'uploaded', bytes: bytesRead });\n\t\t\t}\n\t\t} while ((bytesRead < maxSize) && (result.byteLength === bytesToRead));\n\n\t\tif (bytesRead === maxSize) {\n\t\t\tawait this.abortToIdle();\n\t\t}\n\n\t\tthis._log.trace(`Read ${bytesRead} bytes`);\n\t\tif (progress) {\n\t\t\tprogress({ event: 'complete-upload', bytes: bytesRead });\n\t\t}\n\n\t\treturn Buffer.concat(blocks);\n\t}\n\n\tasync abortToIdle() {\n\t\tawait this._sendAbortRequest();\n\t\tlet state = await this._getStatus();\n\t\tif (state.state === DfuDeviceState.dfuERROR) {\n\t\t\tawait this._clearStatus();\n\t\t\tstate = await this._getStatus();\n\t\t}\n\t\tif (state.state !== DfuDeviceState.dfuIDLE) {\n\t\t\tthrow new Error('Failed to return to idle state after abort: state ' + state.state);\n\t\t}\n\t}\n}\n\nmodule.exports = {\n\tDfuError,\n\tDfuRequestType,\n\tDfuDeviceStatus,\n\tDfuDeviceStatusMap,\n\tDfuDeviceState,\n\tDfuDeviceStateMap,\n\tDfuseCommand,\n\tDfuBmRequestType,\n\tDFU_STATUS_SIZE,\n\tDfu\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/dfu.js?");

/***/ }),

/***/ "./src/error.js":
/*!**********************!*\
  !*** ./src/error.js ***!
  \**********************/
/***/ ((module) => {

eval("/**\n * Generic device error. This is a base class for all errors reported by the library.\n */\nclass DeviceError extends Error {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a requested resource cannot be found.\n */\nclass NotFoundError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a requested operation is not permitted.\n */\nclass NotAllowedError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when an object is not in an appropriate state to perform an operation.\n */\nclass StateError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Timeout error.\n */\nclass TimeoutError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * An error reported when a device has no enough memory to perform an operation.\n */\nclass MemoryError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Protocol error.\n */\nclass ProtocolError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * USB error.\n */\nclass UsbError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Internal error.\n */\nclass InternalError extends DeviceError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\n/**\n * Request error.\n */\nclass RequestError extends DeviceError {\n\tconstructor(result, ...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t\tthis.result = result;\n\t}\n}\n\n/**\n * USB stall error.\n */\nclass UsbStallError extends UsbError {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.name = this.constructor.name;\n\t}\n}\n\nfunction assert(val, msg = null) {\n\tif (!val) {\n\t\tthrow new InternalError(msg ? msg : 'Assertion failed');\n\t}\n}\n\nmodule.exports = {\n\tDeviceError,\n\tNotFoundError,\n\tNotAllowedError,\n\tStateError,\n\tTimeoutError,\n\tMemoryError,\n\tProtocolError,\n\tUsbError,\n\tInternalError,\n\tRequestError,\n\tUsbStallError,\n\tassert\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/error.js?");

/***/ }),

/***/ "./src/gen3-device.js":
/*!****************************!*\
  !*** ./src/gen3-device.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\n\n/**\n * Gen 3 device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst Gen3Device = (base) => class extends base {\n\t/**\n\t * Set the setup done flag.\n\t *\n\t * @param {Boolean} [done] Flag value.\n\t * @return {Promise}\n\t */\n\tasync setSetupDone(done) {\n\t\tif (done === undefined) {\n\t\t\tdone = true;\n\t\t}\n\t\tawait this.sendRequest(Request.SET_DEVICE_SETUP_DONE, { done });\n\t}\n\n\t/**\n\t * Set to `true` if this is a Gen 3 device.\n\t */\n\tget isGen3Device() {\n\t\treturn true;\n\t}\n};\n\nmodule.exports = {\n\tGen3Device\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/gen3-device.js?");

/***/ }),

/***/ "./src/network-device.js":
/*!*******************************!*\
  !*** ./src/network-device.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n\nconst proto = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\nconst DEFAULT_INTERFACE = 1;\n\n/**\n * Network status.\n */\nconst NetworkStatus = fromProtobufEnum(proto.NetworkState, {\n\tDOWN: 'DOWN',\n\tUP: 'UP'\n});\n\n/**\n * Network device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst NetworkDevice = base => class extends base {\n\t/**\n\t * Get network status.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetNetworkStatus() {\n\t\treturn this.sendRequest(Request.NETWORK_GET_STATUS, {\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t}).then(rep => NetworkStatus.fromProtobuf(rep.config.state));\n\t}\n\n\t/**\n\t * Get network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Object>}\n\t */\n\tgetNetworkConfig() {\n\t\treturn this.sendRequest(Request.NETWORK_GET_CONFIGURATION, { // TODO\n\t\t\tinterface: DEFAULT_INTERFACE\n\t\t});\n\t}\n\n\t/**\n\t * Set network configuration.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} config Network configuration.\n\t * @return {Promise}\n\t */\n\tsetNetworkConfig(config) {\n\t\treturn this.sendRequest(Request.NETWORK_SET_CONFIGURATION, config); // TODO\n\t}\n};\n\nmodule.exports = {\n\tNetworkStatus,\n\tNetworkDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/network-device.js?");

/***/ }),

/***/ "./src/particle-usb.js":
/*!*****************************!*\
  !*** ./src/particle-usb.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { getDevices: getUsbDevices, openDeviceById: openUsbDeviceById, openNativeUsbDevice: openUsbNativeUsbDevice } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { PollingPolicy } = __webpack_require__(/*! ./device-base */ \"./src/device-base.js\");\nconst { FirmwareModule, FirmwareModuleDisplayNames } = __webpack_require__(/*! ./device */ \"./src/device.js\");\nconst { NetworkStatus } = __webpack_require__(/*! ./network-device */ \"./src/network-device.js\");\nconst { WifiAntenna, WifiSecurity, WifiCipher, EapMethod } = __webpack_require__(/*! ./wifi-device */ \"./src/wifi-device.js\");\nconst { CloudConnectionStatus, ServerProtocol } = __webpack_require__(/*! ./cloud-device */ \"./src/cloud-device.js\");\nconst { Result } = __webpack_require__(/*! ./result */ \"./src/result.js\");\nconst { DeviceError, NotFoundError, NotAllowedError, StateError, TimeoutError, MemoryError, ProtocolError, UsbError, InternalError, RequestError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\nconst { config } = __webpack_require__(/*! ./config */ \"./src/config.js\");\nconst { setDevicePrototype } = __webpack_require__(/*! ./set-device-prototype */ \"./src/set-device-prototype.js\");\n\n/**\n * Enumerate Particle USB devices attached to the host.\n *\n * @param {Object} options Options.\n * @param {Array<String>} [options.types] Device types (photon, boron, tracker, etc). By default, this\n *        function enumerates devices of all platforms supported by the library.\n * @param {Boolean} [options.includeDfu=true] Whether to include devices in DFU mode.\n * @return {Promise<Array<Device>>}\n */\nfunction getDevices(options) {\n\treturn getUsbDevices(options).then(devs => devs.map(dev => setDevicePrototype(dev)));\n}\n\n/**\n * Open a Particle USB device with the specified ID.\n *\n * @param {String} id Device ID.\n * @param {Object} [options] Options (see {@link DeviceBase#open}).\n * @return {Promise<Device>}\n */\nfunction openDeviceById(id, options) {\n\treturn openUsbDeviceById(id, options).then(dev => setDevicePrototype(dev));\n}\n\n/**\n * Open a Particle USB device from a native browser or node USB device handle\n *\n * @param {Object} nativeUsbDevice A WebUSB (browser) or node-usb USB device\n * @param {Object} [options] Options (see {@link DeviceBase#open}).\n * @return {Promise<Device>}\n */\nfunction openNativeUsbDevice(nativeUsbDevice, options) {\n\treturn openUsbNativeUsbDevice(nativeUsbDevice, options).then(dev => setDevicePrototype(dev));\n}\n\nmodule.exports = {\n\tPollingPolicy,\n\tFirmwareModule,\n\tFirmwareModuleDisplayNames,\n\tNetworkStatus,\n\tWifiAntenna,\n\tWifiSecurity,\n\tWifiCipher,\n\tEapMethod,\n\tCloudConnectionStatus,\n\tServerProtocol,\n\tResult,\n\tDeviceError,\n\tNotFoundError,\n\tNotAllowedError,\n\tStateError,\n\tTimeoutError,\n\tMemoryError,\n\tProtocolError,\n\tUsbError,\n\tInternalError,\n\tRequestError,\n\tgetDevices,\n\topenDeviceById,\n\topenNativeUsbDevice,\n\tconfig\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/particle-usb.js?");

/***/ }),

/***/ "./src/platforms.js":
/*!**************************!*\
  !*** ./src/platforms.js ***!
  \**************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const deviceConstants = __webpack_require__(/*! @particle/device-constants */ \"./node_modules/@particle/device-constants/dist/js/constants.json\");\n\nconst PLATFORMS = Object.values(clone(deviceConstants)); // TODO: (Julien) .filter((platform) => platform.features.include('usb-requests'));\n\nPLATFORMS.forEach((platform) => {\n\tif (platform.usb) {\n\t\tplatform.usb = parseUsbInfo(platform.usb);\n\t}\n\tif (platform.dfu) {\n\t\tplatform.dfu = parseUsbInfo(platform.dfu);\n\t}\n});\n\n// Convert the \"0x2b04\" id strings to 0x2b04 numbers\nfunction parseUsbInfo({ vendorId, productId, quirks }) {\n\treturn {\n\t\tvendorId: Number(vendorId),\n\t\tproductId: Number(productId),\n\t\tquirks: quirks || {}\n\t};\n}\n\nfunction clone(x) {\n\treturn JSON.parse(JSON.stringify(x));\n}\n\nmodule.exports = {\n\tPLATFORMS\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/platforms.js?");

/***/ }),

/***/ "./src/protobuf-util.js":
/*!******************************!*\
  !*** ./src/protobuf-util.js ***!
  \******************************/
/***/ ((module) => {

eval("// Transforms a Protobuf enum to an API object according to the provided mapping. Resulting object\n// provides functions for a checked conversion between the protocol and API values\nfunction fromProtobufEnum(pbEnum, map, unknownVal) {\n\tconst mapToProtobuf = {};\n\tconst mapFromProtobuf = {};\n\tconst funcs = {\n\t\ttoProtobuf: (val) => {\n\t\t\tconst pbVal = mapToProtobuf[val.toLowerCase()];\n\t\t\tif (pbVal === undefined) {\n\t\t\t\tthrow new RangeError(`Invalid value: ${val}`);\n\t\t\t}\n\t\t\treturn pbVal;\n\t\t},\n\t\tfromProtobuf: (pbVal) => {\n\t\t\tconst val = mapFromProtobuf[pbVal];\n\t\t\tif (val === undefined) {\n\t\t\t\treturn (unknownVal !== undefined ? unknownVal : 'UNKNOWN');\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t};\n\tconst obj = Object.create(funcs);\n\tfor (const val in map) {\n\t\tconst pbName = map[val];\n\t\tconst pbVal = pbEnum[pbName];\n\t\tif (pbVal === undefined) {\n\t\t\tthrow new Error(`Unknown enum value: ${pbName}`);\n\t\t}\n\t\tconst v = val.toLowerCase();\n\t\tif (v in mapToProtobuf) {\n\t\t\tthrow new Error(`Duplicate value: ${val}`);\n\t\t}\n\t\tmapToProtobuf[v] = pbVal;\n\t\tmapFromProtobuf[pbVal] = val;\n\t\tobj[val] = val;\n\t}\n\treturn Object.freeze(obj);\n}\n\nfunction transformMessage(msg, map) {\n\tconst obj = {};\n\tfor (let name of Object.keys(msg)) { // Ignore prototype properties\n\t\tlet val = msg[name];\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m; // Rename property\n\t\t} else if (typeof m == 'function') {\n\t\t\tval = m(val); // Convert value\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name; // Rename property\n\t\t\t}\n\t\t\tif (m.value) {\n\t\t\t\tval = m.value(val); // Convert value\n\t\t\t}\n\t\t} else if (!m) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tif (val === undefined) {\n\t\t\tcontinue; // Skip property\n\t\t}\n\t\tobj[name] = val;\n\t}\n\treturn obj;\n}\n\nfunction checkFromProtobufMessageMap(pbMsgProto, map) {\n\tfor (const name in map) {\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction checkToProtobufMessageMap(pbMsgProto, map) {\n\tfor (let name in map) {\n\t\tconst m = map[name];\n\t\tif (typeof m == 'string') {\n\t\t\tname = m;\n\t\t} else if (typeof m == 'object') {\n\t\t\tif (m.name) {\n\t\t\t\tname = m.name;\n\t\t\t}\n\t\t}\n\t\tif (!Object.prototype.hasOwnProperty.call(pbMsgProto, name)) {\n\t\t\tthrow new Error(`Unknown message field: ${name}`);\n\t\t}\n\t}\n}\n\nfunction assignMessagePropertyMaps(obj, ...maps) {\n\tfor (let map of maps) {\n\t\tif (Array.isArray(map)) {\n\t\t\tmap = map.reduce((obj, name) => {\n\t\t\t\tobj[name] = true;\n\t\t\t\treturn obj;\n\t\t\t}, {});\n\t\t}\n\t\tObject.assign(obj, map);\n\t}\n\treturn obj;\n}\n\n// Returns a function that transforms a Protobuf message to an API object according to the provided mapping\nfunction fromProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckFromProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\n// Returns a function that transforms an API object to a Protobuf message according to the provided mapping\nfunction toProtobufMessage(pbMsg, ...maps) {\n\tconst map = assignMessagePropertyMaps({}, ...maps);\n\tcheckToProtobufMessageMap(pbMsg.prototype, map);\n\treturn msg => transformMessage(msg, map);\n}\n\nmodule.exports = {\n\tfromProtobufEnum,\n\tfromProtobufMessage,\n\ttoProtobufMessage\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/protobuf-util.js?");

/***/ }),

/***/ "./src/protocol.js":
/*!*************************!*\
  !*** ./src/protocol.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// This is a wrapper module for the generated protocol data\n\nconst proto = __webpack_require__(/*! ../lib/pb-message */ \"./lib/pb-message.js\");\n\nmodule.exports = proto.particle.ctrl;\n\n\n//# sourceURL=webpack://ParticleUsb/./src/protocol.js?");

/***/ }),

/***/ "./src/request.js":
/*!************************!*\
  !*** ./src/request.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const proto = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n// Mapping of request types to Protobuf messages\nconst Request = {\n\tGET_SERIAL_NUMBER: {\n\t\tid: 21,\n\t\trequest: proto.GetSerialNumberRequest,\n\t\treply: proto.GetSerialNumberReply\n\t},\n\tRESET: {\n\t\tid: 40\n\t},\n\tFACTORY_RESET: {\n\t\tid: 41\n\t},\n\tDFU_MODE: {\n\t\tid: 50\n\t},\n\tSAFE_MODE: {\n\t\tid: 60\n\t},\n\tSTART_LISTENING: {\n\t\tid: 70\n\t},\n\tSTOP_LISTENING: {\n\t\tid: 71\n\t},\n\tGET_DEVICE_MODE: {\n\t\tid: 72,\n\t\trequest: proto.GetDeviceModeRequest,\n\t\treply: proto.GetDeviceModeReply\n\t},\n\tSET_DEVICE_SETUP_DONE: {\n\t\tid: 73,\n\t\trequest: proto.SetDeviceSetupDoneRequest,\n\t\treply: proto.SetDeviceSetupDoneReply\n\t},\n\tLOG_CONFIG: {\n\t\tid: 80\n\t},\n\tMODULE_INFO: {\n\t\tid: 90\n\t},\n\tDIAGNOSTIC_INFO: {\n\t\tid: 100\n\t},\n\tWIFI_SET_ANTENNA: {\n\t\tid: 110,\n\t\trequest: proto.WiFiSetAntennaRequest,\n\t\treply: proto.WiFiSetAntennaReply\n\t},\n\tWIFI_GET_ANTENNA: {\n\t\tid: 111,\n\t\trequest: proto.WiFiGetAntennaRequest,\n\t\treply: proto.WiFiGetAntennaReply\n\t},\n\tWIFI_SCAN: {\n\t\tid: 112,\n\t\trequest: proto.WiFiScanRequest,\n\t\treply: proto.WiFiScanReply\n\t},\n\tWIFI_SET_CREDENTIALS: {\n\t\tid: 113,\n\t\trequest: proto.WiFiSetCredentialsRequest,\n\t\treply: proto.WiFiSetCredentialsReply\n\t},\n\tWIFI_GET_CREDENTIALS: {\n\t\tid: 114,\n\t\trequest: proto.WiFiGetCredentialsRequest,\n\t\treply: proto.WiFiGetCredentialsReply\n\t},\n\tWIFI_CLEAR_CREDENTIALS: {\n\t\tid: 115,\n\t\trequest: proto.WiFiClearCredentialsRequest,\n\t\treply: proto.WiFiClearCredentialsReply\n\t},\n\tNETWORK_SET_CONFIGURATION: {\n\t\tid: 120,\n\t\trequest: proto.NetworkSetConfigurationRequest,\n\t\treply: proto.NetworkSetConfigurationReply\n\t},\n\tNETWORK_GET_CONFIGURATION: {\n\t\tid: 121,\n\t\trequest: proto.NetworkGetConfigurationRequest,\n\t\treply: proto.NetworkGetConfigurationReply\n\t},\n\tNETWORK_GET_STATUS: {\n\t\tid: 122,\n\t\trequest: proto.NetworkGetStatusRequest,\n\t\treply: proto.NetworkGetStatusReply\n\t},\n\tSET_CLAIM_CODE: {\n\t\tid: 200,\n\t\trequest: proto.SetClaimCodeRequest,\n\t\treply: proto.SetClaimCodeReply\n\t},\n\tIS_CLAIMED: {\n\t\tid: 201,\n\t\trequest: proto.IsClaimedRequest,\n\t\treply: proto.IsClaimedReply\n\t},\n\tSET_SECURITY_KEY: {\n\t\tid: 210,\n\t\trequest: proto.SetSecurityKeyRequest,\n\t\treply: proto.SetSecurityKeyReply\n\t},\n\tGET_SECURITY_KEY: {\n\t\tid: 211,\n\t\trequest: proto.GetSecurityKeyRequest,\n\t\treply: proto.GetSecurityKeyReply\n\t},\n\tSET_SERVER_ADDRESS: {\n\t\tid: 220,\n\t\trequest: proto.SetServerAddressRequest,\n\t\treply: proto.SetServerAddressReply\n\t},\n\tGET_SERVER_ADDRESS: {\n\t\tid: 221,\n\t\trequest: proto.GetServerAddressRequest,\n\t\treply: proto.GetServerAddressReply\n\t},\n\tSET_SERVER_PROTOCOL: {\n\t\tid: 222,\n\t\trequest: proto.SetServerProtocolRequest,\n\t\treply: proto.SetServerProtocolReply\n\t},\n\tGET_SERVER_PROTOCOL: {\n\t\tid: 223,\n\t\trequest: proto.GetServerProtocolRequest,\n\t\treply: proto.GetServerProtocolReply\n\t},\n\tSTART_NYAN_SIGNAL: {\n\t\tid: 230\n\t},\n\tSTOP_NYAN_SIGNAL: {\n\t\tid: 231\n\t},\n\tSET_SOFTAP_SSID: {\n\t\tid: 240,\n\t\trequest: proto.SetSoftApSsidRequest,\n\t\treply: proto.SetSoftApSsidReply\n\t},\n\tSTART_FIRMWARE_UPDATE: {\n\t\tid: 250,\n\t\trequest: proto.StartFirmwareUpdateRequest,\n\t\treply: proto.StartFirmwareUpdateReply\n\t},\n\tFINISH_FIRMWARE_UPDATE: {\n\t\tid: 251,\n\t\trequest: proto.FinishFirmwareUpdateRequest,\n\t\treply: proto.FinishFirmwareUpdateReply\n\t},\n\tCANCEL_FIRMWARE_UPDATE: {\n\t\tid: 252,\n\t\trequest: proto.CancelFirmwareUpdateRequest,\n\t\treply: proto.CancelFirmwareUpdateReply\n\t},\n\tFIRMWARE_UPDATE_DATA: {\n\t\tid: 253,\n\t\trequest: proto.FirmwareUpdateDataRequest,\n\t\treply: proto.FirmwareUpdateDataReply\n\t},\n\tDESCRIBE_STORAGE: {\n\t\tid: 260,\n\t\trequest: proto.DescribeStorageRequest,\n\t\treply: proto.DescribeStorageReply\n\t},\n\tREAD_SECTION_DATA: {\n\t\tid: 261,\n\t\trequest: proto.ReadSectionDataRequest,\n\t\treply: proto.ReadSectionDataReply\n\t},\n\tWRITE_SECTION_DATA: {\n\t\tid: 262,\n\t\trequest: proto.WriteSectionDataRequest,\n\t\treply: proto.WriteSectionDataReply\n\t},\n\tCLEAR_SECTION_DATA: {\n\t\tid: 263,\n\t\trequest: proto.ClearSectionDataRequest,\n\t\treply: proto.ClearSectionDataReply\n\t},\n\tGET_SECTION_DATA_SIZE: {\n\t\tid: 264,\n\t\trequest: proto.GetSectionDataSizeRequest,\n\t\treply: proto.GetSectionDataSizeReply\n\t},\n\t// Cloud connectivity\n\tCLOUD_STATUS: {\n\t\tid: 300,\n\t\trequest: proto.cloud.GetConnectionStatusRequest,\n\t\treply: proto.cloud.GetConnectionStatusReply\n\t},\n\tCLOUD_CONNECT: {\n\t\tid: 301,\n\t\trequest: proto.cloud.ConnectRequest,\n\t\treply: proto.cloud.ConnectReply\n\t},\n\tCLOUD_DISCONNECT: {\n\t\tid: 302,\n\t\trequest: proto.cloud.DisconnectRequest,\n\t\treply: proto.cloud.DisconnectReply\n\t},\n\t// Cellular-specific requests\n\tCELLULAR_GET_ICCID: {\n\t\tid: 554,\n\t\trequest: proto.cellular.GetIccidRequest,\n\t\treply: proto.cellular.GetIccidReply\n\t},\n\t// Logging configuration\n\tADD_LOG_HANDLER: {\n\t\tid: 1100,\n\t\trequest: proto.logging.AddLogHandlerRequest,\n\t\treply: proto.logging.AddLogHandlerReply\n\t},\n\tREMOVE_LOG_HANDLER: {\n\t\tid: 1101,\n\t\trequest: proto.logging.RemoveLogHandlerRequest,\n\t\treply: proto.logging.RemoveLogHandlerReply\n\t},\n\tGET_LOG_HANDLERS: {\n\t\tid: 1102,\n\t\trequest: proto.logging.GetLogHandlersRequest,\n\t\treply: proto.logging.GetLogHandlersReply\n\t}\n};\n\nmodule.exports = {\n\tRequest\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/request.js?");

/***/ }),

/***/ "./src/result.js":
/*!***********************!*\
  !*** ./src/result.js ***!
  \***********************/
/***/ ((module) => {

eval("// Result codes as defined by the firmware's system_error_t enum\nconst RESULT_CODES = [\n\t{\n\t\tid: 'OK',\n\t\tvalue: 0,\n\t\tmessage: 'Operation succeeded'\n\t},\n\t{\n\t\tid: 'ERROR',\n\t\tvalue: -100,\n\t\tmessage: 'Unknown error'\n\t},\n\t{\n\t\tid: 'BUSY',\n\t\tvalue: -110,\n\t\tmessage: 'Resource is busy'\n\t},\n\t{\n\t\tid: 'NOT_SUPPORTED',\n\t\tvalue: -120,\n\t\tmessage: 'Not supported'\n\t},\n\t{\n\t\tid: 'NOT_ALLOWED',\n\t\tvalue: -130,\n\t\tmessage: 'Not allowed'\n\t},\n\t{\n\t\tid: 'CANCELLED',\n\t\tvalue: -140,\n\t\tmessage: 'Operation cancelled'\n\t},\n\t{\n\t\tid: 'ABORTED',\n\t\tvalue: -150,\n\t\tmessage: 'Operation aborted'\n\t},\n\t{\n\t\tid: 'TIMEOUT_ERROR',\n\t\tvalue: -160,\n\t\tmessage: 'Timeout error'\n\t},\n\t{\n\t\tid: 'NOT_FOUND',\n\t\tvalue: -170,\n\t\tmessage: 'Not found'\n\t},\n\t{\n\t\tid: 'ALREADY_EXISTS',\n\t\tvalue: -180,\n\t\tmessage: 'Already exists'\n\t},\n\t{\n\t\tid: 'TOO_LARGE',\n\t\tvalue: -190,\n\t\tmessage: 'Data is too large'\n\t},\n\t{\n\t\tid: 'LIMIT_EXCEEDED',\n\t\tvalue: -200,\n\t\tmessage: 'Limit exceeded'\n\t},\n\t{\n\t\tid: 'INVALID_STATE',\n\t\tvalue: -210,\n\t\tmessage: 'Invalid state'\n\t},\n\t{\n\t\tid: 'IO_ERROR',\n\t\tvalue: -220,\n\t\tmessage: 'IO error'\n\t},\n\t{\n\t\tid: 'NETWORK_ERROR',\n\t\tvalue: -230,\n\t\tmessage: 'Network error'\n\t},\n\t{\n\t\tid: 'PROTOCOL_ERROR',\n\t\tvalue: -240,\n\t\tmessage: 'Protocol error'\n\t},\n\t{\n\t\tid: 'INTERNAL_ERROR',\n\t\tvalue: -250,\n\t\tmessage: 'Internal error'\n\t},\n\t{\n\t\tid: 'NO_MEMORY',\n\t\tvalue: -260,\n\t\tmessage: 'Memory allocation error'\n\t},\n\t{\n\t\tid: 'INVALID_ARGUMENT',\n\t\tvalue: -270,\n\t\tmessage: 'Invalid argument'\n\t},\n\t{\n\t\tid: 'BAD_DATA',\n\t\tvalue: -280,\n\t\tmessage: 'Invalid data format'\n\t},\n\t{\n\t\tid: 'OUT_OF_RANGE',\n\t\tvalue: -290,\n\t\tmessage: 'Out of range'\n\t}\n];\n\n// Result code messages\nconst RESULT_CODE_MESSAGES = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.value] = result.message;\n\treturn obj;\n}, {});\n\n/**\n * Request result codes.\n *\n * @enum {Number}\n */\nconst Result = RESULT_CODES.reduce((obj, result) => {\n\tobj[result.id] = result.value;\n\treturn obj;\n}, {});\n\n/**\n * Return a message for the result code.\n *\n * @param {Number} result Result code.\n * @return {String} Error message.\n */\nfunction messageForResultCode(result) {\n\treturn (RESULT_CODE_MESSAGES[result] || 'Request error');\n}\n\nmodule.exports = {\n\tResult,\n\tmessageForResultCode\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/result.js?");

/***/ }),

/***/ "./src/set-device-prototype.js":
/*!*************************************!*\
  !*** ./src/set-device-prototype.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { PLATFORMS } = __webpack_require__(/*! ./platforms */ \"./src/platforms.js\");\nconst { Device } = __webpack_require__(/*! ./device */ \"./src/device.js\");\nconst { WifiDevice } = __webpack_require__(/*! ./wifi-device */ \"./src/wifi-device.js\");\nconst { WifiDeviceLegacy } = __webpack_require__(/*! ./wifi-device-legacy */ \"./src/wifi-device-legacy.js\");\nconst { CellularDevice } = __webpack_require__(/*! ./cellular-device */ \"./src/cellular-device.js\");\nconst { CloudDevice } = __webpack_require__(/*! ./cloud-device */ \"./src/cloud-device.js\");\nconst { Gen3Device } = __webpack_require__(/*! ./gen3-device */ \"./src/gen3-device.js\");\nconst { NetworkDevice } = __webpack_require__(/*! ./network-device */ \"./src/network-device.js\");\nconst { DfuDevice } = __webpack_require__(/*! ./dfu-device */ \"./src/dfu-device.js\");\n\n/**\n * This constant has a structure like this:\n//   photon: klass {},\n//   electron: klass {},\n//   p2: klass {},\n//   ...\n// }\n */\nconst DEVICE_CLASSES = PLATFORMS.reduce((classes, platform) => {\n\tlet klass = class extends NetworkDevice(Device) {};\n\tif (platform.generation === 3) {\n\t\tklass = class extends Gen3Device(klass) {};\n\t}\n\tif (platform.features.includes('cellular')) {\n\t\tklass = class extends CellularDevice(klass) {};\n\t}\n\tif (platform.features.includes('wifi')) {\n\t\tif (platform.generation === 2 || platform.generation === 1) {\n\t\t\tklass = class extends WifiDeviceLegacy(klass) {};\n\t\t} else {\n\t\t\tklass = class extends WifiDevice(klass) {};\n\t\t}\n\t}\n\tklass = class extends CloudDevice(klass) {};\n\n\tclasses[platform.name] = klass;\n\n\treturn classes;\n}, {});\n\n\n\n/**\n * Determines the the class and inheritance hierarchy\n * of a Particle USB device based on it's platform characteristics *\n * @param {*} usbDevice - An object with a .type field that is a string like \"p1\", \"argon\", \"p2\", etc\n * \t\t\t\t\t\t  representing the short name of the device platform.\n * @returns {*} an instance of a class like WifiDevice, CellularDevice with the correct inheritance hierachy\n */\nfunction setDevicePrototype(usbDevice) {\n\tlet klass = DEVICE_CLASSES[usbDevice.type];\n\tif (!klass) {\n\t\treturn usbDevice;\n\t}\n\t// if usb device is in dfu mode, we could also add the prototype for the dfu device\n\tif (usbDevice.isInDfuMode) {\n\t\tklass = class extends DfuDevice(klass){};\n\t\treturn Object.setPrototypeOf(usbDevice, klass.prototype);\n\t} else {\n\t\treturn Object.setPrototypeOf(usbDevice, klass.prototype);\n\t}\n}\n\nmodule.exports = {\n\tsetDevicePrototype\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/set-device-prototype.js?");

/***/ }),

/***/ "./src/usb-device-webusb.js":
/*!**********************************!*\
  !*** ./src/usb-device-webusb.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { UsbError, UsbStallError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n// Maximum size of a control transfer's data stage\nconst MAX_CONTROL_TRANSFER_DATA_SIZE = 4096;\n\nfunction bmRequestTypeToString(type) {\n\ttype = (type >> 5) & 0x03;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'standard';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'class';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'vendor';\n\t\t}\n\t\tdefault: {\n\t\t\treturn 'unknown';\n\t\t}\n\t}\n}\n\nfunction bmRequestTypeToRecipientString(type) {\n\ttype = type & 0x0f;\n\tswitch (type) {\n\t\tcase 0: {\n\t\t\treturn 'device';\n\t\t}\n\t\tcase 1: {\n\t\t\treturn 'interface';\n\t\t}\n\t\tcase 2: {\n\t\t\treturn 'endpoint';\n\t\t}\n\t\tcase 3:\n\t\tdefault: {\n\t\t\treturn 'other';\n\t\t}\n\t}\n}\n\nclass UsbDevice {\n\tconstructor(dev) {\n\t\tthis._dev = dev;\n\t\tthis._dev.timeout = 5000; // Use longer timeout for control transfers\n\t\tthis._quirks = {};\n\t}\n\n\tasync open() {\n\t\ttry {\n\t\t\tawait this._dev.open();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Unable to open USB device', { cause: err });\n\t\t}\n\t}\n\n\tasync close() {\n\t\ttry {\n\t\t\tawait this._dev.close();\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Unable to close USB device', { cause: err });\n\t\t}\n\t}\n\tasync transferIn(setup) {\n\t\tlet res;\n\t\ttry {\n\t\t\tres = await this._dev.controlTransferIn({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, setup.wLength);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('IN control transfer failed', { cause: err });\n\t\t}\n\t\tif (res.status !== 'ok') {\n\t\t\tif (res.status === 'stall') {\n\t\t\t\tthrow new UsbStallError('Transfer stalled');\n\t\t\t}\n\t\t\tthrow new Error(`Status: ${res.status}`);\n\t\t}\n\t\treturn Buffer.from(res.data.buffer);\n\t}\n\n\tasync transferOut(setup, data) {\n\t\tlet res;\n\t\ttry {\n\t\t\tif (!data && this._quirks.controlOutTransfersRequireDataStage) {\n\t\t\t\tdata = Buffer.alloc(1);\n\t\t\t}\n\t\t\tres = await this._dev.controlTransferOut({\n\t\t\t\trequestType: bmRequestTypeToString(setup.bmRequestType),\n\t\t\t\trecipient: bmRequestTypeToRecipientString(setup.bmRequestType),\n\t\t\t\trequest: setup.bRequest,\n\t\t\t\tvalue: setup.wValue,\n\t\t\t\tindex: setup.wIndex\n\t\t\t}, data); // data is optional\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('OUT control transfer failed', { cause: err });\n\t\t}\n\t\tif (res.status !== 'ok') {\n\t\t\tif (res.status === 'stall') {\n\t\t\t\tthrow new UsbStallError('Transfer stalled');\n\t\t\t}\n\t\t\tthrow new Error(`Status: ${res.status}`);\n\t\t}\n\t}\n\n\tasync claimInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.claimInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to claim interface', { cause: err });\n\t\t}\n\t}\n\n\tasync releaseInterface(intrface) {\n\t\ttry {\n\t\t\tawait this._dev.releaseInterface(intrface);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to release interface', { cause: err });\n\t\t}\n\t}\n\n\tasync setAltSetting(intrface, setting) {\n\t\ttry {\n\t\t\tawait this._dev.selectAlternateInterface(intrface, setting);\n\t\t} catch (err) {\n\t\t\tthrow new UsbError('Failed to set alt setting', { cause: err });\n\t\t}\n\t}\n\n\tget vendorId() {\n\t\treturn this._dev.vendorId;\n\t}\n\n\tget productId() {\n\t\treturn this._dev.productId;\n\t}\n\n\tget serialNumber() {\n\t\treturn this._dev.serialNumber;\n\t}\n\n\tget isOpen() {\n\t\treturn this._dev.opened;\n\t}\n\n\tget internalObject() {\n\t\treturn this._dev;\n\t}\n\n\tget quirks() {\n\t\treturn this._quirks;\n\t}\n\n\tset quirks(qs) {\n\t\tthis._quirks = qs;\n\t}\n}\n\nasync function getUsbDevices(filters) {\n\tif (filters) {\n\t\t// Validate filtering options\n\t\tfilters.forEach(f => {\n\t\t\tif (f.productId && !f.vendorId) {\n\t\t\t\tthrow new RangeError('Vendor ID is missing');\n\t\t\t}\n\t\t});\n\t} else {\n\t\tfilters = [];\n\t}\n\tlet devs = [];\n\ttry {\n\t\t// Fow now, always ask the user to grant access to the device, even if we already have a\n\t\t// permission to access it. The permissions API for USB is not yet implemented in Chrome,\n\t\t// and calling requestDevice() after getDevices() causes a SecurityError.\n\t\t// TODO: Implement a separate API to request a permission from the user\n\t\tlet newDev = null;\n\t\ttry {\n\t\t\tnewDev = await navigator.usb.requestDevice({ filters });\n\t\t} catch (e) {\n\t\t\t// Ignore NotFoundError which means that the user has cancelled the request\n\t\t\tif (e.name !== 'NotFoundError') {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t\t// Get the list of known devices and filter them according to the provided options\n\t\tdevs = await navigator.usb.getDevices();\n\t\tif (filters.length > 0) {\n\t\t\tdevs = devs.filter(dev => filters.some(f => ((!f.vendorId || dev.vendorId === f.vendorId) &&\n\t\t\t\t\t(!f.productId || dev.productId === f.productId) &&\n\t\t\t\t\t(!f.serialNumber || dev.serialNumber === f.serialNumber))));\n\t\t}\n\t\tif (newDev) {\n\t\t\t// Avoid listing the same device twice\n\t\t\tconst hasNewDev = devs.some(dev => dev.vendorId === newDev.vendorId && dev.productId === newDev.productId &&\n\t\t\t\t\tdev.serialNumber === newDev.serialNumber);\n\t\t\tif (!hasNewDev) {\n\t\t\t\tdevs.push(newDev);\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\tthrow new UsbError('Unable to enumerate USB devices', { cause: err });\n\t}\n\tdevs = devs.map(dev => new UsbDevice(dev));\n\treturn devs;\n}\n\nmodule.exports = {\n\tMAX_CONTROL_TRANSFER_DATA_SIZE,\n\tUsbDevice,\n\tgetUsbDevices\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-device-webusb.js?");

/***/ }),

/***/ "./src/usb-protocol.js":
/*!*****************************!*\
  !*** ./src/usb-protocol.js ***!
  \*****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\nconst { ProtocolError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n// Service request types\nconst ServiceType = {\n\tINIT: 1,\n\tCHECK: 2,\n\tSEND: 3,\n\tRECV: 4,\n\tRESET: 5\n};\n\n// Field flags\nconst FieldFlag = {\n\tSTATUS: 0x01,\n\tID: 0x02,\n\tSIZE: 0x04,\n\tRESULT: 0x08\n};\n\n// Status codes\nconst Status = {\n\tOK: 0,\n\tERROR: 1,\n\tPENDING: 2,\n\tBUSY: 3,\n\tNO_MEMORY: 4,\n\tNOT_FOUND: 5\n};\n\n// Values of the bmRequestType field used by the protocol\nconst BmRequestType = {\n\tHOST_TO_DEVICE: 0x40, // 01000000b (direction: host-to-device; type: vendor; recipient: device)\n\tDEVICE_TO_HOST: 0xc0 // 11000000b (direction: device_to_host; type: vendor; recipient: device)\n};\n\n// Value of the bRequest field for Particle vendor requests\nconst PARTICLE_BREQUEST = 0x50; // ASCII code of the character 'P'\n\n// Minimum length of the data stage for high-speed USB devices\nconst MIN_WLENGTH = 64;\n\n// Misc. constraints defined by the protocol and the USB specification\nconst MAX_REQUEST_ID = 0xffff;\nconst MAX_REQUEST_TYPE = 0xffff;\nconst MAX_PAYLOAD_SIZE = 0xffff;\n\n// Returns the setup packet fields for the INIT service request\nfunction initRequest(reqType, dataSize = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.INIT,\n\t\twIndex: reqType, // Request type\n\t\twValue: dataSize, // Payload size\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the CHECK service request\nfunction checkRequest(reqId) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.CHECK,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Returns the setup packet fields for the SEND service request\nfunction sendRequest(reqId, dataSize) {\n\treturn {\n\t\t// SEND is the only host-to-device service request defined by the protocol\n\t\tbmRequestType: BmRequestType.HOST_TO_DEVICE,\n\t\tbRequest: ServiceType.SEND,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RECV service request\nfunction recvRequest(reqId, dataSize) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RECV,\n\t\twIndex: reqId, // Request ID\n\t\twValue: 0, // Not used\n\t\twLength: dataSize // Payload size\n\t};\n}\n\n// Returns the setup packet fields for the RESET service request\nfunction resetRequest(reqId = 0) {\n\treturn {\n\t\tbmRequestType: BmRequestType.DEVICE_TO_HOST,\n\t\tbRequest: ServiceType.RESET,\n\t\twIndex: reqId, // Request ID (can be set to 0 to reset all requests)\n\t\twValue: 0, // Not used\n\t\twLength: MIN_WLENGTH\n\t};\n}\n\n// Parses service reply data\nfunction parseReply(data) {\n\ttry {\n\t\tconst rep = {};\n\t\tlet offs = 0;\n\t\t// Field flags (4 bytes)\n\t\trep.flags = data.readUInt32LE(offs);\n\t\toffs += 4;\n\t\t// Status code (2 bytes)\n\t\tif (!(rep.flags & FieldFlag.STATUS)) {\n\t\t\tthrow new ProtocolError('Service reply is missing mandatory status field');\n\t\t}\n\t\trep.status = data.readUInt16LE(offs);\n\t\toffs += 2;\n\t\t// Request ID (2 bytes, optional)\n\t\tif (rep.flags & FieldFlag.ID) {\n\t\t\trep.id = data.readUInt16LE(offs);\n\t\t\toffs += 2;\n\t\t}\n\t\t// Payload size (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.SIZE) {\n\t\t\trep.size = data.readUInt32LE(offs);\n\t\t\toffs += 4;\n\t\t}\n\t\t// Result code (4 bytes, optional)\n\t\tif (rep.flags & FieldFlag.RESULT) {\n\t\t\trep.result = data.readInt32LE(offs); // Signed\n\t\t\toffs += 4;\n\t\t}\n\t\treturn rep;\n\t} catch (err) {\n\t\tif (!(err instanceof ProtocolError)) {\n\t\t\tthrow new ProtocolError('Unable to parse service reply', { cause: err });\n\t\t}\n\t\tthrow err;\n\t}\n}\n\n// Serializes service reply data\nfunction encodeReply(rep) {\n\tlet flags = FieldFlag.STATUS; // Status code is a mandatory field\n\tlet size = 6; // 4 bytes for field flags and 2 bytes for status code\n\tif ('id' in rep) {\n\t\tflags |= FieldFlag.ID;\n\t\tsize += 2;\n\t}\n\tif ('size' in rep) {\n\t\tflags |= FieldFlag.SIZE;\n\t\tsize += 4;\n\t}\n\tif ('result' in rep) {\n\t\tflags |= FieldFlag.RESULT;\n\t\tsize += 4;\n\t}\n\tconst data = Buffer.alloc(size);\n\tlet offs = 0;\n\t// Field flags (4 bytes)\n\tdata.writeUInt32LE(flags, offs);\n\toffs += 4;\n\t// Status code (2 bytes)\n\tdata.writeUInt16LE(rep.status, offs);\n\toffs += 2;\n\t// Request ID (2 bytes, optional)\n\tif (flags & FieldFlag.ID) {\n\t\tdata.writeUInt16LE(rep.id, offs);\n\t\toffs += 2;\n\t}\n\t// Payload size (4 bytes, optional)\n\tif (flags & FieldFlag.SIZE) {\n\t\tdata.writeUInt32LE(rep.size, offs);\n\t\toffs += 4;\n\t}\n\t// Result code (4 bytes, optional)\n\tif (flags & FieldFlag.RESULT) {\n\t\tdata.writeInt32LE(rep.result, offs); // Signed\n\t\toffs += 4;\n\t}\n\treturn data;\n}\n\nmodule.exports = {\n\tServiceType,\n\tFieldFlag,\n\tStatus,\n\tBmRequestType,\n\tPARTICLE_BREQUEST,\n\tMIN_WLENGTH,\n\tMAX_REQUEST_ID,\n\tMAX_REQUEST_TYPE,\n\tMAX_PAYLOAD_SIZE,\n\tinitRequest,\n\tcheckRequest,\n\tsendRequest,\n\trecvRequest,\n\tresetRequest,\n\tparseReply,\n\tencodeReply\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/usb-protocol.js?");

/***/ }),

/***/ "./src/wifi-device-legacy.js":
/*!***********************************!*\
  !*** ./src/wifi-device-legacy.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * All of the functionality in this class is deprecated.\n * However, it can still be used on Paticle Photon devices running\n * Device OS systems firmware from 0.8.0 to pre 2.0.0.\n */\nconst { Request } = __webpack_require__(/*! ./request */ \"./src/request.js\");\nconst { fromProtobufEnum, fromProtobufMessage, toProtobufMessage } = __webpack_require__(/*! ./protobuf-util */ \"./src/protobuf-util.js\");\n\nconst proto = __webpack_require__(/*! ./protocol */ \"./src/protocol.js\");\n\n/**\n * WiFi antenna types.\n */\nconst WifiAntenna = fromProtobufEnum(proto.WiFiAntenna, {\n\tINTERNAL: 'INTERNAL',\n\tEXTERNAL: 'EXTERNAL',\n\tAUTO: 'AUTO'\n});\n\n/**\n * WiFi security types.\n */\nconst WifiSecurity = fromProtobufEnum(proto.WiFiSecurityType, {\n\tNONE: 'UNSEC',\n\tWEP: 'WEP',\n\tWPA: 'WPA',\n\tWPA2: 'WPA2',\n\tWPA_ENTERPRISE: 'WPA_ENTERPRISE',\n\tWPA2_ENTERPRISE: 'WPA2_ENTERPRISE',\n\tUNKNOWN: 'UNKNOWN'\n});\n\n/**\n * WiFi cipher types.\n */\nconst WifiCipher = fromProtobufEnum(proto.WiFiSecurityCipher, {\n\tAES: 'AES',\n\tTKIP: 'TKIP',\n\tAES_TKIP: 'AES_TKIP'\n});\n\n/**\n * EAP methods.\n */\nconst EapMethod = fromProtobufEnum(proto.EapType, {\n\tTLS: 'TLS',\n\tPEAP: 'PEAP'\n});\n\nfunction bssidFromProtobuf(bssid) {\n\treturn [...bssid].map(b => b.toString(16).padStart(2, '0')).join(':');\n}\n\nfunction bssidToProtobuf(bssid) {\n\treturn Buffer.from(bssid.replace(/:/g, ''), 'hex');\n}\n\nconst accessPointCommonProperties = ['ssid', 'channel', 'maxDataRate', 'rssi', 'password', 'innerIdentity',\n\t'outerIdentity', 'privateKey', 'clientCertificate', 'caCertificate'];\n\nconst accessPointFromProtobuf = fromProtobufMessage(proto.WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidFromProtobuf,\n\tsecurity: WifiSecurity.fromProtobuf,\n\tcipher: WifiCipher.fromProtobuf,\n\teapType: {\n\t\tname: 'eapMethod',\n\t\tvalue: EapMethod.fromProtobuf\n\t}\n});\n\nconst accessPointToProtobuf = toProtobufMessage(proto.WiFiAccessPoint, accessPointCommonProperties, {\n\tbssid: bssidToProtobuf,\n\tsecurity: WifiSecurity.toProtobuf,\n\tcipher: WifiCipher.toProtobuf,\n\teapMethod: {\n\t\tname: 'eapType',\n\t\tvalue: EapMethod.toProtobuf\n\t}\n});\n\n/**\n * Wi-Fi device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst WifiDeviceLegacy = base => class extends base {\n\t/**\n\t * Set the WiFi antenna to use.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {String} antenna Antenna type.\n\t * @return {Promise}\n\t */\n\tsetWifiAntenna(antenna) {\n\t\treturn this.sendRequest(Request.WIFI_SET_ANTENNA, {\n\t\t\tantenna: WifiAntenna.toProtobuf(antenna)\n\t\t});\n\t}\n\n\t/**\n\t * Get the currently used WiFi antenna.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<String>}\n\t */\n\tgetWifiAntenna(/* antenna */) {\n\t\treturn this.sendRequest(Request.WIFI_GET_ANTENNA).then(rep => {\n\t\t\treturn WifiAntenna.fromProtobuf(rep.antenna);\n\t\t});\n\t}\n\n\t/**\n\t * Perform the WiFi scan.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tscanWifiNetworks() {\n\t\treturn this.sendRequest(Request.WIFI_SCAN).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Set the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @param {Object} credentials Credentials.\n\t * @return {Promise}\n\t */\n\tsetWifiCredentials(credentials) {\n\t\treturn this.sendRequest(Request.WIFI_SET_CREDENTIALS, {\n\t\t\tap: accessPointToProtobuf(credentials)\n\t\t});\n\t}\n\n\t/**\n\t * Get the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise<Array>}\n\t */\n\tgetWifiCredentials() {\n\t\treturn this.sendRequest(Request.WIFI_GET_CREDENTIALS).then(rep => {\n\t\t\tif (!rep.list) {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t\treturn rep.list.aps.map(ap => accessPointFromProtobuf(ap));\n\t\t});\n\t}\n\n\t/**\n\t * Clear the WiFi credentials.\n\t *\n\t * @deprecated This method is not guaranteed to work with recent versions of Device OS and it will\n\t *             be removed in future versions of this library.\n\t *\n\t * Supported platforms:\n\t * - Gen 2 (since Device OS 0.8.0, deprecated in 2.0.0)\n\t *\n\t * @return {Promise}\n\t */\n\tclearWifiCredentials() {\n\t\treturn this.sendRequest(Request.WIFI_CLEAR_CREDENTIALS);\n\t}\n};\n\nmodule.exports = {\n\tWifiAntenna,\n\tWifiSecurity,\n\tWifiCipher,\n\tEapMethod,\n\tWifiDeviceLegacy\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/wifi-device-legacy.js?");

/***/ }),

/***/ "./src/wifi-device.js":
/*!****************************!*\
  !*** ./src/wifi-device.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const DeviceOSProtobuf = __webpack_require__(/*! @particle/device-os-protobuf */ \"./node_modules/@particle/device-os-protobuf/src/index.js\");\nconst { TimeoutError } = __webpack_require__(/*! ./error */ \"./src/error.js\");\n\n/**\n * Wi-Fi device.\n *\n * This class is not meant to be instantiated directly. Use {@link getDevices} and\n * {@link openDeviceById} to create device instances.\n *\n * @mixin\n */\nconst WifiDevice = base => class extends base {\n\t/**\n\t * Perform WiFi scan for Gen 3+ devices\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {Promise[Object]} - Each object in array has these properties: ssid, bssid, security, channel, rssi. See Network protobuf message from https://github.com/particle-iot/device-os-protobuf for more details.\n\t */\n\tasync scanWifiNetworks(options) {\n\t\tconst result = await this._sendAndHandleProtobufRequest(\n\t\t\t'wifi.ScanNetworksRequest',\n\t\t\t{},\n\t\t\toptions\n\t\t);\n\n\t\tlet returnThis;\n\t\tif (result.pass) {\n\t\t\treturnThis = result.replyObject.networks.map((network) => {\n\t\t\t\treturn {\n\t\t\t\t\tssid: network.ssid || null, // can be blank for hidden networks\n\t\t\t\t\tbssid: network.bssid.toString('hex'), // convert buffer to hex string\n\t\t\t\t\tsecurity: this._mapSecurityValueToString(network.security),\n\t\t\t\t\tchannel: network.channel,\n\t\t\t\t\trssi: network.rssi\n\t\t\t\t};\n\t\t\t});\n\t\t} else {\n\t\t\treturnThis = [];\n\t\t}\n\t\treturn returnThis;\n\t}\n\n\t// Internal helper that transforms int or undefined into a string\n\t// for security field from scanWifiNetworks\n\t_mapSecurityValueToString(value) {\n\t\tif (value === undefined) {\n\t\t\treturn 'UNKNOWN';\n\t\t}\n\t\tconst wifiSecurityEnum = DeviceOSProtobuf.getDefinition('wifi.Security').message;\n\t\tconst firstMatchingKey = Object.keys(wifiSecurityEnum).find(key => wifiSecurityEnum[key] === value);\n\t\tif (firstMatchingKey === undefined) {\n\t\t\treturn 'UNKNOWN';\n\t\t} else {\n\t\t\treturn firstMatchingKey;\n\t\t}\n\t}\n\n\t/**\n\t * Join a new WiFi network for Gen 3+ devices.\n\t *\n\t * Note, there are known bugs with this method/Device OS:\n\t *   - sc-96270: where P2's don't do anything with bssid or security fields; so cannot connect to hidden networks\n\t *   - sc-96826: Connecting to open network without passsword does not work\n\t *\n\t * Supported platforms:\n\t * - Gen 4: Supported on P2 since Device OS 3.x\n\t * @param {string} ssid - SSID of Wifi Network\n\t * @param {string} password - Password of Wifi network, if not set will not use security\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} -\n\t */\n\tasync joinNewWifiNetwork({ ssid, password = null }, options) {\n\t\tlet dataPayload;\n\t\tif (password === null) {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\tsecurity: 0 // Security.NO_SECURITY\n\t\t\t};\n\t\t\tthrow new Error('joinNewWifiNetwork() does not currently support connecting to networks without a password/security, sc-TODO');\n\t\t} else {\n\t\t\tdataPayload = {\n\t\t\t\tssid,\n\t\t\t\tbssid: null,\n\t\t\t\tsecurity: null,\n\t\t\t\tcredentials: {\n\t\t\t\t\ttype: 1, // CredentialsType.PASSWORD\n\t\t\t\t\tpassword\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn await this._sendAndHandleProtobufRequest(\n\t\t\t'wifi.JoinNewNetworkRequest',\n\t\t\tdataPayload,\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Clear Wifi networks for Gen 3+ devices\n\t *\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} -\n\t */\n\n\tasync clearWifiNetworks(options) {\n\t\treturn await this._sendAndHandleProtobufRequest(\n\t\t\t'wifi.ClearKnownNetworksRequest',\n\t\t\t{},\n\t\t\toptions\n\t\t);\n\t}\n\n\t/**\n\t * Returned by _sendAndHandleProtobufRequest\n\t * @typedef {Object} ProtobufInteraction\n\t * @property {boolean} pass - Indicates whether the request/reply succeeded\n\t * @property {undefined|*} replyObject - An instance created via the protobuf replyMessage constructor\n\t * @property {undefined|string} error - If pass is false, will be a string explaining failure reason\n\t */\n\n\t/**\n\t * Wraps .sendProtobufRequest, handles validation and error handling in opinionated way\n\t * to DRY up code in higher level methods\n\t *\n\t * @private could conceivably be added to public api in device.js later.\n\t *\n\t * @param {String} protobufMessageName - name of protobuf message see DeviceOSProtobuf.getDefinitions() to possible values\n\t * @param {Object} protobufMessageData - An object of key/values to encode into the protobuf message\n\t * @param {Object} options See sendControlRequest(), same options are here.\n\t * @return {ProtobufInteraction} - Summary of request/reply object\n\t * @throws {*} - Throws errors considered abnormal, catches TimeoutError which is considered normal type of\n\t *               failure/did-not-suceed for many Device OS requests\n\t */\n\tasync _sendAndHandleProtobufRequest(protobufMessageName, protobufMessageData = {}, options) {\n\t\tconst protobufDefinition = DeviceOSProtobuf.getDefinition(protobufMessageName);\n\t\tconst returnThis = {};\n\n\t\tlet replyObject;\n\t\ttry {\n\t\t\treplyObject = await this.sendProtobufRequest(\n\t\t\t\tprotobufMessageName,\n\t\t\t\tprotobufMessageData,\n\t\t\t\toptions\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tif (error instanceof TimeoutError) {\n\t\t\t\treturnThis.pass = false;\n\t\t\t\tif (options && options.timeout) {\n\t\t\t\t\treturnThis.error = `Request timed out, exceeded ${options.timeout}ms`;\n\t\t\t\t} else {\n\t\t\t\t\treturnThis.error = `Request timed out, exceeded default timeout`;\n\t\t\t\t}\n\t\t\t\treturn returnThis;\n\t\t\t}\n\t\t\tthrow error;\n\t\t}\n\n\t\t// Example:\n\t\t//   replyObject.constructor.name might be 'JoinNewNetworkReply'\n\t\t//   for a protobufMessageName to 'wifi.JoinNewNetworkRequest'\n\t\tif (replyObject && replyObject.constructor &&\n\t\t\treplyObject.constructor.name === protobufDefinition.replyMessage.name) {\n\t\t\treturnThis.pass = true;\n\t\t\treturnThis.replyObject = replyObject;\n\t\t} else {\n\t\t\treturnThis.pass = false;\n\t\t\treturnThis.error = `Device did not return a valid reply. expected=${protobufDefinition.replyMessage.name} actual=${JSON.stringify(replyObject)}`;\n\t\t}\n\t\treturn returnThis;\n\t}\n};\n\nmodule.exports = {\n\tWifiDevice\n};\n\n\n//# sourceURL=webpack://ParticleUsb/./src/wifi-device.js?");

/***/ }),

/***/ "./node_modules/@particle/device-constants/dist/js/constants.json":
/*!************************************************************************!*\
  !*** ./node_modules/@particle/device-constants/dist/js/constants.json ***!
  \************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"core\":{\"id\":0,\"name\":\"core\",\"displayName\":\"Core\",\"generation\":1,\"baseMcu\":\"stm32f1xx\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":true,\"usb\":{\"vendorId\":\"0x1d50\",\"productId\":\"0x607d\"},\"dfu\":{\"vendorId\":\"0x1d50\",\"productId\":\"0x607f\",\"segments\":{\"factoryReset\":{\"address\":\"0x00020000\",\"alt\":1}}}},\"gcc\":{\"id\":3,\"name\":\"gcc\",\"displayName\":\"GCC\",\"generation\":-1,\"baseMcu\":\"gcc\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"photon\":{\"id\":6,\"name\":\"photon\",\"displayName\":\"Photon\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc006\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd006\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080e0000\",\"alt\":0}}}},\"p1\":{\"id\":8,\"name\":\"p1\",\"displayName\":\"P1\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc008\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd008\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080e0000\",\"alt\":0}}}},\"electron\":{\"id\":10,\"name\":\"electron\",\"displayName\":\"Electron\",\"generation\":2,\"baseMcu\":\"stm32f2xx\",\"features\":[\"cellular\",\"udp\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":1,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"index\":3,\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00a\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00a\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}],\"segments\":{\"factoryReset\":{\"address\":\"0x080a0000\",\"alt\":0},\"transport\":{\"address\":\"2977\",\"alt\":1,\"size\":1}}}},\"esp32\":{\"id\":11,\"name\":\"esp32\",\"displayName\":\"ESP32\",\"generation\":-1,\"baseMcu\":\"esp32xx\",\"features\":[\"wifi\",\"udp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"argon\":{\"id\":12,\"name\":\"argon\",\"displayName\":\"Argon\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"wifi\",\"udp\",\"mesh\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00c\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00c\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"boron\":{\"id\":13,\"name\":\"boron\",\"displayName\":\"Boron\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"cellular\",\"udp\",\"mesh\",\"ble\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00d\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00d\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"xenon\":{\"id\":14,\"name\":\"xenon\",\"displayName\":\"Xenon\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"mesh\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00e\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00e\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"esomx\":{\"id\":15,\"name\":\"esomx\",\"displayName\":\"E SoM X\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc00f\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd00f\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"asom\":{\"id\":22,\"name\":\"asom\",\"displayName\":\"A SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"wifi\",\"mesh\",\"udp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc016\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd016\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"bsom\":{\"id\":23,\"name\":\"bsom\",\"displayName\":\"B SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"mesh\",\"udp\",\"ble\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc017\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd017\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"xsom\":{\"id\":24,\"name\":\"xsom\",\"displayName\":\"X SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"mesh\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc018\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd018\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00200000\",\"alt\":2}}}},\"b5som\":{\"id\":25,\"name\":\"b5som\",\"displayName\":\"B5 SoM\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"mesh\",\"udp\",\"ble\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc019\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd019\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00600000\",\"alt\":2}}}},\"tracker\":{\"id\":26,\"name\":\"tracker\",\"displayName\":\"Asset Tracker\",\"generation\":3,\"baseMcu\":\"nrf52840\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"},{\"type\":\"radioStack\",\"storage\":\"internalFlash\"},{\"type\":\"ncpFirmware\",\"storage\":\"externalMcu\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc01a\"},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd01a\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0},{\"type\":\"externalFlash\",\"alt\":2}],\"segments\":{\"factoryReset\":{\"address\":\"0x00600000\",\"alt\":2}}}},\"trackerm\":{\"id\":28,\"name\":\"trackerm\",\"displayName\":\"Tracker M\",\"generation\":3,\"baseMcu\":\"rtl872x\",\"features\":[\"som\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc01c\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd01c\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]}},\"raspi\":{\"id\":31,\"name\":\"raspi\",\"displayName\":\"Raspberry Pi\",\"generation\":-1,\"baseMcu\":\"raspi\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"p2\":{\"id\":32,\"name\":\"p2\",\"displayName\":\"Photon 2 / P2\",\"generation\":3,\"baseMcu\":\"rtl872x\",\"features\":[\"wifi\",\"udp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc020\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd020\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]}},\"msom\":{\"id\":35,\"name\":\"msom\",\"displayName\":\"M SoM\",\"generation\":3,\"baseMcu\":\"rtl872x\",\"features\":[\"wifi\",\"cellular\",\"udp\",\"ble\",\"gnss\",\"trackerServices\"],\"billingConnectivity\":\"cellular\",\"productEligible\":true,\"public\":true,\"firmwareModules\":[{\"type\":\"bootloader\",\"index\":0,\"storage\":\"internalFlash\"},{\"type\":\"bootloader\",\"index\":1,\"storage\":\"internalFlash\",\"encrypted\":true},{\"type\":\"bootloader\",\"index\":2,\"storage\":\"internalFlash\"},{\"type\":\"systemPart\",\"storage\":\"internalFlash\"},{\"type\":\"userPart\",\"storage\":\"internalFlash\"}],\"usb\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xc023\",\"quirks\":{\"controlOutTransfersRequireDataStage\":true}},\"dfu\":{\"vendorId\":\"0x2b04\",\"productId\":\"0xd023\",\"storage\":[{\"type\":\"internalFlash\",\"alt\":0}]}},\"oak\":{\"id\":82,\"name\":\"oak\",\"displayName\":\"Oak\",\"generation\":-1,\"baseMcu\":\"esp8266\",\"features\":[\"wifi\",\"tcp\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"duo\":{\"id\":88,\"name\":\"duo\",\"displayName\":\"Duo\",\"generation\":-1,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}},\"bluz\":{\"id\":103,\"name\":\"bluz\",\"displayName\":\"Bluz\",\"generation\":-1,\"baseMcu\":\"stm32f2xx\",\"features\":[\"wifi\",\"tcp\",\"ble\"],\"billingConnectivity\":\"wifi\",\"productEligible\":false,\"public\":false,\"usb\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"},\"dfu\":{\"vendorId\":\"0x0\",\"productId\":\"0x0\"}}}');\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-constants/dist/js/constants.json?");

/***/ }),

/***/ "./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json":
/*!***************************************************************************************!*\
  !*** ./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json ***!
  \***************************************************************************************/
/***/ ((module) => {

"use strict";
eval("module.exports = JSON.parse('{\"options\":{\"java_package\":\"fi.kapsi.koti.jpa.nanopb\"},\"nested\":{\"particle\":{\"nested\":{\"ctrl\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl\"},\"nested\":{\"cellular\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.cellular\"},\"nested\":{\"SimType\":{\"values\":{\"INVALID_SIM_TYPE\":0,\"INTERNAL\":1,\"EXTERNAL\":2}},\"AccessPoint\":{\"fields\":{\"apn\":{\"type\":\"string\",\"id\":1},\"user\":{\"type\":\"string\",\"id\":2},\"password\":{\"type\":\"string\",\"id\":3},\"useDefaults\":{\"type\":\"bool\",\"id\":4}}},\"SetAccessPointRequest\":{\"options\":{\"(type_id)\":550},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1},\"accessPoint\":{\"type\":\"AccessPoint\",\"id\":2}}},\"SetAccessPointReply\":{\"fields\":{}},\"GetAccessPointRequest\":{\"options\":{\"(type_id)\":551},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"GetAccessPointReply\":{\"fields\":{\"accessPoint\":{\"type\":\"AccessPoint\",\"id\":1}}},\"SetActiveSimRequest\":{\"options\":{\"(type_id)\":552},\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"SetActiveSimReply\":{\"fields\":{}},\"GetActiveSimRequest\":{\"options\":{\"(type_id)\":553},\"fields\":{}},\"GetActiveSimReply\":{\"fields\":{\"simType\":{\"type\":\"SimType\",\"id\":1}}},\"GetIccidRequest\":{\"options\":{\"(type_id)\":554},\"fields\":{}},\"GetIccidReply\":{\"fields\":{\"iccid\":{\"type\":\"string\",\"id\":1}}}}},\"ResultCode\":{\"values\":{\"OK\":0,\"NOT_ALLOWED\":1,\"TIMEOUT\":2,\"NOT_FOUND\":3,\"ALREADY_EXIST\":4,\"INVALID_STATE\":5,\"NO_MEMORY\":6,\"INVALID_PARAM\":7}},\"Ipv4Address\":{\"fields\":{\"address\":{\"type\":\"fixed32\",\"id\":1}}},\"Ipv6Address\":{\"fields\":{\"address\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":16,\"(nanopb).fixed_length\":true}}}},\"IpAddress\":{\"oneofs\":{\"address\":{\"oneof\":[\"v4\",\"v6\"]}},\"fields\":{\"v4\":{\"type\":\"Ipv4Address\",\"id\":1},\"v6\":{\"type\":\"Ipv6Address\",\"id\":2}}},\"IPAddress\":{\"fields\":{\"protocol\":{\"type\":\"Protocol\",\"id\":1},\"address\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":16}}},\"nested\":{\"Protocol\":{\"values\":{\"NONE\":0,\"IPv4\":1,\"IPv6\":2}}}},\"cloud\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.cloud\"},\"nested\":{\"ConnectionStatus\":{\"values\":{\"DISCONNECTED\":0,\"CONNECTING\":1,\"CONNECTED\":2,\"DISCONNECTING\":3}},\"GetConnectionStatusRequest\":{\"options\":{\"(type_id)\":300},\"fields\":{}},\"GetConnectionStatusReply\":{\"fields\":{\"status\":{\"type\":\"ConnectionStatus\",\"id\":1}}},\"ConnectRequest\":{\"options\":{\"(type_id)\":301},\"fields\":{}},\"ConnectReply\":{\"fields\":{}},\"DisconnectRequest\":{\"options\":{\"(type_id)\":302},\"fields\":{}},\"DisconnectReply\":{\"fields\":{}}}},\"SecurityKeyType\":{\"values\":{\"INVALID_SECURITY_KEY\":0,\"TCP_DEVICE_PRIVATE_KEY\":1,\"TCP_DEVICE_PUBLIC_KEY\":2,\"TCP_SERVER_PUBLIC_KEY\":3,\"UDP_DEVICE_PRIVATE_KEY\":4,\"UDP_DEVICE_PUBLIC_KEY\":5,\"UDP_SERVER_PUBLIC_KEY\":6}},\"ServerProtocolType\":{\"values\":{\"INVALID_PROTOCOL\":0,\"TCP_PROTOCOL\":1,\"UDP_PROTOCOL\":2}},\"DeviceMode\":{\"values\":{\"NORMAL_MODE\":0,\"LISTENING_MODE\":1}},\"SystemCapabilityFlag\":{\"values\":{\"NO_SYSTEM_CAPABILITY_FLAGS\":0,\"COMPRESSED_OTA\":1}},\"Feature\":{\"values\":{\"INVALID_FEATURE\":0,\"ETHERNET_DETECTION\":1}},\"GetDeviceIdRequest\":{\"options\":{\"(type_id)\":20},\"fields\":{}},\"GetDeviceIdReply\":{\"fields\":{\"id\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":24}}}},\"GetSerialNumberRequest\":{\"options\":{\"(type_id)\":21},\"fields\":{}},\"GetSerialNumberReply\":{\"fields\":{\"serial\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":16}}}},\"GetSystemVersionRequest\":{\"options\":{\"(type_id)\":30},\"fields\":{}},\"GetSystemVersionReply\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1}}},\"GetNcpFirmwareVersionRequest\":{\"options\":{\"(type_id)\":31},\"fields\":{}},\"GetNcpFirmwareVersionReply\":{\"fields\":{\"version\":{\"type\":\"string\",\"id\":1},\"moduleVersion\":{\"type\":\"uint32\",\"id\":2}}},\"GetSystemCapabilitiesRequest\":{\"options\":{\"(type_id)\":32},\"fields\":{}},\"GetSystemCapabilitiesReply\":{\"fields\":{\"flags\":{\"type\":\"fixed32\",\"id\":1}}},\"SetClaimCodeRequest\":{\"options\":{\"(type_id)\":200},\"fields\":{\"code\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":64}}}},\"SetClaimCodeReply\":{\"fields\":{}},\"IsClaimedRequest\":{\"options\":{\"(type_id)\":201},\"fields\":{}},\"IsClaimedReply\":{\"fields\":{\"claimed\":{\"type\":\"bool\",\"id\":1}}},\"SetSecurityKeyRequest\":{\"options\":{\"(type_id)\":210},\"fields\":{\"type\":{\"type\":\"SecurityKeyType\",\"id\":1},\"data\":{\"type\":\"bytes\",\"id\":2}}},\"SetSecurityKeyReply\":{\"fields\":{}},\"GetSecurityKeyRequest\":{\"options\":{\"(type_id)\":211},\"fields\":{\"type\":{\"type\":\"SecurityKeyType\",\"id\":1}}},\"GetSecurityKeyReply\":{\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"SetServerAddressRequest\":{\"options\":{\"(type_id)\":220},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1},\"address\":{\"type\":\"string\",\"id\":2,\"options\":{\"(nanopb).max_size\":64}},\"port\":{\"type\":\"int32\",\"id\":3}}},\"SetServerAddressReply\":{\"fields\":{}},\"GetServerAddressRequest\":{\"options\":{\"(type_id)\":221},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"GetServerAddressReply\":{\"fields\":{\"address\":{\"type\":\"string\",\"id\":1},\"port\":{\"type\":\"int32\",\"id\":2}}},\"SetServerProtocolRequest\":{\"options\":{\"(type_id)\":222},\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"SetServerProtocolReply\":{\"fields\":{}},\"GetServerProtocolRequest\":{\"options\":{\"(type_id)\":223},\"fields\":{}},\"GetServerProtocolReply\":{\"fields\":{\"protocol\":{\"type\":\"ServerProtocolType\",\"id\":1}}},\"SetSoftApSsidRequest\":{\"options\":{\"(type_id)\":240},\"fields\":{\"prefix\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":32}},\"suffix\":{\"type\":\"string\",\"id\":2,\"options\":{\"(nanopb).max_size\":16}}}},\"SetSoftApSsidReply\":{\"fields\":{}},\"StartListeningModeRequest\":{\"options\":{\"(type_id)\":70},\"fields\":{}},\"StartListeningModeReply\":{\"fields\":{}},\"StopListeningModeRequest\":{\"options\":{\"(type_id)\":71},\"fields\":{}},\"StopListeningModeReply\":{\"fields\":{}},\"GetDeviceModeRequest\":{\"options\":{\"(type_id)\":72},\"fields\":{}},\"GetDeviceModeReply\":{\"fields\":{\"mode\":{\"type\":\"DeviceMode\",\"id\":1}}},\"SetDeviceSetupDoneRequest\":{\"options\":{\"(type_id)\":73},\"fields\":{\"done\":{\"type\":\"bool\",\"id\":1}}},\"SetDeviceSetupDoneReply\":{\"fields\":{}},\"IsDeviceSetupDoneRequest\":{\"options\":{\"(type_id)\":74},\"fields\":{}},\"IsDeviceSetupDoneReply\":{\"fields\":{\"done\":{\"type\":\"bool\",\"id\":1}}},\"SetStartupModeRequest\":{\"options\":{\"(type_id)\":75},\"fields\":{\"mode\":{\"type\":\"DeviceMode\",\"id\":1}}},\"SetStartupModeReply\":{\"fields\":{}},\"SystemResetRequest\":{\"options\":{\"(type_id)\":40},\"fields\":{}},\"SystemResetReply\":{\"fields\":{}},\"SetFeatureRequest\":{\"options\":{\"(type_id)\":33},\"fields\":{\"feature\":{\"type\":\"Feature\",\"id\":1},\"enabled\":{\"type\":\"bool\",\"id\":2}}},\"SetFeatureReply\":{\"fields\":{}},\"GetFeatureRequest\":{\"options\":{\"(type_id)\":34},\"fields\":{\"feature\":{\"type\":\"Feature\",\"id\":1}}},\"GetFeatureReply\":{\"fields\":{\"enabled\":{\"type\":\"bool\",\"id\":1}}},\"StartNyanSignalRequest\":{\"options\":{\"(type_id)\":230},\"fields\":{}},\"StartNyanSignalReply\":{\"fields\":{}},\"StopNyanSignalRequest\":{\"options\":{\"(type_id)\":231},\"fields\":{}},\"StopNyanSignalReply\":{\"fields\":{}},\"WiFiGetAntennaRequest\":{\"options\":{\"(type_id)\":111},\"fields\":{}},\"WiFiGetAntennaReply\":{\"fields\":{\"antenna\":{\"type\":\"WiFiAntenna\",\"id\":1}}},\"WiFiSetAntennaRequest\":{\"options\":{\"(type_id)\":110},\"fields\":{\"antenna\":{\"type\":\"WiFiAntenna\",\"id\":1}}},\"WiFiSetAntennaReply\":{\"fields\":{}},\"WiFiScanRequest\":{\"options\":{\"(type_id)\":112},\"fields\":{}},\"WiFiScanReply\":{\"fields\":{\"list\":{\"type\":\"WiFiAccessPointList\",\"id\":1}}},\"WiFiGetCredentialsRequest\":{\"options\":{\"(type_id)\":114},\"fields\":{}},\"WiFiGetCredentialsReply\":{\"fields\":{\"list\":{\"type\":\"WiFiAccessPointList\",\"id\":1}}},\"WiFiSetCredentialsRequest\":{\"options\":{\"(type_id)\":113},\"fields\":{\"ap\":{\"type\":\"WiFiAccessPoint\",\"id\":1}}},\"WiFiSetCredentialsReply\":{\"fields\":{}},\"WiFiClearCredentialsRequest\":{\"options\":{\"(type_id)\":115},\"fields\":{}},\"WiFiClearCredentialsReply\":{\"fields\":{}},\"WiFiAntenna\":{\"values\":{\"ANTENNA_NONE\":0,\"INTERNAL\":1,\"EXTERNAL\":2,\"AUTO\":3}},\"WiFiSecurityType\":{\"values\":{\"UNSEC\":0,\"WEP\":1,\"WPA\":2,\"WPA2\":3,\"WPA_ENTERPRISE\":4,\"WPA2_ENTERPRISE\":5,\"UNKNOWN\":255}},\"WiFiSecurityCipher\":{\"values\":{\"CIPHER_NONE\":0,\"AES\":1,\"TKIP\":2,\"AES_TKIP\":3}},\"EapType\":{\"values\":{\"EAP_TYPE_NONE\":0,\"TLS\":13,\"PEAP\":25}},\"WiFiAccessPoint\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1,\"options\":{\"(nanopb).max_size\":33}},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6,\"(nanopb).fixed_length\":true}},\"security\":{\"type\":\"WiFiSecurityType\",\"id\":3},\"cipher\":{\"type\":\"WiFiSecurityCipher\",\"id\":4},\"channel\":{\"type\":\"uint32\",\"id\":5},\"maxDataRate\":{\"type\":\"int32\",\"id\":6},\"rssi\":{\"type\":\"int32\",\"id\":7},\"password\":{\"type\":\"string\",\"id\":8},\"eapType\":{\"type\":\"EapType\",\"id\":9},\"innerIdentity\":{\"type\":\"string\",\"id\":10},\"outerIdentity\":{\"type\":\"string\",\"id\":11},\"privateKey\":{\"type\":\"bytes\",\"id\":12},\"clientCertificate\":{\"type\":\"bytes\",\"id\":13},\"caCertificate\":{\"type\":\"bytes\",\"id\":14}}},\"WiFiAccessPointList\":{\"fields\":{\"aps\":{\"rule\":\"repeated\",\"type\":\"WiFiAccessPoint\",\"id\":1}}},\"NetworkGetStatusRequest\":{\"options\":{\"(type_id)\":122},\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1}}},\"NetworkGetStatusReply\":{\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkGetConfigurationRequest\":{\"options\":{\"(type_id)\":120},\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1}}},\"NetworkGetConfigurationReply\":{\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkSetConfigurationRequest\":{\"options\":{\"(type_id)\":121},\"fields\":{\"config\":{\"type\":\"NetworkConfiguration\",\"id\":1}}},\"NetworkSetConfigurationReply\":{\"fields\":{}},\"NetworkState\":{\"values\":{\"NETWORK_STATUS_NONE\":0,\"DOWN\":1,\"UP\":2}},\"IPConfiguration\":{\"fields\":{\"type\":{\"type\":\"Type\",\"id\":1},\"address\":{\"type\":\"IPAddress\",\"id\":2},\"netmask\":{\"type\":\"IPAddress\",\"id\":3},\"gateway\":{\"type\":\"IPAddress\",\"id\":4},\"dhcpServer\":{\"type\":\"IPAddress\",\"id\":5},\"hostname\":{\"type\":\"string\",\"id\":6}},\"nested\":{\"Type\":{\"values\":{\"NONE\":0,\"DHCP\":1,\"STATIC\":2}}}},\"DNSConfiguration\":{\"fields\":{\"servers\":{\"rule\":\"repeated\",\"type\":\"IPAddress\",\"id\":1}}},\"NetworkConfiguration\":{\"fields\":{\"interface\":{\"type\":\"int32\",\"id\":1},\"state\":{\"type\":\"NetworkState\",\"id\":2},\"name\":{\"type\":\"string\",\"id\":3},\"mac\":{\"type\":\"bytes\",\"id\":4,\"options\":{\"(nanopb).max_size\":6}},\"ipconfig\":{\"type\":\"IPConfiguration\",\"id\":5},\"dnsconfig\":{\"type\":\"DNSConfiguration\",\"id\":6}}},\"InterfaceAddress\":{\"fields\":{\"address\":{\"type\":\"IpAddress\",\"id\":1},\"prefixLength\":{\"type\":\"uint32\",\"id\":2}}},\"Ipv4Config\":{\"fields\":{\"addresses\":{\"rule\":\"repeated\",\"type\":\"InterfaceAddress\",\"id\":1},\"peer\":{\"type\":\"Ipv4Address\",\"id\":2},\"gateway\":{\"type\":\"Ipv4Address\",\"id\":3}}},\"Ipv6Config\":{\"fields\":{\"addresses\":{\"rule\":\"repeated\",\"type\":\"InterfaceAddress\",\"id\":1}}},\"InterfaceFlag\":{\"options\":{\"allow_alias\":true},\"values\":{\"IFF_NONE\":0,\"IFF_UP\":1,\"IFF_BROADCAST\":2,\"IFF_DEBUG\":4,\"IFF_LOOPBACK\":8,\"IFF_POINTTOPOINT\":16,\"IFF_RUNNING\":64,\"IFF_LOWER_UP\":64,\"IFF_NOARP\":128,\"IFF_PROMISC\":256,\"IFF_ALLMULTI\":512,\"IFF_MULTICAST\":32768,\"IFF_NOND6\":65536}},\"InterfaceExtFlag\":{\"values\":{\"IFXF_NONE\":0,\"IFXF_WOL\":16,\"IFXF_AUTOCONF6\":32,\"IFXF_DHCP\":65536,\"IFXF_DHCP6\":131072,\"IFXF_AUTOIP\":262144}},\"InterfaceType\":{\"values\":{\"INVALID_INTERFACE_TYPE\":0,\"LOOPBACK\":1,\"THREAD\":2,\"ETHERNET\":4,\"WIFI\":8,\"PPP\":16}},\"Interface\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"name\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"InterfaceType\",\"id\":3},\"flags\":{\"type\":\"uint32\",\"id\":4},\"extFlags\":{\"type\":\"uint32\",\"id\":5},\"ipv4Config\":{\"type\":\"Ipv4Config\",\"id\":6},\"ipv6Config\":{\"type\":\"Ipv6Config\",\"id\":7},\"hwAddress\":{\"type\":\"bytes\",\"id\":8,\"options\":{\"(nanopb).max_size\":8}},\"mtu\":{\"type\":\"uint32\",\"id\":9},\"metric\":{\"type\":\"uint32\",\"id\":10}}},\"InterfaceEntry\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"name\":{\"type\":\"string\",\"id\":2},\"type\":{\"type\":\"InterfaceType\",\"id\":3}}},\"GetInterfaceListRequest\":{\"options\":{\"(type_id)\":400},\"fields\":{}},\"GetInterfaceListReply\":{\"fields\":{\"interfaces\":{\"rule\":\"repeated\",\"type\":\"InterfaceEntry\",\"id\":1}}},\"GetInterfaceRequest\":{\"options\":{\"(type_id)\":401},\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1}}},\"GetInterfaceReply\":{\"fields\":{\"interface\":{\"type\":\"Interface\",\"id\":1}}},\"wifi\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.wifi\"},\"nested\":{\"Security\":{\"values\":{\"NO_SECURITY\":0,\"WEP\":1,\"WPA_PSK\":2,\"WPA2_PSK\":3,\"WPA_WPA2_PSK\":4}},\"CredentialsType\":{\"values\":{\"NO_CREDENTIALS\":0,\"PASSWORD\":1}},\"Credentials\":{\"fields\":{\"type\":{\"type\":\"CredentialsType\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2}}},\"JoinNewNetworkRequest\":{\"options\":{\"(type_id)\":500},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"Security\",\"id\":3},\"credentials\":{\"type\":\"Credentials\",\"id\":4}}},\"JoinNewNetworkReply\":{\"fields\":{}},\"JoinKnownNetworkRequest\":{\"options\":{\"(type_id)\":501},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1}}},\"JoinKnownNetworkReply\":{\"fields\":{}},\"GetKnownNetworksRequest\":{\"options\":{\"(type_id)\":502},\"fields\":{}},\"GetKnownNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"Network\",\"id\":1}},\"nested\":{\"Network\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"security\":{\"type\":\"Security\",\"id\":2},\"credentialsType\":{\"type\":\"CredentialsType\",\"id\":3}}}}},\"RemoveKnownNetworkRequest\":{\"options\":{\"(type_id)\":503},\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1}}},\"RemoveKnownNetworkReply\":{\"fields\":{}},\"ClearKnownNetworksRequest\":{\"options\":{\"(type_id)\":504},\"fields\":{}},\"ClearKnownNetworksReply\":{\"fields\":{}},\"GetCurrentNetworkRequest\":{\"options\":{\"(type_id)\":505},\"fields\":{}},\"GetCurrentNetworkReply\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"channel\":{\"type\":\"int32\",\"id\":3},\"rssi\":{\"type\":\"int32\",\"id\":4}}},\"ScanNetworksRequest\":{\"options\":{\"(type_id)\":506},\"fields\":{}},\"ScanNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"Network\",\"id\":1}},\"nested\":{\"Network\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"Security\",\"id\":3},\"channel\":{\"type\":\"int32\",\"id\":4},\"rssi\":{\"type\":\"int32\",\"id\":5}}}}}}},\"logging\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.logging\"},\"nested\":{\"LogLevel\":{\"options\":{\"allow_alias\":true},\"values\":{\"INVALID_LOG_LEVEL\":0,\"ALL\":1,\"TRACE\":1,\"INFO\":30,\"WARN\":40,\"ERROR\":50,\"NONE\":70}},\"LogHandlerType\":{\"values\":{\"INVALID_LOG_HANDLER_TYPE\":0,\"DEFAULT_STREAM_HANDLER\":1,\"JSON_STREAM_HANDLER\":2}},\"StreamType\":{\"values\":{\"INVALID_STREAM_TYPE\":0,\"USB_SERIAL_STREAM\":1,\"HW_SERIAL_STREAM\":2}},\"LogFilter\":{\"fields\":{\"category\":{\"type\":\"string\",\"id\":1},\"level\":{\"type\":\"LogLevel\",\"id\":2}}},\"SerialStreamParams\":{\"fields\":{\"index\":{\"type\":\"uint32\",\"id\":1},\"baudRate\":{\"type\":\"uint32\",\"id\":2}}},\"AddLogHandlerRequest\":{\"options\":{\"(type_id)\":1100},\"oneofs\":{\"streamParams\":{\"oneof\":[\"serial\"]}},\"fields\":{\"id\":{\"type\":\"string\",\"id\":1},\"handlerType\":{\"type\":\"LogHandlerType\",\"id\":2},\"level\":{\"type\":\"LogLevel\",\"id\":3},\"filters\":{\"rule\":\"repeated\",\"type\":\"LogFilter\",\"id\":4},\"streamType\":{\"type\":\"StreamType\",\"id\":5},\"serial\":{\"type\":\"SerialStreamParams\",\"id\":6}}},\"AddLogHandlerReply\":{\"fields\":{}},\"RemoveLogHandlerRequest\":{\"options\":{\"(type_id)\":1101},\"fields\":{\"id\":{\"type\":\"string\",\"id\":1}}},\"RemoveLogHandlerReply\":{\"fields\":{}},\"GetLogHandlersRequest\":{\"options\":{\"(type_id)\":1102},\"fields\":{}},\"GetLogHandlersReply\":{\"fields\":{\"handlers\":{\"rule\":\"repeated\",\"type\":\"Handler\",\"id\":1}},\"nested\":{\"Handler\":{\"fields\":{\"id\":{\"type\":\"string\",\"id\":1}}}}}}},\"mesh\":{\"options\":{\"java_package\":\"io.particle.firmwareprotos.ctrl.mesh\"},\"nested\":{\"NetworkInfo\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"extPanId\":{\"type\":\"string\",\"id\":2},\"panId\":{\"type\":\"uint32\",\"id\":3},\"channel\":{\"type\":\"uint32\",\"id\":4},\"networkId\":{\"type\":\"string\",\"id\":5}}},\"AuthRequest\":{\"options\":{\"(type_id)\":1001},\"fields\":{\"password\":{\"type\":\"string\",\"id\":1}}},\"AuthReply\":{\"fields\":{}},\"CreateNetworkRequest\":{\"options\":{\"(type_id)\":1002},\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2},\"channel\":{\"type\":\"uint32\",\"id\":3},\"networkId\":{\"type\":\"string\",\"id\":4}}},\"CreateNetworkReply\":{\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"StartCommissionerRequest\":{\"options\":{\"(type_id)\":1003},\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1}}},\"StartCommissionerReply\":{\"fields\":{}},\"StopCommissionerRequest\":{\"options\":{\"(type_id)\":1004},\"fields\":{}},\"StopCommissionerReply\":{\"fields\":{}},\"PrepareJoinerRequest\":{\"options\":{\"(type_id)\":1005},\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"PrepareJoinerReply\":{\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2}}},\"AddJoinerRequest\":{\"options\":{\"(type_id)\":1006},\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1},\"password\":{\"type\":\"string\",\"id\":2},\"timeout\":{\"type\":\"uint32\",\"id\":3}}},\"AddJoinerReply\":{\"fields\":{}},\"RemoveJoinerRequest\":{\"options\":{\"(type_id)\":1007},\"fields\":{\"eui64\":{\"type\":\"string\",\"id\":1}}},\"RemoveJoinerReply\":{\"fields\":{}},\"JoinNetworkRequest\":{\"options\":{\"(type_id)\":1008},\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1}}},\"JoinNetworkReply\":{\"fields\":{}},\"LeaveNetworkRequest\":{\"options\":{\"(type_id)\":1009},\"fields\":{}},\"LeaveNetworkReply\":{\"fields\":{}},\"GetNetworkInfoRequest\":{\"options\":{\"(type_id)\":1010},\"fields\":{}},\"GetNetworkInfoReply\":{\"fields\":{\"network\":{\"type\":\"NetworkInfo\",\"id\":1}}},\"ScanNetworksRequest\":{\"options\":{\"(type_id)\":1011},\"fields\":{\"duration\":{\"type\":\"uint32\",\"id\":1}}},\"ScanNetworksReply\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"NetworkInfo\",\"id\":1}}},\"DiagnosticType\":{\"options\":{\"allow_alias\":true},\"values\":{\"MAC_EXTENDED_ADDRESS\":0,\"RLOC\":1,\"MAC_ADDRESS\":1,\"MODE\":2,\"TIMEOUT\":3,\"CONNECTIVITY\":4,\"ROUTE64\":5,\"LEADER_DATA\":6,\"NETWORK_DATA\":7,\"IPV6_ADDRESS_LIST\":8,\"MAC_COUNTERS\":9,\"BATTERY_LEVEL\":14,\"SUPPLY_VOLTAGE\":15,\"CHILD_TABLE\":16,\"CHANNEL_PAGES\":17,\"TYPE_LIST\":18,\"MAX_CHILD_TIMEOUT\":19}},\"DiagnosticInfo\":{\"fields\":{\"extMacAddress\":{\"type\":\"bytes\",\"id\":1,\"options\":{\"(nanopb).max_size\":8}},\"rloc\":{\"type\":\"uint32\",\"id\":2},\"mode\":{\"type\":\"uint32\",\"id\":3},\"timeout\":{\"type\":\"uint32\",\"id\":4},\"connectivity\":{\"type\":\"Connectivity\",\"id\":5},\"route64\":{\"type\":\"Route64\",\"id\":6},\"leaderData\":{\"type\":\"LeaderData\",\"id\":7},\"networkData\":{\"type\":\"NetworkData\",\"id\":8},\"ipv6AddressList\":{\"rule\":\"repeated\",\"type\":\"Ipv6Address\",\"id\":9},\"macCounters\":{\"type\":\"MacCounters\",\"id\":10},\"batteryLevel\":{\"type\":\"uint32\",\"id\":15},\"supplyVoltage\":{\"type\":\"uint32\",\"id\":16},\"childTable\":{\"type\":\"ChildTable\",\"id\":17},\"channelPages\":{\"type\":\"bytes\",\"id\":18,\"options\":{\"(nanopb).max_size\":3}},\"typeList\":{\"rule\":\"repeated\",\"type\":\"DiagnosticType\",\"id\":19},\"maxChildTimeout\":{\"type\":\"uint32\",\"id\":20},\"deviceId\":{\"type\":\"bytes\",\"id\":100,\"options\":{\"(nanopb).max_size\":12}}},\"nested\":{\"Mode\":{\"options\":{\"allow_alias\":true},\"values\":{\"INVALID\":0,\"RECEIVER_ON_WHEN_IDLE\":16,\"SECURE_DATA_REQUESTS\":32,\"DEVICE_TYPE\":48,\"DEVICE_TYPE_FTD\":48,\"NETWORK_DATA\":64,\"NETWORK_DATA_FULL\":64}},\"Connectivity\":{\"fields\":{\"parentPriority\":{\"type\":\"uint32\",\"id\":1},\"linkQuality_1\":{\"type\":\"uint32\",\"id\":2},\"linkQuality_2\":{\"type\":\"uint32\",\"id\":3},\"linkQuality_3\":{\"type\":\"uint32\",\"id\":4},\"leaderCost\":{\"type\":\"uint32\",\"id\":5},\"idSequence\":{\"type\":\"uint32\",\"id\":6},\"activeRouters\":{\"type\":\"uint32\",\"id\":7},\"sedBufferSize\":{\"type\":\"uint32\",\"id\":8},\"sedDatagramCount\":{\"type\":\"uint32\",\"id\":9}}},\"Route64\":{\"fields\":{\"idSequence\":{\"type\":\"uint32\",\"id\":1},\"routes\":{\"rule\":\"repeated\",\"type\":\"RouteData\",\"id\":2}},\"nested\":{\"RouteData\":{\"fields\":{\"routerRloc\":{\"type\":\"uint32\",\"id\":1},\"linkQualityOut\":{\"type\":\"uint32\",\"id\":2},\"linkQualityIn\":{\"type\":\"uint32\",\"id\":3},\"routeCost\":{\"type\":\"uint32\",\"id\":4}}}}},\"LeaderData\":{\"fields\":{\"partitionId\":{\"type\":\"uint32\",\"id\":1},\"weighting\":{\"type\":\"uint32\",\"id\":2},\"dataVersion\":{\"type\":\"uint32\",\"id\":3},\"stableDataVersion\":{\"type\":\"uint32\",\"id\":4},\"leaderRloc\":{\"type\":\"uint32\",\"id\":5}}},\"RoutePreference\":{\"values\":{\"MEDIUM\":0,\"HIGH\":1,\"LOW\":-1}},\"NetworkData\":{\"fields\":{\"stable\":{\"type\":\"Data\",\"id\":1},\"temporary\":{\"type\":\"Data\",\"id\":2}},\"nested\":{\"HasRoute\":{\"fields\":{\"entries\":{\"rule\":\"repeated\",\"type\":\"HasRouteEntry\",\"id\":1}},\"nested\":{\"HasRouteEntry\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"preference\":{\"type\":\"RoutePreference\",\"id\":2}}}}},\"BorderRouter\":{\"fields\":{\"entries\":{\"rule\":\"repeated\",\"type\":\"BorderRouterEntry\",\"id\":1}},\"nested\":{\"BorderRouterEntry\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"preference\":{\"type\":\"RoutePreference\",\"id\":2},\"flags\":{\"type\":\"uint32\",\"id\":3}},\"nested\":{\"Flags\":{\"values\":{\"NONE\":0,\"PREFERRED\":1,\"SLAAC\":2,\"DHCP\":4,\"CONFIGURE\":8,\"DEFAULT_ROUTE\":16,\"ON_MESH\":32,\"ND_DNS\":64}}}}}},\"Context\":{\"fields\":{\"cid\":{\"type\":\"uint32\",\"id\":1},\"compress\":{\"type\":\"bool\",\"id\":2},\"contextLength\":{\"type\":\"uint32\",\"id\":3}}},\"Prefix\":{\"fields\":{\"domainId\":{\"type\":\"uint32\",\"id\":1},\"prefixLength\":{\"type\":\"uint32\",\"id\":2},\"prefix\":{\"type\":\"bytes\",\"id\":3,\"options\":{\"(nanopb).max_size\":16}},\"context\":{\"rule\":\"repeated\",\"type\":\"Context\",\"id\":4},\"hasRoute\":{\"type\":\"HasRoute\",\"id\":5},\"borderRouter\":{\"type\":\"BorderRouter\",\"id\":6}}},\"Server\":{\"fields\":{\"rloc\":{\"type\":\"uint32\",\"id\":1},\"data\":{\"type\":\"bytes\",\"id\":2}}},\"Service\":{\"fields\":{\"sid\":{\"type\":\"uint32\",\"id\":1},\"enterpriseNumber\":{\"type\":\"uint32\",\"id\":2},\"data\":{\"type\":\"bytes\",\"id\":3},\"servers\":{\"rule\":\"repeated\",\"type\":\"Server\",\"id\":4}}},\"Data\":{\"fields\":{\"prefixes\":{\"rule\":\"repeated\",\"type\":\"Prefix\",\"id\":1},\"services\":{\"rule\":\"repeated\",\"type\":\"Service\",\"id\":2}}}}},\"MacCounters\":{\"fields\":{\"ifInUnknownProtos\":{\"type\":\"uint32\",\"id\":1},\"ifInErrors\":{\"type\":\"uint32\",\"id\":2},\"ifOutErrors\":{\"type\":\"uint32\",\"id\":3},\"ifInUcastPkts\":{\"type\":\"uint32\",\"id\":4},\"ifInBroadcastPkts\":{\"type\":\"uint32\",\"id\":5},\"ifInDiscards\":{\"type\":\"uint32\",\"id\":6},\"ifOutUcastPkts\":{\"type\":\"uint32\",\"id\":7},\"ifOutBroadcastPkts\":{\"type\":\"uint32\",\"id\":8},\"ifOutDiscards\":{\"type\":\"uint32\",\"id\":9}}},\"ChildTable\":{\"fields\":{\"children\":{\"rule\":\"repeated\",\"type\":\"ChildEntry\",\"id\":1}},\"nested\":{\"ChildEntry\":{\"fields\":{\"timeout\":{\"type\":\"uint32\",\"id\":1},\"childId\":{\"type\":\"uint32\",\"id\":2},\"mode\":{\"type\":\"uint32\",\"id\":3}}}}}}},\"GetNetworkDiagnosticsRequest\":{\"options\":{\"(type_id)\":1012},\"fields\":{\"flags\":{\"type\":\"uint32\",\"id\":1},\"diagnosticTypes\":{\"rule\":\"repeated\",\"type\":\"DiagnosticType\",\"id\":2},\"timeout\":{\"type\":\"uint32\",\"id\":3}},\"nested\":{\"Flags\":{\"values\":{\"INVALID\":0,\"QUERY_CHILDREN\":1,\"RESOLVE_DEVICE_ID\":2}}}},\"GetNetworkDiagnosticsReply\":{\"fields\":{\"nodes\":{\"rule\":\"repeated\",\"type\":\"DiagnosticInfo\",\"id\":1}}}}},\"StorageType\":{\"values\":{\"INVALID_STORAGE\":0,\"INTERNAL\":1}},\"SectionType\":{\"values\":{\"INVALID_SECTION\":0,\"FIRMWARE\":1,\"OTA_BACKUP\":2,\"FACTORY_BACKUP\":3,\"CONFIG\":4,\"EEPROM\":5}},\"FirmwareModuleType\":{\"values\":{\"INVALID_FIRMWARE_MODULE\":0,\"BOOTLOADER\":1,\"SYSTEM_PART\":2,\"USER_PART\":3,\"MONO_FIRMWARE\":4,\"NCP_FIRMWARE\":5,\"RADIO_STACK\":6}},\"FirmwareModuleValidityFlag\":{\"values\":{\"NO_VALIDATION_ERRORS\":0,\"INTEGRITY_CHECK_FAILED\":1,\"DEPENDENCY_CHECK_FAILED\":2}},\"SectionFlag\":{\"values\":{\"NO_SECTION_FLAGS\":0,\"CAN_READ\":1,\"CAN_WRITE\":2,\"CAN_CLEAR\":4,\"CAN_GET_SIZE\":8,\"NEED_CLEAR\":16}},\"FileFormat\":{\"values\":{\"BIN\":0,\"MINIZ\":1}},\"StartFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":250},\"fields\":{\"size\":{\"type\":\"uint32\",\"id\":1},\"format\":{\"type\":\"FileFormat\",\"id\":2}}},\"StartFirmwareUpdateReply\":{\"fields\":{\"chunkSize\":{\"type\":\"uint32\",\"id\":1}}},\"FinishFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":251},\"fields\":{\"validateOnly\":{\"type\":\"bool\",\"id\":1}}},\"FinishFirmwareUpdateReply\":{\"fields\":{}},\"CancelFirmwareUpdateRequest\":{\"options\":{\"(type_id)\":252},\"fields\":{}},\"CancelFirmwareUpdateReply\":{\"fields\":{}},\"FirmwareUpdateDataRequest\":{\"options\":{\"(type_id)\":253},\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"FirmwareUpdateDataReply\":{\"fields\":{}},\"DescribeStorageRequest\":{\"options\":{\"(type_id)\":260},\"fields\":{}},\"DescribeStorageReply\":{\"fields\":{\"storage\":{\"rule\":\"repeated\",\"type\":\"Storage\",\"id\":1}},\"nested\":{\"Section\":{\"fields\":{\"type\":{\"type\":\"SectionType\",\"id\":1},\"size\":{\"type\":\"uint32\",\"id\":2},\"flags\":{\"type\":\"uint32\",\"id\":3},\"firmwareModule\":{\"type\":\"FirmwareModule\",\"id\":4}},\"nested\":{\"FirmwareModule\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2}}}}},\"Storage\":{\"fields\":{\"type\":{\"type\":\"StorageType\",\"id\":1},\"flags\":{\"type\":\"uint32\",\"id\":2},\"sections\":{\"rule\":\"repeated\",\"type\":\"Section\",\"id\":3}}}}},\"ReadSectionDataRequest\":{\"options\":{\"(type_id)\":261},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2},\"offset\":{\"type\":\"uint32\",\"id\":3},\"size\":{\"type\":\"uint32\",\"id\":4}}},\"ReadSectionDataReply\":{\"fields\":{\"data\":{\"type\":\"bytes\",\"id\":1}}},\"WriteSectionDataRequest\":{\"options\":{\"(type_id)\":262},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2},\"offset\":{\"type\":\"uint32\",\"id\":3},\"data\":{\"type\":\"bytes\",\"id\":4}}},\"WriteSectionDataReply\":{\"fields\":{}},\"ClearSectionDataRequest\":{\"options\":{\"(type_id)\":263},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2}}},\"ClearSectionDataReply\":{\"fields\":{}},\"GetSectionDataSizeRequest\":{\"options\":{\"(type_id)\":264},\"fields\":{\"storage\":{\"type\":\"uint32\",\"id\":1},\"section\":{\"type\":\"uint32\",\"id\":2}}},\"GetSectionDataSizeReply\":{\"fields\":{\"size\":{\"type\":\"uint32\",\"id\":1}}},\"GetModuleInfoRequest\":{\"options\":{\"(type_id)\":90},\"fields\":{}},\"GetModuleInfoReply\":{\"fields\":{\"modules\":{\"rule\":\"repeated\",\"type\":\"Module\",\"id\":1}},\"nested\":{\"Dependency\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3}}},\"Module\":{\"fields\":{\"type\":{\"type\":\"FirmwareModuleType\",\"id\":1},\"index\":{\"type\":\"uint32\",\"id\":2},\"version\":{\"type\":\"uint32\",\"id\":3},\"size\":{\"type\":\"uint32\",\"id\":4},\"validity\":{\"type\":\"uint32\",\"id\":5},\"dependencies\":{\"rule\":\"repeated\",\"type\":\"Dependency\",\"id\":6}}}}}}},\"firmware\":{\"nested\":{\"WifiConfig\":{\"fields\":{\"networks\":{\"rule\":\"repeated\",\"type\":\"Network\",\"id\":1}},\"nested\":{\"Network\":{\"fields\":{\"ssid\":{\"type\":\"string\",\"id\":1},\"bssid\":{\"type\":\"bytes\",\"id\":2,\"options\":{\"(nanopb).max_size\":6}},\"security\":{\"type\":\"ctrl.wifi.Security\",\"id\":3},\"credentials\":{\"type\":\"ctrl.wifi.Credentials\",\"id\":4}}}}},\"CellularConfig\":{\"fields\":{\"internalSim\":{\"type\":\"ctrl.cellular.AccessPoint\",\"id\":1},\"externalSim\":{\"type\":\"ctrl.cellular.AccessPoint\",\"id\":2},\"activeSim\":{\"type\":\"ctrl.cellular.SimType\",\"id\":3}}}}}}},\"typeId\":{\"type\":\"int32\",\"id\":50001,\"extend\":\"google.protobuf.MessageOptions\"},\"intValue\":{\"type\":\"int32\",\"id\":50002,\"extend\":\"google.protobuf.EnumValueOptions\"},\"google\":{\"nested\":{\"protobuf\":{\"nested\":{\"FileDescriptorSet\":{\"fields\":{\"file\":{\"rule\":\"repeated\",\"type\":\"FileDescriptorProto\",\"id\":1}}},\"FileDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"package\":{\"type\":\"string\",\"id\":2},\"dependency\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":3},\"publicDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":10,\"options\":{\"packed\":false}},\"weakDependency\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":11,\"options\":{\"packed\":false}},\"messageType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":4},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":5},\"service\":{\"rule\":\"repeated\",\"type\":\"ServiceDescriptorProto\",\"id\":6},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":7},\"options\":{\"type\":\"FileOptions\",\"id\":8},\"sourceCodeInfo\":{\"type\":\"SourceCodeInfo\",\"id\":9},\"syntax\":{\"type\":\"string\",\"id\":12}}},\"DescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"field\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":2},\"extension\":{\"rule\":\"repeated\",\"type\":\"FieldDescriptorProto\",\"id\":6},\"nestedType\":{\"rule\":\"repeated\",\"type\":\"DescriptorProto\",\"id\":3},\"enumType\":{\"rule\":\"repeated\",\"type\":\"EnumDescriptorProto\",\"id\":4},\"extensionRange\":{\"rule\":\"repeated\",\"type\":\"ExtensionRange\",\"id\":5},\"oneofDecl\":{\"rule\":\"repeated\",\"type\":\"OneofDescriptorProto\",\"id\":8},\"options\":{\"type\":\"MessageOptions\",\"id\":7},\"reservedRange\":{\"rule\":\"repeated\",\"type\":\"ReservedRange\",\"id\":9},\"reservedName\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":10}},\"nested\":{\"ExtensionRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}},\"ReservedRange\":{\"fields\":{\"start\":{\"type\":\"int32\",\"id\":1},\"end\":{\"type\":\"int32\",\"id\":2}}}}},\"FieldDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":3},\"label\":{\"type\":\"Label\",\"id\":4},\"type\":{\"type\":\"Type\",\"id\":5},\"typeName\":{\"type\":\"string\",\"id\":6},\"extendee\":{\"type\":\"string\",\"id\":2},\"defaultValue\":{\"type\":\"string\",\"id\":7},\"oneofIndex\":{\"type\":\"int32\",\"id\":9},\"jsonName\":{\"type\":\"string\",\"id\":10},\"options\":{\"type\":\"FieldOptions\",\"id\":8}},\"nested\":{\"Type\":{\"values\":{\"TYPE_DOUBLE\":1,\"TYPE_FLOAT\":2,\"TYPE_INT64\":3,\"TYPE_UINT64\":4,\"TYPE_INT32\":5,\"TYPE_FIXED64\":6,\"TYPE_FIXED32\":7,\"TYPE_BOOL\":8,\"TYPE_STRING\":9,\"TYPE_GROUP\":10,\"TYPE_MESSAGE\":11,\"TYPE_BYTES\":12,\"TYPE_UINT32\":13,\"TYPE_ENUM\":14,\"TYPE_SFIXED32\":15,\"TYPE_SFIXED64\":16,\"TYPE_SINT32\":17,\"TYPE_SINT64\":18}},\"Label\":{\"values\":{\"LABEL_OPTIONAL\":1,\"LABEL_REQUIRED\":2,\"LABEL_REPEATED\":3}}}},\"OneofDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"options\":{\"type\":\"OneofOptions\",\"id\":2}}},\"EnumDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"value\":{\"rule\":\"repeated\",\"type\":\"EnumValueDescriptorProto\",\"id\":2},\"options\":{\"type\":\"EnumOptions\",\"id\":3}}},\"EnumValueDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"number\":{\"type\":\"int32\",\"id\":2},\"options\":{\"type\":\"EnumValueOptions\",\"id\":3}}},\"ServiceDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"method\":{\"rule\":\"repeated\",\"type\":\"MethodDescriptorProto\",\"id\":2},\"options\":{\"type\":\"ServiceOptions\",\"id\":3}}},\"MethodDescriptorProto\":{\"fields\":{\"name\":{\"type\":\"string\",\"id\":1},\"inputType\":{\"type\":\"string\",\"id\":2},\"outputType\":{\"type\":\"string\",\"id\":3},\"options\":{\"type\":\"MethodOptions\",\"id\":4},\"clientStreaming\":{\"type\":\"bool\",\"id\":5},\"serverStreaming\":{\"type\":\"bool\",\"id\":6}}},\"FileOptions\":{\"fields\":{\"javaPackage\":{\"type\":\"string\",\"id\":1},\"javaOuterClassname\":{\"type\":\"string\",\"id\":8},\"javaMultipleFiles\":{\"type\":\"bool\",\"id\":10},\"javaGenerateEqualsAndHash\":{\"type\":\"bool\",\"id\":20,\"options\":{\"deprecated\":true}},\"javaStringCheckUtf8\":{\"type\":\"bool\",\"id\":27},\"optimizeFor\":{\"type\":\"OptimizeMode\",\"id\":9,\"options\":{\"default\":\"SPEED\"}},\"goPackage\":{\"type\":\"string\",\"id\":11},\"ccGenericServices\":{\"type\":\"bool\",\"id\":16},\"javaGenericServices\":{\"type\":\"bool\",\"id\":17},\"pyGenericServices\":{\"type\":\"bool\",\"id\":18},\"deprecated\":{\"type\":\"bool\",\"id\":23},\"ccEnableArenas\":{\"type\":\"bool\",\"id\":31},\"objcClassPrefix\":{\"type\":\"string\",\"id\":36},\"csharpNamespace\":{\"type\":\"string\",\"id\":37},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[38,38]],\"nested\":{\"OptimizeMode\":{\"values\":{\"SPEED\":1,\"CODE_SIZE\":2,\"LITE_RUNTIME\":3}}}},\"MessageOptions\":{\"fields\":{\"messageSetWireFormat\":{\"type\":\"bool\",\"id\":1},\"noStandardDescriptorAccessor\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"mapEntry\":{\"type\":\"bool\",\"id\":7},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[8,8]]},\"FieldOptions\":{\"fields\":{\"ctype\":{\"type\":\"CType\",\"id\":1,\"options\":{\"default\":\"STRING\"}},\"packed\":{\"type\":\"bool\",\"id\":2},\"jstype\":{\"type\":\"JSType\",\"id\":6,\"options\":{\"default\":\"JS_NORMAL\"}},\"lazy\":{\"type\":\"bool\",\"id\":5},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"weak\":{\"type\":\"bool\",\"id\":10},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]],\"reserved\":[[4,4]],\"nested\":{\"CType\":{\"values\":{\"STRING\":0,\"CORD\":1,\"STRING_PIECE\":2}},\"JSType\":{\"values\":{\"JS_NORMAL\":0,\"JS_STRING\":1,\"JS_NUMBER\":2}}}},\"OneofOptions\":{\"fields\":{\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumOptions\":{\"fields\":{\"allowAlias\":{\"type\":\"bool\",\"id\":2},\"deprecated\":{\"type\":\"bool\",\"id\":3},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"EnumValueOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":1},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"ServiceOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"MethodOptions\":{\"fields\":{\"deprecated\":{\"type\":\"bool\",\"id\":33},\"uninterpretedOption\":{\"rule\":\"repeated\",\"type\":\"UninterpretedOption\",\"id\":999}},\"extensions\":[[1000,536870911]]},\"UninterpretedOption\":{\"fields\":{\"name\":{\"rule\":\"repeated\",\"type\":\"NamePart\",\"id\":2},\"identifierValue\":{\"type\":\"string\",\"id\":3},\"positiveIntValue\":{\"type\":\"uint64\",\"id\":4},\"negativeIntValue\":{\"type\":\"int64\",\"id\":5},\"doubleValue\":{\"type\":\"double\",\"id\":6},\"stringValue\":{\"type\":\"bytes\",\"id\":7},\"aggregateValue\":{\"type\":\"string\",\"id\":8}},\"nested\":{\"NamePart\":{\"fields\":{\"namePart\":{\"rule\":\"required\",\"type\":\"string\",\"id\":1},\"isExtension\":{\"rule\":\"required\",\"type\":\"bool\",\"id\":2}}}}},\"SourceCodeInfo\":{\"fields\":{\"location\":{\"rule\":\"repeated\",\"type\":\"Location\",\"id\":1}},\"nested\":{\"Location\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"span\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":2},\"leadingComments\":{\"type\":\"string\",\"id\":3},\"trailingComments\":{\"type\":\"string\",\"id\":4},\"leadingDetachedComments\":{\"rule\":\"repeated\",\"type\":\"string\",\"id\":6}}}}},\"GeneratedCodeInfo\":{\"fields\":{\"annotation\":{\"rule\":\"repeated\",\"type\":\"Annotation\",\"id\":1}},\"nested\":{\"Annotation\":{\"fields\":{\"path\":{\"rule\":\"repeated\",\"type\":\"int32\",\"id\":1},\"sourceFile\":{\"type\":\"string\",\"id\":2},\"begin\":{\"type\":\"int32\",\"id\":3},\"end\":{\"type\":\"int32\",\"id\":4}}}}}}}}},\"NanoPBOptions\":{\"fields\":{\"maxSize\":{\"type\":\"int32\",\"id\":1},\"maxLength\":{\"type\":\"int32\",\"id\":14},\"maxCount\":{\"type\":\"int32\",\"id\":2},\"intSize\":{\"type\":\"IntSize\",\"id\":7,\"options\":{\"default\":\"IS_DEFAULT\"}},\"type\":{\"type\":\"FieldType\",\"id\":3,\"options\":{\"default\":\"FT_DEFAULT\"}},\"longNames\":{\"type\":\"bool\",\"id\":4,\"options\":{\"default\":true}},\"packedStruct\":{\"type\":\"bool\",\"id\":5,\"options\":{\"default\":false}},\"packedEnum\":{\"type\":\"bool\",\"id\":10,\"options\":{\"default\":false}},\"skipMessage\":{\"type\":\"bool\",\"id\":6,\"options\":{\"default\":false}},\"noUnions\":{\"type\":\"bool\",\"id\":8,\"options\":{\"default\":false}},\"msgid\":{\"type\":\"uint32\",\"id\":9},\"anonymousOneof\":{\"type\":\"bool\",\"id\":11,\"options\":{\"default\":false}},\"proto3\":{\"type\":\"bool\",\"id\":12,\"options\":{\"default\":false}},\"enumToString\":{\"type\":\"bool\",\"id\":13,\"options\":{\"default\":false}},\"fixedLength\":{\"type\":\"bool\",\"id\":15,\"options\":{\"default\":false}},\"fixedCount\":{\"type\":\"bool\",\"id\":16,\"options\":{\"default\":false}}}},\"nanopbFileopt\":{\"type\":\"NanoPBOptions\",\"id\":1010,\"extend\":\"google.protobuf.FileOptions\"},\"nanopbMsgopt\":{\"type\":\"NanoPBOptions\",\"id\":1010,\"extend\":\"google.protobuf.MessageOptions\"},\"nanopbEnumopt\":{\"type\":\"NanoPBOptions\",\"id\":1010,\"extend\":\"google.protobuf.EnumOptions\"},\"nanopb\":{\"type\":\"NanoPBOptions\",\"id\":1010,\"extend\":\"google.protobuf.FieldOptions\"},\"FieldType\":{\"values\":{\"FT_DEFAULT\":0,\"FT_CALLBACK\":1,\"FT_POINTER\":4,\"FT_STATIC\":2,\"FT_IGNORE\":3,\"FT_INLINE\":5}},\"IntSize\":{\"values\":{\"IS_DEFAULT\":0,\"IS_8\":8,\"IS_16\":16,\"IS_32\":32,\"IS_64\":64}}}}');\n\n//# sourceURL=webpack://ParticleUsb/./node_modules/@particle/device-os-protobuf/src/pbjs-generated/definitions.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/particle-usb.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});