{
  "type": "libraries",
  "id": "SpiffsParticleRK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/SpiffsParticleRK/archive/0.0.8.tar.gz"
  },
  "attributes": {
    "name": "SpiffsParticleRK",
    "version": "0.0.8",
    "installs": 9401,
    "license": "MIT",
    "author": "rickkas7@rickkas7.com",
    "sentence": "Particle port for the spiffs (SPI flash file system) library",
    "url": "https://github.com/rickkas7/SpiffsParticleRK",
    "repository": "https://github.com/rickkas7/SpiffsParticleRK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "s",
  "cardUrl": "/cards/libraries/s/SpiffsParticleRK",
  "versions": {
    "0.0.8": {
      "builds": {
        "2.0.1": {
          "photon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "electron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "argon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "boron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          }
        },
        "1.5.2": {
          "photon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "electron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "argon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "boron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          }
        },
        "3.3.0": {
          "photon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "electron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "argon": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": true,
            "4-deep-sleep-SpiffsParticleRK": false,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          },
          "boron": {
            "1-simple-SpiffsParticleRK": true,
            "2-self-test-SpiffsParticleRK": true,
            "3-stop-sleep-SpiffsParticleRK": false,
            "4-deep-sleep-SpiffsParticleRK": true,
            "5-benchmark-SpiffsParticleRK": true,
            "6-list-files-SpiffsParticleRK": true,
            "7-large-files-SpiffsParticleRK": true
          }
        }
      },
      "added": "2022-06-17T10:16:53.763Z"
    }
  },
  "readme": "# SpiffsParticleRK\n\n*Port of the SPIFFS library for the Particle platform*\n\n## Introduction\n\nThe [excellent SPIFFS library](https://github.com/pellepl/spiffs) provides a simple file system on a NOR flash chip. This is a port of the library for the Particle platform, with a few convenience helpers to make using it easier from C++ and using standard Particle/Arduino/Wiring APIs.\n\nBoth the original SPIFFS library and this port are MIT licensed, so you can use them in open-source or in closed-source commercial products without a fee or license.\n\nThe full browsable API documentation can be found [here](http://rickkas7.github.io/SpiffsParticleRK/). \n\n## Flash Support\n\nThis library supports SPI-connected NOR flash chips. These are typically tiny 8-SOIC surface mount chips, intended to be included on your own circuit board. There are also breadboard adapters that are available, shown in the examples below.\n\nThe chips are really inexpensive, less than US$0.50 in single quantities for a 1 Mbyte flash. They're available in sizes up to 16 Mbyte.\n\nSPI flash is less expensive than SD cards, and do not need an adapter or card slot. Of course they're not removable.\n\nThe underlying [SpiFlashRK library](https://github.com/rickkas7/SpiFlashRK) library supports SPI NOR flash from\n\n- ISSI, such as a [IS25LQ080B](http://www.digikey.com/product-detail/en/issi-integrated-silicon-solution-inc/IS25LQ080B-JNLE/706-1331-ND/5189766).\n- Winbond, such as a [W25Q32](https://www.digikey.com/product-detail/en/winbond-electronics/W25Q32JVSSIQ/W25Q32JVSSIQ-ND/5803981).\n- Macronix, such as the [MX25L8006EM1I-12G](https://www.digikey.com/product-detail/en/macronix/MX25L8006EM1I-12G/1092-1117-ND/2744800)\n- The external 1 Mbyte flash on the P1 module.\n- Probably others.\n\nIt is sometimes possible to find the 8-PDIP (0.3\") versions suitable for plugging directly into a breadboard. Both Macronix and Winbond make them, but they're infrequently used and often not available.\n\nIt does not support I2C flash, SD cards, or non-flash chips like FRAM.\n\n## Instantiating an SpiFlash object\n\nYou typically instantiate an object to interface to the flash chip as a global variable:\n\n---\n\n```\nSpiFlashISSI spiFlash(SPI, A2);\n```\n\nISSI flash connected to the primary SPI with A2 as the CS (chip select or SS).\n\n---\n\n```\nSpiFlashWinbond spiFlash(SPI, A2);\n```\n\nWinbond flash connected to the primary SPI with A2 as the CS (chip select or SS).\n\n---\n\n```\nSpiFlashWinbond spiFlash(SPI1, D5);\n```\n\nWinbond flash connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS).\n\n---\n\n```\nSpiFlashMacronix spiFlash(SPI1, D5);\n```\n\nMacronix flash connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS). This is the recommended for use on the E-Series module. Note that the E series requires the [MX25L8006EM1I-12G](https://www.digikey.com/product-detail/en/macronix/MX25L8006EM1I-12G/1092-1117-ND/2744800) the 0.154\", 3.90mm width 8-SOIC package.\n\n---\n\n```\nSpiFlashP1 spiFlash;\n```\n\nThe external flash on the P1 module. This extra flash chip is entirely available for your use; it is not used by the system firmware. You can only use this on the P1; it relies on system functions that are not available on other devices.\n\n\n## Connecting the hardware\n\nThe real intention is to reflow the 8-SOIC module directly to your custom circuit board. However, for prototyping, here are some examples:\n\nFor the primary SPI (SPI):\n\n| Name | Flash Alt Name | Particle Pin | Example Color |\n| ---- | -------------- | ------------ | ------------- |\n| SS   | CS             | A2           | White         |\n| SCK  | CLK            | A3           | Orange        |\n| MISO | DO             | A4           | Blue          |\n| MOSI | DI             | A5           | Green         |\n\n\nFor the secondary SPI (SPI1):\n\n| Name | Flash Alt Name | Particle Pin | Example Color |\n| ---- | -------------- | ------------ | ------------- |\n| SS   | CS             | D5           | White         |\n| SCK  | CLK            | D4           | Orange        |\n| MISO | DO             | D3           | Blue          |\n| MOSI | DI             | D2           | Green         |\n\nNote that the SS/CS line can be any available GPIO pin, not just the one specified in the table above.\n\n- Electron using Primary SPI\n\n![Electron](images/electron.jpg)\n\n- Photon using Secondary SPI (SPI1)\n\n![Photon SPI1](images/spi1.jpg)\n\n- Photon using Primary SPI and a poorly hand-soldered 8-SOIC adapter\n\n![SOIC Adapter](images/soic.jpg)\n\n- E-series evaluation kit with a [Macronix MX25L8006EM1I-12G](https://www.digikey.com/product-detail/en/macronix/MX25L8006EM1I-12G/1092-1117-ND/2744800) soldered to the E-series module (outlined in pink).\n\n![E-Series](images/eseries.png)\n\n- P1 module (extra flash is under the can)\n\n![P1](images/p1.jpg)\n\n\n## Using the SPIFFS API\n\n### Background\n\nA few things about SPIFFS:\n\n- It's relatively small, way smaller than SDFAT at least.\n- It has the bare minimum of things you need to store files.\n- You can allocate all or part of the flash chip to SPIFFS.\n\nIn particular, there are two important limitations:\n\n- It does not support subdirectories; all files are in a single directory.\n- Filenames are limited to 31 characters.\n- It does not have file timestamps (modification or creation times).\n\nWithin the scope of how you use SPIFFS these shouldn't be unreasonable limitations, though you should be aware.\n\nLike most file systems, there are a few things you must do:\n\n- You must mount the file system, typically at startup.\n- If your flash is blank, you'll need to format the file system.\n- You can iterate the top level directory to find the file names in it.\n- In order to use data in a file, you must open it and get a file handle, read or write, then close it.\n- There are a finite number of files that can be open, but you can set the maximum at mount time. The default is 4.\n- If you think the file system is corrupted, you can check and repair it.\n\nOnce you get it working, there is some fine-tuning you can do:\n\n- The cache size is programmable, which speeds up operations at the cost of additional RAM. The default is 2 logical blocks.\n- The logical block size is programmable. Using larger blocks can make using large files more efficient in flash storage, at the cost of more RAM and making small files less efficient in flash storage. The default is 4K, and can't be made smaller but can be made larger.\n- Even with the default settings, it's surprisingly fast (see the benchmarking section, below).\n\n## Example 1 - Simple\n\nThis example should be pretty straightforward:\n\n```\n#include \"Particle.h\"\n\n#include \"SpiffsParticleRK.h\"\n\n// Pick a debug level from one of these two:\n// SerialLogHandler logHandler;\nSerialLogHandler logHandler(LOG_LEVEL_TRACE);\n\n// Chose a flash configuration:\nSpiFlashISSI spiFlash(SPI, A2); \t\t// ISSI flash on SPI (A pins)\n// SpiFlashISSI spiFlash(SPI1, D5);\t\t// ISSI flash on SPI1 (D pins)\n// SpiFlashMacronix spiFlash(SPI1, D5);\t// Macronix flash on SPI1 (D pins), typical config for E series\n// SpiFlashWinbond spiFlash(SPI, A2);\t// Winbond flash on SPI (A pins)\n// SpiFlashP1 spiFlash;\t\t\t\t\t// P1 external flash inside the P1 module\n\n// Create an object for the SPIFFS file system\nSpiffsParticle fs(spiFlash);\n\nvoid setup() {\n\tSerial.begin();\n\n\tspiFlash.begin();\n\n\tfs.withPhysicalSize(1024 * 1024);\n\n\ts32_t res = fs.mountAndFormatIfNecessary();\n\tLog.info(\"mount res=%d\", res);\n\n\tif (res == SPIFFS_OK) {\n\t\tSpiffsParticleFile f = fs.openFile(\"test\", SPIFFS_O_RDWR|SPIFFS_O_CREAT);\n\t\tif (f.isValid()) {\n\t\t\tf.println(\"hello world\");\n\n\t\t\tf.seekStart();\n\n\t\t\tString s = f.readStringUntil('\\n');\n\t\t\tLog.info(\"got: %s\", s.c_str());\n\n\t\t\tf.close();\n\t\t}\n\t}\n}\n\nvoid loop() {\n\n}\n```\n\nIn more detail:\n\n---\n\n```\n// Pick a debug level from one of these two:\n// SerialLogHandler logHandler;\nSerialLogHandler logHandler(LOG_LEVEL_TRACE);\n```\n\nThis determines the log level. If you want fewer logs, uncomment the first SerialLogHandler definition and comment out the second.\n\n---\n\n```\n// Chose a flash configuration:\nSpiFlashISSI spiFlash(SPI, A2); \t\t// ISSI flash on SPI (A pins)\n// SpiFlashISSI spiFlash(SPI1, D5);\t\t// ISSI flash on SPI1 (D pins)\n// SpiFlashMacronix spiFlash(SPI1, D5);\t// Macronix flash on SPI1 (D pins), typical config for E series\n// SpiFlashWinbond spiFlash(SPI, A2);\t// Winbond flash on SPI (A pins)\n// SpiFlashP1 spiFlash;\t\t\t\t\t// P1 external flash inside the P1 module\n```\n\nThis sets up an ISSI flash chip on primary SPI (SPI), with A2 as the CS (chip select or SS line). You can comment this out and uncomment one of the other lines for other configurations.\n\n---\n\n```\nSpiffsParticle fs(spiFlash);\n```\n\nThis sets up the SpiffsParticle object using that flash chip. You will typically create this object as a global variable.\n\n---\n\n```\n\tspiFlash.begin();\n\n\tfs.withPhysicalSize(1024 * 1024);\n\t\n\ts32_t res = fs.mountAndFormatIfNecessary();\n\tLog.info(\"mount res=%d\", res);\n\n```\n\nYou must call begin() on the flash object. Then you must set the size of the file system. This is 1 Mbyte. The SPIFFS file system can use only a part of the flash, if you want. It can't be resized without reformatting, however.\n\nFinally, you must mount the file system. This call mounts it, if not formatted, will format it and try to mount it again.\n\n---\n\n```\n\t\tSpiffsParticleFile f = fs.openFile(\"test\", SPIFFS_O_RDWR|SPIFFS_O_CREAT);\n\t\tif (f.isValid()) {\n\t\t\tf.println(\"hello world\");\n\n\t\t\tf.seekStart();\n\n\t\t\tString s = f.readStringUntil('\\n');\n\t\t\tLog.info(\"got: %s\", s.c_str());\n\n\t\t\tf.close();\n\t\t}\n```\n\nThis block of code opens the file, creating it if necessary.\n\nIt writes the line `hello world` to the file.\n\nThen it reads the line back and prints it to the debug serial.\n\nOnce you get your filesystem working, you may want to eliminate the info messages from Spiffs. This can be done by using the categories feature of the log handler:\n\n```\nSerialLogHandler logHandler(LOG_LEVEL_WARN, { // Logging level for non-application messages\n    { \"app\", LOG_LEVEL_INFO }, // Default logging level for all application messages\n    { \"app.spiffs\", LOG_LEVEL_WARN } // Disable spiffs info and trace messages\n});\n```\n\n## Other examples\n\nThe 2-self-test example runs a bunch of tests to verify functionality. It also shows how to use most of the functions.\n\nThe 3-stop-sleep example shows how to use stop mode sleep (pin + time) to efficiently and safely manage the flash. Since stop mode sleep preserves the contents of RAM, you don't need to re-mount the file system or even the close and open the files. You can just continue where you left off.\n\nThe 6-list-files examples shows how to list the files on the flash. There are no subdirectories; only the single root directory.\n\n## Benchmarking\n\nThe 5-benchmark example runs some tests to evaluate the speed of the file system. This log is testing a 1 Mbyte ISSI flash chip on a Photon.\n\nThe format operation is slow, about 14 seconds for a 1 Mbyte flash. Fortunately you shouldn't have to format often (probably only once).\n\n```\n0000010000 [app] INFO: starting chipErase\n0000011853 [app] INFO: finished chipErase: 1853 ms\n0000011853 [app] INFO: starting format\n0000026245 [app] INFO: format res=0\n0000026245 [app] INFO: finished format: 14392 ms\n0000026245 [app] INFO: starting mount\n0000026291 [app] INFO: mount res=0\n0000026292 [app] INFO: finished mount: 47 ms\n```\n\nThe bulk write and read test does 512 byte operations sequentially. It's able to write 256 Kbytes in 1.5 seconds. It can read it in 264 milliseconds.\n\n```\n0000026292 [app] INFO: testing 262144 bytes in 512 byte blocks \n0000026360 [app] INFO: starting write\n0000027924 [app] INFO: finished write: 1564 ms\n0000027924 [app] INFO: starting read\n0000028188 [app] INFO: finished read: 264 ms\n```\n\nThe append and flush test writes 100 bytes and flushes the contents to flash so they'll be preserved if there is a power outage. It's able to do 5000 append and flush operations in 831 milliseconds.\n\nReading the blocks back only takes 104 milliseconds.\n\n```\n0000028708 [app] INFO: testing append and flush 100 bytes 5000 times \n0000028776 [app] INFO: starting append\n0000029607 [app] INFO: finished append: 831 ms\n0000029607 [app] INFO: starting read\n0000029711 [app] INFO: finished read: 104 ms\n```\n\nMacronix 1 Mbyte on SPI1 (D pins)\n\n```\n0000010000 [app] INFO: starting chipErase\n0000012944 [app] INFO: finished chipErase: 2944 ms\n0000012944 [app] INFO: starting format\n0000021291 [app] INFO: format res=0\n0000021291 [app] INFO: finished format: 8347 ms\n0000021291 [app] INFO: starting mount\n0000021356 [app] INFO: mount res=0\n0000021356 [app] INFO: finished mount: 65 ms\n0000021356 [app] INFO: testing 262144 bytes in 512 byte blocks \n0000021461 [app] INFO: starting write\n0000023808 [app] INFO: finished write: 2347 ms\n0000023808 [app] INFO: starting read\n0000024164 [app] INFO: finished read: 356 ms\n0000024989 [app] INFO: testing append and flush 100 bytes 5000 times \n0000025093 [app] INFO: starting append\n0000026331 [app] INFO: finished append: 1238 ms\n0000026331 [app] INFO: starting read\n0000026466 [app] INFO: finished read: 135 ms\n```\n\nWinbond 16 Mbyte on SPI (A pins), only 1 Mbyte file system (format would take longer with a full 16 Mbyte file system).\n\n```\n0000010000 [app] INFO: starting chipErase\n0000038317 [app] INFO: finished chipErase: 28317 ms\n0000038318 [app] INFO: starting format\n0000044716 [app] INFO: format res=0\n0000044716 [app] INFO: finished format: 6398 ms\n0000044716 [app] INFO: starting mount\n0000044763 [app] INFO: mount res=0\n0000044763 [app] INFO: finished mount: 47 ms\n0000044763 [app] INFO: testing 262144 bytes in 512 byte blocks \n0000044831 [app] INFO: starting write\n0000046392 [app] INFO: finished write: 1561 ms\n0000046392 [app] INFO: starting read\n0000046656 [app] INFO: finished read: 264 ms\n0000047201 [app] INFO: testing append and flush 100 bytes 5000 times \n0000047269 [app] INFO: starting append\n0000048118 [app] INFO: finished append: 849 ms\n0000048119 [app] INFO: starting read\n0000048223 [app] INFO: finished read: 104 ms\n```\n\n## Resource usage\n\nThe code space used by the library is slightly less than 30 Kbytes. This includes both the SpiFlashRK and SpiffsParticleRK libraries and the Wiring/Arduino Stream compatibility.\n\nThe RAM usage is dependent on various settings.\n\n- Work buffers (2 * logical page size), default is 2 * 256 = 512\n- File descriptor buffers (32 * max open files), default is 32 * 4 = 128\n- Cache (logical page size + 32) * cachePages + 40 byte, default is (256 + 32) * 2 + 40 = 616\n* Thus the total RAM allocated during mount is by default is 1256 bytes\n\nThis memory is freed if you unmount, though in most cases you'll keep the volume mounted all of the time.\n\n\n# Version History\n\n### 0.0.8 (2020-10-29)\n\n- Updated to SpiFlashRK 0.0.8, fixes SPI transactions and add 32-bit addressing support\n- Added new large file test code (example 7).\n- Note: File systems are still limited to 16 Mbytes, however on a 32 Mbyte flash chip you\ncan now use the upper half as a file system.\n\n\n### 0.0.7 (2020-05-04)\n\n- Updated to SpiFlashRK 0.0.6\n\n",
  "allVersions": [
    "0.0.8",
    "0.0.7",
    "0.0.6",
    "0.0.5",
    "0.0.4",
    "0.0.3",
    "0.0.2",
    "0.0.1"
  ]
}