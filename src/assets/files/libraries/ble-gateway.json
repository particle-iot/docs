{
  "type": "libraries",
  "id": "ble-gateway",
  "links": {
    "download": "https://api.particle.io/v1/libraries/ble-gateway/archive/0.0.1.tar.gz"
  },
  "attributes": {
    "name": "ble-gateway",
    "version": "0.0.1",
    "installs": 450,
    "license": "MIT",
    "author": "Mariano Goluboff",
    "sentence": "Connect to different BLE peripherals.",
    "paragraph": "This library requires DeviceOS 3.0+",
    "repository": "https://github.com/particle-iot/ble-gateway-library",
    "architectures": [],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "b",
  "cardUrl": "/cards/libraries/b/ble-gateway",
  "versions": {
    "0.0.1": {
      "builds": {
        "2.0.1": {
          "photon": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "electron": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "argon": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "boron": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          }
        },
        "1.5.2": {
          "photon": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "electron": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "argon": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          },
          "boron": {
            "masterbuilt-smoker": false,
            "tracker-bike_speed-heartrate": false,
            "veepeak": false
          }
        }
      }
    }
  },
  "readme": "# BLE Gateway Library\n\n__This library requires DeviceOS version 3.0.0 or higher__\n\nThis library turns a Particle Gen3 device (Tracker, Boron, Argon) into a Bluetooth Low Energy (BLE) Central device. In this mode, it is able to detect and connect to BLE Peripherals, and expose APIs so that your application can get and/or send data to the peripherals, depending on their capabilities.\n\nIf the peripheral that you’d like to connect to is already supported by the library, you can use this without any modifications. Here's a list of peripherals currently supported:\n* Heart Rate Monitor\n* Cycling Speed and Cadence Sensor\n* Jumper brand Pulse Oximeter\n\nIf the peripheral is not currently supported, the library is written in a modular format so that it is easy to add your peripheral.\n\n## Usage\n\nFor basic usage, you will need to:\n\n* Include the header files for the peripherals you want to use\n* Enable the type of devices you want to connect to\n* Register a callback to be notified when a connection happens\n\n```c++\n#include \"ble-device-gateway.h\"\n#include \"peripherals/pulse-oximeter.h\"\n#include \"peripherals/cycling-sensor.h\"\n#include \"peripherals/heart-rate-monitor.h\"\n#include \"peripherals/masterbuilt-smoker.h\"\n\nvoid setup() {\n  BleDeviceGateway::instance().setup();\n  BleDeviceGateway::instance().onConnectCallback(onConnect);\n  BleDeviceGateway::instance().enableServiceCustom(PulseOx::bleDevicePtr, JUMPER_PULSEOX_SERVICE);\n  BleDeviceGateway::instance().enableService(HeartRateMonitor::bleDevicePtr, BLE_SIG_UUID_HEART_RATE_SVC);\n  BleDeviceGateway::instance().enableService(CyclingSpeedAndCadence::bleDevicePtr ,BLE_SIG_UUID_CYCLING_SPEED_CADENCE_SVC);\n  BleDeviceGateway::instance().enableServiceByName(MasterbuiltSmoker::bleDevicePtr ,\"Masterbuilt Smoker\");\n}\n\nvoid loop() {\n  BleDeviceGateway::instance().loop();\n}\n```\n\nThe callback function for when a device is connected has the device class as the parameter. You can find out what type of device it is by checking the `getType()` function, like this:\n\n```c++\nvoid onConnect(BleDevice& device)\n{\n  if (device.getType() == BleUuid(JUMPER_PULSEOX_SERVICE))  {\n    Log.info(\"Connected to Jumper Pulse Oximeter\");\n  } else if (device.getType() == BleUuid(BLE_SIG_UUID_HEART_RATE_SVC))\n  {\n    HeartRateMonitor& dev = (HeartRateMonitor&)device;\n    dev.setNewValueCallback(onNewHrValue, NULL);\n    uint8_t buf[20];\n    if (dev.getManufacturerName(buf, 20) > -1) {\n      Log.info(\"Connected to Heart Rate Monitor named: %s\", buf);\n    }\n    Log.info(\"Battery Level: %d\", dev.getBatteryLevel());\n  }\n}\n```\n\nHere is where you also would add the capabilities that your application needs. For example, a Heart Rate Monitor typically notifies once per second of the heart rate, so the Heart Rate Monitor type in the library has an API to register a callback to receive the notifications. The battery level is usually notified only when it changes. The `NOTIFY` property is Optional for the Battery Service, while `READ` is mandatory. If you know the heart rate monitor that you're using implements `NOTIFY`, then you can also get the battery level in the same callback as the heart rate measurement. For example:\n\n```c++\nvoid onNewHrValue(HeartRateMonitor& monitor, BleUuid uuid, void* context) {\n  if (uuid == BLE_SIG_HEART_RATE_MEASUREMENT_CHAR) {\n    //Log.info(\"Heart Rate: %u\", monitor.getHeartRate() );\n  } else if (uuid == BLE_SIG_BATTERY_LEVEL_CHAR) {\n    Log.info(\"Battery callback level: %d\", monitor.getBatteryLevel() );\n  } \n}\n```\n\nIf you're not sure if the Heart Rate monitor supports `NOTIFY`, you can use the `bool batterySupportsNotify()` API to find out.\n\nAnother device might instead allow you to read or write to it. In that case, the type for that device would have APIs to allow you to do that within your application.\n\n### Handle Pairing\n\nThe Gateway Library can help with pairing to a device, whether the pairing is Just Works, or it requires a passkey. Since pairing can involve entering or displaying a passkey, during `setup()` you need to tell the library what the input/output\ncapabilities of your device are. For example:\n\n```c++\nvoid setup() {\n  ...\n  BleDeviceGateway::instance().setup(BlePairingIoCaps::KEYBOARD_DISPLAY);\n}\n```\n\nThe options are:\n   *  NONE - default, no input/ouput\n   *  DISPLAY_ONLY - can display a passkey, but no input\n   *  DISPLAY_YESNO - can display a passkey, and user can enter yes/no\n   *  KEYBOARD_ONLY - user can enter a passkey, but no display\n   *  KEYBOARD_DISPLAY - user can enter a passkey, and device can display a passkey\n\n#### Display a Passkey\n\nFor displaying a passkey that is sent by the peripheral, you register a callback like this:\n\n```c++\nvoid onPasskeyDisplay(BleDevice& device, const uint8_t* passkey, size_t passkeyLen);\n\nvoid setup() {\n  ...\n  BleDeviceGateway::instance().onPasskeyDisplay(onPasskeyDisplay);\n}\n```\n\nThe callback will be called when we receive a passkey from the device. The callback can then display it as needed. If there is no callback registered, by default the library will use `Log.info` to log the passkey received.\n\n#### Input a passkey\n\nFor entering a passkey value, you can register a callback like this:\n\n```c++\nvoid onPasskeyInput(BleDevice& device) {\n  if (device.getType() == BleUuid(MASTERBUILT_SMOKER_SERVICE)) {\n    device.passkeyInput((uint8_t *)\"000000\");\n  } else {\n    device.passkeyInput();\n  }\n}\n\nvoid setup() {\n  ...\n  BleDeviceGateway::instance().onPasskeyInput(onPasskeyInput);\n}\n```\n\nThe callback must call the `passkeyInput` function on the `BleDevice` object. Either call it with a pointer to the passkey (in the example above, 000000), or call it without an argument to use the default passkey\nfor that type of peripheral. Note that if the type of peripheral doesn't override `passkeyInput()`, the library will reject the pairing.\n\n## Examples\n\n* [Tracker Bike Speed and Heart Rate](examples/tracker-bike_speed-heartrate): use a Bicycle Speed sensor and a Heart Rate monitor to track your speed and heart rate as you bike around town.\n* [Read OBD2 on Tracker with Veepeak OBDCheck BLE+](examples/veepeak): use an OBD2 BLE dongle to read CAN parameters from your car and track speed, RPM, and engine temperature associated with your car's location.\n* [Remotely view and control a food smoker](examples/masterbuilt-smoker): view the temperature of food and smoker, as well as remotely change the temperature and timer.\n\n## Library Design\n\nThe BLE specification takes a modular approach to building a device. Peripherals are structured like this:\n\n* Peripheral includes one or more services\n* Service includes one or more characteristics\n* Characteristic data may be written to, read from (polled), or sent from the device (pushed). A characteristic may support one or more of these methods of data transfer\n\nThis library takes a similar modular approach with the following goals:\n\n* Application only needs to know about the peripheral type APIs\n* Characteristics and services can be reused when adding peripheral types\n* Easily add new peripheral types, characteristics, or services\n\n### Characteristics\n\nThe definition for characteristics are found in the `src/characteristics` directory. The characteristics can be ones that are defined by the Bluetooth SIG standards, or custom characteristics for a specific device type. Standards based characteristics have a 16-bit UUID, which is assigned by the Bluetooth SIG and can be found here: [Characteristics assigned numbers](https://www.bluetooth.com/specifications/gatt/characteristics/). Custom characteristics have a 128-bit UUID that is selected by the manufacturer of the peripheral device.\n\n### Services\n\nThe definition for services are found in the `src/services` directory. Just like with characteristics, both 16-bit standards based and 128-bit custom UUIDs are supported. The services defined by the Bluetooth SIG can be found here: [Services assigned numbers](https://www.bluetooth.com/specifications/gatt/services/)\n\n### Peripheral types\n\nThe top-level is the definition of peripheral types, and can be found in the `src/peripherals` directory. A header file for each device type should be placed here, and these are the only APIs that the application needs to be aware of. The peripheral type implementation should abstract the service and characteristics complexities.\n\n## Adding new device types\n\nTo add a new type of device to connect to, follow these steps:\n\n* Create any needed characteristics in `src/characteristics`\n* Create any needed services in `src/services`\n* In `src/peripherals/<new-peripheral-type>.h`, derive the BleDevice class\n* The derived BleDevice class should expose methods to read/set characteristics as appropriate, and must override the `getType()` function.\n* If a characteristic is `NOTIFY` or `INDICATE`, the class should have a `setNewValueCallback()` function, which accepts a callback to be called when there’s a new value\n\n\n## LICENSE\nCopyright 2020 Mariano Goluboff\n\nLicensed under the MIT license\n",
  "allVersions": [
    "0.0.1"
  ]
}