{
  "type": "libraries",
  "id": "PublishManager",
  "links": {
    "download": "https://api.particle.io/v1/libraries/PublishManager/archive/1.0.0.tar.gz"
  },
  "attributes": {
    "name": "PublishManager",
    "version": "1.0.0",
    "installs": 1981,
    "license": "MIT",
    "author": "Ben Veenema <bveenema@gmail.com>",
    "sentence": "Caches Particle.publish events until the Cloud is available and limits to 1 publish/sec.",
    "paragraph": "PublishManager implements a FIFO queue so your Particle.publish()'s are published in the order they are created. Thanks to tiagonmas and JumpMaster for PublishQueue.",
    "repository": "git repository for the project, like https://github.com/bveenema/PublishManager",
    "architectures": [],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "p",
  "cardUrl": "/cards/libraries/p/PublishManager",
  "versions": {
    "1.0.0": {
      "builds": {
        "2.0.1": {
          "photon": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          },
          "electron": {
            "BasicExample-TimeDelayOnly": false,
            "CacheBeforeCloudConnect": false,
            "CustomCacheSize": false,
            "PublishWithTimestamp": false,
            "StaticBuffer": false
          },
          "argon": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          },
          "boron": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          }
        },
        "1.5.2": {
          "photon": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          },
          "electron": {
            "BasicExample-TimeDelayOnly": false,
            "CacheBeforeCloudConnect": false,
            "CustomCacheSize": false,
            "PublishWithTimestamp": false,
            "StaticBuffer": false
          },
          "argon": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          },
          "boron": {
            "BasicExample-TimeDelayOnly": true,
            "CacheBeforeCloudConnect": true,
            "CustomCacheSize": true,
            "PublishWithTimestamp": true,
            "StaticBuffer": true
          }
        }
      }
    }
  },
  "readme": "# PublishManager\r\n\r\nA Particle library for managing your `Particle.publish()` events.  Store's your `Particle.publish()` events while you're offline and makes sure you don't exceed the maximum publish rate of 1/second by caching `Particle.publish()` events.\r\n\r\nPublishManager implements a First-In-First-Out (FIFO), circular buffer so that `Particle.publish()'s` are published in the same order they are created and if you aren't generating publishes faster than 1/second, `publish events` will be sent at the same time they are created.\r\n\r\n[This library uses static memory allocation](#memory-allocation)\r\n\r\n## Usage\r\n\r\nUsing PublishManager can be as simple as:\r\n\r\n```\r\n#include \"PublishManager.h\"\r\nPublishManager<> publishManager;\r\n\r\nvoid setup() {\r\n  publishManager.publish(\"My_Event_Name\",\"My_Data\");\r\n}\r\n\r\nvoid loop() {\r\n  publishManager.process();\r\n}\r\n```\r\n`.publish()` creates a Publish Event (pubEvent) that is stored in the cache of PublishManager and released to the cloud when it is safe to do so by calling `.process()`. The `.process()` method can (and should) be called more often than 1/second and is safe to call when the Particle device is offline. Process will make sure your device is connected to the Particle Cloud before publishing.\r\n\r\nNote: In this simplified example, \"My_Event_Name\" would actually publish immediately and not be stored in the cache at all. A subsequent, immediate (under 1 second) call to `.publish()` would be stored in the cache.\r\n\r\nStoring publish events can use up a lot of memory so PublishManager limits the number of events to **5**. You can ovverride this (with caution) using the by setting the variables between the `<` and `>` brackets. See the `CustomCacheSize` example for more info.\r\n\r\nSee the [examples](examples) folder for more details.\r\n\r\n## Adding a Timestamp\r\nWhen caching publish events for large durations of time, it can be useful to tag the event with a time stamp so the server can determine when the event occurred instead of when it was published.\r\n\r\nIn order for this library to remain agnostic to data formatting, no method has been included to automatically add a time stamp, but a simple `sprintf()` statement can easily add a time stamp to the cache:\r\n```\r\n// Publishs \"data\" as a JSON char string called buffer, which contains the\r\n//  original data and a timestamp.\r\n//  ex: {\"data\": \"test: 0\", \"time\": 1524500000}\r\nvoid publishWithTimeStamp(String eventName, String data){\r\n  char buffer[255];\r\n\r\n  sprintf(buffer, \"{\\\"data\\\": \\\"%s\\\", \\\"time\\\": %u}\",data.c_str(), Time.now());\r\n\r\n  publishManager.publish(eventName, buffer);\r\n}\r\n```\r\n\r\n## Documentation\r\n\r\n```\r\nPublishManager<size_t _maxCacheSize, size_t _maxEventName, size_t _maxData> ()\r\n```\r\nConstructor - Creates a statically allocated circular buffer of **_maxCacheSize** elements, with **_maxEventName** maximum Publish Event Name and **_maxData** maximum data length. Defaults to 5, 63, 255 respectively.\r\nEx.\r\n* `PublishManager<> publishManager() // default (5,63,255) ~1590 bytes`\r\n* `PublishManager<15> publishManager() // Additional elements in cache (15,63,255) ~4770 bytes`\r\n* `PublishManager<15,20,50> publishManager() // Custom Cache (15,20,50) ~1050 bytes`\r\n___\r\n\r\n```\r\nbool publish(String eventName, String data)\r\n```\r\nAdds a publish event to the queue or publishes event immediately if timer has elapsed. Returns `true` if event is published or added to queue. Returns `false` is the queue is full, or the eventName or data is greater than the maximum* and event is discarded.\r\n\r\n*If the cache is empty, you can publish an event greater than the size declared in the constructor as it bypasses the cache and is published immediately\r\n___\r\n\r\n```\r\nint16_t cacheSize()\r\n```\r\nReturns the number of Particle.publish() events in the queue. 0 if empty. -1 if empty and enough time has passed for instant publish.\r\n___\r\n\r\n```\r\nvoid process()\r\n```\r\nCall `.process()` every loop and at least 1x/sec. `.process()` can be safely called when the device is offline.\r\n___\r\n\r\n## Using PublishManager in multiple files\r\nIf your application requires PublishManager to be called from multiple files, like your own `.cpp` or `.c` files, create the `publishManager` object in your main `.ino` file and then use the `extern` keyword when \"creating\" the publishManager object in additional files.\r\n\r\nThis will prevent duplicate PublishManager objects from being created, and consequentally creating `Particle.publish()` events too often.\r\n\r\n**Example**\r\n___\r\n_main.ino_\r\n```\r\n#include \"PublishManager.h\"\r\n#include \"MyLibrary.h\"\r\n\r\nPublishManager<> publishManager;\r\n\r\nvoid setup() {\r\n  // Do setup stuff\r\n  publishManager.publish(\"My_Event_Name\",\"My_Data\");\r\n}\r\n\r\nvoid loop() {\r\n  // Do loop stuff\r\n}\r\n```\r\n_MyLibrary.h_\r\n```\r\n#pragma once\r\n//MyLibrary.h - by Me\r\n\r\n#include \"Particle.h\"\r\n#include \"PublishManager.h\"\r\n\r\nextern PublishManager<> publishManager\r\n\r\nClass MyLibrary {\r\n  public:\r\n    MyLibrary();\r\n\r\n    update(String message){\r\n      publishManager.publish(\"MyLibrary\", message);\r\n    }\r\n\r\n  private:\r\n};\r\n```\r\n\r\n## Memory Allocation\r\nThis library uses a statically allocated circular buffer, based heavily on code from [Embedded Artistry](https://embeddedartistry.com/blog/2017/4/6/circular-buffers-in-cc) This means an entire block of heap memory is allocated at the beginning of the program execution and remains for the entire duration (unless PublishManager is `deleted` or goes out of scope).  This means that PublishManager can use a lot of memory; ~1590 bytes in the default case, with only a 5 event cache.  \r\n\r\nPublishManager can be easily modified to use less memory or store more publish events by changing the default template. by instantiating PublishManager with `PublishManager<10,20,50>` PublishManager can store 10 events in less than half the space (~700 bytes)! But the programmer must take care to limit eventNames to less than 20 characters and data to less than 50.\r\n\r\n## CHANGELOG\r\n\r\n* v0.0.1 - Initial Release\r\n* v0.0.2 - Add cacheSize()\r\n* v0.0.3 - Additional method for using with Core's\r\n* v0.0.4 - Add example publishWithTimeStamp\r\n* v0.0.5 - Change to statically allocated memory. Remove Software Timer publish in favor of `.process()` method\r\n\r\n## LICENSE\r\nCopyright 2018 Ben Veenema\r\n\r\nLicensed under the MIT license\r\n",
  "allVersions": [
    "1.0.0",
    "0.0.5",
    "0.0.4",
    "0.0.2",
    "0.0.1"
  ]
}