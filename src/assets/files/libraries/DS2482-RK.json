{
  "type": "libraries",
  "id": "DS2482-RK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/DS2482-RK/archive/0.0.3.tar.gz"
  },
  "attributes": {
    "name": "DS2482-RK",
    "version": "0.0.3",
    "installs": 1874,
    "license": "MIT",
    "author": "rickkas7@rickkas7.com",
    "sentence": "Particle driver for DS2482 I2C to 1-Wire interface",
    "url": "https://github.com/rickkas7/DS2482-RK",
    "repository": "https://github.com/rickkas7/DS2482-RK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "d",
  "cardUrl": "/reference/device-os/libraries/d/DS2482-RK",
  "versions": {
    "0.0.3": {
      "builds": {
        "2.0.1": {
          "photon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "electron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "1.5.2": {
          "photon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "electron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "3.3.0": {
          "photon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "electron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "5.0.1": {
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "bsom": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "b5som": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "tracker": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "p2": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "4.0.0": {
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "bsom": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "b5som": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "tracker": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "esomx": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "5.6.0": {
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "bsom": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "b5som": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "tracker": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "p2": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        },
        "4.2.0": {
          "argon": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "boron": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "bsom": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "b5som": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "tracker": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          },
          "esomx": {
            "01-single-drop": true,
            "02-multi-drop": true,
            "03-simple-class": true
          }
        }
      },
      "added": "2022-06-17T10:16:53.941Z"
    }
  },
  "readme": "# DS2482 Library\n\nThe DS2482 is an I2C to 1-wire interface chip. It comes in two versions, the DS2482-100 (1-port) and DS2482-800 (8-port). Using an interface chip is helpful because most DS18B20/1-wire libraries use timing sensitive code and may run for extended periods with interrupts disabled. This can cause the rest of your program to have poor performance. \n\nThe library fully supports both single-drop and multi-drop modes, allowing many DS18B20 sensors on a single 1-wire bus.\n\nThe DS2482 library is completely asynchronous, never blocking for more than the time to do an I2C read or write. Interrupts are never disabled.\n\nEvery call uses a C++11 lambda completion handler. The second part of this document has a bit of explanation of why and how it works.\n\nThe DS2482 also has an internal transistor to pull the 1-wire bus high during temperature conversion and flash writes. This allows the use of parasitic power mode, requiring only two wires for sensors (DQ and GND), with no separate power line. The library supports this as well.\n\nThe full API documentation can be browsed at [http://rickkas7.github.io/DS2482-RK/](http://rickkas7.github.io/DS2482-RK/). The same HTML documentation is in the docs folder in Github.\n\nThe official Github is: [https://github.com/rickkas7/DS2482-RK](https://github.com/rickkas7/DS2482-RK).\n\nIt's in the Particle community libraries as DS2482-RK.\n\n## Common tasks\n\n### Get temperature of one sensor (single-drop)\n\nThe code is also in examples, in the 01-single-drop directory.\n\n```\n#include \"DS2482.h\"\n\nSerialLogHandler logHandler;\n\nDS2482 ds(Wire, 3);\n\nconst unsigned long CHECK_PERIOD = 30000;\nunsigned long lastCheck = 5000 - CHECK_PERIOD;\n\nvoid setup() {\n\tSerial.begin(9600);\n\tds.setup();\n\n\tDS2482DeviceReset::run(ds, (link unavailable in preview) {\n\t\tSerial.printlnf(\"deviceReset=%d\", status);\n\t});\n\n\tSerial.println(\"setup complete\");\n}\n\n\n\nvoid loop() {\n\n\tds.loop();\n\n\tif (millis() - lastCheck >= CHECK_PERIOD) {\n\t\tlastCheck = millis();\n\n\t\t// For single-drop you can pass an empty address to get the temperature of the only\n\t\t// sensor on the 1-wire bus\n\t\tDS24821WireAddress addr;\n\n\t\tDS2482GetTemperatureCommand::run(ds, addr, (link unavailable in preview) {\n\t\t\tif (status == DS2482Command::RESULT_DONE) {\n\t\t\t\tchar buf[32];\n\t\t\t\tsnprintf(buf, sizeof(buf), \"%.4f\", tempC);\n\n\t\t\t\tSerial.printlnf(\"temperature=%s deg C\", buf);\n\t\t\t\tParticle.publish(\"temperature\", buf, PRIVATE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSerial.printlnf(\"DS2482GetTemperatureCommand failed status=%d\", status);\n\t\t\t}\n\t\t});\n\t}\n}\n```\n\n### Get temperatures of multiple sensors (multi-drop)\n\nThe code is also in examples, in the 02-multi-drop directory.\n\n```\n#include \"DS2482.h\"\n\nSerialLogHandler logHandler;\n\nDS2482 ds(Wire, 3);\n\nDS2482DeviceListStatic<10> deviceList;\nconst unsigned long CHECK_PERIOD = 30000;\nunsigned long lastCheck = 10000 - CHECK_PERIOD;\n\nvoid setup() {\n\tSerial.begin(9600);\n\tds.setup();\n\n\tDS2482DeviceReset::run(ds, (link unavailable in preview) {\n\t\tSerial.printlnf(\"deviceReset=%d\", status);\n\t\tDS2482SearchBusCommand::run(ds, deviceList, (link unavailable in preview) {\n\n\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\tSerial.printlnf(\"DS2482SearchBusCommand status=%d\", status);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSerial.printlnf(\"Found %u devices\", deviceList.getDeviceCount());\n\t\t});\n\t});\n\n\tSerial.println(\"setup complete\");\n}\n\n\nvoid loop() {\n\n\tds.loop();\n\n\tif (millis() - lastCheck >= CHECK_PERIOD) {\n\t\tlastCheck = millis();\n\n\t\tif (deviceList.getDeviceCount() > 0) {\n\n\t\t\tDS2482GetTemperatureForListCommand::run(ds, deviceList, (link unavailable in preview) {\n\t\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\t\tSerial.printlnf(\"DS2482GetTemperatureForListCommand status=%d\", status);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tSerial.printlnf(\"got temperatures!\");\n\n\t\t\t\tfor(size_t ii = 0; ii < deviceList.getDeviceCount(); ii++) {\n\t\t\t\t\tSerial.printlnf(\"%s valid=%d C=%f F=%f\",\n\t\t\t\t\t\t\tdeviceList.getAddressByIndex(ii).toString().c_str(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getValid(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureC(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureF());\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tSerial.printlnf(\"no devices found\");\n\t\t}\n\t}\n}\n```\n\n### Multi-drop with parasitic power\n\nJust as the previous example, except within loop the call to D2482GetTemperatureListCommand::run has an extra optional fluent parameter, `.withParasiticPower()`.\n\n```\n\t\t\tDS2482GetTemperatureForListCommand::run(ds, deviceList, (link unavailable in preview) {\n\t\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\t\tSerial.printlnf(\"DS2482GetTemperatureForListCommand status=%d\", status);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tSerial.printlnf(\"got temperatures!\");\n\n\t\t\t\tfor(size_t ii = 0; ii < deviceList.getDeviceCount(); ii++) {\n\t\t\t\t\tSerial.printlnf(\"%s valid=%d C=%f F=%f\",\n\t\t\t\t\t\t\tdeviceList.getAddressByIndex(ii).toString().c_str(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getValid(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureC(),\n\t\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureF());\n\t\t\t\t}\n\n\t\t\t}).withParasiticPower();\n```\n\n### Multi-drop with JSON publish\n\nThis example is like the previous, except it publishes multiple sensor values via a single Particle.publish in JSON format (up to 10 DS18B20s supported).\n\nThe full examples is only in github, in the test-projects/10-multidrop-json directory. This is because it requires another library, JsonParserGeneratorRK, in addition to DS2482-RK.\n\n```\n#include \"DS2482.h\"\n#include \"JsonParserGeneratorRK.h\"\n\nSerialLogHandler logHandler;\n\nDS2482 ds(Wire, 3);\n\nDS2482DeviceListStatic<10> deviceList;\nJsonWriterStatic<256> jsonWriter;\n\nconst unsigned long CHECK_PERIOD = 30000;\nunsigned long lastCheck = 10000 - CHECK_PERIOD;\n\nvoid setup() {\n\tSerial.begin(9600);\n\tds.setup();\n\n\tDS2482DeviceReset::run(ds, (link unavailable in preview) {\n\t\tSerial.printlnf(\"deviceReset=%d\", status);\n\t\tDS2482SearchBusCommand::run(ds, deviceList, (link unavailable in preview) {\n\n\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\tSerial.printlnf(\"DS2482SearchBusCommand status=%d\", status);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSerial.printlnf(\"Found %u devices\", deviceList.getDeviceCount());\n\t\t});\n\t});\n\n\tSerial.println(\"setup complete\");\n}\n\n\nvoid loop() {\n\n\tds.loop();\n\n\tif (millis() - lastCheck >= CHECK_PERIOD) {\n\t\tlastCheck = millis();\n\n\t\tif (deviceList.getDeviceCount() > 0) {\n\n\t\t\tDS2482GetTemperatureForListCommand::run(ds, deviceList, (link unavailable in preview) {\n\t\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\t\tSerial.printlnf(\"DS2482GetTemperatureForListCommand status=%d\", status);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tSerial.printlnf(\"got temperatures!\");\n\n\t\t\t\t// Initialize the JsonWriter object and sets it to send 2 decimal places\n\t\t\t\tjsonWriter.init();\n\t\t\t\tjsonWriter.setFloatPlaces(2);\n\n\t\t\t\t// startObject is for the outer object and must be balanced with finishObjectOrArray.\n\t\t\t\tjsonWriter.startObject();\n\n\t\t\t\t// Write the actual temperatures\n\t\t\t\tfor(size_t ii = 0; ii < deviceList.getDeviceCount(); ii++) {\n\t\t\t\t\tif (deviceList.getDeviceByIndex(ii).getValid()) {\n\t\t\t\t\t\t// This creates a key of the form \"t0\" for the first, \"t1\" for the second, ...\n\t\t\t\t\t\tchar key[4];\n\t\t\t\t\t\tkey[0] = 't';\n\t\t\t\t\t\tkey[1] = '0' + ii;\n\t\t\t\t\t\tkey[2] = 0;\n\n\t\t\t\t\t\t// Inserts the float as a key value pair\n\t\t\t\t\t\tjsonWriter.insertKeyValue(key, deviceList.getDeviceByIndex(ii).getTemperatureC());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tjsonWriter.finishObjectOrArray();\n\n\t\t\t\tSerial.println(jsonWriter.getBuffer());\n\t\t\t\tParticle.publish(\"temperature\", jsonWriter.getBuffer(), PRIVATE);\n\n\t\t\t\t// Example output:\n\t\t\t\t// {\"t0\":23.56,\"t1\":23.12}\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tSerial.printlnf(\"no devices found\");\n\t\t}\n\t}\n}\n```\n\nExample serial output:\n\n```\ngot temperatures!\n{\"t0\":23.56,\"t1\":23.12}\n```\n\nBecause the 1-wire bus search is deterministic, it will always returns the sensors in the same order, sorted by 1-wire device address (increasing).\n\n### Test Suite\n\nThere's a test suite for the library in Github, in test-projects/11-testboard. This is a hardware and software combination used to do regression testing on the library.\n\n## About lambdas, fluent-style and more\n\nThe DS2482 library uses a C++11 style of coding that is very powerful, but will probably be foreign to you if you learned old-school C and C++. It's actually more like the way Javascript/node.js is programmed.\n\nOne of the main advantages of the DS2482 library is that it's completely asynchronous. No call blocks for more than the time it takes to make an I2C transfer. This is important because getting a temperature sensor reading can take 750 milliseconds, and most DS18B20 software libraries block during conversion.\n\n### Synchronous way\n\nUsing the [DS18B20 library](https://build.particle.io/libs/DS18B20/0.1.7/tab/DS18B20.cpp), you make a call like this:\n\n```\nfloat tempC = ds.getTemperature(addr);\n```\n\nThe main loop thread is blocked during this call for 750 milliseconds, which may affect performance elsewhere in your code. \n\n### State machines\n\nOne common way of implementing asynchronous code is state machines. This is a bit of pseudo-code of what a state machine version might look like. \n\n```\nvoid loop() {\n\tswitch(state) {\n\tcase GET_TEMPERATURE_STATE:\n\t\tds.startTemperature();\n\t\tstate = TEMPERATURE_WAIT_STATE;\n\t\tbreak;\n\n\tcase TEMPERATURE_WAIT_STATE:\n\t\tif (ds.isTemperatureDone()) {\n\t\t\tfloat temp = ds.readTemperature();\n\t\t\tstate = ANOTHER_STATE;\n\t\t}\n\t\tbreak;\n\t}\n}\n```\n\nState machines are really powerful, and actually how the DS2482 library is implemented internally, but can get a bit unwieldy.\n\n### Callbacks\n\nCallback functions are another common way of handling asynchronous code, like in this pseudo-code example:\n\n```\nvoid temperatureCallback(float temp) {\n\tSerial.printlnf(\"got temperature %f\", temp);\n}\n\nvoid loop() {\n\tif (millis() - lastCheck >= CHECK_PERIOD) {\n\t\tlastCheck = millis();\n\t\tds.getTemperature(temperatureCallback);\n\t}\n}\n```\n\nThe problem with callbacks is that it's a pain to pass state data to the callback, and it requires some effort to make a callback handler a class member function.\n\n### The Lambda\n\nThe lambda solves some of the problems with callbacks. Here's an example of doing an asynchronous device reset call:\n\n```\nvoid setup() {\n\tSerial.begin(9600);\n\tds.setup();\n\n\tDS2482DeviceReset::run(ds, (link unavailable in preview) {\n\t\tSerial.printlnf(\"deviceReset=%d\", status);\n\t});\n\n\tSerial.println(\"setup complete\");\n}\n```\n\nThe syntax is a little weird, and I'll get to that a moment, however the important thing is that this block of code, the lambda, is executed later.\n\n```\n\t(link unavailable in preview) {\n\t\tSerial.printlnf(\"deviceReset=%d\", status);\n\t}\n```\n\nThe \n\n```\nsetup complete\n```\n\nmessage appears next.\n\nWhen the asynchronous device reset completes, the block runs and\n\n```\ndeviceReset=1\n``` \n\nwill likely be printed to the serial console. Note, however, that the lines after the block, like printing setup complete! won't happen a second time.\n\n\nA declaration of a lambda function looks like \n\n```\n(link unavailable in preview) {\n\t// Code goes here\n}\n``` \n\nThe `[]` part is the capture, which we'll discuss in a moment, and `(DS2482DeviceReset&, int status)` is a function parameter declaration. Basically the callback is a function that takes two parameters, a `DS2482DeviceReset&` object (not used here) and an `int status` (for status).\n\n### Nesting calls\n\nThis example demonstrates two handy things:\n\n- Making your lambda be a class member\n- Nesting lambdas for sequential operations\n\n```\nvoid TestClass::check() {\n\tDS2482SearchBusCommand::run(ds, deviceList, this {\n\n\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\tSerial.printlnf(\"DS2482SearchBusCommand status=%d\", status);\n\t\t\treturn;\n\t\t}\n\n\t\tif (deviceList.getDeviceCount() == 0) {\n\t\t\tSerial.println(\"no devices\");\n\t\t\treturn;\n\t\t}\n\n\t\tDS2482GetTemperatureForListCommand::run(ds, obj.getDeviceList(), this {\n\t\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\t\tSerial.printlnf(\"DS2482GetTemperatureForListCommand status=%d\", status);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSerial.printlnf(\"got temperatures!\");\n\n\t\t\tfor(size_t ii = 0; ii < deviceList.getDeviceCount(); ii++) {\n\t\t\t\tSerial.printlnf(\"%s valid=%d C=%f F=%f\",\n\t\t\t\t\t\tdeviceList.getAddressByIndex(ii).toString().c_str(),\n\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getValid(),\n\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureC(),\n\t\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureF());\n\t\t\t}\n\n\t\t});\n\t});\n}\n```\n\nYou'll notice the slightly different syntax in the capture, the part in the square brackets:\n\n```\nDS2482SearchBusCommand::run(ds, deviceList, this {\n```\n\nInstead of just being `[]` it's `[this]`. That means that `this`, your class instance, is captured, and available inside the lambda. It essentially makes the inner function a class member, available to access class member functions and variables.\n\nYou can capture multiple variables, separated by commas. You can capture function parameters and local variables, for example.\n\nThe other thing is that you can nest these, so each new indent in occurs at a later time. If you don't like that style, however, you can just split your code into separate member functions like this:\n\n```\nvoid TestClass::searchBus() {\n\n\tDS2482SearchBusCommand::run(ds, deviceList, this {\n\n\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\tSerial.printlnf(\"DS2482SearchBusCommand status=%d\", status);\n\t\t\treturn;\n\t\t}\n\n\t\tif (deviceList.getDeviceCount() == 0) {\n\t\t\tSerial.println(\"no devices\");\n\t\t\treturn;\n\t\t}\n\n\t\tgetTemperatures();\n\t});\n}\n\nvoid TestClass::getTemperatures() {\n\n\tDS2482GetTemperatureForListCommand::run(ds, deviceList, this {\n\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\tSerial.printlnf(\"DS2482GetTemperatureForListCommand status=%d\", status);\n\t\t\treturn;\n\t\t}\n\n\t\tSerial.printlnf(\"got temperatures!\");\n\n\t\tfor(size_t ii = 0; ii < deviceList.getDeviceCount(); ii++) {\n\t\t\tSerial.printlnf(\"%s valid=%d C=%f F=%f\",\n\t\t\t\t\tdeviceList.getAddressByIndex(ii).toString().c_str(),\n\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getValid(),\n\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureC(),\n\t\t\t\t\tdeviceList.getDeviceByIndex(ii).getTemperatureF());\n\t\t}\n\t});\n\n}\n```\n\n### Optional parameters\n\nWithin the library, optional parameters are passed fluent-style instead of using C++ optional parameters. The fluent-style parameters are easier to identify and don't depend on order. For example:\n\n```\nDS2482GetTemperatureCommand::run(ds, addr, this,completion {\n\t\tif (status != DS2482Command::RESULT_DONE) {\n\t\t\tLog.error(\"FAILURE DS2482GetTemperatureCommand failed %d bus %s\", status, name.c_str());\n\t\t\tcompletion();\n\t\t\treturn;\n\t\t}\n\n\t\ttestsComplete(completion);\n\t}).withParasiticPower(isParasiticPowered).withMaxRetries(1);\n```\n\nOf note:\n\n- The optional parameters go after the `})` that closes the run command.\n- You can chain as many or as few as you want in any order.\n- The names all begin with `with`.\n\nIn this example, it uses parasitic power or not based on the member variable `isParasiticPowered` and limits the number of retries to 1.\n\n\n### Run methods\n\nAll of the asynchronous functions are implemented as separate classes with a static run method. For example `DS2482GetTemperatureCommand::run`.\n\nThis is done because the objects need to be allocated on the heap (using new), not stack allocated. Since they continue after your function returns, stack allocated classes wouldn't work because they would go away when the enclosing function returns.\n\nThe run methods take care of allocated the objects and enqueueing them for execution so they make sure the objects gets deleted later, as well.\n\n## Hardware examples\n\nThe hardware examples are in Github in the hardware directory. The Eagle board and schematic files are there as well.\n\n### 1-port\n\nThis is a simple breakout board for the DS2482-100 (1-port):\n\n1-port board (image removed)\n\n1-port schematic (image removed)\n\n\n### 8-port\n\nThis is a simple board for the DS2482-800 (8-port), though it's only populated for 6 ports. Four of them are modular jacks, designed to connect with one of the remote sensors below.\n\n8-port board (image removed)\n\n8-port schematic (image removed)\n\n\n### DS18B20-regular\n\nThis is a simple DS18B20 remote sensor with a modular connector. The extra chip is a bridge rectifier, which makes it tolerant of having the connector polarity reversed, for example yellow and black reversed. This happens frequently when the flat cable is used and there isn't the proper twist in it.\n\nDS18B20-regular board (image removed)\n\nDS18B20-regular schematic (image removed)\n\n\n### DS18B20-Mini\n\nThis is an even smaller DS18B20 remote sensor with a modular connector. It leaves off the screw terminal space and does not include the bridge rectifier, so make sure you don't cross the yellow and black wires!\n\nDS18B20-mini board (image removed)\n\n\n\n### test-board\n\nThis is how I regression test the library. It's a board with DS2482-100 (1-port), DS2482-800 (8-port), 8x DS18B20s, and MCP23008 so I can switch the DS18B20s between powered and parasitic power mode individually.\n\ntest-board (image removed)\n\ntest-board schematic (image removed)\n\n\n\n",
  "allVersions": [
    "0.0.3",
    "0.0.2"
  ]
}