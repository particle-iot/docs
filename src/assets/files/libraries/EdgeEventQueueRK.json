{
  "type": "libraries",
  "id": "EdgeEventQueueRK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/EdgeEventQueueRK/archive/0.0.1.tar.gz"
  },
  "attributes": {
    "name": "EdgeEventQueueRK",
    "version": "0.0.1",
    "installs": 18,
    "license": "MIT",
    "author": "Rick Kaseguma <rickkas7@rickkas7.com>",
    "sentence": "Store and forward publishing queue for Tracker Edge and Monitor Edge",
    "url": "https://github.com/rickkas7/JsonParserGeneratorRK",
    "repository": "https://github.com/rickkas7/JsonParserGeneratorRK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "e",
  "cardUrl": "/reference/device-os/libraries/e/EdgeEventQueueRK",
  "versions": {
    "0.0.1": {
      "added": "2023-08-20T13:45:31.262Z",
      "builds": {},
      "noExamples": true
    }
  },
  "readme": "# EdgeEventQueueRK\n\n*Store and forward publishing queue for Tracker Edge and Monitor Edge*\n\n- Repository: https://github.com/rickkas7/EdgeEventQueueRK\n- License: MIT (free for use in open or closed-source projects, including commercial projects)\n- [Browseable API docs](https://rickkas7.github.io/EdgeEventQueueRK/index.html)\n\nThis library is intended to be used with Tracker Edge or Monitor Edge for implementing custom store and forward queueing. Because its requires the\nfunction of your Edge software, there are no library examples in this repository as they wouldn't be able to be compiled successfully.\n\nFor more information about store and forward, see the [Particle docs](https://docs.particle.io/firmware/tracker-edge/sotre-and-forward/).\n\n\n## Setup\n\n### Tracker Edge\n\n\n- Add the EdgeEventQueueRK library to your Tracker Edge product, typically using **Particle: Install Library** in Particle Workbench.\n\n- Add the include file:\n\n```cpp\n#include \"EdgeEventQueueRK.h\"\n```\n\n- Add a global variable for your queue, typically in main.cpp. You will typically one have one, but you can have multiple queues.\n\n```cpp\nstatic EdgeEventQueueRK privateEventQueue;\n```\n\n- Initialize the library from `setup()`:\n\n```cpp\nprivateEventQueue\n    .withSizeLimit(50 * 1024)\n    .withQueuePath(\"/usr/testq\")\n    .setup();\n```\n\n- Make sure you provide time to handle the queue by adding a call to `loop()`:\n\n```cpp\nprivateEventQueue.loop();\n```\n\n\n### Monitor Edge\n\n- Add the EdgeEventQueueRK library to your Monitor Edge product, typically using **Particle: Install Library** in Particle Workbench.\n\n- Add the include file:\n\n```cpp\n#include \"EdgeEventQueueRK.h\"\n```\n\n- Add a global variable for your queue, typically in user_setup.cpp. You will typically one have one, but you can have multiple queues.\n\n```cpp\nstatic EdgeEventQueueRK privateEventQueue;\n```\n\n- Initialize the library from `user_init()`:\n\n```cpp\nprivateEventQueue\n    .withSizeLimit(50 * 1024)\n    .withQueuePath(\"/usr/testq\")\n    .setup();\n```\n\n- Make sure you provide time to handle the queue by adding a call to `user_loop()`:\n\n```cpp\nprivateEventQueue.loop();\n```\n\n### Setup options\n\nAt minimum you will probably want to set a queue path and call setup, as in the examples above. You chain together as many of the\n`withXXX()` options you want, then finally call `.setup()` to complete the setup.\n\n```cpp\nprivateEventQueue\n    .withQueuePath(\"/usr/testq\")\n    .setup();\n```\n\n#### withPriority\n\n```cpp\n// PROTOTYPE\nEdgeEventQueueRK &withPriority(size_t priority)\n```\n\n- priority 0 or 1. 0 is the high priority queue and 1 is the normal priority queue. Location publishes use the normal queue, 1. The default is 1.\n\n#### withPublishFlags\n\nSince `PRIVATE` is always used now (there is no `PUBLIC`), the only flag that applies now is `NO_ACK`, however you will\nrarely use this with queued events.\n\n```cpp \n// PROTOTYPE\nEdgeEventQueueRK &withPublishFlags(PublishFlags flags)\n```\n\n#### withSizeLimit\n\nSet the size limit in bytes. Default is unlimited (0). There is no guarantee you will be able to save the limit you specify\nas the space is not reserved, but it is treated as a maximum.\n\n```cpp\n// PROTOTYPE\nEdgeEventQueueRK &withSizeLimit(size_t sizeLimit)\n```\n\n#### withDiskQueuePolicy\n\n```cpp\n// PROTOTYPE\nEdgeEventQueueRK &withDiskQueuePolicy(DiskQueuePolicy policy)\n```\n\n- policy DiskQueuePolicy::FifoDeleteOld (default) or DiskQueuePolicy::FifoDeleteNew\n\n#### withQueuePath\n\nSet the directory path in the flash file system to store the queue files. Each event is stored in a separate file\nin the queue directory. Each queue must have its own separate directory.\n\n```cpp\n// PROTOTYPE\nEdgeEventQueueRK &withQueuePath(const char *path)\n```\n\n- path Typically put in \"/usr/\" directory. Does not need to exist; will be created if it does not exist.\n\n\n## Using the library\n\n### Publishing using the queue\n\nTo queue the data on the flash file system, use the `publish()` method.\n\n```cpp\n// PROTOTYPE\nint publish(const char *eventName, const char *eventData);\n\n// EXAMPLE\nprivateEventQueue.publish(\"eventQueueTest\", eventData);\n```\n\nIt returns 0 on success, or a non-zero error code. You will get a success result even if offline, as long as the event can be enqueued.\n\n### Publishing without queueing\n\nSometimes you will want to publish an event without using the queue, because the event is temporal and historical data is not useful if the \ndevice is currently offline.\n\nTo do this, use `EdgeEventQueueRK::cloudServicePublish`, which takes an eventName and eventData. \n\n```cpp\nEdgeEventQueueRK::cloudServicePublish(\"eventQueueTest\", eventData);\n```\n\nThis is preferable to directly using Particle.publish because it will interleave the emptying of the queue with sending your non-queued \nmessage and will not exceed the publish rate limit. \n\nThe full API is:\n\n```cpp\n// PROTOTYPE - EdgeEventQueueRK\nstatic int cloudServicePublish(const char *eventName, const char *eventData, PublishFlags publishFlags = {}, size_t priority = 0, std::function<int(CloudServiceStatus)> cb = 0);\n```\n\n- `eventName` The event name, as is used in `Particle.publish`. \n\n- `eventData` The event data, as is used in `Particle.publish`.\n\n- `publishFlags` Publish flags, as is used in Particle.publish. This is optional, and if omitted the default flags are used.\n\n- `priority` 0 or 1. 0 is the default queue and 1 is the low priority queue.\n\n- `cb` Callback function to be called on successful completion or error. Optional. Not called if an immediate error\nresults in a non-zero result code; callback is only called if the return value is 0.\n\n- Returns `int` 0 on success or a non-zero error code\n\nThe callback function has this prototype:\n\n```cpp\nint callback(CloudServiceStatus status)\n```\n\n- `status` is `particle::Error::NONE` (0) or an system error code on error\n\nCallback is a std::function so you can pass a lambda, which allows you to pass additional data via capture variables, or\ncall a C++ class method and instance easily.\n\nThe eventName and eventValue are copied and do not need to remain valid until the callback is called. Once the\ncloudServicePublish call returns, the variables can go out of scope, so it's safe for them to be local variables\non the stack.\n\nUsing cloudServicePublish interleaves your event with others in the system in a queue in RAM. The queue is finite\nin size (currently 8 elements per priority queue) and if the queue is full, -EBUSY (-16) is returned.\n\nNote that this function does not use the disk queue! It's a low-level function used by the publish method in this\nclass, or you can use it for your own purposes if you want to publish events that are not saved to disk if the device\nis currently offline.\n\n",
  "allVersions": [
    "0.0.1"
  ]
}