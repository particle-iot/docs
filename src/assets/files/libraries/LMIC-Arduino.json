{
  "type": "libraries",
  "id": "LMIC-Arduino",
  "links": {
    "download": "https://api.particle.io/v1/libraries/LMIC-Arduino/archive/1.0.0.tar.gz"
  },
  "attributes": {
    "name": "LMIC-Arduino",
    "version": "1.0.0",
    "installs": 325,
    "author": "IBM",
    "sentence": "Arduino port of the LMIC (LoraWAN-in-C, formerly LoraMAC-in-C) framework provided by IBM.",
    "paragraph": "Supports SX1272/SX1276 and HopeRF RFM92/RFM95 tranceivers",
    "url": "https://github.com/matthijskooijman/arduino-lmic",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "l",
  "cardUrl": "/cards/libraries/l/LMIC-Arduino",
  "versions": {
    "1.0.0": {
      "builds": {
        "2.0.1": {
          "photon": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "electron": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "argon": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "boron": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          }
        },
        "1.5.2": {
          "photon": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "electron": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "argon": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          },
          "boron": {
            "raw": false,
            "ttn-abp": false,
            "ttn-otaa": false
          }
        }
      }
    }
  },
  "readme": "Arduino-LMIC library\n====================\nThis repository contains the IBM LMIC (LoraMAC-in-C) library, slightly\nmodified to run in the Arduino environment, allowing using the SX1272,\nSX1276 tranceivers and compatible modules (such as some HopeRF RFM9x\nmodules).\n\nThis library mostly exposes the functions defined by LMIC, it makes no\nattempt to wrap them in a higher level API that is more in the Arduino\nstyle. To find out how to use the library itself, see the examples, or\nsee the PDF file in the doc subdirectory.\n\nThis library requires Arduino IDE version 1.6.6 or above, since it\nrequires C99 mode to be enabled by default.\n\nInstalling\n----------\nTo install this library:\n\n - install it using the Arduino Library manager (\"Sketch\" -> \"Include\n   Library\" -> \"Manage Libraries...\"), or\n - download a zipfile from github using the \"Download ZIP\" button and\n   install it using the IDE (\"Sketch\" -> \"Include Library\" -> \"Add .ZIP\n   Library...\"\n - clone this git repository into your sketchbook/libraries folder.\n\nFor more info, see https://www.arduino.cc/en/Guide/Libraries\n\nFeatures\n--------\nThe LMIC library provides a fairly complete LoRaWAN Class A and Class B\nimplementation, supporting the EU-868 and US-915 bands. Only a limited\nnumber of features was tested using this port on Arduino hardware, so be\ncareful when using any of the untested features.\n\nWhat certainly works:\n - Sending packets uplink, taking into account duty cycling.\n - Encryption and message integrity checking.\n - Receiving downlink packets in the RX2 window.\n - Custom frequencies and datarate settings.\n - Over-the-air activation (OTAA / joining).\n\nWhat has not been tested:\n - Receiving downlink packets in the RX1 window.\n - Receiving and processing MAC commands.\n - Class B operation.\n\nIf you try one of these untested features and it works, be sure to let\nus know (creating a github issue is probably the best way for that).\n\nConfiguration\n-------------\nA number of features can be configured or disabled by editing the\n`config.h` file in the library folder. Unfortunately the Arduino\nenvironment does not offer any way to do this (compile-time)\nconfiguration from the sketch, so be careful to recheck your\nconfiguration when you switch between sketches or update the library.\n\nAt the very least, you should set the right type of transceiver (SX1272\nvs SX1276) in config.h, most other values should be fine at their\ndefaults.\n\nSupported hardware\n------------------\nThis library is intended to be used with plain LoRa transceivers,\nconnecting to them using SPI. In particular, the SX1272 and SX1276\nfamilies are supported (which should include SX1273, SX1277, SX1278 and\nSX1279 which only differ in the available frequencies, bandwidths and\nspreading factors). It has been tested with both SX1272 and SX1276\nchips, using the Semtech SX1272 evaluation board and the HopeRF RFM92\nand RFM95 boards (which supposedly contain an SX1272 and SX1276 chip\nrespectively).\n\nThis library contains a full LoRaWAN stack and is intended to drive\nthese Transceivers directly. It is *not* intended to be used with\nfull-stack devices like the Microchip RN2483 and the Embit LR1272E.\nThese contain a transceiver and microcontroller that implements the\nLoRaWAN stack and exposes a high-level serial interface instead of the\nlow-level SPI transceiver interface.\n\nThis library is intended to be used inside the Arduino environment. It\nshould be architecture-independent, so it should run on \"normal\" AVR\narduinos, but also on the ARM-based ones, and some success has been seen\nrunning on the ESP8266 board as well. It was tested on the Arduino Uno,\nPinoccio Scout, Teensy LC and 3.x, ESP8266, Arduino 101.\n\nThis library an be quite heavy, especially if the fairly small ATmega\n328p (such as in the Arduino Uno) is used. In the default configuration,\nthe available 32K flash space is nearly filled up (this includes some\ndebug output overhead, though). By disabling some features in `config.h`\n(like beacon tracking and ping slots, which are not typically needed),\nsome space can be freed up. Some work is underway to replace the AES\nencryption implementation, which should free up another 8K or so of\nflash in the future, making this library feasible to run on a 328p\nmicrocontroller.\n\nConnections\n-----------\nTo make this library work, your Arduino (or whatever Arduino-compatible\nboard you are using) should be connected to the transceiver. The exact\nconnections are a bit dependent on the transceiver board and Arduino\nused, so this section tries to explain what each connection is for and\nin what cases it is (not) required.\n\nNote that the SX1272 module runs at 3.3V and likely does not like 5V on\nits pins (though the datasheet is not say anything about this, and my\ntransceiver did not obviously break after accidentally using 5V I/O for\na few hours). To be safe, make sure to use a level shifter, or an\nArduino running at 3.3V. The Semtech evaluation board has 100 ohm resistors in\nseries with all data lines that might prevent damage, but I would not\ncount on that.\n\n### Power\nThe SX127x transceivers need a supply voltage between 1.8V and 3.9V.\nUsing a 3.3V supply is typical. Some modules have a single power pin\n(like the HopeRF modules, labeled 3.3V) but others expose multiple power\npins for different parts (like the Semtech evaluation board that has\n`VDD_RF`, `VDD_ANA` and `VDD_FEM`), which can all be connected together.\nAny *GND* pins need to be connected to the Arduino *GND* pin(s).\n\n### SPI\nThe primary way of communicating with the transceiver is through SPI\n(Serial Peripheral Interface). This uses four pins: MOSI, MISO, SCK and\nSS. The former three need to be directly connected: so MOSI to MOSI,\nMISO to MISO, SCK to SCK. Where these pins are located on your Arduino\nvaries, see for example the \"Connections\" section of the [Arduino SPI\ndocumentation](SPI).\n\nThe SS (slave select) connection is a bit more flexible. On the SPI\nslave side (the transceiver), this must be connect to the pin\n(typically) labeled *NSS*. On the SPI master (Arduino) side, this pin\ncan connect to any I/O pin. Most Arduinos also have a pin labeled \"SS\",\nbut this is only relevant when the Arduino works as an SPI slave, which\nis not the case here. Whatever pin you pick, you need to tell the\nlibrary what pin you used through the pin mapping (see below).\n\n[SPI]: https://www.arduino.cc/en/Reference/SPI\n\n### DIO pins\nThe DIO (digitial I/O) pins on the transceiver board can be configured\nfor various functions. The LMIC library uses them to get instant status\ninformation from the transceiver. For example, when a LoRa transmission\nstarts, the DIO0 pin is configured as a TxDone output. When the\ntransmission is complete, the DIO0 pin is made high by the transceiver,\nwhich can be detected by the LMIC library.\n\nThe LMIC library needs only access to DIO0, DIO1 and DIO2, the other\nDIOx pins can be left disconnected. On the Arduino side, they can\nconnect to any I/O pin, since the current implementation does not use\ninterrupts or other special hardware features (though this might be\nadded in the feature, see also the \"Timing\" section).\n\nIn LoRa mode the DIO pins are used as follows:\n * DIO0: TxDone and RxDone\n * DIO1: RxTimeout\n\nIn FSK mode they are used as follows::\n * DIO0: PayloadReady and PacketSent\n * DIO2: TimeOut\n\nBoth modes need only 2 pins, but the tranceiver does not allow mapping\nthem in such a way that all needed interrupts map to the same 2 pins.\nSo, if both LoRa and FSK modes are used, all three pins must be\nconnected.\n\nThe pins used on the Arduino side should be configured in the pin\nmapping in your sketch (see below).\n\n### Reset\nThe transceiver has a reset pin that can be used to explicitely reset\nit. The LMIC library uses this to ensure the chip is in a consistent\nstate at startup. In practice, this pin can be left disconnected, since\nthe transceiver will already be in a sane state on power-on, but\nconnecting it might prevent problems in some cases.\n\nOn the Arduino side, any I/O pin can be used. The pin number used must\nbe configured in the pin mapping (see below).\n\n### RXTX\nThe transceiver contains two separate antenna connections: One for RX\nand one for TX. A typical transceiver board contains an antenna switch\nchip, that allows switching a single antenna between these RX and TX\nconnections.  Such a antenna switcher can typically be told what\nposition it should be through an input pin, often labeled *RXTX*.\n\nThe easiest way to control the antenna switch is to use the *RXTX* pin\non the SX127x transceiver. This pin is automatically set high during TX\nand low during RX. For example, the HopeRF boards seem to have this\nconnection in place, so they do not expose any *RXTX* pins and the pin\ncan be marked as unused in the pin mapping.\n\nSome boards do expose the antenna switcher pin, and sometimes also the\nSX127x *RXTX* pin. For example, the SX1272 evaluation board calls the\nformer *FEM_CTX* and the latter *RXTX*. Again, simply connecting these\ntogether with a jumper wire is the easiest solution.\n\nAlternatively, or if the SX127x *RXTX* pin is not available, LMIC can be\nconfigured to control the antenna switch. Connect the antenna switch\ncontrol pin (e.g. *FEM_CTX* on the Semtech evaluation board) to any I/O\npin on the Arduino side, and configure the pin used in the pin map (see\nbelow). It is not entirely clear why would *not* want the transceiver to\ncontrol the antenna directly, though.\n\n### Pin mapping\nAs described above, most connections can use arbitrary I/O pins on the\nArduino side. To tell the LMIC library about these, a pin mapping struct\nis used in the sketch file.\n\nFor example, this could look like this:\n\n\tlmic_pinmap lmic_pins = {\n\t    .nss = 6,\n\t    .rxtx = LMIC_UNUSED_PIN,\n\t    .rst = 5,\n\t    .dio = {2, 3, 4},\n\t};\n\nThe names refer to the pins on the transceiver side, the numbers refer\nto the Arduino pin numbers (to use the analog pins, use constants like\n`A0`). For the DIO pins, the three numbers refer to DIO0, DIO1 and DIO2\nrespectively. Any pins that are not needed should be specified as\n`LMIC_UNUSED_PIN`. The nss and dio0 pin is required, the others can\npotentially left out (depending on the environments and requirements,\nsee the notes above for when a pin can or cannot be left out).\n\nThe name of this struct must always be `lmic_pins`, which is a special name\nrecognized by the library.\n\n#### LoRa Nexus by Ideetron\nThis board uses the following pin mapping:\n\n    const lmic_pinmap lmic_pins = {\n        .nss = 10,\n        .rxtx = LMIC_UNUSED_PIN,\n        .rst = LMIC_UNUSED_PIN, // hardwired to AtMega RESET\n        .dio = {4, 5, 7},\n    };\n\nExamples\n--------\nThis library currently provides three examples:\n\n - `ttn-abp.ino` shows a basic transmission of a \"Hello, world!\" message\n   using the LoRaWAN protocol. It contains some frequency settings and\n   encryption keys intended for use with The Things Network, but these\n   also correspond to the default settings of most gateways, so it\n   should work with other networks and gateways as well. This example\n   uses activation-by-personalization (ABP, preconfiguring a device\n   address and encryption keys), and does not employ over-the-air\n   activation.\n\n   Reception of packets (in response to transmission, using the RX1 and\n   RX2 receive windows is also supported).\n\n - `ttn-otaa.ino` also sends a \"Hello, world!\" message, but uses over\n   the air activation (OTAA) to first join a network to establish a\n   session and security keys. This was tested with The Things Network,\n   but should also work (perhaps with some changes) for other networks.\n\n - `raw.ino` shows how to access the radio on a somewhat low level,\n   and allows to send raw (non-LoRaWAN) packets between nodes directly.\n   This is useful to verify basic connectivity, and when no gateway is\n   available, but this example also bypasses duty cycle checks, so be\n   careful when changing the settings.\n\nTiming\n------\nUnfortunately, the SX127x tranceivers do not support accurate\ntimekeeping themselves (there is a sequencer that is *almost* sufficient\nfor timing the RX1 and RX2 downlink windows, but that is only available\nin FSK mode, not in LoRa mode). This means that the microcontroller is\nresponsible for keeping track of time. In particular, it should note\nwhen a packet finished transmitting, so it can open up the RX1 and RX2\nreceive windows at a fixed time after the end of transmission.\n\nThis timing uses the Arduino `micros()` timer, which has a granularity\nof 4μs and is based on the primary microcontroller clock.  For timing\nevents, the tranceiver uses its DIOx pins as interrupt outputs. In the\ncurrent implementation, these pins are not handled by an actual\ninterrupt handler, but they are just polled once every LMIC loop,\nresulting in a bit inaccuracy in the timestamping. Also, running\nscheduled jobs (such as opening up the receive windows) is done using a\npolling approach, which might also result in further delays.\n\nFortunately, LoRa is a fairly slow protocol and the timing of the\nreceive windows is not super critical. To synchronize transmitter and\nreceiver, a preamble is first transmitted. Using LoRaWAN, this preamble\nconsists of 8 symbols, of which the receiver needs to see 4 symbols to\nlock on. The current implementation tries to enable the receiver for 5\nsymbol times at 1.5 symbol after the start of the receive window,\nmeaning that a inacurracy of plus or minus 2.5 symbol times should be\nacceptable.\n\nAt the fastest LoRa setting supported by the tranceiver (SF5BW500) a\nsingle preamble symbol takes 64μs, so the receive window timing should\nbe accurate within 160μs (for LoRaWAN this is SF7BW250, needing accuracy\nwithin 1280μs). This is certainly within a crystal's accuracy, but using\nthe internal oscillator is probably not feasible (which is 1% - 10%\naccurate, depending on calibration). This accuracy should also be\nfeasible with the polling approach used, provided that the LMIC loop is\nrun often enough.\n\nIt would be good to properly review this code at some point, since it\nseems that in some places some offsets and corrections are applied that\nmight not be appropriate for the Arduino environment. So if reception is\nnot working, the timing is something to have a closer look at.\n\nThe LMIC library was intended to connect the DIO pins to interrupt\nlines and run code inside the interrupt handler. However, doing this\nopens up an entire can of worms with regard to doing SPI transfers\ninside interrupt routines (some of which is solved by the Arduino\n`beginTransaction()` API, but possibly not everything). One simpler\nalternative could be to use an interrupt handler to just store a\ntimestamp, and then do the actual handling in the main loop (this\nrequires modifications of the library to pass a timestamp to the LMIC\n`radio_irq_handler()` function).\n\nAn even more accurate solution could be to use a dedicated timer with an\ninput capture unit, that can store the timestamp of a change on the DIO0\npin (the only one that is timing-critical) entirely in hardware.\nUnfortunately, timer0, as used by Arduino's `millis()` and `micros()`\nfunctions does not seem to have an input capture unit, meaning a\nseparate timer is needed for this.\n\nIf the main microcontroller does not have a crystal, but uses the\ninternal oscillator, the clock output of the transceiver (on DIO5) could\nbe usable to drive this timer instead of the main microcontroller clock,\nto ensure the receive window timing is sufficiently accurate. Ideally,\nthis would use timer2, which supports asynchronous mode (e.g. running\nwhile the microcontroller is sleeping), but that timer does not have an\ninput capture unit. Timer1 has one, but it seems it will stop running\nonce the microcontroller sleeps. Running the microcontroller in idle\nmode with a slower clock might be feasible, though. Instead of using the\nmain crystal oscillator of the transceiver, it could be possible to use\nthe transceiver's internal RC oscillator (which is calibrated against\nthe transceiver crystal), or to calibrate the microcontroller internal\nRC oscillator using the transceiver's clkout. However, that datasheet is\na bit vague on the RC oscillator's accuracy and how to use it exactly\n(some registers seem to be FSK-mode only), so this needs some\nexperiments.\n\nDownlink datarate\n-----------------\nNote that the datarate used for downlink packets in the RX2 window\ndefaults to SF12BW125 according to the specification, but some networks\nuse different values (iot.semtech.com and The Things Network both use\nSF9BW). When using personalized activate (ABP), it is your\nresponsibility to set the right settings, e.g. by adding this to your\nsketch (after calling `LMIC_setSession`). `ttn-abp.ino` already does\nthis.\n\n     LMIC.dn2Dr = DR_SF9;\n\nWhen using OTAA, the network communicates the RX2 settings in the\njoin accept message, but the LMIC library does not currently process\nthese settings. Until that is solved (see issue #20), you should\nmanually set the RX2 rate, *after* joining (see the handling of\n`EV_JOINED` in the `ttn-otaa.ino` for an example.\n\nLicense\n-------\nMost source files in this repository are made available under the\nEclipse Public License v1.0. The examples which use a more liberal\nlicense. Some of the AES code is available under the LGPL. Refer to each\nindividual source file for more details.\n",
  "allVersions": [
    "1.0.0"
  ]
}