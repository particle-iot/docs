{
  "type": "libraries",
  "id": "PublishQueueAsyncRK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/PublishQueueAsyncRK/archive/0.2.5.tar.gz"
  },
  "attributes": {
    "name": "PublishQueueAsyncRK",
    "version": "0.2.5",
    "installs": 54549,
    "license": "MIT",
    "author": "rickkas7@rickkas7.com",
    "sentence": "Asynchronous publishing code for the Particle Electron",
    "url": "https://github.com/rickkas7/PublishQueueAsyncRK",
    "repository": "https://github.com/rickkas7/PublishQueueAsyncRK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "p",
  "cardUrl": "/reference/device-os/libraries/p/PublishQueueAsyncRK",
  "versions": {
    "0.2.0": {
      "builds": {
        "2.0.1": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "1.5.2": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        }
      }
    },
    "0.2.4": {
      "builds": {
        "2.0.1": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "1.5.2": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        }
      }
    },
    "0.2.5": {
      "builds": {
        "2.0.1": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "1.5.2": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "3.3.0": {
          "photon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "electron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": false
          },
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "5.0.1": {
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "bsom": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "b5som": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "tracker": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "p2": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "4.0.0": {
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "bsom": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "b5som": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "tracker": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "esomx": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "5.6.0": {
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "bsom": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "b5som": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "tracker": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "p2": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        },
        "4.2.0": {
          "argon": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "boron": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "bsom": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "b5som": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "tracker": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          },
          "esomx": {
            "1-periodic": true,
            "2-button-and-timer": true,
            "3-test-suite": true,
            "4-test-suite-posix": true
          }
        }
      },
      "added": "2022-06-17T10:16:53.686Z"
    }
  },
  "readme": "# PublishQueueAsyncRK\n\n*A library for asynchronous Particle.publish*\n\nThis library is designed for fire-and-forget publishing of events. It allows you to publish, even when not connected to the cloud, and the events are saved until connected. It also buffers events so you can call it a bunch of times rapidly and the events are metered out one per second to stay within the publish limits.\n\nAlso, it's entirely non-blocking. The publishing occurs from a separate thread so the loop is never blocked. \n\nNormally, if you're careful you can avoid publish blocking loop for long periods of time, but it still regularly blocks for 1-2 seconds on the Electron. Using this library eliminates all blocking and publishQueue.publish returns immediately, always.\n\nAnd it uses retained memory, so the events are saved when you reboot or go into sleep mode. They'll be transmitted when you finally connect to the cloud again.\n\nVersion 0.0.3 of this library and newer support WITH\\_ACK mode!\n\nAlso note: This library requires system firmware 0.7.0 or later. The publish flags were different in 0.6.x, and this library doesn't support the old method. Since it uses threads, it does not work on the Spark Core.\n\nVersion 0.1.0 supports multiple back-end storage methods, including:\n\n- Retained memory\n- Regular RAM\n- FRAM (MB85RC256V ferro-electric non-volatile RAM) connected by I2C\n- SPI NOR Flash (using SpiffsParticleRK)\n- SPI Flash memory on P1 module\n- External SPI Flash soldered to E Series module\n- SD cards using the SdFat library\n\nBrowsable API documentation for this library can be found [here](https://rickkas7.github.io/PublishQueueAsyncRK/).\n\nIf you are using a Gen 3 devices (Argon, Boron, B Series SoM, or Tracker SoM), you may prefer to use [PublishQueuePosixRK](https://github.com/rickkas7/PublishQueuePosixRK) instead. It uses the flash file system on these devices to store events, and it's a much simpler architecture.\n\n## Using it\n\nYou'll need to add the PublishQueueAsyncRK library. It's in the community libraries and here on Github.\n\nYou must use system threading mode with PublishQueueAsyncRK. The library will no longer initialize \nif you do not have threading enabled.\n\n```\nSYSTEM_THREAD(ENABLED);\n```\n\nIn your main source file, you'll need to allocate a retained buffer and initialize the object:\n\n```\nretained uint8_t publishQueueRetainedBuffer[2048];\nPublishQueueAsync publishQueue(publishQueueRetainedBuffer, sizeof(publishQueueRetainedBuffer));\n```\n\nNote that even when cloud connected, all events are copied to this buffer first (that's what makes it asynchronous), so it must be larger than the largest event you want to send. It must be at least 704 bytes, and preferably at least 1024 bytes.\n\nYou can also use a buffer in regular (not retained) memory.\n\nFor other storage methods (FRAM, flash memory, etc. see below). The initialization varies, but usage is the same.\n\nThen, when you want to send, use one of these variants instead of the Particle.publish version:\n\n```\n\t\tpublishQueue.publish(\"testEvent\", PRIVATE, WITH_ACK);\n\t\tpublishQueue.publish(\"testEvent\", \"x\", PRIVATE, WITH_ACK);\n\t\tpublishQueue.publish(\"testEvent\", \"x\", 60, PRIVATE, WITH_ACK);\n```\n\nNote that like system 0.8.0 and later, you must specify PUBLIC or PRIVATE.\n\nYou can also use NO\\_ACK, if you'd like:\n\n```\n\t\tpublishQueue.publish(\"testEvent\", \"x\", PRIVATE, NO_ACK);\n\t\tpublishQueue.publish(\"testEvent\", \"x\", PRIVATE | NO_ACK);\n```\n\nI recommend using WITH\\_ACK. The worker thread will wait for the ACK from the cloud before dequeing the event. This allows for several tries to send the event, and if it does not work, the send will be tried again in 30 seconds if cloud-connected. New events can still be queued during this time.\n\nSince the queue is stored in retained memory, you can even reset the device and the queue will be transmitted on boot.\n\nYou can call the publishQueue.publish method from any thread, including the main loop thread, software timer, or your own worker thread. You cannot call it from an interrupt service routine (ISR) such as from attachInterrupt or a hardware timer (SparkIntervalTimer), however. \n\nThe data is stored packed, so if your event name and data are small, you can store many events. From the retained buffer you pass in there is 8 bytes of overhead. Then each event requires the size of the event name and event data in bytes, plus an overhead of 10 bytes (8 byte header and 2 c-string null terminators), rounded up to a multiple of 4 bytes so each entry starts on a 4-byte aligned boundary.\n\nThe library is also compatible with 622 byte event data [in 0.8.0-rc.4 and later](https://github.com/particle-iot/firmware/pull/1537)).\n\nEvents are logged with the category app.pubq so you can use a [logging filter](https://docs.particle.io/reference/firmware/#logging-categories) to disable them if desired.\n\n```\n0000210062 [app.pubq] INFO: queueing eventName=testEvent data=7 ttl=60 flags1=1 flags2=0 size=20\n0000210063 [app.pubq] INFO: publishing testEvent 7 ttl=60 flags=1\n0000211105 [app.pubq] INFO: published successfully\n```\n\n## Examples\n\nThere are three examples:\n\n- 1-periodic\n- 2-button-and-timer\n- 3-test-suite\n\nThe first one publishes every 30 seconds from loop using a millis() check. It uses WITH_ACK.\n\nThe second one publishes every 30 seconds from a software timer. It also publishes when you press the MODE button. It uses WITH_ACK.\n\nThe third is described in the next section.\n\n## More Examples\n\nThere are examples of using other storage methods in the more-examples directory.\n\n### MB85RC256V FRAM\n\nYou typically include something like this at the top of your main source file. The order is important; you must include the FRAM include file before PublishQueueAsyncRK.h in order to enable FRAM support.\n\n```\n#include \"MB85RC256V-FRAM-RK.h\"\n#include \"PublishQueueAsyncRK.h\"\n\nMB85RC256V fram(Wire, 0);\n\nPublishQueueAsyncFRAM publishQueue(fram);\n```\n\nIn setup(), be sure to initialize the FRAM library and then the publishQueue, in that order.\n\n```\nfram.begin();\npublishQueue.setup();\n```\n\nIf you only want to use a subset of the FRAM for the publish queue, specify an offset and length in the constructor\n\n```\nPublishQueueAsyncFRAM publishQueue(fram, 100, 2000);\n```\n\n\n### SPI Flash using SpiffsParticleRK\n\nUsing SpiffsParticleRK you can store events in a variety of SPI NOR flash memory chips using the SpiFlashRK library.\n\nYou typically include something like this at the top of your main source file. The order is important; you must include the SdFat.h before PublishQueueAsyncRK.h in order to enable SD card support.\n\nThe second parameter to the publish queue constructor is the filename, it should be an 8.3 filename. It will contain binary data.\n\n```\n#include \"SpiffsParticleRK.h\"\n#include \"PublishQueueAsyncRK.h\"\n\nSpiFlashISSI spiFlash(SPI, A2); \t\t// ISSI flash on SPI (A pins)\n\nSpiffsParticle fs(spiFlash);\n\nPublishQueueAsyncSpiffs publishQueue(fs, \"events\");\n```\n\nIn setup(), you initialize it like this:\n\n```\nspiFlash.begin();\n\n// Dedicate 64 Kbytes to file system (increase as desired)\nfs.withPhysicalSize(64 * 1024);\n\ns32_t res = fs.mountAndFormatIfNecessary();\nLog.info(\"mount res=%ld\", res);\nif (res == 0) {\n\tpublishQueue.setup();\n}\n```\n\n#### Instantiating a SpiFlash object\n\nYou typically instantiate an object to interface to the flash chip as a global variable:\n\n```\nSpiFlashISSI spiFlash(SPI, A2);\n```\n\nUse an ISSI flash, such as a [IS25LQ080B](http://www.digikey.com/product-detail/en/issi-integrated-silicon-solution-inc/IS25LQ080B-JNLE/706-1331-ND/5189766). In this case, connected to the primary SPI with A2 as the CS (chip select or SS).\n\n```\nSpiFlashWinbond spiFlash(SPI, A2);\n```\n\nUse a Winbond flash, such as a [W25Q32](https://www.digikey.com/product-detail/en/winbond-electronics/W25Q32JVSSIQ/W25Q32JVSSIQ-ND/5803981). In this case, connected to the primary SPI with A2 as the CS (chip select or SS).\n\n```\nSpiFlashWinbond spiFlash(SPI1, D5);\n```\n\nWinbond flash, connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS).\n\n```\nSpiFlashMacronix spiFlash(SPI1, D5);\n```\n\nMacronix flash, such as the [MX25L8006EM1I-12G](https://www.digikey.com/product-detail/en/macronix/MX25L8006EM1I-12G/1092-1117-ND/2744800). In this case connected to the secondary SPI, SPI1, with D5 as the CS (chip select or SS). This is the recommended for use on the E-Series module. Note that this is the 0.154\", 3.90mm width 8-SOIC package.\n\n```\nSpiFlashP1 spiFlash;\n```\n\nThis is the external flash on the P1 module. This extra flash chip is entirely available for your user; it is not used by the system firmware at this time. You can only use this on the P1; it relies on system functions that are not available on other devices.\n\n\n### SD cards using SdFat\n\nYou typically include something like this at the top of your main source file. The order is important; you must include the SdFat.h before PublishQueueAsyncRK.h in order to enable SD card support.\n\nThe second parameter to the publish queue constructor is the filename, it should be an 8.3 filename. It will contain binary data.\n\n```\n#include \"SdFat.h\"\n#include \"PublishQueueAsyncRK.h\"\n\nconst int SD_CHIP_SELECT = A2;\n\nSdFat sdCard;\n\nPublishQueueAsyncSdFat publishQueue(sdCard, \"events.dat\");\n```\n\nIn your setup function you typically call:\n\n```\n\tif (sdCard.begin(SD_CHIP_SELECT, SPI_FULL_SPEED)) {\n\t\tpublishQueue.setup();\n\t}\n\telse {\n\t\tLog.info(\"failed to initialize sd card\");\n\t}\n```\n\n## Test Suite\n\nThe example 03-test-suite makes it easy to test some of the features. Flag the code to a Photon or Electron and send a function to it to make it do things:\n\nThe first parameter is the test number:\n\n- 0 idle\n- 1 publish periodically \n- 2 publish rapidly\n- 3 disconnect from the cloud, publish rapidly, then reconnect\n- 4 publish periodically using WITH\\_ACK\n\nThere may be additional parameters based on the test number, as well.\n\n--\n\n```\nparticle call electron3 test \"1,10000\"\n```\n\nPublish a sequential event every 10 seconds.\n\n--\n\n```\nparticle call electron3 test \"0\"\n```\n\nStop publish events\n\n--\n\n```\nparticle call electron3 test \"2,5,64\"\n```\n\nPublish 5 events of 64 bytes each. \n\n--\n\n```\nparticle call electron3 test \"3,5,64\"\n```\n\nDisconnect from the cloud, publish 5 events of 64 bytes each, then go back online.\n\n## Version History\n\n### 0.2.5 (2021-07-26)\n\n- Use particle::protocol::MAX_EVENT_DATA_LENGTH instead of 623 as the maximum publish size.\n\n### 0.2.4 (2021-06-18)\n\n- Removed test files from Particle library upload\n\n### 0.2.3 (2021-05-18)\n\n- Added trace messages for debugging FRAM implementation\n- Optimized the way entries are read out of FRAM to not read way past the end of the actual data\n- Added automated test for FRAM\n\n### 0.2.2 (2021-05-10)\n\n- Added trace messages to event addition and removal with retained memory\n- Fixed several problems with clearEvents\n- Added automated test suite\n\n### 0.2.1 (2021-05-04)\n\n- Added check to require SYSTEM_THREAD(ENABLED)\n- Information about PublishQueuePosixRK\n\n### 0.2.0 (2020-11-06)\n\n- Fixed a bug in all file-based implementations (Spiffs, SdFat) where events were not published after a reboot.\n- Added a new test suite function (7) to disconnect, post events to the queue, then reboot.\n- Added support for storing events on the POSIX file system on Gen 3 devices (Argon, Boron, Tracker SoM) in 2.0.0-rc.3 and later.\n\n### 0.1.3 (2019-11-21)\n\n- Added getNumEvent() method so you can know if the queue is empty or not\n\n### 0.1.2 (2019-11-18)\n\n- Fixed a bug that causes thread deadlock when using FRAM\n- Fixed a bug that can cause corrupted event data when FRAM is full\n- Upgraded to MB85RC256V version 0.0.4 for FRAM example (adds support for MB85RC64, MB85RC512, and MB85RC1M)\n\n### 0.1.1 (2019-11-15)\n\n- Fixed a bug that causes thread deadlock when the publish queue is full.\n\n### 0.1.0 (2019-10-30)\n\n- Refactored code to allow for storage in other things like FRAM, SPI Flash, and SD Card.\n\n### 0.0.5 (2019-06-27)\n\n- Same code as 0.0.4 but corrected the comments that said that WITH_ACK was not supported.\n\n### 0.0.4 (2019-06-12)\n\n- Fixed a cause where deadlock can occur if the queue fills up. If another thread was logging\nwhen this occurred, the Log.trace in the publish queue thread will block on the logging mutex,\nbut the mutex can never clear because of the SINGLE_THREADED_BLOCK.\n\n### 0.0.3\n\n- Added support for WITH\\_ACK mode\n\n### 0.1.0\n\n- Added support for other storage methods",
  "allVersions": [
    "0.2.5",
    "0.2.4",
    "0.2.3",
    "0.2.2",
    "0.2.1",
    "0.2.0",
    "0.1.3",
    "0.1.2",
    "0.1.1",
    "0.1.0",
    "0.0.5",
    "0.0.4",
    "0.0.3",
    "0.0.2",
    "0.0.1"
  ]
}