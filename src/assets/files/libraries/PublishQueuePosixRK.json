{
  "type": "libraries",
  "id": "PublishQueuePosixRK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/PublishQueuePosixRK/archive/0.0.5.tar.gz"
  },
  "attributes": {
    "name": "PublishQueuePosixRK",
    "version": "0.0.5",
    "installs": 4267,
    "license": "MIT",
    "author": "Rick Kaseguma <rickkas7@rickkas7.com>",
    "sentence": "Library asynchronous publish with a file-based queue on Particle Gen 3 devices",
    "url": "https://github.com/rickkas7/PublishQueuePosixRK",
    "repository": "https://github.com/rickkas7/PublishQueuePosixRK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "p",
  "cardUrl": "/cards/libraries/p/PublishQueuePosixRK",
  "versions": {
    "0.0.1": {
      "builds": {
        "2.0.1": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": false
          },
          "boron": {
            "2-test-suite": false
          }
        },
        "1.5.2": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": false
          },
          "boron": {
            "2-test-suite": false
          }
        }
      }
    },
    "0.0.2": {
      "builds": {
        "2.0.1": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        },
        "1.5.2": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        }
      }
    },
    "0.0.3": {
      "builds": {
        "2.0.1": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        },
        "1.5.2": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        },
        "3.3.0": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        }
      },
      "added": "2022-06-17T10:16:53.839Z"
    },
    "0.0.5": {
      "added": "2022-10-26T16:40:29.462Z",
      "builds": {
        "5.0.1": {
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          },
          "bsom": {
            "2-test-suite": true
          },
          "b5som": {
            "2-test-suite": true
          },
          "tracker": {
            "2-test-suite": true
          },
          "p2": {
            "2-test-suite": true
          }
        },
        "4.0.0": {
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          },
          "bsom": {
            "2-test-suite": true
          },
          "b5som": {
            "2-test-suite": true
          },
          "tracker": {
            "2-test-suite": true
          },
          "esomx": {
            "2-test-suite": true
          }
        },
        "3.3.0": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        },
        "2.3.0": {
          "photon": {
            "2-test-suite": false
          },
          "electron": {
            "2-test-suite": false
          },
          "argon": {
            "2-test-suite": true
          },
          "boron": {
            "2-test-suite": true
          }
        }
      }
    }
  },
  "readme": "# PublishQueuePosixRK\n\n*Version of publish queue for storing events on the POSIX flash file system*\n\nThis library works a bit differently than [PublishQueueAsyncRK](https://github.com/rickkas7/PublishQueueAsyncRK):\n\n- It only works with the POSIX flash file system\n- It can keep a number of events in regular memory for efficiency and reduced flash wear\n- Or it can always write events to the file system for maximum prevention of event loss\n- The file system queue supports discarding the oldest events when the size limit is exceeded\n\n## Usage\n\nIn many cases, you simply call this from setup:\n\n```cpp\nPublishQueuePosix::instance().setup();\n```\n\nAnd this from loop:\n\n```cpp\nPublishQueuePosix::instance().setup();\n```\n\nTo publish you do something like this:\n\n```\nPublishQueuePosix::instance().publish(\"testEvent\", buf, PRIVATE | WITH_ACK);\n```\n\n### RAM Queue\n\nOne parameter you may want to change is the RAM queue size:\n\n```cpp\nPublishQueuePosix::instance().withRamQueueSize(0);\n```\n\nSetting it to 0 means all events will be written to the file system immediately to reduce the chance of \nlosing an event. This has higher overhead and can cause flash wear if you are publishing very frequently. \n\nThe default is 2. However, if you normally burst out multiple events at a time, be sure to set the RAM \nqueue size larger than the maximum number of events you burst out. If the RAM queue becomes full, all events \nwill be written to the file system.\n\nThe RAM queue is also written to the file system if a publish fails, and right before a reset caused by \na software update. However, on other resets the queue will be lost, so if you must not lose an event \nyou should set the RAM queue size to 0.\n\n### File Queue\n\nThe default maximum file queue size is 100, which corresponds to 100 events. Each event takes is stored in \na single file. In many cases, an event will fit in a single 512-byte flash sector, but it could require two,\nor three, for a full 1024 byte event with the overhead. \n\nAlso remember that events can only be sent out one per second, so a very long queue will take a while to send!\n\n```cpp\nPublishQueuePosix::instance().withFileQueueSize(50);\n```\n\n## Dependencies\n\nThis library depends on two additional libraries:\n\n- [SequentialFileRK](https://github.com/rickkas7/SequentialFileRK) manages the queue on the flash file system\n- [BackgroundPublishRK](https://github.com/rickkas7/BackgroundPublishRK) handles publishing from a background thread\n\n\n## API\n\n---\n\n### void PublishQueuePosix::setup() \n\nYou must call this from setup() to initialize this library.\n\n```\nvoid setup()\n```\n\n---\n\n### void PublishQueuePosix::loop() \n\nYou must call the loop method from the global loop() function!\n\n```\nvoid loop()\n```\n\n---\n\n### PublishQueuePosix & PublishQueuePosix::withRamQueueSize(size_t size) \n\nSets the RAM based queue size (default is 2)\n\n```\nPublishQueuePosix & withRamQueueSize(size_t size)\n```\n\n#### Parameters\n* `size` The size to set (can be 0, default is 2)\n\nYou can set this to 0 and the events will be stored on the flash file system immediately. This is the best option if the events must not be lost in the event of a sudden reboot.\n\nIt's more efficient to have a small RAM-based queue and it eliminates flash wear. Make sure you set the size larger than the maximum number of events you plan to send out in bursts, as if you exceed the RAM queue size, all outstanding events will be moved to files.\n\n---\n\n### size_t PublishQueuePosix::getRamQueueSize() const \n\nGets the size of the RAM queue.\n\n```\nsize_t getRamQueueSize() const\n```\n\n---\n\n### PublishQueuePosix & PublishQueuePosix::withFileQueueSize(size_t size) \n\nSets the file-based queue size (default is 100)\n\n```\nPublishQueuePosix & withFileQueueSize(size_t size)\n```\n\n#### Parameters\n* `size` The maximum number of files to store (one event per file)\n\nIf you exceed this number of events, the oldest event is discarded.\n\n---\n\n### size_t PublishQueuePosix::getFileQueueSize() const \n\nGets the file queue size.\n\n```\nsize_t getFileQueueSize() const\n```\n\n---\n\n### PublishQueuePosix & PublishQueuePosix::withDirPath(const char * dirPath) \n\nSets the directory to use as the queue directory. This is required!\n\n```\nPublishQueuePosix & withDirPath(const char * dirPath)\n```\n\n#### Parameters\n* `dirPath` the pathname, Unix-style with / as the directory separator.\n\nTypically you create your queue either at the top level (\"/myqueue\") or in /usr (\"/usr/myqueue\"). The directory will be created if necessary, however only one level of directory will be created. The parent must already exist.\n\nThe dirPath can end with a slash or not, but if you include it, it will be removed.\n\nYou must call this as you cannot use the root directory as a queue!\n\n---\n\n### const char * PublishQueuePosix::getDirPath() const \n\nGets the directory path set using withDirPath()\n\n```\nconst char * getDirPath() const\n```\n\nThe returned path will not end with a slash.\n\n---\n\n### bool PublishQueuePosix::publish(const char * eventName, PublishFlags flags1, PublishFlags flags2) \n\nOverload for publishing an event.\n\n```\nbool publish(const char * eventName, PublishFlags flags1, PublishFlags flags2)\n```\n\n#### Parameters\n* `eventName` The name of the event (63 character maximum).\n\n* `flags1` Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.\n\n* `flags2` (optional) You can use NO_ACK or WITH_ACK if desired.\n\n#### Returns\ntrue if the event was queued or false if it was not.\n\nThis function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.\n\n---\n\n### bool PublishQueuePosix::publish(const char * eventName, const char * data, PublishFlags flags1, PublishFlags flags2) \n\nOverload for publishing an event.\n\n```\nbool publish(const char * eventName, const char * data, PublishFlags flags1, PublishFlags flags2)\n```\n\n#### Parameters\n* `eventName` The name of the event (63 character maximum).\n\n* `data` The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).\n\n* `flags1` Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.\n\n* `flags2` (optional) You can use NO_ACK or WITH_ACK if desired.\n\n#### Returns\ntrue if the event was queued or false if it was not.\n\nThis function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.\n\n---\n\n### bool PublishQueuePosix::publish(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2) \n\nOverload for publishing an event.\n\n```\nbool publish(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)\n```\n\n#### Parameters\n* `eventName` The name of the event (63 character maximum).\n\n* `data` The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).\n\n* `ttl` The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.\n\n* `flags1` Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.\n\n* `flags2` (optional) You can use NO_ACK or WITH_ACK if desired.\n\n#### Returns\ntrue if the event was queued or false if it was not.\n\nThis function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.\n\n---\n\n### bool PublishQueuePosix::publishCommon(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2) \n\nCommon publish function. All other overloads lead here. This is a pure virtual function, implemented in subclasses.\n\n```\nvirtual bool publishCommon(const char * eventName, const char * data, int ttl, PublishFlags flags1, PublishFlags flags2)\n```\n\n#### Parameters\n* `eventName` The name of the event (63 character maximum).\n\n* `data` The event data (255 bytes maximum, 622 bytes in system firmware 0.8.0-rc.4 and later).\n\n* `ttl` The time-to-live value. If not specified in one of the other overloads, the value 60 is used. However, the ttl is ignored by the cloud, so it doesn't matter what you set it to. Essentially all events are discarded immediately if not subscribed to so they essentially have a ttl of 0.\n\n* `flags1` Normally PRIVATE. You can also use PUBLIC, but one or the other must be specified.\n\n* `flags2` (optional) You can use NO_ACK or WITH_ACK if desired.\n\n#### Returns\ntrue if the event was queued or false if it was not.\n\nThis function almost always returns true. If you queue more events than fit in the buffer the oldest (sometimes second oldest) is discarded.\n\n---\n\n### void PublishQueuePosix::writeQueueToFiles() \n\nIf there are events in the RAM queue, write them to files in the flash file system.\n\n```\nvoid writeQueueToFiles()\n```\n\n---\n\n### void PublishQueuePosix::clearQueues() \n\nEmpty both the RAM and file based queues. Any queued events are discarded.\n\n```\nvoid clearQueues()\n```\n\n---\n\n### void PublishQueuePosix::setPausePublishing(bool value) \n\nPause or resume publishing events.\n\n```\nvoid setPausePublishing(bool value)\n```\n\n#### Parameters\n* `value` The value to set, true = pause, false = normal operation\n\nIf called while a publish is in progress, that publish will still proceed, but the next event (if any) will not be attempted.\n\nThis is used by the automated test tool; you probably won't need to manually manage this under normal circumstances.\n\n---\n\n### bool PublishQueuePosix::getPausePublishing() const \n\nGets the state of the pause publishing flag.\n\n```\nbool getPausePublishing() const\n```\n---\n\n### bool PublishQueuePosix::getCanSleep() const \n\nDetermine if it's a good time to go to sleep. Added in version 0.0.3.\n\n```\nbool getCanSleep() const\n```\n\nIf a publish is not in progress and the queue is empty, returns true.\n\nIf pausePublishing is true, then return true if either the current publish has completed, or not cloud connected.\n\n---\n\n### size_t PublishQueuePosix::getNumEvents() \n\nGets the total number of events queued.\n\n```\nsize_t getNumEvents()\n```\n\nThis is the number of events in the RAM-based queue and the file-based queue. This operation is fast; the file queue length is stored in RAM, so this command does not need to access the file system.\n\nIf an event is currently being sent, the result includes this event.\n\n---\n\n### void PublishQueuePosix::lock() \n\nLock the queue protection mutex.\n\n```\nvoid lock()\n```\n\nThis is done internally; you probably won't need to call this yourself. It needs to be public for the WITH_LOCK() macro to work properly.\n\n---\n\n### bool PublishQueuePosix::tryLock() \n\nAttempt the queue protection mutex.\n\n```\nbool tryLock()\n```\n\n---\n\n### void PublishQueuePosix::unlock() \n\nUnlock the queue protection mutex.\n\n```\nvoid unlock()\n```\n\n## Version History\n\n### 0.0.5 (2022-10-06)\n\n- I believe I fixed a situation where getCanSleep() can return true during the waitAfterConnect period after connecting\neven though there are events in the queue.\n\n### 0.0.4 (2022-06-21)\n\n- When setPausePublishing(false), set the canSleep flag to false if there are events in the queue\n- The canSleep flag was not set after sending the last event\n\n### 0.0.3 (2022-03-07)\n\n- Added getCanSleep() method to determine if the queue has been sent and it's safe to sleep. \n\n### 0.0.2 (2022-01-28)\n\n- Rename BackgroundPublishRK class to BackgroundPublishRK to avoid conflict with a class of the same name in Tracker Edge.\n\n\n### 0.0.1 (2021-04-28)\n\n- Initial version\n",
  "allVersions": [
    "0.0.5",
    "0.0.4",
    "0.0.3",
    "0.0.2",
    "0.0.1"
  ]
}