{
  "type": "libraries",
  "id": "JSN-SR04_Gen3_RK",
  "links": {
    "download": "https://api.particle.io/v1/libraries/JSN-SR04_Gen3_RK/archive/0.0.2.tar.gz"
  },
  "attributes": {
    "name": "JSN-SR04_Gen3_RK",
    "version": "0.0.2",
    "installs": 384,
    "license": "MIT",
    "author": "rickkas7@rickkas7.com",
    "sentence": "Library for JSN-SR04 ultrasonic distance sensor for Particle Gen 3 devices",
    "url": "https://github.com/rickkas7/JSN-SR04_Gen3_RK",
    "repository": "https://github.com/rickkas7/JSN-SR04_Gen3_RK.git",
    "architectures": [
      "*"
    ],
    "visibility": "public",
    "mine": false
  },
  "kind": "community library",
  "letter": "j",
  "cardUrl": "/reference/device-os/libraries/j/JSN-SR04_Gen3_RK",
  "versions": {
    "0.0.2": {
      "added": "2023-03-21T18:26:55.818Z",
      "builds": {
        "5.0.1": {
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          },
          "bsom": {
            "1-simple": true,
            "2-alarm": true
          },
          "b5som": {
            "1-simple": true,
            "2-alarm": true
          },
          "tracker": {
            "1-simple": true,
            "2-alarm": true
          },
          "p2": {
            "1-simple": false,
            "2-alarm": false
          }
        },
        "4.0.0": {
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          },
          "bsom": {
            "1-simple": true,
            "2-alarm": true
          },
          "b5som": {
            "1-simple": true,
            "2-alarm": true
          },
          "tracker": {
            "1-simple": true,
            "2-alarm": true
          },
          "esomx": {
            "1-simple": false,
            "2-alarm": false
          }
        },
        "3.3.0": {
          "photon": {
            "1-simple": false,
            "2-alarm": false
          },
          "electron": {
            "1-simple": false,
            "2-alarm": false
          },
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          }
        },
        "2.3.0": {
          "photon": {
            "1-simple": false,
            "2-alarm": false
          },
          "electron": {
            "1-simple": false,
            "2-alarm": false
          },
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          }
        },
        "5.6.0": {
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          },
          "bsom": {
            "1-simple": true,
            "2-alarm": true
          },
          "b5som": {
            "1-simple": true,
            "2-alarm": true
          },
          "tracker": {
            "1-simple": true,
            "2-alarm": true
          },
          "p2": {
            "1-simple": false,
            "2-alarm": false
          }
        },
        "4.2.0": {
          "argon": {
            "1-simple": true,
            "2-alarm": true
          },
          "boron": {
            "1-simple": true,
            "2-alarm": true
          },
          "bsom": {
            "1-simple": true,
            "2-alarm": true
          },
          "b5som": {
            "1-simple": true,
            "2-alarm": true
          },
          "tracker": {
            "1-simple": true,
            "2-alarm": true
          },
          "esomx": {
            "1-simple": false,
            "2-alarm": false
          }
        }
      }
    }
  },
  "readme": "# JSN-SR04_Gen3_RK\n\n*Library for JSN-SR04 ultrasonic distance sensor for Particle Gen 3 devices (Argon, Boron, B Series SoM, Tracker)*\n\nThe JSN-SR04 is an inexpensive ultrasonic distance sensor. There are many manufacturers, some are weather resistant, and they have somewhat different supported ranges, but usually in the range of a few centimeters to maybe a few meters. Also note: these sensors are generally not all that reliable. I would not use one in a life-safety situation and be sure to code defensively for the case when it fails.\n\nOnce characteristic of the sensor is that you need to measure the pulse width to within a microsecond or so, and measurement takes around 150 microseconds of setup time and up to 29 milliseconds of pulse width (at 5 meters). At a more reasonable 1 meter, it's still around 9 milliseconds.\n\nThe problem on Gen 3 devices (nRF52840) is that even if you use interrupts, the interrupt latency is high, and extremely variable. The radio stack runs at a high interrupt priority and will delay other interrupts until completion. Because of the long time to sample, you don't want to disable interrupts because it will adversely affect the BLE radio, and the reset of the system. But if you do not disable interrupts, the interrupt latency makes for very inaccurate readings.\n\nThe solution is the technique used in this library: The nRF52840 I2S, note this is I2S, as in sound, not I2C, peripheral is really just a high-speed digital input and output device with hardware DMA. The library is configured to use 32,000 samples per second, with 16 bits per sample, stereo. This works out to a bit clock of 1 MHz, or 1 Âµs per sample bit, which is perfect for the JSN-SR04.\n\nThe library uses the I2S peripheral to both generate the TRIG pulse and measure the resulting ECHO pulse. It does so without ever disabling interrupts, and the interrupt occurs after the entire maximum measurement is complete. A deferred interrupt does not affect the accuracy of the sensor!\n\n\n### Level shifter required!\n\nOne caveat is the the JSN-SR04 sensors generally require 5V to operate properly.\n\nParticle Gen 3 devices are not 5V tolerant because the nRF52840 MCU is not! Be sure to use a level shifter on the ECHO output from the JSN-SR04 to the GPIO on the Particle device, or you will likely permanently damage the pin on the Particle device.\n\nAlso note that since you need 5V you will not be able to power the sensor off the LiPo battery unless you use an external boost converter. If you are powered by USB, you can power the sensor from the VUSB bin.\n\nMost JSN-SR04 sensors will trigger if TRIG only goes up to 3.3V so you generally don't need a level shifter on TRIG.\n\nIf you're looking for an inexpensive breadboard-friendly DIP package, the [74AHCT125](https://www.adafruit.com/product/1787) can be used. It's overkill in that it's a quad level-shifter, but it works. Connect VCC on the chip to 3V3 because you're using it to reduce the voltage!\n\nFor custom boards I often use a [Texas Instruments SN74LVC1T45](https://www.digikey.com/product-detail/en/texas-instruments/SN74LVC1T45QDCKRQ1/296-39212-1-ND/5143211) which comes in a tiny SC70-7 SMD package and is even less expensive.\n\n\n### Lots of GPIO required\n\nAnother caveat is that this library requires a lot of GPIO: four GPIO.\n\nOf course there are the two standard JSN-SR04 pins, TRIG (output) and ECHO (input).\n\nThe unfortunate thing is that you also need to dedicate two other pins, unusedPin1 and unusedPin2. These must not be the same pin, and can't be used for anything else for all practical purposes. This is due to how the I2S peripheral works. You have to assign the I2S LRCK and SCK to pins or the nRF52 I2S peripheral won't initialize. You won't need these outputs for anything, but they do need to be assigned real GPIOs. The signals happen to be 32 kHz for the LRCK and 1 MHz for SCK while getting a distance sample. \n\n### Memory requirements\n\nThe DMA buffers require 2,144 of RAM at the default maximum measurement distance of 1 meter. The library can be configured for larger or smaller distances, which affect both RAM usage and the amount of time to measure a distance.\n\n## Modes of operation\n\nThe library essentially only works with one sensor. You could reinitialize it on different pins for multiple sensors, but you can't measure more than one sensor at the same time because the I2S peripheral has a single bit digital capture.\n\n\n### Periodic with callback\n\nThe recommended mode of operation is to assign a callback function, and set the sensor to periodically sample. The minimum period is around 10 milliseconds with a maximum distance of 1 meter. Ideally you should set to to be 300 milliseconds or larger to account for timeout situations.\n\nThe callback is called with a DistanceResult object that contains the distance which you can retrieve in meters, centimeters, or inches. It will also include a status code, such as SUCCESS, RANGE_ERROR (too close or too far), BUSY, or other errors.\n\nSee the example examples/1-simple for how to use this mode.\n\n### Single sample with callback\n\nIf you only need a single sample, you can do that as well.\n\n### Single sample synchronous\n\nThis is not recommended, because it will block the current thread for up to the safety timer period, which is 300 milliseconds. Using the callback or polling is preferable. \n\n### Alarm mode\n\nAlarm mode calls the callback when the alarm condition is entered or exited. The alarm condition is a distance, along with an less than or greater than test, and a hysteresis value. It can be used to alert when you are too close or too far away from the thing being measured.\n\nIf you want to measure for change in distance, use the periodic measurement mode directly instead.\n\nSee the example examples/2-alarm for how to use this mode.\n\n## Usage\n\n- Include the library, such as by using `Particle: Install Library` in Particle Workbench, or by adding the **JSN-SR04_Gen3_RK** library in the Web IDE.\n\n- Add the necessary header file:\n\n```cpp\n#include \"JSN-SR04_Gen3_RK.h\"\n```\n\n- Declare one of these as a global variable to manage the JSN-SR04 sensor:\n\n```cpp\nJSN_SR04_Gen3 distanceSensor;\n```\n\n- In setup(), initialize the sensor pins and settings\n\n```cpp\nvoid setup() {\n\n    // Initialize the sensor configuration from setup()\n    distanceSensor\n        .withTrigPin(D3)\n        .withEchoPin(D4)\n        .withUnusedPins(A0, A1)\n        .setup();\n}\n```\n\n- Be sure to call the loop() method from loop()!\n\n```cpp\nvoid loop() {\n    // You must call this frequently from loop(), preferable on every execution\n    distanceSensor.loop();\n}\n```\n\n- If you are using a callback (recommended), the function might look something like this:\n\n```cpp\nvoid distanceCallback(JSN_SR04_Gen3::DistanceResult result) {\n    switch(result.status) {\n        case JSN_SR04_Gen3::DistanceResult::Status::SUCCESS:\n            Log.info(\"cm=%lf inch=%lf\", result.cm(), result.inch());\n            break;\n\n        case JSN_SR04_Gen3::DistanceResult::Status::RANGE_ERROR:\n            Log.info(\"distance range error\");\n            break;\n\n        default:\n            Log.info(\"distance error %d\", result.status);\n            break;\n    }\n}\n```\n\n## JSN_SR04_Gen3 API\n\nThe full browseable API can be found [online](https://rickkas7.github.io/JSN-SR04_Gen3_RK/) or in the docs folder docs/index.html offline.\n\nClass for a JSN-SR04 ultrasonic distance sensor.\n\nNote: You can effectively only have one instance of this class per device, because there is only one I2S peripheral, which is what is used to implement the device driver.\n\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withTrigPin(pin_t trigPin) \n\nSpecifies the TRIG pin (OUTPUT)\n\n```\nJSN_SR04_Gen3 & withTrigPin(pin_t trigPin)\n```\n\n#### Parameters\n* `trigPin` A pin, such as D2 or A0, or another port that is not being used, such as TX, RX, DAC, etc.\n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withEchoPin(pin_t echoPin) \n\nSpecifies the ECHO pin (INPUT)\n\n```\nJSN_SR04_Gen3 & withEchoPin(pin_t echoPin)\n```\n\n#### Parameters\n* `echoPin` A pin, such as D2 or A0, or another port that is not being used, such as TX, RX, DAC, etc.\n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nThe ECHO pin is typically a 5V logic level. You MUST add a level shifter before connecting it to a Particle Gen 3 device GPIO because GPIO are not 5V tolerant on the nRF52!\n\nThe ECHO pin on a JSN-SR04 is driven by a push-pull driver so you can only connect a single sensor to a single GPIO.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withUnusedPins(pin_t unusedPin1, pin_t unusedPin2) \n\nYou must specify two GPIO that are not otherwise used that will be used as outputs by this library.\n\n```\nJSN_SR04_Gen3 & withUnusedPins(pin_t unusedPin1, pin_t unusedPin2)\n```\n\n#### Parameters\n* `unusedPin1` A pin, such as D2 or A0, or another port that is not being used, such as TX, RX, DAC, etc. \n\n* `unusedPin2` A pin, such as D2 or A0, or another port that is not being used, such as TX, RX, DAC, etc. Must be different than unusedPin1. \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nYou need to dedicate two other pins, unusedPin1 and unusedPin2. These must not be the same pin, and can't be used for anything else for all practical purposes. This is due to how the I2S peripheral works. You have to assign the I2S LRCK and SCK to pins or the nRF52 I2S peripheral won't initialize. You won't need these outputs for anything, but they do need to be assigned GPIOs. The signals happen to be 32 kHz for the LRCK and 1 MHz for SCK while getting a distance sample.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withMaxLengthMeters(float maxLengthM) \n\nThe maximum length that can be measured in meters. Default: 1 meter.\n\n```\nJSN_SR04_Gen3 & withMaxLengthMeters(float maxLengthM)\n```\n\n#### Parameters\n* `maxLengthM` Distance in meters \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nThis affects the amount of memory that is used, and also the amount of time a sampling takes. See the README for more information.\n\nAt the default is 1 meter, the memory is 2,080 bytes and the time is 9 milliseconds.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withCallback(std::function< void(DistanceResult)> callback) \n\nSpecify a callback function to be called on samples, errors, and alarm conditions.\n\n```\nJSN_SR04_Gen3 & withCallback(std::function< void(DistanceResult)> callback)\n```\n\n#### Parameters\n* `callback` The callback function \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nThe callback function has the prototype;\n\nvoid callback(DistanceResult distanceResult)\n\nIt can be a C++11 lambda, if desired, to call a class member function.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withSamplePeriodic(std::chrono::milliseconds period) \n\nEnabling periodic sampling mode.\n\n```\nJSN_SR04_Gen3 & withSamplePeriodic(std::chrono::milliseconds period)\n```\n\n#### Parameters\n* `period` The sampling period as a chrono literal, such as 500ms, 10s, etc. \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nIt's recommended to specify a sampling period greater than safetyTimeoutMs milliseconds (currently 300). However, in practice you can specify a much faster sampling period, as low as getSampleTimeMs() milliseconds. The latter varies depending on the max length meters. At the default value of 1 meter, you can use a periodic sample rate at low as 10 milliseconds, however you might not get every sample. The sensor may not always reset in time an the BUSY error will be called on the callback.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withSamplePeriodicMs(unsigned long periodMs) \n\nEnabling periodic sampling mode.\n\n```\nJSN_SR04_Gen3 & withSamplePeriodicMs(unsigned long periodMs)\n```\n\n#### Parameters\n* `periodMs` The sampling period in milliseconds \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\nIt's recommended to specify a sampling period greater than safetyTimeoutMs milliseconds (currently 300). However, in practice you can specify a much faster sampling period, as low as getSampleTimeMs() milliseconds. The latter varies depending on the max length meters. At the default value of 1 meter, you can use a periodic sample rate at low as 10 milliseconds, however you might not get every sample. The sensor may not always reset in time an the BUSY error will be called on the callback.\n\n---\n\n### JSN_SR04_Gen3 & JSN_SR04_Gen3::withDistanceAlarm(DistanceAlarm distanceAlarm) \n\nEnable distance alarm mode.\n\n```\nJSN_SR04_Gen3 & withDistanceAlarm(DistanceAlarm distanceAlarm)\n```\n\n#### Parameters\n* `distanceAlarm` The distance alarm configuration \n\n#### Returns\nJSN_SR04_Gen3& This object, for chaining options, fluent-style\n\n---\n\n### bool JSN_SR04_Gen3::setup() \n\nYou typically call this from setup() after setting all of the configuration parameters using the withXXX() methods.\n\n```\nbool setup()\n```\n\nYou must call setup() before any samples can be taken.\n\n---\n\n### void JSN_SR04_Gen3::loop() \n\nYou must call this from loop()\n\n```\nvoid loop()\n```\n\n---\n\n### bool JSN_SR04_Gen3::sampleOnce() \n\nGet a sample from the sensor.\n\n```\nbool sampleOnce()\n```\n\n#### Returns\ntrue \n\n#### Returns\nfalse\n\nYou still must configure the pins and call the setup() method. You must also call the loop() method from loop().\n\n---\n\n### DistanceResult JSN_SR04_Gen3::sampleOnceSync() \n\nSynchronous version of sampleOnce - not recommended.\n\n```\nDistanceResult sampleOnceSync()\n```\n\n#### Returns\nDistanceResult\n\nUsing the asynchronous callback is preferable, but this call is provided to make it somewhat easier to convert code from other libraries.\n\n---\n\n### DistanceResult JSN_SR04_Gen3::getLastResult() const \n\nGets the last result code.\n\n```\nDistanceResult getLastResult() const\n```\n\n#### Returns\nDistanceResult\n\nNormally you should use the callback, but if you want to poll instead of using a callback you can use this function for periodic, sample once, and alarm modes.\n\n---\n\n### unsigned long JSN_SR04_Gen3::getSampleTimeMs() const \n\nReturns the number of milliseconds it takes to process a sample.\n\n```\nunsigned long getSampleTimeMs() const\n```\n\n#### Returns\nunsigned long number of milliseconds\n\nIn practice it might take a few milliseconds longer because of the delays in dispatching loop(). The value is calculated from the maxLengthM and leadingOverhead values.\n\nWith the default value of 1 meter maximum and 152 leadingOverhead, this returns 9 milliseconds.\n\nIn theory you could sample at around every 9 milliseconds, maybe 10, but it's probably best to limit it to 100 milliseconds, or even 500 milliseconds, to be safe. If you sample frequently, be sure to handle the case where BUSY status is returned. This means that that sensor has not yet reset the ECHO output low and a sample cannot be taken yet.\n\nNote that the callback will not be called for at least this long, regardless of distance! The reason is that the sample buffer is not processed until the DMA engine stops writing to the entire buffer, and then it waits until in loop context again.\n\n## JSN_SR04_Gen3::DistanceResult API\n\n```\nclass JSN_SR04_Gen3::DistanceResult\n  : public JSN_SR04_Gen3::Distance\n```  \n\nStructure passed to the callback when the distance has been retrieved.\n\nThis includes a Status enum for the result status, and optionally a distance as this class is derived from class Distance. Thus you can use the inherited methods such as cm(), mm(), and inch() to get the distance in centimeters, millimeters, or inches, for example.\n\n### Status status \n\nCurrent status value.\n\n```\nStatus status\n```\n\n---\n\n### Status JSN_SR04_Gen3::DistanceResult::getStatus() const \n\nGet the Status value for this result.\n\n```\nStatus getStatus() const\n```\n\n#### Returns\nStatus\n\n---\n\n### bool JSN_SR04_Gen3::DistanceResult::success() const \n\nHelper function to return true if the Status is SUCCESS.\n\n```\nbool success() const\n```\n\n#### Returns\ntrue \n\n#### Returns\nfalse\n\n---\n\n### enum Status \n\nStatus of the call.\n\n```\nenum Status\n```\n\n Values                         | Descriptions                                \n--------------------------------|---------------------------------------------\nSUCCESS            | Success, got a valid looking measurement.\nERROR            | An internal error (problem with the I2S peripheral, etc.)\nRANGE_ERROR            | Too close or too far away to detect.\nBUSY            | Called before the previous call completed.\nIN_PROGRESS            | Call is in progress (getting sample from sensor)\nENTER_ALARM            | When using distance alarm, entering alarm state.\nEXIT_ALARM            | When using distance alarm, exiting alarm state.\n\n\n# class JSN_SR04_Gen3::Distance \n\nUtility class for holding a distance.\n\nThe storage value is in meters, but there are accessors for cm, mm, and inches. This is used for both getting distances (the sensor value) as well as setting distances (for distance alarm mode).\n\nThe JSN_SR04_Gen3::DistanceResult class is derived from this class, so the methods here can be used with a DistanceResult that is passed to the callback.\n\n### double distanceM \n\nThe value of the distance in meters.\n\n```\ndouble distanceM\n```\n\n---\n\n###  JSN_SR04_Gen3::Distance::Distance() \n\nConstruct a new Distance object with a distance of 0.\n\n```\n Distance()\n```\n\n---\n\n###  JSN_SR04_Gen3::Distance::Distance(double valueM) \n\nConstruct a new Distance object with a distance in meters.\n\n```\n Distance(double valueM)\n```\n\n#### Parameters\n* `valueM` distance in meters (double floating point)\n\n---\n\n###  JSN_SR04_Gen3::Distance::Distance(const Distance & value) \n\nConstruct a new Distance object from another Distance object.\n\n```\n Distance(const Distance & value)\n```\n\n#### Parameters\n* `value` The object to copy the distance from\n\n---\n\n### Distance & JSN_SR04_Gen3::Distance::operator=(const Distance & value) \n\nCopy the distance value from another Distance object.\n\n```\nDistance & operator=(const Distance & value)\n```\n\n#### Parameters\n* `value` The object to copy the distance from\n\n#### Returns\nDistance& Return this object, so you can chain multiple assignments\n\n---\n\n### void JSN_SR04_Gen3::Distance::setDistanceM(double distanceM) \n\nSet the Distance in meters.\n\n```\nvoid setDistanceM(double distanceM)\n```\n\n#### Parameters\n* `distanceM` the distance in meters to set\n\n---\n\n### double JSN_SR04_Gen3::Distance::getDistanceM() const \n\nGet the Distance in meters.\n\n```\ndouble getDistanceM() const\n```\n\n#### Returns\ndouble Distance in meters\n\n---\n\n### void JSN_SR04_Gen3::Distance::cm(double cm) \n\nSet the distance in centimeters.\n\n```\nvoid cm(double cm)\n```\n\n#### Parameters\n* `cm` Distance in centimeters (double floating point)\n\nInternally, the distance is stored in meters, but this sets the value in centimeters. You can mix-and-match, for example you can get the distance in inches after setting it in centimeters.\n\n---\n\n### double JSN_SR04_Gen3::Distance::cm() const \n\nGet the value of the Distance in centimeters.\n\n```\ndouble cm() const\n```\n\n#### Returns\ndouble Distance in centimeters\n\n---\n\n### void JSN_SR04_Gen3::Distance::mm(double mm) \n\nSet the distance in millimeter.\n\n```\nvoid mm(double mm)\n```\n\n#### Parameters\n* `mm` Distance in millimeters (double floating point)\n\nInternally, the distance is stored in meters, but this sets the value in millimeters. You can mix-and-match, for example you can get the distance in inches after setting it in millimeters.\n\n---\n\n### double JSN_SR04_Gen3::Distance::mm() const \n\nGet the value of the Distance in millimeters.\n\n```\ndouble mm() const\n```\n\n#### Returns\ndouble Distance in millimeters\n\n---\n\n### void JSN_SR04_Gen3::Distance::inch(double inch) \n\nSet the distance in inches.\n\n```\nvoid inch(double inch)\n```\n\n#### Parameters\n* `inch` Distance in inches (double floating point)\n\nInternally, the distance is stored in meters, but this sets the value in inches. You can mix-and-match, for example you can get the distance in centimeters after setting it in inches.\n\n---\n\n### double JSN_SR04_Gen3::Distance::inch() const \n\nGet the value of the Distance in inches.\n\n```\ndouble inch() const\n```\n\n#### Returns\ndouble Distance in inches\n\n\n## Calculations\n\nThe TRIG pin is normally low, you pulse it high for 10 ÂµS to begin measurement.\n\nThe ECHO pin is normally low, it will go high during the measurement, and the length of the high pulse determines the distance:\n\nDistance = (T Ã C) / 2\n\nwhere:\n\n- T is the time of the pulse in seconds  \n- C is the speed of sound (340 meters/sec)\n\nThe detection range of the sensor I got is 2 cm (0.02 m) to 500 cm (5 m). This means the time of the pulse ranges from:\n\n- Min: 0.02 m = 0.00011765 sec = 0.1176 ms = 117 Âµs\n- Max: 5 m = 0.0294 sec = 29 ms\n\n\nThe accuracy of the sensor I got is claimed to be 0.3 cm, or 0.0003 meters. \n\n- 0.0003 meters = 0.00000186 sec = 0.00176 milliseconds = 1.76 microseconds\n- 568,181 Hz\n\nWe want to sample at roughly twice that frequency, if possible, or even higher.\n\nThe I2S peripheral has many possible configurations:\n\n(image removed)\n\nNote that the sample rate (LRCK), is the number of 16-bit stereo samples. Each bit of our input is one of those bits, so a sample rate of 32000 Hz is actually samples at 1,024,000 Hz, which is close to our target. Perfect!\n\nIn other words, with a 1 MHz sample rate, we can measure the width of a pulse with a resolution if 1 Âµs (1 microsecond), without touching interrupts and with no interrupt latency, because the I2S peripheral does not require bit-level interrupts. \n\nThe total buffer length is the length of the TRIG pulse (10 ÂµS) + setup time + maximum detection pulse (up to 29 ms). \n\nThe TRIG pulse output should be 10 Âµs. This is a minimum of 10 bits of output 1. We use 16 bits because it's really convenient with 16-bit samples.\n\nThe setup time is not in the datasheet, but dumping the ECHO pin output from the sensor looks like this:\n\n```\n0000005026 [app] INFO: 0090: 0000 0000 0000 0000\n0000005026 [app] INFO: 0094: 03ff ffff ffff ffff\n0000005027 [app] INFO: 0098: ffff ffff ffff ffff\n0000005027 [app] INFO: 009c: ffff ffff ffff ffff\n0000005028 [app] INFO: 00a0: ffff ffff ffff ffff\n0000005028 [app] INFO: 00a4: ffff ffff ffff ffff\n0000005029 [app] INFO: 00a8: ffff ffff ffff ffff\n0000005029 [app] INFO: 00ac: ffff ffff ffff ffff\n0000005030 [app] INFO: 00b0: ffff ffff ffff ffff\n0000005030 [app] INFO: 00b4: ffff ffff ffff ffff\n0000005031 [app] INFO: 00b8: ffff ffff fffe 0000\n0000005031 [app] INFO: 00bc: 0000 0000 0000 0000\n0000005032 [app] INFO: 00c0: 0000 0000 0000 0000\n```\n\n- The time from the falling TRIG pulse to ECHO going high is 0x93 16-bit samples (147), or 2.35 ms.\n\n- In other words, the leading overhead should be assumed to be around 150 16-bit samples.\n\n- When the signal goes high the sample has a value of 0x03ff. The leftmost (MSB) is the first, chronologically.\n\n- When the signal goes low the sample has a value of 0xfff3. The rightmost (LSB) is the last, chronologically.\n\nI set the leadingOverhead to 152 16-bit samples, or 2432 Âµs.\n\nEven though this sensor is theoretically able to measure up to 5 meters, I've never had a sensor work at that distance reliably. To save RAM, I set the maximum distance to 1 meter. You could set it shorter or a longer if desired.\n\n- D = 1 meters\n- C = 340 meters/sec\n- T = (2 Ã D) / C\n- T = 0.005882 sec = 5.882 ms = 5882 Âµs = 5,882 1-bit samples = 368 16-bit samples\n\nAdding in the 152 16-bit setup time results in 520 16-bit samples. This is 1,040 bytes, however we need both transmit and receive DMA buffers, so that's a total overhead of 2,080 bytes for transmit and receive buffers at 1 meter.\n\nIf you wanted a 2 meter range and had a sensor that worked acceptable at that range, it would require 3,552 bytes of buffer. The range is floating point, so you can specify fractions of a meter as well.\n\nAt a maximum distance of 5 meters, T = (2 Ã D) / C = 0.294 seconds = 294 milliseconds. This is where the 300 millisecond safety timer is derived from. If the sensor fails to respond in this amount of time, something has gone wrong.\n\nThe datasheet is silent as to what happens if you pulse TRIG high while ECHO is still high. The library returns a BUSY error if you attempt this since the behavior in unspecified.\n\nThe getSampleTimeMs() method returns the number of milliseconds it takes to process a sample. In practice it might take a few milliseconds longer because of the delays in dispatching loop().\n\nThe formula is:\n\n- T = (2 Ã D) / C\n- leadingOverheadMs = leadingOverhead * 16 / 1000 = 152 * 16 / 1000 = 2.432 ms\n- Cms = 0.340 meters/millisecond\n- Tms = (2 Ã D) / Cms + leadingOverheadMs\n\nFor the default of D = 1 meter:\n\n- D = 1 meter\n- Tms = (2 Ã D) / Cms + leadingOverheadMs\n- Tms = 2 / 0.340 + 2.432\n- Tms = 8.31 ms (rounded up to 9)\n\nThus in theory you could sample at around every 9 milliseconds, maybe 10, but it's probably best to limit it to 100 milliseconds, or even 500 milliseconds, to be safe. If you sample frequently, be sure to handle the case where BUSY status is returned. This means that that sensor has not yet reset the ECHO output low and a sample cannot be taken yet.\n\n## Version History\n\n### 0.0.2 (2021-12-15)\n\n- Fixed a bug that caused busy errors\n\n### 0.0.1 (2021-12-15)\n\n- Initial version\n",
  "allVersions": [
    "0.0.2",
    "0.0.1"
  ]
}