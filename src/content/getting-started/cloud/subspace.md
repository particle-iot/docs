---
title: Subspace
columns: two
layout: commonTwo.hbs
description: Subspace
---

# {{title}}

## Overview

Subspace was created to allow users to get additional value and insights from their data. There are many insights a combination of events can provide, and Logic & Ledger were created to help you do just that.

Some fundamental uses that subspace can provide:

#### Updating a derived state

For many state records, the data is a single read (like temperature, PSI, or isMotorRunning) but for some, the state is derived from the combination of several streams of data, and requires logic to create the appropriate amalgam. 
    
*Example: I would like to know if a person is actively in and using a hot tub. This can allow me to build an energy efficient experience by lowering the temperature of the hot tub water at times that the user is likely not going to use it.*

#### Creating an observation record in another data system    

Observed activity will be important for customer dashboards or BI tools.
    
*Example: As an operations manager, I would like to see which products in the field may have recently lost connection due to low battery and may require onsite servicing. This can allow me to proactively plan for onsite servicing without waiting for a customer service call.*
    
#### Integrating with an existing workflow tool

Logic blocks allow transformation of data to make it easy to integrate with existing tools you are already using.

    
*Example: As a customer service rep, I would like for my existing Salesforce workflow to include IoT-based customer updates like issues identified needing service.*
    
#### Triggering a message

Resulting actions and insights that are outcomes of Logic can be used to trigger a message using an external service.

*Example: As a homeowner, I would like to receive a notification when a water issue is detected at a property I own, as well as any relevant actions automatically taken.*

## Logic

Logic blocks are bits of Javascript code that get called in response to a trigger event, which can be:

- A Particle event, generated by a device or generated by the Particle cloud API
- A periodic time event ("cron")

Logic block implement a *lambda calculus* model where each block has a defined input (event or cron) and a defined output, such as:

- Generation of new event (which might be subscribed to by a device, or trigger an integration)
- Storing data in the Ledger database (in the future)

In particular, logic blocks are short-running and consist only of calculations, conditional logic, etc.. Logic blocks cannot interact with the outside world (such by REST APIs) and do not maintain state across invocations.

{{collapse op="start" label="Tell me more the lambda calculus"}}

**Lambda calculus** is a mathematical formalism that was first introduced by mathematician Alonzo Church in the 1930s. It provides a way to describe and reason about functions, which are the central building blocks of computer programs.

In lambda calculus, functions are treated as mathematical entities that can be passed around and applied to other functions, just like numbers or variables. A function in lambda calculus is defined using a "lambda" expression, which consists of an input variable, an arrow, and an expression that defines what the function does. For example, the function that takes a number x and adds 1 to it can be written as:

x &rarr; x + 1

In lambda calculus, functions can be composed to create more complex functions, and functions can be applied to other functions to produce new functions. This allows for the creation of sophisticated functions from simpler building blocks, making it a powerful tool for describing and reasoning about computation.

In addition to its use as a theoretical foundation for computer science, lambda calculus has been used in the design of programming languages, particularly functional programming languages like Haskell, Lisp, and Scheme. These languages often adopt many of the concepts and notation of lambda calculus, making it an important area of study for computer scientists and programming language designers.

**A lambda function** is a small, self-contained piece of code that takes in a set of known inputs, performs a calculation, and then generates a set of outputs. These inputs are often referred to as parameters, and they are passed into the lambda function when it is invoked.

Once the lambda function is invoked, it runs its code to perform the calculation, which may involve operations like mathematical computations, data transformations, or conditional logic (limited to its input data). The calculation performed by the lambda function can be as simple or as complex as needed to solve the problem at hand.

Finally, once the calculation is complete, the lambda function generates a set of outputs, which may include a single result or a collection of results. These outputs can then be used by other parts of the system or passed on to other functions for further processing.

In this way, a lambda function acts like a tiny, self-contained program that can be used to perform a specific task or calculation. Because they are small and self-contained, they are easy to write, test, and deploy, making them a powerful tool for solving complex problems in a modular and scalable way.

{{collapse op="end"}}

### Logic blocks

Logic blocks can be edited from the [Particle console](https://console.particle.io/) or using the Particle cloud API. At this time, blocks are only available in organization accounts (growth an enterprise). First select your organization at the top of the console, then if you have logic blocks available to your account a new icon **Blocks** will appear in the left tool palette.

![Blocks Tab](/assets/images/subspace/blocks-tab.png)

Creating a block involves setting one or more triggers and setting the code to run.

![Create Block](/assets/images/subspace/blocks-tab.png)

There are currently two options for triggering: Particle event or scheduled (cron):

![Trigger Type](/assets/images/subspace/trigger-type.png)

When triggering by an event, there are two required parameters:

- Event name (prefix match)
- Product the event will be generated in

![Trigger Event](/assets/images/subspace/trigger-event.png)

When using a scheduled trigger a cron-style schedule string is required, see the next section for the syntax.

![Trigger Scheduled](/assets/images/subspace/trigger-cron.png)

### Cron syntax

When scheduling events, **cron** syntax is used. A chron schedule consists of 5 space-separated fields for:

| Field | Range |
| :--- | :--- |
| minute | 0 - 59 |
| hour | 0 - 23 |
| day of month | 1 - 31|
| month | 1 - 12 |
| day of week | 0 = Sunday, 1 = Monday, ..., 6 = Saturday |

Additionally, three special characters are allowed:

| Character | Meaning |
| :---: | :--- |
| `*` | All (wildcard) |
| `,` | List of options (any of the list) |
| `-` | Range (inclusive) |

This most easily illustrated by examples:

| Example | Description |
| :--- | :--- |
| `0 * * * *` | Every hour at minute = 0 |
| `0 4 * * *` | Every day at 4:00 UTC (minute = 0, hour = 4) |
| `0 4,8,12,16 * * *` | Every day at 4:00, 8:00, 12:00, at 16:00 UTC |
| `0 4 * * 1-5` | Every weekday at 4:00 UTC (minute = 0, hour = 4, day of week = 1 - 5 or Monday - Friday |

### Logic block code

The logic block code is Javascript. You can use built-in language features such as:

- calculations
- if blocks
- for and while loops
- functions
- JSON features like `JSON.parse()` and `JSON.stringify()`
- `console.log`
- [Particle Blocks API](#particle-blocks-api) (below)

You cannot use features such as:

- functions implemented in external packages (no package.json)
- network access (access to external APIs using things like fetch)
- long running operations
- asynchronous features like async/await, promises, etc.

### Particle Blocks API

#### Particle.getTrigger()

Returns an object containing the raw trigger and its details. Depending on the details.type which specifies what
triggered this runtime, you'll have access to different sets of data.

```js
// EXAMPLE
const trigger = Particle.getTrigger();
const data = JSON.parse(trigger.details.event_data);
console.log('JSON data', data);
```

The `trigger` object has the following Typescript definition:

```js
interface PubSubDetails {
    type: 'PubSub',
    event_name: string,
    event_data?: string,
    device_id: string,
    product_id?: number,
    user_id?: string,
}

interface ChronDetails {
    type: 'Chron',
    id: number,
    version: number,
    start_at: string,
    end_at: string
}

interface Trigger {
    trigger_id?: string,
    organization_id: string,
    published_at: string,
    details: PubSubDetails | ChronDetails
}
```

#### Particle.publish

Synchronously publishes an event to the Particle cloud. This event can be subscribed to on-device or be used to trigger a webhook.

```
// PROTOTYPE
publish(name: string, data?: any, tags?: { productId: number, userId: number }): boolean,
```

- `name` The name of the event
- `data` The particle publish data. This can be a string or an object. If an object, it will be serialized to JSON using `JSON.stringify`.
- `tags` Allows specifying a `productId` or `userId` which you would like the data to be published to

