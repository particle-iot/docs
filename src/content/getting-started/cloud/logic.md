---
title: Logic
columns: two
layout: commonTwo.hbs
description: Logic cloud functions
---

# {{title}} Beta

{{note op="start" type="note"}}
Logic is in beta and is not recommended for production applications. There may be breaking changes to the behavior 
and APIs in future versions based on user feedback. 

Pricing and availability may change in the future.
{{note op="end"}}

Logic functions are bits of Javascript code that get called in response to a trigger event, which can be:

- A Particle event, generated by a device or generated by the Particle cloud API
- A periodic time event ("cron")

Logic functions run in the cloud and are designed to perfom short-running calculations such as:

- Generation of new event (which might be subscribed to by a device, or trigger an integration)
- Storing data in the Ledger database (in the future)

In particular, Logic functions consist only of calculations, conditional logic, etc.. Logic functions cannot interact with the outside world (such by REST APIs) and do not maintain state across invocations in the logic function.

Logic functions can, however, trigger an integration (webhook), and also respond to the results from a webhook.

For this beta version:

- Logic functions are only available in the developer sandbox (not growth or enterprise organizations)
- Maximum number of logic functions per sandbox: 20
- Maximum number of triggers per logic function: 5
- Run logs per function retained: 100
- Maximum logic run execution time: 30 seconds


## Common use cases

### Data trasformation

Events to and from devices have a limited size (typically 1024 bytes). Using Logic you can transform data that has been abbreviated or compressed, expanding it and passing it to a webhook. The communication between logic and a webhook is not limited by the 1024 byte event size limitation, making it ideal for expanding compressed data.

While a webhook hook-response cannot trigger another webhook, it can trigger a logic block. This allows much more complex processing of the data coming from a web service than is possible using mustache variables in your hook response template.

There are several use-cases for data transformation:

- Cloud protocol translation
- Moving business logic from firmware to the cloud
- Alerting on abnormal conditions (using an external service)

In addition to bypassing event size limitations, logic events do not currently count as an additional data operations, however a triggering event from a device or hook-response does still count.

## Console interface

The Logic feature is typically accessed from the [Particle console](https://console.particle.io/). It is also possible to access it from the Particle Cloud API, and there will be support for creating logic functions in a future version of the Particle CLI.

In the developer sandbox in the console, select the **Logic** icon.

![](/assets/images/subspace/console-icon.png)


### Logic templates

Using a template is the easiest way to get started.

The current templates are:

- Decode Base64: Decode an event data payload that is encoded using Base64 back into a byte array.
- Decode Base85: Decode an event data payload that is encoded using Base85 back into a byte array.
- Reformat JSON data: Reformat and add fields to a JSON event to make it compatible with an external service.
- Event-triggered function: Start with a clean logic function that triggers from an event.
- Scheduled function: Start with a clean logic function that triggers on a schedule.

### Creating a logic function from a template

Using a template is a three step process:

- Define (set name and description)
- Execute (update the Javascript and test)
- Deploy (set triggers and enable to run in the cloud)

#### Define logic function

![](/assets/images/subspace/logic-define.png)

The name and description are just for your information.

#### Execute logic function

![](/assets/images/subspace/logic-execute.png)

This is the sample code generated in the template, it will be explained in more detail below.

```js
import Particle from 'particle:core';

export default function decode({ event }) {
  let data;
  try {
	  data = JSON.parse(event.eventData);
  } catch (err) {
    console.error("Invalid JSON", event.eventData);
    throw err;
  }
  const reformatted = {
    id: data.i,
    data: {
      value: data.d,
      type: 'Sensor'
    }
  };
  Particle.publish("data-reformatted", reformatted, { productId: event.productId });
}
```

The next part of interest is the **Event Test Data**. The field is initially empty and says Sensor Data but if you are transforming JSON, you will typically enter sample data that your device would normally publish. For example:

```json
{"i":12, "d":34.56}
```

You'll enter the event name in the next step.

Finally, click the **Run Code** button. 

![](/assets/images/subspace/logic-run-code.png)

### Deploy logic function

![](/assets/images/subspace/logic-deploy.png)

For an event triggered logic function, this is where you enter the **Trigger event name**. Unlike an integration, a logic function event name trigger is an exact match, not a prefix match.

You must specify a product to associate the logic function with! Logic functions only work with product devices, not sandbox devices. For the beta, only personal sandbox products can be used (not organization products).

### Testing from console

Since logic functions only work with products:

- From the **Products** icon in your developer sandbox, open the product that you associated your logic function with.
- Click on the **Events** icon within your product.
- Click on the **Publish an event** icon near the top, to the left of Search for events.

![](/assets/images/subspace/logic-publish.png)

- For **Event name** enter the event name you entered in the Deploy step above.
- For **Event data** enter the test JSON data. For example: 

```json
{"i":12, "d":34.56}
```

Click the **Publish** button and you should see both the `sensor-test` event and the `data-reformatted` event!

![](/assets/images/subspace/logic-complete.png)


### Testing from the Particle CLI

You can publish events using the Particle CLI for testing, but remember to pass the product number, since logic functions only work with product devices.

```
% particle publish --product 1234 'sensor-test' '{"i":12, "d":34.56}'
Published private event: sensor-test to product: 1234
```

### Testing from a device

Of course the real application for this is having a device publish the data. 

- The [JSON documentation](/firmware/best-practices/json/) is a good place for a background in JSON.
- The [JSONWriter](/reference/device-os/api/json/json/) is a good way to generate JSON on device.
- Of course you're use [Particle.publish](/reference/device-os/api/cloud-functions/particle-publish/) from device firmware to publish an event.

For example:

```cpp
char buf[particle::protocol::MAX_EVENT_DATA_LENGTH + 1];
memset(buf, 0, sizeof(buf));
JSONBufferWriter writer(buf, sizeof(buf) - 1);

writer.beginObject();
    writer.name("d").value(sensorData);
    writer.name("i").value(sensorId);
writer.endObject();

Particle.publish("sensor-test", buf);
```

Remember that logic functions only work with product devices. The devices can be product developer devices (or not) and can be claimed or unclaimed.

{{!-- 
### Cron syntax

When scheduling events, **cron** syntax is used. A chron schedule consists of 5 space-separated fields for:

| Field | Range |
| :--- | :--- |
| minute | 0 - 59 |
| hour | 0 - 23 |
| day of month | 1 - 31|
| month | 1 - 12 |
| day of week | 0 = Sunday, 1 = Monday, ..., 6 = Saturday |

Additionally, three special characters are allowed:

| Character | Meaning |
| :---: | :--- |
| `*` | All (wildcard) |
| `,` | List of options (any of the list) |
| `-` | Range (inclusive) |

This most easily illustrated by examples:

| Example | Description |
| :--- | :--- |
| `0 * * * *` | Every hour at minute = 0 |
| `0 4 * * *` | Every day at 4:00 UTC (minute = 0, hour = 4) |
| `0 4,8,12,16 * * *` | Every day at 4:00, 8:00, 12:00, at 16:00 UTC |
| `0 4 * * 1-5` | Every weekday at 4:00 UTC (minute = 0, hour = 4, day of week = 1 - 5 or Monday - Friday |

--}}

## Logic function code

The Logic function code is Javascript. You can use built-in language features such as:

- calculations
- if blocks
- for and while loops
- functions
- JSON features like `JSON.parse()` and `JSON.stringify()`
- `console.log`
- [Particle Logic Core API](#particle-logic-core-api) (below)
- [Particle Logic Core API](#particle-logic-core-api) (below)
- [Vendor packages](#vendor-packages) (below)


You cannot use features such as:

- functions implemented in external packages (no package.json)
- network access (access to external APIs using things like fetch)
- long running operations
- asynchronous features like async/await, promises, etc.

## Particle Logic Core API

To use the Particle Logic Core API this line is added automatically when using a template:

```js
import Particle from 'particle:core';
```

### Particle.publish

Publishes an event to the Particle cloud. This event can be subscribed to on-device or be used to trigger a webhook.

```
// PROTOTYPE
export function publish(name: string, data: any | undefined, options: { productId: number, asDeviceId: string }): null;
```

- `name` The name of the event
- `data` The particle publish data. This can be a string or an object. If an object, it will be serialized to JSON using `JSON.stringify`.
- `options` The product or device to that the event should be sent from

When triggering from an event, you will typically publish the event to the same product:

```js
Particle.publish("data-reformatted", reformatted, { productId: event.productId });
```

When using a schedule (cron) event, you need to specify which product to send the cron event to.

A logic function can publish more than one event if desired, and is not limited to the one-per second publish that devices are. However if you are publishing 
events that devices are subscribed to, you should limit the size and number of events published to devices, as the device can drop events that it is unable to process.


## Particle encoding API

```js
import Particle from 'particle:core';
import { base85Decode } from 'particle:encoding';
```


## Vendor packages


