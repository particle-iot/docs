---
title: Logic
columns: two
layout: commonTwo.hbs
description: Logic cloud functions
---

# {{title}} (Beta)

{{box op="start" cssClass="boxed warningBox"}}
Logic is in beta and is not recommended for production applications. There may be breaking changes to the behavior 
and APIs in future versions based on user feedback. 

Pricing and availability may change in the future.
{{box op="end"}}

Logic functions are bits of Javascript code that get called in response to a trigger event, which can be:

- A Particle event, generated by a device, Particle cloud API, or webhook response
- A scheduled, periodic time event ("cron")

Logic functions run in the cloud and are designed to perform short-running calculations such as:

- Generation of new event (which might be subscribed to by a device, or trigger an integration)
- Storing data in the Ledger database (in the future)

In particular, Logic functions consist only of calculations, conditional logic, etc.. Logic functions cannot directly interact with the outside world (such by REST APIs), and do not maintain state across invocations of the logic function.

Logic functions can, however, trigger an integration (webhook), and also respond to the results from a webhook.

For this beta version:

- Logic functions are only available in the developer sandbox (not at the organization level)
- Maximum number of logic functions per sandbox: 20
- Maximum number of triggers per logic function: 5
- Run logs per function retained: 100
- Maximum logic run execution time: 30 seconds

A companion feature, Ledger, allows data to be stored in the cloud and synchronized with devices. That feature is not included in this beta release.

## Common use cases

### Data transformation

Events to and from devices have a limited size (typically 1024 bytes). Using Logic you can transform data that has been abbreviated or compressed, expanding it and passing it to a webhook. The communication between logic and a webhook is not limited by the 1024 byte event size limitation, making it ideal for expanding compressed data.

While a webhook hook-response cannot trigger another webhook, it can trigger a logic block. This allows much more complex processing of the data coming from a web service than is possible using mustache variables in your hook response template.

There are several use-cases for data transformation:

- Cloud protocol translation
- Moving business logic from firmware to the cloud
- Alerting on abnormal conditions (using an external service)

In addition to bypassing event size limitations, logic events do not currently count as an additional data operations, however a triggering event from a device or hook-response does still count.

## Console interface

The Logic feature is typically accessed from the [Particle console](https://console.particle.io/). It is also possible to access it from the Particle Cloud API, and there will be support for creating logic functions in a future version of the Particle CLI.

In the developer sandbox in the console, select the **Logic** icon.

![](/assets/images/subspace/console-icon.png)


### Logic templates

Using a template is the easiest way to get started.

The current templates are:

- Decode Base64: Decode an event data payload that is encoded using Base64 back into a byte array.
- Decode Base85: Decode an event data payload that is encoded using Base85 back into a byte array.
- Reformat JSON data: Reformat and add fields to a JSON event to make it compatible with an external service.
- Event-triggered function: Start with a clean logic function that triggers from an event.
- Scheduled function: Start with a clean logic function that triggers on a schedule.

### Creating a logic function from a template

Using a template is a three step process:

- Define: Set name and description
- Execute: Update the Javascript and test
- Deploy: Set triggers and enable to run in the cloud

#### Define logic function

The name and description are just for your information.

![](/assets/images/subspace/logic-define.png)


#### Execute logic function

![](/assets/images/subspace/logic-execute.png)

This is the sample code generated in the template, it will be explained in more detail [below](#deep-dive-into-the-reformat-json-template).

```js
import Particle from 'particle:core';

export default function decode({ event }) {
  let data;
  try {
	  data = JSON.parse(event.eventData);
  } catch (err) {
    console.error("Invalid JSON", event.eventData);
    throw err;
  }
  const reformatted = {
    id: data.i,
    data: {
      value: data.d,
      type: 'Sensor'
    }
  };
  Particle.publish("data-reformatted", reformatted, { productId: event.productId });
}
```

The next part of interest is the **Event Test Data**. The field is initially empty and says Sensor Data but if you are transforming JSON, you will typically enter sample data that your device would normally publish. For example:

```json
{"i":12, "d":34.56}
```

You'll enter the event name in the next step.

Finally, click the **Run Code** button. 

![](/assets/images/subspace/logic-run-code.png)

If you have an error in your Javascript code, or in the event data, you will get an error message instead.

![](/assets/images/subspace/logic-error.png)

### Deploy logic function

![](/assets/images/subspace/logic-deploy.png)

For an event triggered logic function, this is where you enter the **Trigger event name**. Unlike an integration, a logic function event name trigger is an exact match, not a prefix match.

You must specify a product to associate the logic function with! Logic functions only work with product devices, not sandbox devices. For the beta, only personal sandbox products can be used (not organization products).

If you add multiple triggers, if any of the triggers occurs, the logic function will be called. Each function can have up to 5 triggers. 
One use case of this is if you have two products, one for the bsom and one for the b5som, but you want to use the same logic functions 
for both. If you need to figure out which product triggered the event, use `event.productId` which contains the numeric product ID
that triggered the event.

When you've succeesfully deployed the logic function:

![](/assets/images/subspace/logic-deployed.png)


### Testing from console

Since logic functions only work with products:

- From the **Products** icon in your developer sandbox, open the product that you associated your logic function with.
- Click on the **Events** icon within your product.
- Click on the **Publish an event** icon near the top, to the left of Search for events.

![](/assets/images/subspace/logic-publish.png)

- For **Event name** enter the event name you entered in the Deploy step above.
- For **Event data** enter the test JSON data. For example: 

```json
{"i":12, "d":34.56}
```

Click the **Publish** button and you should see both the `sensor-test` event and the `data-reformatted` event!

![](/assets/images/subspace/logic-publish-complete.png)


### Testing from the Particle CLI

You can publish events using the Particle CLI for testing, but remember to pass the product number, since logic functions only work with product devices.

```
% particle publish --product 1234 'sensor-test' '{"i":12, "d":34.56}'
Published private event: sensor-test to product: 1234
```

### Testing from a device

Of course the real application for this is having a device publish the data. 

- The [JSON documentation](/firmware/best-practices/json/) is a good place for a background in JSON.
- The [JSONWriter](/reference/device-os/api/json/json/) is a good way to generate JSON on device.
- Of course you're use [Particle.publish](/reference/device-os/api/cloud-functions/particle-publish/) from device firmware to publish an event.

For example:

```cpp
char buf[particle::protocol::MAX_EVENT_DATA_LENGTH + 1];
memset(buf, 0, sizeof(buf));
JSONBufferWriter writer(buf, sizeof(buf) - 1);

writer.beginObject();
    writer.name("d").value(sensorData);
    writer.name("i").value(sensorId);
writer.endObject();

Particle.publish("sensor-test", buf);
```

Remember that logic functions only work with product devices. The devices can be product developer devices (or not) and can be claimed or unclaimed.

### Scheduled events

When using the scheduled event template, the following code is provided to start:

```js
import Particle from 'particle:core';

export default function decode({ functionInfo, trigger, scheduled }) {
  // Add your code here
}
```

#### Cron syntax

In the **Deploy** step of creating a scheduled event, you enter the schedule in cron format.

When scheduling events, **cron** syntax is used. A chron schedule consists of 4 or 5 space-separated fields for:

| Field | Range |
| :--- | :--- |
| minute | 0 - 59 |
| hour | 0 - 23 |
| day of month | 1 - 31|
| month | 1 - 12 |
| day of week | 0 = Sunday, 1 = Monday, ..., 6 = Saturday (optional) |

Additionally, three special characters are allowed:

| Character | Meaning |
| :---: | :--- |
| `*` | All (wildcard) |
| `,` | List of options (any of the list) |
| `-` | Range (inclusive) |

This most easily illustrated by examples:

| Example | Description |
| :--- | :--- |
| `* * * *` | Once per minute |
| `0 * * * *` | Every hour at minute = 0 |
| `0,30 * * * *` | Every half hour (at minute = 0 and minute = 30) |
| `0 4 * * *` | Every day at 4:00 UTC (minute = 0, hour = 4) |
| `0 4,8,12,16 * * *` | Every day at 4:00, 8:00, 12:00, at 16:00 UTC |
| `0 4 * * 1-5` | Every weekday at 4:00 UTC (minute = 0, hour = 4, day of week = 1 - 5 or Monday - Friday |

You cannot schedule an logic function to execute more than one time per minute. This only applies to cron scheduled functions;
event triggered functions will be called as often as necessary based on the events that are received by the cloud.

## Logic function coding

The Logic function code is Javascript (actually, Typescript). You can use built-in language features such as:

- calculations
- if blocks
- for and while loops
- functions
- JSON features like `JSON.parse()` and `JSON.stringify()`
- Standard built-in objects like `Math` and `String`
- `console.log` (useful for debugging, as the run logs include this log output)
- [Particle Logic Core API](#particle-logic-core-api) (below)
- [Particle Encoding API](#particle-encoding-api) (below)
- [Vendor packages](#vendor-packages) (below)

This list is not complete! If it's a standard Javascript function it may work and you should just try it. It only
takes a few seconds to edit and test from the console.

You cannot use features such as:

- functions implemented in external packages (no package.json)
- network access (access to external APIs using things like fetch or axios)
- long running operations (limit is 20 seconds)
- asynchronous features like async/await, promises, etc.
- browser features like the DOM
- node.js features like Buffer, the file API, etc.

### Deep dive into the reformat JSON template

Every template has one or more import statement to make certain features available to your logic function. The `Particle` class from `particle:core` contains the `Particle.publish` call that you will frequently use.

```js
import Particle from 'particle:core';
```

You must define a function to be called to implement the logic function. The JSON example uses this declaration, but you may have a comma-separated list of other parameters in some cases.

```js
export default function decode({ event }) {
```

This bit of code transforms `event.eventData`, which is a string, into a JSON object. It includes some error checking, but even if you didn't handle the exception
using a try/catch block, the exception would still be caught and displayed in the run logs for your logic function.

```js
  let data;
  try {
      data = JSON.parse(event.eventData);
  } catch (err) {
    console.error("Invalid JSON", event.eventData);
    throw err;
  }
```

Here's where a new object is created based on the original event JSON. 

```js
  const reformatted = {
    id: data.i,
    data: {
      value: data.d,
      type: 'Sensor'
    }
  };
```

In addition to simply changing the "shape" of the object (key names, embedded objects, etc.), you can also perform calculations. For example, this makes the reformatted 
`data.d` value the square of the original value using the Javascript `Math.pow()` (power) method.

```js
  const reformatted = {
    id: data.i,
    data: {
      value: Math.pow(data.d, 2),
      type: 'Sensor'
    }
  };
```
 
And, finally, the reformatted object is published. The options (last parameter) specify that the event goes out to the same product that the event came from.

```js
  Particle.publish("data-reformatted", reformatted, { productId: event.productId });
}
```

### Particle Logic Core API

To use the Particle Logic Core API this line is added automatically when using a template:

```js
import Particle from 'particle:core';
```

#### Particle.publish

Publishes an event to the Particle cloud. This event can be subscribed to on-device or be used to trigger a webhook.

```
// PROTOTYPE
export function publish(name: string, data: any | undefined, options: { productId: number, asDeviceId: string }): null;
```

- `name` The name of the event
- `data` The particle publish data. This can be a string or an object. If an object, it will be serialized to JSON using `JSON.stringify`.
- `options` The product or device to that the event should be sent from

When triggering from an event, you will typically publish the event to the same product:

```js
Particle.publish("data-reformatted", reformatted, { productId: event.productId });
```

When using a schedule (cron) event, you need to specify which product to send the cron event to.

A logic function can publish more than one event if desired, and is not limited to the once per second average that devices are. However if you are publishing 
events that devices are subscribed to, you should limit the size and number of events published to devices, as the device will drop events that it is unable to process.

When publishing to a webhook, the data can exceed the normal 1024 bytes event size limit. When sending to a device, however, you must still limit the size
of the event data. Events published by logic do not currently count against your data operations usage.

### Particle encoding API

Particle publish data can consist only of UTF-8 characters and cannot contain binary data. Likewise, JSON does not allow inclusion of binary data directly.

To get around this, an encoding mechanism is typically used, such as:

- Hexadecimal (hex): Each byte creates two characters 0-9 and a-f, a 16-character alphabet, doubling the size of the data
- Base64: Every 3 bytes of binary data produces 4 safe ASCII characters out of a set of 64 (RFC 3548)
- Base85 (Ascii85): Uses an 85-character alphabet, which is even denser (RFC 1924)

While Base85 provides a more dense encoding than Base64, it is not recommended if you are publishing data to be sent to an external server by a webhook. The Base85 alphabet includes the left curly bracket, and the `\{{` sequence is recognized as a mustache template delimiter during webhook processing, causing the data to be corrupted. The backslash can also cause unexpected data transformation. One use case of Base85, however, is to use that to send the data from the device to the cloud, and then use a logic function to expand this to a different format, like Base64 or hex.

If you are interpreting binary data from your logic function, you will typically convert the encoded data (Base64 or Base85) to a byte array, so you can access the individual values of each byte (0 - 255) as values in an array. Logic functions do not support node.js style `Buffer` objects for binary data.


#### Using the encoding APIs

To use the Particle encoding API, lines like this are added automatically when using a template:

```js
import Particle from 'particle:core';
import { base85Decode } from 'particle:encoding';
```

You can substitute other functions like `bytesToString` for `base85Decode` in the example above. 

You can include a comma-separated list of multiple imports if desired:

```js
import Particle from 'particle:core';
import { bytesToString, stringToBytes } from 'particle:encoding';
```


#### base64Encode

Encodes a string or byte array to base64 (RFC 3548).

```js
// PROTOTYPE
export function base64Encode(input: string | number[]): string;
```

In your device firmware, use the [Base64RK](https://github.com/rickkas7/Base64RK) library to encode and decode Base64.

#### base64Decode

Decodes a base64 (RFC 3548) string to a byte array

```js
// PROTOTYPE
export function base64Decode(input: string): number[];
```

In your device firmware, use the [Base64RK](https://github.com/rickkas7/Base64RK) library to encode and decode Base64.

#### base85Encode

Encodes a string or byte array to base85 (RFC1924)

```js
// PROTOTYPE
export function base85Encode(input: string | number[]): string;
```

In your device firmware, use the [Base85](https://github.com/particle-iot/base85) library to encode or decode Base85.

#### base85Decode

Decodes a base85 (RFC1924) string to a byte array.

```js
// PROTOTYPE
export function base85Decode(input: string): number[];
```

In your device firmware, use the [Base85](https://github.com/particle-iot/base85) library to encode or decode Base85.


#### bytesToString

Convert a byte array into a UTF-8 string. This should not be used for arbitrary binary data; use Base64 or Base85 for that.

```js
// PROTOTYPE
export function bytesToString(input: number[]): string;

```

#### stringToBytes

Converts a string into an array of bytes.

```js
// PROTOTYPE
export function stringToBytes(input: string): number[];
```

### Vendor packages

Additionally, some utility packages are available by importing the following:

| Import | Package | Version | Description |
| :--- | :--- | :--- | :--- |
| vendor:lodash | [lodash-es](https://lodash.com/) | 4.17.21 | General utility functions |
| vendor:date-fns | [date-fns](https://date-fns.org/) | 2.30.0 | Date handling |
| vendor:cbor-x | [cbor-x](https://github.com/kriszyp/cbor-x) | 1.5.4 | CBOR (Concise Binary Object Representation) |
| vendor:unishox2 | [unishox2.siara.cc](https://github.com/siara-cc/Unishox2) | 1.1.3 | Compression of short UTF8 strings |

It is not possible to import arbitrary npm or other packages in your logic function.

### Logic function context

When your logic function is called, it will always include required parameters:

- `functionInfo`: information about the function that was called
- `trigger`: information about the time the event was triggered

Additionally, there are optional parameters based on the type of trigger:

- `event`: information about the event that triggered the logic function
- `scheduled`: information about a scheduled (cron) logic function call
- `ledgerChange`: information about a ledger database change the triggered the logic function (future)

```js
// PROTOTYPE
export interface FunctionContext {
    functionInfo: FunctionInfo;
    trigger: TriggerInfo;
    event?: EventInfo;
    scheduled?: ScheduledInfo;
    ledgerChange?: LedgerChangeInfo;
}
```

#### Accessing the context

To access just the event, specify it as is done in the event trigger template.

```js
export default function decode({ event })
```

You can also add other parameters in a comma-separated list if you're interested in those values.

```js
export default function decode({ functionInfo, trigger, scheduled })
```

#### functionInfo - logic function context

This object specifies the function that was called:

- `ownerId``: The user that owns this function. In the future, this could be an organization. It contains the user GUID, not the email address.
- `logicFunctionId``: The unique identifier for the function.

```js
// PROTOTYPE
export interface FunctionContext {
    functionInfo: FunctionInfo;
    trigger: TriggerInfo;
    event?: EventInfo;
    scheduled?: ScheduledInfo;
    ledgerChange?: LedgerChangeInfo;
}
```

#### trigger - logic function context

Information about how the event was triggered (event or scheduled).

- `triggeredAt`: The time the trigger occurred in ISO 8601 format (`2023-11-07T14:01:57.923225531Z`)
- `triggerEventId`: The event ID that triggered the event (for event triggers)

```js
// PROTOTYPE
export interface TriggerInfo {
    triggerEventId?: string;
    triggeredAt: string;
}
```

#### event - logic function context

- `eventName`: The event name.
- `eventData`: The event data as a string. If you are expecting JSON, you will need to use `JSON.parse()` to convert `event.eventData` to an object. This may be omitted if there is no event data.
- `publishedAt`: Time in ISO 8601 format when the event was received by the cloud.
- `deviceId`: The device ID (24 character hex) that triggered the event.
- `productId`: The numeric product ID this trigger is associated with.

```js
// PROTOTYPE
export interface EventInfo {
    publishedAt: string;
    eventName: string;
    eventData?: string;
    deviceId: string;
    productId?: number;
    userId?: string;
}
```

#### scheduled - logic function context

- `scheduledAt`: When the event was scheduled at in ISO 8601 format (`2023-11-07T14:01:57.923225531Z`).
- `startAt`: When execution started.

```js
// PROTOTYPE
export interface ScheduledInfo {
    scheduledAt: string;
    startAt: string;
    endAt?: string;
}
```