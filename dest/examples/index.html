<!doctype html>
<html>
<head>
  <meta charset='utf-8'>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width">

  <title>Spark Docs | </title>

  <!-- Flatdoc -->
  <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

  <!-- Let me embed vines --> 
  <script async src="//platform.vine.co/static/scripts/embed.js" charset="utf-8"></script>

  <!-- Favicon -->
  <link rel="icon" href="../../assets/favicon.ico">

  <!-- Flatdoc theme -->
  <link href='../../assets/css/theme-white.css' rel='stylesheet'>
  <script src='../../assets/js/theme-white.js'></script>

  <!-- Spark theme mods -->
  <link href='../../assets/css/style.css' rel='stylesheet'>
  <script src='../../assets/js/spark.js'></script>

  <!-- Meta -->
  <meta content="Spark" property="og:title">
  <meta content="Documentation for Spark, a platform for connected devices." name="description">

</head>
<body role='flatdoc'>

  <div id="docs">
    <div class='header'>
      <div class='left'>
        <a href="https://www.spark.io">
          <img src="../../assets/images/sparklogo-2x.png" id="logo">
        </a>
        <ul>
          <li><a href='start'>Getting started</a></li>
          <li><a href='connect'>Connecting your Core</a></li>
          <li><a href='examples'>Annotated examples</a></li>
          <li><a href='api'>Cloud API reference</a></li>
          <li><a href='firmware'>Core firmware reference</a></li>
          <li><a href='hardware'>Core hardware reference</a></li>
          <li><a href='shields'>Shields and kits</a></li>
        </ul>
      </div>
      <div class='right'>
        <a href="http://www.github.com/spark/docs" class="contribute">Contribute</a>
      </div>
    </div>

    <div class='content-root'>
      <div class='menubar'>
        <div class='menu section' role='flatdoc-menu'></div>
      </div>
      <div role='flatdoc-content' class='content'>
        <h1 id="annotated-examples">Annotated examples</h1>
<p>Here you will find a bunch of examples to get you started with your all new Spark Core!</p>
<h1 id="blink-an-led">Blink an LED</h1>
<p><img src="images/annotated-example1.jpg" alt="One LED illustration"></p>
<p>Blinking an LED is the <a href="http://en.wikipedia.org/wiki/Hello_world_program">&quot;Hello World&quot;</a> example of the microcontroller  world. It&#39;s a nice way to warm up and start your journey into the land of embedded hardware.</p>
<p>For this example, you will need a Spark Core (duh!), a Breadboard, an LED, a Resistor (we will soon find out a suitable value) and an USB cable.</p>
<p>Connect everything together as shown in the picture. The LED is connected to pin D0 of the Core. The positive (longer pin) of the LED is connected to D0 and its negative pin (shorter) is connected to ground via a resistor.</p>
<p><img src="images/breadboard-one-led.jpg" alt="One LED setup"></p>
<p>But wait, whats the value of the resistor again?</p>
<p><em>Heres how we find that out:</em></p>
<p>According to <a href="http://en.wikipedia.org/wiki/Ohm%27s_law">Ohm&#39;s Law</a> : Voltage = Current x Resistance</p>
<p>Therefore, Resistance = Voltage/ Current</p>
<p>In our case, the output voltage of the Core is 3.3V but the LED (typically) has a forward voltage drop of around 2.0V. So the actual voltage would be:</p>
<p>3.3V - 2.0V = 1.3V</p>
<p>The required current to light up an LED varies any where between 2mA to 20mA. More the current, brighter the intensity. But generally its a good idea to drive the LED at a lower limit to prolong its life span. We will choose a drive current of 5mA.</p>
<p>Hence, Resistance = 1.3V/ 5mA = 260 Ohms</p>
<p><strong>NOTE:</strong> Since there is so much variation in the values of the forward voltage drop of the LEDs depending upon type, size, color, manufacturer, etc., you could successfully use a resistor value from anywhere between 220Ohms to 1K Ohms.</p>
<p>In the picture above, we used a 1K resistor (Brown Black Red)</p>
<p>Now on to the actual program:</p>
<pre><code class="language-cpp"><span class="comment">// Program to blink an LED connected to pin D0</span>
<span class="comment">// of the Spark Core. </span>

<span class="comment">// We name pin D0 as led</span>
<span class="keyword">int</span> led = D0; 

<span class="comment">// This routine runs only once upon reset</span>
<span class="keyword">void</span> setup() 
{
  <span class="comment">// Initialize D0 pin as output</span>
  pinMode(led, OUTPUT);
}

<span class="comment">// This routine loops forever </span>
<span class="keyword">void</span> loop() 
{
  digitalWrite(led, HIGH);   <span class="comment">// Turn ON the LED</span>
  delay(<span class="number">1000</span>);               <span class="comment">// Wait for 1000mS = 1 second</span>
  digitalWrite(led, LOW);    <span class="comment">// Turn OFF the LED</span>
  delay(<span class="number">1000</span>);               <span class="comment">// Wait for 1 second</span>
}</code></pre>
<h1 id="control-leds-over-the-net">Control LEDs over the &#39;net</h1>
<p><img src="images/breadboard-two-leds.jpg" alt="Two LED setup"></p>
<p>Now that we know how to blink an LED, how about we control it over the Internet? This is where the fun begins.</p>
<p>Lets hook up two LEDs this time.</p>
<p>Here is the algorithm: </p>
<ul>
<li>Set up the pins as outputs that have LEDs connected to them</li>
<li>Create and register a Spark function ( this gets called automagically when you make an API request to it)</li>
<li>Parse the incoming command and take appropriate actions</li>
</ul>
<pre><code class="language-cpp"><span class="comment">// -----------------------------------</span>
<span class="comment">// Controlling LEDs over the Internet</span>
<span class="comment">// -----------------------------------</span>

<span class="comment">// name the pins</span>
<span class="keyword">int</span> led1 = D0;
<span class="keyword">int</span> led2 = D1;

<span class="comment">// This routine runs only once upon reset</span>
<span class="keyword">void</span> setup()
{
   <span class="comment">//Register our Spark function here</span>
   Spark.function(<span class="string">"led"</span>, ledControl);

   <span class="comment">// Configure the pins to be outputs</span>
   pinMode(led1, OUTPUT);
   pinMode(led2, OUTPUT);

   <span class="comment">// Initialize both the LEDs to be OFF</span>
   digitalWrite(led1, LOW);
   digitalWrite(led2, LOW);
}


<span class="comment">// This routine loops forever </span>
<span class="keyword">void</span> loop()
{
   <span class="comment">// Nothing to do here</span>
}


<span class="comment">// This function gets called whenever there is a matching API request</span>
<span class="comment">// the command string format is l&lt;led number&gt;,&lt;state&gt;</span>
<span class="comment">// for example: l1,HIGH or l1,LOW</span>
<span class="comment">//              l2,HIGH or l2,LOW</span>

<span class="keyword">int</span> ledControl(String command)
{
   <span class="keyword">int</span> state = <span class="number">0</span>;
   <span class="comment">//find out the pin number and convert the ascii to integer</span>
   <span class="keyword">int</span> pinNumber = command.charAt(<span class="number">1</span>) - <span class="string">'0'</span>;
   <span class="comment">//Sanity check to see if the pin numbers are within limits</span>
   <span class="keyword">if</span> (pinNumber &lt; <span class="number">0</span> || pinNumber &gt; <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;

   <span class="comment">// find out the state of the led</span>
   <span class="keyword">if</span>(command.substring(<span class="number">3</span>,<span class="number">7</span>) == <span class="string">"HIGH"</span>) state = <span class="number">1</span>;
   <span class="keyword">else</span> <span class="keyword">if</span>(command.substring(<span class="number">3</span>,<span class="number">6</span>) == <span class="string">"LOW"</span>) state = <span class="number">0</span>;
   <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;

   <span class="comment">// write to the appropriate pin</span>
   digitalWrite(pinNumber, state);
   <span class="keyword">return</span> <span class="number">1</span>;
}</code></pre>
<hr>
<p>The API request will look something like this:</p>
<pre><code class="language-json">POST /v1/devices/{DEVICE_ID}/led

# EXAMPLE REQUEST IN TERMINAL
# Core ID is 0123456789abcdef01234567
# Your access token is 1234123412341234123412341234123412341234
curl https://api.spark.io/v1/devices/0123456789abcdef01234567/led \
  -d access_token=1234123412341234123412341234123412341234 \
  -d params=l1,HIGH</code></pre>
<p>Note that the API endpoint is &#39;led&#39;, not &#39;ledControl&#39;. This is because the endpoint is defined by the first argument of Spark.function(), which is a string of characters, rather than the second argument, which is a function.</p>
<p>To better understand the concept of making API calls to your Core over the cloud checkout the <a href="/#/api">Cloud API reference.</a></p>
<h1 id="measuring-the-temperature">Measuring the temperature</h1>
<p><img src="images/annotated-example3.jpg" alt="Read Sensor"></p>
<p>We have now learned how to send custom commands to the Core and control the hardware. But how about reading data back from the Core?</p>
<p>In this example, we will hook up a temperature sensor to the Core and read the values over the internet with a web browser.</p>
<p><img src="images/breadboard-temp-sensor.jpg" alt="Read Temperature"></p>
<p>We have used a widely available analog temperature called TMP36 from Analog Devices. You can download the <a href="http://www.analog.com/static/imported-files/data_sheets/TMP35_36_37.pdf">datasheet here.</a></p>
<p>Notice how we are powering the sensor from 3.3V* pin instead of the regular 3.3V. This is because the 3.3V* pin gives out a (LC) clean filtered  voltage, ideal for analog applications like these.</p>
<pre><code class="language-C++">// -----------------
// Read temperature
// -----------------

// Create a variable that will store the temperature value
int temperature = 0;

void setup()
{
  // Register a Spark variable here
  Spark.variable(&quot;temperature&quot;, &amp;temperature, INT);

  // Connect the temperature sensor to A0 and configure it
  // to be an input
  pinMode(A0, INPUT);
}

void loop()
{
  // Keep reading the temperature so when we make an API
  // call to read its value, we have the latest one
  temperature = analogRead(A0);
}</code></pre>
<p>The returned value from the Core is going to be in the range from 0 to 4095. You can easily convert this value to actual temperature reading by using the following formula:</p>
<pre><code>voltage = (sensor reading x 3.3)/4095
Temperature (in Celsius) = (voltage - 0.5) X 100</code></pre>
<hr>
<p>The API request will look something like this:</p>
<pre><code class="language-json">GET /v1/devices/{DEVICE_ID}/temperature

# EXAMPLE REQUEST IN TERMINAL
# Core ID is 0123456789abcdef01234567
# Your access token is 1234123412341234123412341234123412341234
curl -G https://api.spark.io/v1/devices/0123456789abcdef01234567/temperature \
  -d access_token=1234123412341234123412341234123412341234</code></pre>
<h1 id="local-communication">Local Communication</h1>
<p>Now let&#39;s imagine you want to control your Core locally,
so you build a simple server app to which the Core will directly connect.
One puzzle to solve is that you don&#39;t know in advance the
IP address of your Core or of the laptop that will run the server.
How can the Core and the server discover each other?</p>
<p>In this example, we will register a Spark function to pass the
server IP address to the Core.  Once we&#39;ve established the
local connection, we&#39;ll be able to control the Core without
the data going through the Spark Cloud.</p>
<hr>
<pre><code class="language-C++">TCPClient client;</code></pre>
<p>First, we construct the client that will connect to our local server.</p>
<hr>
<pre><code class="language-C++">void ipArrayFromString(byte ipArray[], String ipString) {
  int dot1 = ipString.indexOf(&#39;.&#39;);
  ipArray[0] = ipString.substring(0, dot1).toInt();
  int dot2 = ipString.indexOf(&#39;.&#39;, dot1 + 1);
  ipArray[1] = ipString.substring(dot1 + 1, dot2).toInt();
  dot1 = ipString.indexOf(&#39;.&#39;, dot2 + 1);
  ipArray[2] = ipString.substring(dot2 + 1, dot1).toInt();
  ipArray[3] = ipString.substring(dot1 + 1).toInt();
}</code></pre>
<p>Then we need a function for translating the IP address String into
the array of four bytes needed by the TCP client.</p>
<p>We work our way progressively through the string, saving the
positions of the dots and the numeric substrings between them.</p>
<hr>
<pre><code class="language-C++">int connectToMyServer(String ip) {
  byte serverAddress[4];
  ipArrayFromString(serverAddress, ip);

  if (client.connect(serverAddress, 9000)) {
    return 1; // successfully connected
  } else {
    return -1; // failed to connect
  }
}</code></pre>
<p>Here&#39;s the Spark function we&#39;re going to register.
Like all Spark functions it takes a String parameter
and returns an int.  We allocate an array of 4 bytes
for the IP address, then call <code>ipArrayFromString()</code>
to convert the String into an array.</p>
<p>After that, we simply call <code>client.connect()</code> with the
newly received address! Super simple!</p>
<hr>
<pre><code class="language-C++">void setup() {
  Spark.function(&quot;connect&quot;, connectToMyServer);

  for (int pin = D0; pin &lt;= D7; ++pin) {
    pinMode(pin, OUTPUT);
  }
}</code></pre>
<p>In <code>setup()</code> we only have two jobs:</p>
<ul>
<li>Register the Spark function</li>
<li>Set D0â€“D7 as output pins</li>
</ul>
<hr>
<pre><code class="language-C++">void loop() {
  if (client.connected()) {
    if (client.available()) {
      char pin = client.read() - &#39;0&#39; + D0;
      char level = client.read();
      if (&#39;h&#39; == level) {
        digitalWrite(pin, HIGH);
      } else {
        digitalWrite(pin, LOW);
      }
    }
  }
}</code></pre>
<p>In <code>loop()</code> we first check whether the client is connected
to the server.  If not, we don&#39;t do anything.</p>
<p>If the client is connected, then we ask whether any commands
have been received over local communication.  If not, again,
we don&#39;t do anything.</p>
<p>However, if we are <em>connected</em> and have <em>received a command</em>
then we use the command to perform a <code>digitalWrite()</code>.</p>
<p><a href="https://github.com/spark/local-communication-example">Example server and firmware on github &gt;</a></p>
<h1 id="texting-the-core">texting the core</h1>
<p><strong>coming soon!</strong></p>
<h1 id="an-internet-button">an internet button</h1>
<p><strong>coming soon!</strong></p>

      </div>
    </div>
  </div>


  <!-- Custom -->
  <script src='../../assets/js/main.js'></script>

</body>
</html>